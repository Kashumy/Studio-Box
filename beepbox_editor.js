var updateSampledWaves = function() {}
var updateThemes = function() {}
function POPUP(x, y, title, content, framecolor = "#000080") {
	const win = document.createElement("div");
	Object.assign(win.style, {
		position: "absolute",
		left: x + "px",
		top: y + "px",
		width: "300px",
		height: "150px",
		border: `2px solid ${framecolor}`,
		background: "#e0e0e0",
		resize: "both",
		overflow: "hidden",
		boxShadow: "5px 5px 10px rgba(0,0,0,0.5)",
		minWidth: "200px",
		minHeight: "100px",
		zIndex: ++topZ,
		fontWeight: "200",
		fontFamily: "sans-serif"
	});

	const titlebar = document.createElement("div");
	Object.assign(titlebar.style, {
		background: framecolor,
		color: "#fff",
		padding: "2px 5px",
		cursor: "grab",
		display: "flex",
		fontWeight: "200",
		fontFamily: "sans-serif",
		justifyContent: "space-between",
		alignItems: "center",
		userSelect: "none"
	});

	const titleText = document.createElement("span");
	titleText.textContent = title;

	const buttons = document.createElement("div");
	const closeBtn = document.createElement("button");
	closeBtn.type = "button";
	closeBtn.className = "no-drag";
	closeBtn.innerHTML = `<svg viewBox="0 0 24 24" width="16" height="16" fill="white"><line x1="4" y1="4" x2="20" y2="20" stroke="white" stroke-width="2"/><line x1="20" y1="4" x2="4" y2="20" stroke="white" stroke-width="2"/></svg>`;
	Object.assign(closeBtn.style, {
		background: "red",
		border: "none",
		cursor: "pointer",
		width: "24px",
		height: "24px",
		padding: "0",
		display: "flex",
		justifyContent: "center",
		alignItems: "center"
	});
	closeBtn.addEventListener("mousedown", e => e.stopPropagation());
	closeBtn.addEventListener("touchstart", e => { e.stopPropagation(); }, { passive: false });
	closeBtn.addEventListener("click", () => win.remove());

	buttons.appendChild(closeBtn);
	titlebar.appendChild(titleText);
	titlebar.appendChild(buttons);

	const contentDiv = document.createElement("div");
	Object.assign(contentDiv.style, {
		padding: "10px",
		height: "calc(100% - 26px)",
		overflow: "auto"
	});
	contentDiv.innerHTML = content;

	win.appendChild(titlebar);
	win.appendChild(contentDiv);
	document.body.appendChild(win);

	let isDragging = false, offsetX = 0, offsetY = 0;

	function startDrag(e) {
		const target = e.target;
		if (target && target.closest && target.closest('.no-drag')) return;
		isDragging = true;
		const evt = e.touches ? e.touches[0] : e;
		offsetX = evt.clientX - win.offsetLeft;
		offsetY = evt.clientY - win.offsetTop;
		titlebar.style.cursor = "grabbing";
		document.body.style.overflow = "hidden";
		e.preventDefault();
	}

	function drag(e) {
		if (!isDragging) return;
		const evt = e.touches ? e.touches[0] : e;
		let newX = evt.clientX - offsetX;
		let newY = evt.clientY - offsetY;
		newX = Math.max(0, Math.min(window.innerWidth - win.offsetWidth, newX));
		newY = Math.max(0, Math.min(document.body.scrollHeight - win.offsetHeight, newY));
		win.style.left = newX + "px";
		win.style.top = newY + "px";
	}

	function endDrag() {
		isDragging = false;
		titlebar.style.cursor = "grab";
		document.body.style.overflow = "";
	}

	titlebar.addEventListener("mousedown", startDrag);
	document.addEventListener("mousemove", drag);
	document.addEventListener("mouseup", endDrag);
	titlebar.addEventListener("touchstart", startDrag, { passive: false });
	document.addEventListener("touchmove", drag, { passive: false });
	document.addEventListener("touchend", endDrag);
	win.addEventListener("mousedown", () => win.style.zIndex = ++topZ);
	win.addEventListener("touchstart", () => win.style.zIndex = ++topZ);
}
function showToast(message, duration = 3000) {
    const toast = document.createElement("div");
    toast.textContent = message;
    Object.assign(toast.style, {
        position: "fixed",
        bottom: "30px",
        left: "50%",
        transform: "translateX(-50%)",
        backgroundColor: "#333",
        color: "#fff",
        padding: "10px 20px",
        borderRadius: "8px",
        fontFamily: "sans-serif",
        fontSize: "14px",
        zIndex: "9999",
        opacity: "0",
        transition: "opacity 0.3s ease",
        pointerEvents: "none", 
    });

    document.body.appendChild(toast);
    requestAnimationFrame(() => {
        toast.style.opacity = "1";
    });

    setTimeout(() => {
        toast.style.opacity = "0";
        setTimeout(() => {
            toast.remove();
        }, 300); 
    }, duration);
}


var beepbox
setTimeout(function (){
  //  alert("loaded fruit box")
  try {
    
    
    
function writeBase64Int( number, number) {
    let result = "";
    for (let i = digits - 1; i >= 0; i--) {
        const digit = (value >> (6 * i)) & 63;
        result += base64IntToCharCode[digit];
    }
    return result;
}
function readBase64Int(str, index, digits) {
    var value = 0;
    for (var i = 0; i < digits; i++) {
        value = (value << 6) | base64CharCodeToInt[str.charCodeAt(index++)];
    }
    return {
        value: value,
        nextIndex: index
    };
}


    
    
    function readNBitsPerChar(source, charIndex, bitsPerChar, bitCount) {
  let value = 0;
  let bitsRead = 0;
  const baseCharCodeToInt = bitsPerChar === 6 ? base64CharCodeToInt : base128CharCodeToInt;
  while (bitsRead < bitCount) {
    const val = baseCharCodeToInt[source.charCodeAt(charIndex++)];
    value = (value << bitsPerChar) | val;
    bitsRead += bitsPerChar;
  }
 const extraBits = bitsRead - bitCount;
  if (extraBits > 0) {
    value = value >>> extraBits;
  }
  return { value, charIndex };
}
    
  beepbox = (function (exports) {
    'use strict';

    /*!
    Copyright (C) 2021 John Nesky

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    */
    var _a$1;
    class Config {
    }
    _a$1 = Config;
    Config.thresholdVal = -10;
    Config.kneeVal = 40;
    Config.ratioVal = 12;
    Config.attackVal = 0;
    Config.releaseVal = 0.25;
    Config.scales = toNameMap([
 
      { name: "expert", realName: "expert", flags: [true, true, true, true, true, true, true, true, true, true, true, true] },


        { name: "easy :)", realName: "pentatonic major", flags: [true, false, true, false, true, false, false, true, false, true, false, false] },
        { name: "easy :(", realName: "pentatonic minor", flags: [true, false, false, true, false, true, false, true, false, false, true, false] },
        { name: "island :)", realName: "ryukyu", flags: [true, false, false, false, true, true, false, true, false, false, false, true] },
        { name: "island :(", realName: "pelog selisir", flags: [true, true, false, true, false, false, false, true, true, false, false, false] },
        { name: "blues :)", realName: "blues major", flags: [true, false, true, true, true, false, false, true, false, true, false, false] },
        { name: "blues :(", realName: "blues", flags: [true, false, false, true, false, true, true, true, false, false, true, false] },
        { name: "normal :)", realName: "ionian", flags: [true, false, true, false, true, true, false, true, false, true, false, true] },
        { name: "normal :(", realName: "aeolian", flags: [true, false, true, true, false, true, false, true, true, false, true, false] },
        { name: "dbl harmonic :)", realName: "double harmonic major", flags: [true, true, false, false, true, true, false, true, true, false, false, true] },
        { name: "dbl harmonic :(", realName: "double harmonic minor", flags: [true, false, true, true, false, false, true, true, true, false, false, true] },
        { name: "strange", realName: "whole tone", flags: [true, false, true, false, true, false, true, false, true, false, true, false] },

        { name: "Major", realName: "ionian", flags: [true, false, true, false, true, true, false, true, false, true, false, true] },
        { name: "Minor", realName: "aeolian", flags: [true, false, true, true, false, true, false, true, true, false, true, false] },
        { name: "Mixolydian", realName: "mixolydian", flags: [true, false, true, false, true, true, false, true, false, true, true, false] },
        { name: "Lydian", realName: "lydian", flags: [true, false, true, false, true, false, true, true, false, true, false, true] },
        { name: "Dorian", realName: "dorian", flags: [true, false, true, true, false, true, false, true, false, true, true, false] },
        { name: "Phrygian", realName: "phrygian", flags: [true, true, false, true, false, true, false, true, true, false, true, false] },
        { name: "Locrian", realName: "locrian", flags: [true, true, false, true, false, true, true, false, true, false, true, false] },
        { name: "Lydian Dominant", realName: "lydian dominant", flags: [true, false, true, false, true, false, true, true, false, true, true, false] },
        { name: "Phrygian Dominant", realName: "phrygian dominant", flags: [true, true, false, false, true, true, false, true, true, false, true, false] },
        { name: "Harmonic Major", realName: "harmonic major", flags: [true, false, true, false, true, true, false, true, true, false, false, true] },
        { name: "Harmonic Minor", realName: "harmonic minor", flags: [true, false, true, true, false, true, false, true, true, false, false, true] },
        { name: "Melodic Minor", realName: "melodic minor", flags: [true, false, true, true, false, true, false, true, false, true, false, true] },
        { name: "Blues", realName: "blues", flags: [true, false, false, true, false, true, true, true, false, false, true, false] },
        { name: "Altered", realName: "altered", flags: [true, true, false, true, true, false, true, false, true, false, true, false] },
        { name: "Major Pentatonic", realName: "major pentatonic", flags: [true, false, true, false, true, false, false, true, false, true, false, false] },
        { name: "Minor Pentatonic", realName: "minor pentatonic", flags: [true, false, false, true, false, true, false, true, false, false, true, false] },
        { name: "Whole Tone", realName: "whole tone", flags: [true, false, true, false, true, false, true, false, true, false, true, false] },
        { name: "Octatonic", realName: "octatonic", flags: [true, false, true, true, false, true, true, false, true, true, false, true] },
        { name: "Hexatonic", realName: "hexatonic", flags: [true, false, false, true, true, false, false, true, true, false, false, true] },
        { name: "Free", realName: "chromatic", flags: [true, true, true, true, true, true, true, true, true, true, true, true] },
    ]);
    Config.keys = toNameMap([
        { name: "C", isWhiteKey: true, basePitch: 12 },
        { name: "C♯", isWhiteKey: false, basePitch: 13 },
        { name: "D", isWhiteKey: true, basePitch: 14 },
        { name: "D♯", isWhiteKey: false, basePitch: 15 },
        { name: "E", isWhiteKey: true, basePitch: 16 },
        { name: "F", isWhiteKey: true, basePitch: 17 },
        { name: "F♯", isWhiteKey: false, basePitch: 18 },
        { name: "G", isWhiteKey: true, basePitch: 19 },
        { name: "G♯", isWhiteKey: false, basePitch: 20 },
        { name: "A", isWhiteKey: true, basePitch: 21 },
        { name: "A♯", isWhiteKey: false, basePitch: 22 },
        { name: "B", isWhiteKey: true, basePitch: 23 },
    ]);
    Config.blackKeyNameParents = [-1, 1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1];
    Config.tempoMin = 1;
    Config.tempoMax = 320*3;// 320*3
    Config.echoDelayRange = 24;
    Config.echoDelayStepTicks = 4;
    Config.echoSustainRange = 8;
    Config.echoShelfHz = 4000.0;
    Config.echoShelfGain = Math.pow(2.0, -0.5);
    Config.reverbShelfHz = 8000.0;
    Config.reverbShelfGain = Math.pow(2.0, -1.5);
    Config.reverbRange = 32;
    Config.reverbDelayBufferSize = 16384;
    Config.reverbDelayBufferMask = Config.reverbDelayBufferSize - 1;
    Config.beatsPerBarMin = 2;
    Config.beatsPerBarMax = 24;
    Config.barCountMin = 1;
    Config.barCountMax = 256*4; // 256  default 
    Config.instrumentCountMin = 1;
    Config.layeredInstrumentCountMax = 4;
    Config.patternInstrumentCountMax = 10;
    Config.partsPerBeat = 24;
    Config.ticksPerPart = 2;
    Config.ticksPerArpeggio = 3;
    Config.arpeggioPatterns = [[0], [0, 1], [0, 1, 2, 1], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5, 6], [0, 1, 2, 3, 4, 5, 6, 7]];
    Config.rhythms = toNameMap([
        { name: "÷3 (triplets)", stepsPerBeat: 3, roundUpThresholds: [5, 12, 18] },
        { name: "÷4 (standard)", stepsPerBeat: 4, roundUpThresholds: [3, 9, 17, 21] },
        { name: "÷6", stepsPerBeat: 6, roundUpThresholds: null },
        { name: "÷8", stepsPerBeat: 8, roundUpThresholds: null },
        { name: "÷12", stepsPerBeat: 12, roundUpThresholds: null },
        { name: "freehand", stepsPerBeat: 24, roundUpThresholds: null },
 
 
    ]);
    Config.instrumentTypeNames = ["chip", "FM", "noise", "spectrum", "drumset", "harmonics", "PWM", "Picked String", "custom chip", "mod", "FM8"];
    Config.instrumentTypeHasSpecialInterval = [true, true, false, false, false, true, false, false, false];
    Config.chipBaseExpression = 0.03375;
    Config.fmBaseExpression = 0.03;
    Config.noiseBaseExpression = 0.19;
    Config.spectrumBaseExpression = 0.3;
    Config.drumsetBaseExpression = 0.45;
    Config.harmonicsBaseExpression = 0.025;
    Config.pwmBaseExpression = 0.04725;
    Config.pickedStringBaseExpression = 0.025;
    Config.distortionBaseVolume = 0.011;
    Config.bitcrusherBaseVolume = 0.010;
    Config.rawChipWaves = toNameMap([
        { name: "rounded", expression: 0.94, isSampled: false, samples: centerWave([0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4, 0.2, 0.0, -0.2, -0.4, -0.5, -0.6, -0.7, -0.8, -0.85, -0.9, -0.95, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.7, -0.6, -0.5, -0.4, -0.2]) },
        { name: "triangle", expression: 1.0, isSampled: false, samples: centerWave([1.0 / 15.0, 3.0 / 15.0, 5.0 / 15.0, 7.0 / 15.0, 9.0 / 15.0, 11.0 / 15.0, 13.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 13.0 / 15.0, 11.0 / 15.0, 9.0 / 15.0, 7.0 / 15.0, 5.0 / 15.0, 3.0 / 15.0, 1.0 / 15.0, -1.0 / 15.0, -3.0 / 15.0, -5.0 / 15.0, -7.0 / 15.0, -9.0 / 15.0, -11.0 / 15.0, -13.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -13.0 / 15.0, -11.0 / 15.0, -9.0 / 15.0, -7.0 / 15.0, -5.0 / 15.0, -3.0 / 15.0, -1.0 / 15.0]) },
        { name: "square", expression: 0.5, isSampled: false, samples: centerWave([1.0, -1.0]) },
        { name: "1/4 pulse", expression: 0.5, isSampled: false, samples: centerWave([1.0, -1.0, -1.0, -1.0]) },
        { name: "1/8 pulse", expression: 0.5, isSampled: false, samples: centerWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },
        { name: "sawtooth", expression: 0.65, isSampled: false, samples: centerWave([1.0 / 31.0, 3.0 / 31.0, 5.0 / 31.0, 7.0 / 31.0, 9.0 / 31.0, 11.0 / 31.0, 13.0 / 31.0, 15.0 / 31.0, 17.0 / 31.0, 19.0 / 31.0, 21.0 / 31.0, 23.0 / 31.0, 25.0 / 31.0, 27.0 / 31.0, 29.0 / 31.0, 31.0 / 31.0, -31.0 / 31.0, -29.0 / 31.0, -27.0 / 31.0, -25.0 / 31.0, -23.0 / 31.0, -21.0 / 31.0, -19.0 / 31.0, -17.0 / 31.0, -15.0 / 31.0, -13.0 / 31.0, -11.0 / 31.0, -9.0 / 31.0, -7.0 / 31.0, -5.0 / 31.0, -3.0 / 31.0, -1.0 / 31.0]) },
        { name: "double saw", expression: 0.5, isSampled: false, samples: centerWave([0.0, -0.2, -0.4, -0.6, -0.8, -1.0, 1.0, -0.8, -0.6, -0.4, -0.2, 1.0, 0.8, 0.6, 0.4, 0.2]) },
        { name: "double pulse", expression: 0.4, isSampled: false, samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]) },
        { name: "spiky", expression: 0.4, isSampled: false, samples: centerWave([1.0, -1.0, 1.0, -1.0, 1.0, 0.0]) },
    ]);
	Config.sampledWaves = toNameMap([
		{ name: "kick", expression: 4.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(kicksample) },
		{ name: "snare", expression: 3.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(snaresample) },
		{ name: "piano1", expression: 3.0, isSampled: true, isPercussion: false, extraSampleDetune: 2, samples: centerWave(pianosample) },
		{ name: "WOW", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(WOWsample) },
		{ name: "overdrive", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -2, samples: centerWave(overdrivesample) },
		{ name: "trumpet", expression: 3.0, isSampled: true, isPercussion: false, extraSampleDetune: 1.2, samples: centerWave(trumpetsample) },
		{ name: "saxophone", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -5, samples: centerWave(saxophonesample) },
		{ name: "orchestrahit", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: 4.2, samples: centerWave(orchhitsample) },
		{ name: "detatched violin", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: 4.2, samples: centerWave(detatchedviolinsample) },
		{ name: "synth", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -0.8, samples: centerWave(synthsample) },
		{ name: "sonic3snare", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(sonic3snaresample) },
		{ name: "come on", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(comeonsample) },
		{ name: "choir", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -3, samples: centerWave(choirsample) },
		{ name: "overdriveguitar", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -6.2, samples: centerWave(overdrivensample) },
		{ name: "flute", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -6, samples: centerWave(flutesample) },
		{ name: "legato violin", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -28, samples: centerWave(legatoviolinsample) },
		{ name: "tremolo violin", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -33, samples: centerWave(tremoloviolinsample) },
		{ name: "amen break", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: -55, samples: centerWave(amenbreaksample) },
 
		{ name: "Cavaco", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(cavaco) },
 
		{ name: "darkretrobass", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(darkretrobass) },
		{ name: "phonklaugh", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(phonklaugh) },
		{ name: "anotherpluck", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(anotherpluck) },
		{ name: "phonk sound", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(phonksound) },
 
		{ name: "pianoC42", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(pianoC42) },
		{ name: "sampledpianoc6", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(C6pianoC6) },
		{ name: "sampledGuitar", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(guitarSampled) },
		{ name: "SampledOpenPad", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(openpadsample) },
{ name: "testbuffer1", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(testbuffer) },

 
 
		{ name: "clm synth", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(cmlsynth) },
		{ name: "piano F key", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(Fpianosample) },
		{ name: "texturepads", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -12, samples: centerWave(texturepads) },
{ name: "texturepads2", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -12, samples: centerWave(loopingtexture) },



{ name: "meowsynth", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(meowsynth2) },
{ name: "kickbuff", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(kickbuff) },
{ name: "pufbuff", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(pufbuff) },
{ name: "slapbuff", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(slapbuff) },
{ name: "violinbuff", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(violinbuff) },
{ name: "cello1buff", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(cello1fixed) },
{ name: "stringsbuff", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(stringsbuff) },
{ name: "cellobuff", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(cellobuff) },
{ name: "acousticguitar", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55/2, samples: centerWave(acousticguitar) },
{ name: "buffharp1", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(buffharp1) },
{ name: "elecpianobuff", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(elecpianobuff) },
{ name: "loficlap", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(loficlap) },
{ name: "pianobuff", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(pianobuff) },
{ name: "ambientplucks", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -12, samples: centerWave(ambientpluck) },
		{ name: "breakcoresample", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: -50, samples: centerWave( breakcoresample ) },
		{ name: "breakcore drum1", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(justdrum) },
{ name: "breakcore hitdrum", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(hitdrum) },
{ name: "breakcore per1", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(per1) },
		{ name: "breakcore break1", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(break1) },
{ name: "breakcore hihit", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(hihit) },
{ name: "breakcore cymbals", expression: 1.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(cymbals2) },
		{ name: "ambientsound", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -12, samples: centerWave(ambientsine) },
 
{ name: "somepiano", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(somepiano) },

		{ name: "aaa", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(aaa) },
		{ name: "neow", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(meow) },
		{ name: "vinyl_noise", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: 0, samples: centerWave(vinyl) },
 
		{ name: "marcato", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(marcato) },
		{ name: "legato", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(legato) },
		
 
		{ name: "classicharp", expression: 1.0, isSampled: true, isPercussion: false, extraSampleDetune: -55, samples: centerWave(classicharp) },
		{ name: "pizzicato violin", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: -11, samples: centerWave(pizzicatoviolinsample) },
		{ name: "tim allen grunt", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -20, samples: centerWave(timallengruntsample) },
		{ name: "tuba", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: 44, samples: centerWave(tubasample) },
		{ name: "loopingcymbal", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -17, samples: centerWave(loopingcymbalsample) },
		{ name: "standardkick", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: -7, samples: centerWave(kickdrumsample) },
		{ name: "standardsnare", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: 0, samples: centerWave(snaredrumsample) },
		{ name: "closedhihat", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: 5, samples: centerWave(closedhihatsample) },
		{ name: "foothihat", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: 4, samples: centerWave(foothihatsample) },
		{ name: "openhihat", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: -31, samples: centerWave(openhihatsample) },
		{ name: "crashcymbal", expression: 2.0, isSampled: true, isPercussion: true, extraSampleDetune: -43, samples: centerWave(crashsample) },
		{ name: "pianoC4", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -42.5, samples: centerWave(pianoC4sample) }, 
		{ name: "liver pad", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -22.5, samples: centerWave(liverpadsample) }, 

		{ name: "marimba", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -15.5, samples: centerWave(marimbasample) }, 
		{ name: "susdotwav", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -24.5, samples: centerWave(susdotwavsample) },
		{ name: "wackyboxtts", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -17.5, samples: centerWave(wackyboxttssample) }, 
		{ name: "peppersteak_1", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -42.2, samples: centerWave(peppersteak1) }, 
		{ name: "peppersteak_2", expression: 2.0, isSampled: true, isPercussion: false, extraSampleDetune: -47, samples: centerWave(peppersteak2) },
 


	]);
	
	Config.newWaves = toNameMap([
    { name: "sine", expression: 0.88, isSampled: false, samples: centerAndNormalizeWave([8.0, 9.0, 11.0, 12.0, 13.0, 14.0, 15.0, 15.0, 15.0, 15.0, 14.0, 14.0, 13.0, 11.0, 10.0, 9.0, 7.0, 6.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 2.0, 4.0, 5.0, 6.0]) },
    { name: "flute", expression: 0.8, isSampled: false, samples: centerAndNormalizeWave([3.0, 4.0, 6.0, 8.0, 10.0, 11.0, 13.0, 14.0, 15.0, 15.0, 14.0, 13.0, 11.0, 8.0, 5.0, 3.0]) },
    { name: "harp", expression: 0.8, isSampled: false, samples: centerAndNormalizeWave([0.0, 3.0, 3.0, 3.0, 4.0, 5.0, 5.0, 6.0, 7.0, 8.0, 9.0, 11.0, 11.0, 13.0, 13.0, 15.0, 15.0, 14.0, 12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 7.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0]) },
    { name: "sharp clarinet", expression: 0.38, isSampled: false, samples: centerAndNormalizeWave([0.0, 0.0, 0.0, 1.0, 1.0, 8.0, 8.0, 9.0, 9.0, 9.0, 8.0, 8.0, 8.0, 8.0, 8.0, 9.0, 9.0, 7.0, 9.0, 9.0, 10.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]) },
    { name: "soft clarinet", expression: 0.45, isSampled: false, samples: centerAndNormalizeWave([0.0, 1.0, 5.0, 8.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 11.0, 11.0, 12.0, 13.0, 12.0, 10.0, 9.0, 7.0, 6.0, 4.0, 3.0, 3.0, 3.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]) },
    { name: "alto sax", expression: 0.3, isSampled: false, samples: centerAndNormalizeWave([5.0, 5.0, 6.0, 4.0, 3.0, 6.0, 8.0, 7.0, 2.0, 1.0, 5.0, 6.0, 5.0, 4.0, 5.0, 7.0, 9.0, 11.0, 13.0, 14.0, 14.0, 14.0, 14.0, 13.0, 10.0, 8.0, 7.0, 7.0, 4.0, 3.0, 4.0, 2.0]) },
    { name: "bassoon", expression: 0.35, isSampled: false, samples: centerAndNormalizeWave([9.0, 9.0, 7.0, 6.0, 5.0, 4.0, 4.0, 4.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0, 11.0, 13.0, 13.0, 11.0, 10.0, 9.0, 7.0, 6.0, 4.0, 2.0, 1.0, 1.0, 1.0, 2.0, 2.0, 5.0, 11.0, 14.0]) },
    { name: "trumpet", expression: 0.22, isSampled: false, samples: centerAndNormalizeWave([10.0, 11.0, 8.0, 6.0, 5.0, 5.0, 5.0, 6.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 7.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 7.0, 8.0, 9.0, 11.0, 14.0]) },
    { name: "electric guitar", expression: 0.2, isSampled: false, samples: centerAndNormalizeWave([11.0, 12.0, 12.0, 10.0, 6.0, 6.0, 8.0, 0.0, 2.0, 4.0, 8.0, 10.0, 9.0, 10.0, 1.0, 7.0, 11.0, 3.0, 6.0, 6.0, 8.0, 13.0, 14.0, 2.0, 0.0, 12.0, 8.0, 4.0, 13.0, 11.0, 10.0, 13.0]) },
    { name: "organ", expression: 0.2, isSampled: false, samples: centerAndNormalizeWave([11.0, 10.0, 12.0, 11.0, 14.0, 7.0, 5.0, 5.0, 12.0, 10.0, 10.0, 9.0, 12.0, 6.0, 4.0, 5.0, 13.0, 12.0, 12.0, 10.0, 12.0, 5.0, 2.0, 2.0, 8.0, 6.0, 6.0, 5.0, 8.0, 3.0, 2.0, 1.0]) },
    { name: "pan flute", expression: 0.35, isSampled: false, samples: centerAndNormalizeWave([1.0, 4.0, 7.0, 6.0, 7.0, 9.0, 7.0, 7.0, 11.0, 12.0, 13.0, 15.0, 13.0, 11.0, 11.0, 12.0, 13.0, 10.0, 7.0, 5.0, 3.0, 6.0, 10.0, 7.0, 3.0, 3.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0]) },
    { name: "glitch", expression: 0.5, isSampled: false, samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0]) },
]);
Config.chipWaves = rawChipToIntegrated(Config.rawChipWaves).concat(rawChipToIntegrated(Config.sampledWaves), rawChipToIntegrated(Config.newWaves));
 
Config.rawRawChipWaves = Config.rawChipWaves.concat(Config.sampledWaves, Config.newWaves);

Config.newSet=toNameMap([]);


Config.rawChipWaves = toNameMap([
	{ name: "rounded", expression: 0.94, samples: centerWave([0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4, 0.2, 0.0, -0.2, -0.4, -0.5, -0.6, -0.7, -0.8, -0.85, -0.9, -0.95, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.7, -0.6, -0.5, -0.4, -0.2]) },
	{ name: "triangle", expression: 1.0, samples: centerWave([1.0 / 15.0, 3.0 / 15.0, 5.0 / 15.0, 7.0 / 15.0, 9.0 / 15.0, 11.0 / 15.0, 13.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 13.0 / 15.0, 11.0 / 15.0, 9.0 / 15.0, 7.0 / 15.0, 5.0 / 15.0, 3.0 / 15.0, 1.0 / 15.0, -1.0 / 15.0, -3.0 / 15.0, -5.0 / 15.0, -7.0 / 15.0, -9.0 / 15.0, -11.0 / 15.0, -13.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -13.0 / 15.0, -11.0 / 15.0, -9.0 / 15.0, -7.0 / 15.0, -5.0 / 15.0, -3.0 / 15.0, -1.0 / 15.0]) },
	{ name: "square", expression: 0.5, samples: centerWave([1.0, -1.0]) },
	{ name: "1/4 pulse", expression: 0.5, samples: centerWave([1.0, -1.0, -1.0, -1.0]) },
	{ name: "1/8 pulse", expression: 0.5, samples: centerWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "sawtooth", expression: 0.65, samples: centerWave([1.0 / 31.0, 3.0 / 31.0, 5.0 / 31.0, 7.0 / 31.0, 9.0 / 31.0, 11.0 / 31.0, 13.0 / 31.0, 15.0 / 31.0, 17.0 / 31.0, 19.0 / 31.0, 21.0 / 31.0, 23.0 / 31.0, 25.0 / 31.0, 27.0 / 31.0, 29.0 / 31.0, 31.0 / 31.0, -31.0 / 31.0, -29.0 / 31.0, -27.0 / 31.0, -25.0 / 31.0, -23.0 / 31.0, -21.0 / 31.0, -19.0 / 31.0, -17.0 / 31.0, -15.0 / 31.0, -13.0 / 31.0, -11.0 / 31.0, -9.0 / 31.0, -7.0 / 31.0, -5.0 / 31.0, -3.0 / 31.0, -1.0 / 31.0]) },
	{ name: "double saw", expression: 0.5, samples: centerWave([0.0, -0.2, -0.4, -0.6, -0.8, -1.0, 1.0, -0.8, -0.6, -0.4, -0.2, 1.0, 0.8, 0.6, 0.4, 0.2]) },
	{ name: "double pulse", expression: 0.4, samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "spiky", expression: 0.4, samples: centerWave([1.0, -1.0, 1.0, -1.0, 1.0, 0.0]) },
	{ name: "sine", expression: 0.88, samples: centerAndNormalizeWave([8.0, 9.0, 11.0, 12.0, 13.0, 14.0, 15.0, 15.0, 15.0, 15.0, 14.0, 14.0, 13.0, 11.0, 10.0, 9.0, 7.0, 6.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 2.0, 4.0, 5.0, 6.0]) },
	{ name: "flute", expression: 0.8, samples: centerAndNormalizeWave([3.0, 4.0, 6.0, 8.0, 10.0, 11.0, 13.0, 14.0, 15.0, 15.0, 14.0, 13.0, 11.0, 8.0, 5.0, 3.0]) },
	{ name: "harp", expression: 0.8, samples: centerAndNormalizeWave([0.0, 3.0, 3.0, 3.0, 4.0, 5.0, 5.0, 6.0, 7.0, 8.0, 9.0, 11.0, 11.0, 13.0, 13.0, 15.0, 15.0, 14.0, 12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 7.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0]) },
	{ name: "sharp clarinet", expression: 0.38, samples: centerAndNormalizeWave([0.0, 0.0, 0.0, 1.0, 1.0, 8.0, 8.0, 9.0, 9.0, 9.0, 8.0, 8.0, 8.0, 8.0, 8.0, 9.0, 9.0, 7.0, 9.0, 9.0, 10.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]) },
	{ name: "soft clarinet", expression: 0.45, samples: centerAndNormalizeWave([0.0, 1.0, 5.0, 8.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 11.0, 11.0, 12.0, 13.0, 12.0, 10.0, 9.0, 7.0, 6.0, 4.0, 3.0, 3.0, 3.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]) },
	{ name: "alto sax", expression: 0.3, samples: centerAndNormalizeWave([5.0, 5.0, 6.0, 4.0, 3.0, 6.0, 8.0, 7.0, 2.0, 1.0, 5.0, 6.0, 5.0, 4.0, 5.0, 7.0, 9.0, 11.0, 13.0, 14.0, 14.0, 14.0, 14.0, 13.0, 10.0, 8.0, 7.0, 7.0, 4.0, 3.0, 4.0, 2.0]) },
	{ name: "bassoon", expression: 0.35, samples: centerAndNormalizeWave([9.0, 9.0, 7.0, 6.0, 5.0, 4.0, 4.0, 4.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0, 11.0, 13.0, 13.0, 11.0, 10.0, 9.0, 7.0, 6.0, 4.0, 2.0, 1.0, 1.0, 1.0, 2.0, 2.0, 5.0, 11.0, 14.0]) },
	{ name: "trumpet", expression: 0.22, samples: centerAndNormalizeWave([10.0, 11.0, 8.0, 6.0, 5.0, 5.0, 5.0, 6.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 7.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 7.0, 8.0, 9.0, 11.0, 14.0]) },
	{ name: "electric guitar", expression: 0.2, samples: centerAndNormalizeWave([11.0, 12.0, 12.0, 10.0, 6.0, 6.0, 8.0, 0.0, 2.0, 4.0, 8.0, 10.0, 9.0, 10.0, 1.0, 7.0, 11.0, 3.0, 6.0, 6.0, 8.0, 13.0, 14.0, 2.0, 0.0, 12.0, 8.0, 4.0, 13.0, 11.0, 10.0, 13.0]) },
	{ name: "organ", expression: 0.2, samples: centerAndNormalizeWave([11.0, 10.0, 12.0, 11.0, 14.0, 7.0, 5.0, 5.0, 12.0, 10.0, 10.0, 9.0, 12.0, 6.0, 4.0, 5.0, 13.0, 12.0, 12.0, 10.0, 12.0, 5.0, 2.0, 2.0, 8.0, 6.0, 6.0, 5.0, 8.0, 3.0, 2.0, 1.0]) },
	{ name: "pan flute", expression: 0.35, samples: centerAndNormalizeWave([1.0, 4.0, 7.0, 6.0, 7.0, 9.0, 7.0, 7.0, 11.0, 12.0, 13.0, 15.0, 13.0, 11.0, 11.0, 12.0, 13.0, 10.0, 7.0, 5.0, 3.0, 6.0, 10.0, 7.0, 3.0, 3.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0]) },
	{ name: "glitch", expression: 0.5, samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0]) },
	{ name: "trapezoid", expression: 1.0, samples: centerWave([1.0 / 15.0, 6.0 / 15.0, 10.0 / 15.0, 14.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 14.0 / 15.0, 10.0 / 15.0, 6.0 / 15.0, 1.0 / 15.0, -1.0 / 15.0, -6.0 / 15.0, -10.0 / 15.0, -14.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -14.0 / 15.0, -10.0 / 15.0, -6.0 / 15.0, -1.0 / 15.0, ]) },
	{ name: "modbox 10% pulse", expression: 0.5, samples: centerAndNormalizeWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "modbox sunsoft bass", expression: 1.0, samples: centerAndNormalizeWave([0.0, 0.1875, 0.3125, 0.5625, 0.5, 0.75, 0.875, 1.0, 1.0, 0.6875, 0.5, 0.625, 0.625, 0.5, 0.375, 0.5625, 0.4375, 0.5625, 0.4375, 0.4375, 0.3125, 0.1875, 0.1875, 0.375, 0.5625, 0.5625, 0.5625, 0.5625, 0.5625, 0.4375, 0.25, 0.0]) },
	{ name: "modbox loud pulse", expression: 0.5, samples: centerAndNormalizeWave([1.0, 0.7, 0.1, 0.1, 0, 0, 0, 0, 0, 0.1, 0.2, 0.15, 0.25, 0.125, 0.215, 0.345, 4.0]) },
	{ name: "modbox sax", expression: 0.5, samples: centerAndNormalizeWave([1.0 / 15.0, 3.0 / 15.0, 5.0 / 15.0, 9.0, 0.06]) },
	{ name: "modbox guitar", expression: 0.5, samples: centerAndNormalizeWave([-0.5, 3.5, 3.0, -0.5, -0.25, -1.0]) },
	{ name: "modbox sine", expression: 0.5, samples: centerAndNormalizeWave([0.0, 0.05, 0.125, 0.2, 0.25, 0.3, 0.425, 0.475, 0.525, 0.625, 0.675, 0.725, 0.775, 0.8, 0.825, 0.875, 0.9, 0.925, 0.95, 0.975, 0.98, 0.99, 0.995, 1, 0.995, 0.99, 0.98, 0.975, 0.95, 0.925, 0.9, 0.875, 0.825, 0.8, 0.775, 0.725, 0.675, 0.625, 0.525, 0.475, 0.425, 0.3, 0.25, 0.2, 0.125, 0.05, 0.0, -0.05, -0.125, -0.2, -0.25, -0.3, -0.425, -0.475, -0.525, -0.625, -0.675, -0.725, -0.775, -0.8, -0.825, -0.875, -0.9, -0.925, -0.95, -0.975, -0.98, -0.99, -0.995, -1, -0.995, -0.99, -0.98, -0.975, -0.95, -0.925, -0.9, -0.875, -0.825, -0.8, -0.775, -0.725, -0.675, -0.625, -0.525, -0.475, -0.425, -0.3, -0.25, -0.2, -0.125, -0.05]) },
	{ name: "modbox atari bass", expression: 0.5, samples: centerAndNormalizeWave([1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]) },
	{ name: "modbox atari pulse", expression: 0.5, samples: centerAndNormalizeWave([1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]) },
	{ name: "modbox 1% pulse", expression: 0.5, samples: centerAndNormalizeWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "modbox curved sawtooth", expression: 0.5, samples: centerAndNormalizeWave([1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0 / 4.0]) },
	{ name: "modbox viola", expression: 0.45, samples: centerAndNormalizeWave([-0.9, -1.0, -0.85, -0.775, -0.7, -0.6, -0.5, -0.4, -0.325, -0.225, -0.2, -0.125, -0.1, -0.11, -0.125, -0.15, -0.175, -0.18, -0.2, -0.21, -0.22, -0.21, -0.2, -0.175, -0.15, -0.1, -0.5, 0.75, 0.11, 0.175, 0.2, 0.25, 0.26, 0.275, 0.26, 0.25, 0.225, 0.2, 0.19, 0.18, 0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.275, 0.28, 0.29, 0.3, 0.29, 0.28, 0.27, 0.26, 0.25, 0.225, 0.2, 0.175, 0.15, 0.1, 0.075, 0.0, -0.01, -0.025, 0.025, 0.075, 0.2, 0.3, 0.475, 0.6, 0.75, 0.85, 0.85, 1.0, 0.99, 0.95, 0.8, 0.675, 0.475, 0.275, 0.01, -0.15, -0.3, -0.475, -0.5, -0.6, -0.71, -0.81, -0.9, -1.0, -0.9]) },
	{ name: "modbox brass", expression: 0.45, samples: centerAndNormalizeWave([-1.0, -0.95, -0.975, -0.9, -0.85, -0.8, -0.775, -0.65, -0.6, -0.5, -0.475, -0.35, -0.275, -0.2, -0.125, -0.05, 0.0, 0.075, 0.125, 0.15, 0.20, 0.21, 0.225, 0.25, 0.225, 0.21, 0.20, 0.19, 0.175, 0.125, 0.10, 0.075, 0.06, 0.05, 0.04, 0.025, 0.04, 0.05, 0.10, 0.15, 0.225, 0.325, 0.425, 0.575, 0.70, 0.85, 0.95, 1.0, 0.9, 0.675, 0.375, 0.2, 0.275, 0.4, 0.5, 0.55, 0.6, 0.625, 0.65, 0.65, 0.65, 0.65, 0.64, 0.6, 0.55, 0.5, 0.4, 0.325, 0.25, 0.15, 0.05, -0.05, -0.15, -0.275, -0.35, -0.45, -0.55, -0.65, -0.7, -0.78, -0.825, -0.9, -0.925, -0.95, -0.975]) },
	{ name: "modbox acoustic bass", expression: 0.5, samples: centerAndNormalizeWave([1.0, 0.0, 0.1, -0.1, -0.2, -0.4, -0.3, -1.0]) },
	{ name: "modbox lyre", expression: 0.45, samples: centerAndNormalizeWave([1.0, -1.0, 4.0, 2.15, 4.13, 5.15, 0.0, -0.05, 1.0]) },
	{ name: "modbox ramp pulse", expression: 0.5, samples: centerAndNormalizeWave([6.1, -2.9, 1.4, -2.9]) },
	{ name: "modbox piccolo", expression: 0.5, samples: centerAndNormalizeWave([1, 4, 2, 1, -0.1, -1, -0.12]) },
	{ name: "modbox squaretooth", expression: 0.5, samples: centerAndNormalizeWave([0.2, 1.0, 2.6, 1.0, 0.0, -2.4]) },
	{ name: "modbox flatline", expression: 1.0, samples: centerAndNormalizeWave([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]) },
	{ name: "modbox pnryshk a (u5)", expression: 0.4, samples: centerAndNormalizeWave([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]) },
	{ name: "modbox pnryshk b (riff)", expression: 0.5, samples: centerAndNormalizeWave([1.0, -0.9, 0.8, -0.7, 0.6, -0.5, 0.4, -0.3, 0.2, -0.1, 0.0, -0.1, 0.2, -0.3, 0.4, -0.5, 0.6, -0.7, 0.8, -0.9, 1.0]) },
	{ name: "sandbox shrill lute", expression: 0.94, samples: centerAndNormalizeWave([1.0, 1.5, 1.25, 1.2, 1.3, 1.5]) },
	{ name: "sandbox bassoon", expression: 0.5, samples: centerAndNormalizeWave([1.0, -1.0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]) },
	{ name: "sandbox shrill bass", expression: 0.5, samples: centerAndNormalizeWave([0, 1, 0, 0, 1, 0, 1, 0, 0, 0]) },
	{ name: "sandbox nes pulse", expression: 0.4, samples: centerAndNormalizeWave([2.1, -2.2, 1.2, 3]) },
	{ name: "sandbox saw bass", expression: 0.25, samples: centerAndNormalizeWave([1, 1, 1, 1, 0, 2, 1, 2, 3, 1, -2, 1, 4, 1, 4, 2, 1, 6, -3, 4, 2, 1, 5, 1, 4, 1, 5, 6, 7, 1, 6, 1, 4, 1, 9]) },
	{ name: "sandbox euphonium", expression: 0.3, samples: centerAndNormalizeWave([0, 1, 2, 1, 2, 1, 4, 2, 5, 0, -2, 1, 5, 1, 2, 1, 2, 4, 5, 1, 5, -2, 5, 10, 1]) },
	{ name: "sandbox shrill pulse", expression: 0.3, samples: centerAndNormalizeWave([4 - 2, 0, 4, 1, 4, 6, 7, 3]) },
	{ name: "sandbox r-sawtooth", expression: 0.2, samples: centerAndNormalizeWave([6.1, -2.9, 1.4, -2.9]) },
	{ name: "sandbox recorder", expression: 0.2, samples: centerAndNormalizeWave([5.0, -5.1, 4.0, -4.1, 3.0, -3.1, 2.0, -2.1, 1.0, -1.1, 6.0]) },
	{ name: "sandbox narrow saw", expression: 1.2, samples: centerAndNormalizeWave([0.1, 0.13 / -0.1, 0.13 / -0.3, 0.13 / -0.5, 0.13 / -0.7, 0.13 / -0.9, 0.13 / -0.11, 0.13 / -0.31, 0.13 / -0.51, 0.13 / -0.71, 0.13 / -0.91, 0.13 / -0.12, 0.13 / -0.32, 0.13 / -0.52, 0.13 / -0.72, 0.13 / -0.92, 0.13 / -0.13, 0.13 / 0.13, 0.13 / 0.92, 0.13 / 0.72, 0.13 / 0.52, 0.13 / 0.32, 0.13 / 0.12, 0.13 / 0.91, 0.13 / 0.71, 0.13 / 0.51, 0.13 / 0.31, 0.13 / 0.11, 0.13 / 0.9, 0.13 / 0.7, 0.13 / 0.5, 0.13 / 0.3, 0.13]) },
	{ name: "sandbox deep square", expression: 1.0, samples: centerAndNormalizeWave([1.0, 2.25, 1.0, -1.0, -2.25, -1.0]) },
	{ name: "sandbox ring pulse", expression: 1.0, samples: centerAndNormalizeWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "sandbox double sine", expression: 1.0, samples: centerAndNormalizeWave([1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1, 1.0, 0.0, -1.0, -1.1, -1.2, -1.3, -1.4, -1.5, -1.6, -1.7, -1.8, -1.9, -1.8, -1.7, -1.6, -1.5, -1.4, -1.3, -1.2, -1.1, -1.0]) },
	{ name: "sandbox contrabass", expression: 0.5, samples: centerAndNormalizeWave([4.20, 6.9, 1.337, 6.66]) },
	{ name: "sandbox double bass", expression: 0.4, samples: centerAndNormalizeWave([0.0, 0.1875, 0.3125, 0.5625, 0.5, 0.75, 0.875, 1.0, -1.0, -0.6875, -0.5, -0.625, -0.625, -0.5, -0.375, -0.5625, -0.4375, -0.5625, -0.4375, -0.4375, -0.3125, -0.1875, 0.1875, 0.375, 0.5625, -0.5625, 0.5625, 0.5625, 0.5625, 0.4375, 0.25, 0.0]) },
	{ name: "haileybox test1", expression: 0.5, samples: centerAndNormalizeWave([1.0, 0.5, -1.0]) },
	{ name: "brucebox pokey 4bit lfsr", expression: 0.5, samples: centerAndNormalizeWave([1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0]) },
	{ name: "brucebox pokey 5step bass", expression: 0.5, samples: centerAndNormalizeWave([1.0, -1.0, 1.0, -1.0, 1.0]) },
	{ name: "brucebox isolated spiky", expression: 0.5, samples: centerAndNormalizeWave([1.0, -1.0, 1.0, -1.0, 1.0, -1.0]) },
	{ name: "nerdbox unnamed 1", expression: 0.5, samples: centerAndNormalizeWave([0.2, 0.8 / 0.2, 0.7, -0.4, -1.0, 0.5, -0.5 / 0.6]) },
	{ name: "nerdbox unnamed 2", expression: 0.5, samples: centerAndNormalizeWave([2.0, 5.0 / 55.0, -9.0, 6.5 / 6.5, -55.0, 18.5 / -26.0]) },
	{ name: "zefbox semi-square", expression: 1.0, samples: centerAndNormalizeWave([1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.0, 1.5, 1.0]) },
	{ name: "zefbox deep square", expression: 1.0, samples: centerAndNormalizeWave([1.0, 2.25, 1.0, -1.0, -2.25, -1.0]) },
	{ name: "zefbox squaretal", expression: 0.7, samples: centerAndNormalizeWave([1.5, 1.0, 1.5, -1.5, -1.0, -1.5]) },
	{ name: "zefbox saw wide", expression: 0.65, samples: centerAndNormalizeWave([0.0, -0.4, -0.8, -1.2, -1.6, -2.0, 0.0, -0.4, -0.8, -1.2, -1.6]) },
	{ name: "zefbox saw narrow", expression: 0.65, samples: centerAndNormalizeWave([1, 0.5, 1, 0.5, 1, 0.5, 1, 2, 1, 2, 1]) },
	{ name: "zefbox deep sawtooth", expression: 0.5, samples: centerAndNormalizeWave([0, 2, 3, 4, 4.5, 5, 5.5, 6, 6.25, 6.5, 6.75, 7, 6.75, 6.5, 6.25, 6, 5.5, 5, 4.5, 4, 3, 2, 1]) },
	{ name: "zefbox sawtal", expression: 0.3, samples: centerAndNormalizeWave([1.5, 1.0, 1.25, -0.5, 1.5, -0.5, 0.0, -1.5, 1.5, 0.0, 0.5, -1.5, 0.5, 1.25, -1.0, -1.5]) },
	{ name: "zefbox deep sawtal", expression: 0.7, samples: centerAndNormalizeWave([0.75, 0.25, 0.5, -0.5, 0.5, -0.5, -0.25, -0.75]) },
	{ name: "zefbox pulse", expression: 0.5, samples: centerAndNormalizeWave([1.0, -2.0, -2.0, -1.5, -1.5, -1.25, -1.25, -1.0, -1.0]) },
	{ name: "zefbox triple pulse", expression: 0.4, samples: centerAndNormalizeWave([1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.5, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.5]) },
	{ name: "zefbox high pulse", expression: 0.2, samples: centerAndNormalizeWave([1, -2, 2, -3, 3, -4, 5, -4, 3, -3, 2, -2, 1]) },
	{ name: "zefbox deep pulse", expression: 0.2, samples: centerAndNormalizeWave([1, 2, 2, -2, -2, -3, -4, -4, -5, -5, -5, -5, 0, -1, -2]) },
	{ name: "wackybox guitar string", expression: 0.6, samples: centerAndNormalizeWave([0, 63, 63, 63, 63, 19, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 11, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 27, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 34, 63, 63, 63, 63]) },
	{ name: "wackybox intense", expression: 0.6, samples: centerAndNormalizeWave([36, 25, 33, 35, 18, 51, 22, 40, 27, 37, 31, 33, 25, 29, 41, 23, 31, 31, 45, 20, 37, 23, 29, 26, 42, 29, 33, 26, 31, 27, 40, 25, 40, 26, 37, 24, 41, 32, 0, 32, 33, 29, 32, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]) },
	{ name: "wackybox buzz wave", expression: 0.6, samples: centerAndNormalizeWave([0, 1, 1, 2, 4, 4, 4, 4, 5, 5, 6, 6, 6, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 11, 15, 23, 62, 61, 60, 58, 56, 56, 54, 53, 52, 50, 49, 48, 47, 47, 45, 45, 45, 44, 44, 43, 43, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 53]) },
	{ name: "todbox 1/3 pulse", expression: 0.5, samples: centerWave([1.0, -1.0, -1.0]) },
	{ name: "todbox 1/5 pulse", expression: 0.5, samples: centerWave([1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "todbox slap bass", expression: 0.5, samples: centerAndNormalizeWave([1, 0.5, 0, 0.5, 1.25, 0.5, -0.25, 0.1, -0.1, 0.1, 1.1, 2.1, 3, 3.5, 2.9, 3.3, 2.7, 2.9, 2.3, 2, 1.9, 1.8, 1, 0.7, 0.9, 0.8, 0.4, 0.1, 0.0, 0.2, 0.4, 0.6, 0.5, 0.8]) },
	{ name: "todbox harsh wave", expression: 0.45, samples: centerAndNormalizeWave([1.0, -1.0, -1.0, -1.0, 0.5, 0.5, 0.5, 0.7, 0.39, 1.3, 0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },
	{ name: "todbox accordian", expression: 0.5, samples: centerAndNormalizeWave([0, 1, 1, 2, 2, 1.5, 1.5, 0.8, 0, -2, -3.25, -4, -4.5, -5.5, -6, -5.75, -5.5, -5, -5, -5, -6, -6, -6, -5, -4, -3, -2, -1, 0.75, 1, 2, 3, 4, 5, 6, 6.5, 7.5, 8, 7.75, 6, 5.25, 5, 5, 5, 5, 5, 4.25, 3.75, 3.25, 2.75, 1.25, -0.75, -2, -0.75, 1.25, 1.25, 2, 2, 2, 2, 1.5, -1, -2, -1, 1.5, 2, 2.75, 2.75, 2.75, 3, 2.75, -1, -2, -2.5, -2, -1, -2.25, -2.75, -2, -3, -1.75, 1, 2, 3.5, 4, 5.25, 6, 8, 9.75, 10, 9.5, 9, 8.5, 7.5, 6.5, 5.25, 5, 4.5, 4, 4, 4, 3.25, 2.5, 2, 1, -0.5, -2, -3.5, -4, -4, -4, -3.75, -3, -2, -1]) },
	{ name: "todbox beta banana wave", expression: 0.8, samples: centerAndNormalizeWave([0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4, 0.2, 0.0]) },
	{ name: "todbox beta test wave", expression: 0.5, samples: centerAndNormalizeWave([56, 0, -52, 16, 3, 3, 2, -35, 20, 147, -53, 0, 0, 5, -6]) },
	{ name: "todbox beta real snare", expression: 1.0, samples: centerAndNormalizeWave([0.00000, -0.01208, -0.02997, -0.04382, -0.06042, -0.07529, -0.09116, -0.10654, -0.12189, -0.13751, -0.15289, -0.16849, -0.18387, -0.19974, -0.21484, -0.23071, -0.24557, -0.26144, -0.27731, -0.29141, -0.30350, -0.32416, -0.34406, -0.32947, -0.31158, -0.33725, -0.37579, -0.39746, -0.40201, -0.40906, -0.44180, -0.47229, -0.47379, -0.47733, -0.45239, -0.33954, -0.22894, -0.22443, -0.32138, -0.46371, -0.57178, -0.61081, -0.59998, -0.61459, -0.62189, -0.43979, -0.19217, -0.12643, -0.17252, -0.20956, -0.20981, -0.19217, -0.22845, -0.34332, -0.50629, -0.64307, -0.72922, -0.81384, -0.87857, -0.90149, -0.88687, -0.86169, -0.87781, -0.80478, -0.52493, -0.31308, -0.33249, -0.39395, -0.39017, -0.30301, -0.19949, -0.13071, -0.02493, 0.14307, 0.34961, 0.52542, 0.63223, 0.68613, 0.74710, 0.87305, 0.98184, 0.98889, 0.97052, 0.99066, 0.99747, 0.99344, 0.99469, 0.99393, 0.99570, 0.99393, 0.99521, 0.99469, 0.99420, 0.99521, 0.99420, 0.99521, 0.99469, 0.99469, 0.99521, 0.99420, 0.99545, 0.99445, 0.99469, 0.99493, 0.99420, 0.99521, 0.99393, 0.99493, 0.99469, 0.99445, 0.99570, 0.99445, 0.99521, 0.99469, 0.99469, 0.99521, 0.99420, 0.99545, 0.99445, 0.99445, 0.99493, 0.99420, 0.99545, 0.99420, 0.99493, 0.99493, 0.99420, 0.99545, 0.99445, 0.99521, 0.99469, 0.99445, 0.99545, 0.99368, 0.99393, 0.99445, 0.99268, 0.97983, 0.97229, 0.95944, 0.88486, 0.76773, 0.64481, 0.53098, 0.39847, 0.19318, -0.03827, -0.20325, -0.39319, -0.68765, -0.88461, -0.93448, -0.96069, -0.97681, -0.98715, -0.99042, -0.99142, -0.99091, -0.99142, -0.99219, -0.99091, -0.99219, -0.99066, -0.99142, -0.99142, -0.99118, -0.99191, -0.99066, -0.99191, -0.99142, -0.99142, -0.99191, -0.99091, -0.99219, -0.99118, -0.99142, -0.99167, -0.99091, -0.99219, -0.99091, -0.99167, -0.99142, -0.99091, -0.99191, -0.99091, -0.99191, -0.99142, -0.99118, -0.99191, -0.99066, -0.99191, -0.99118, -0.99142, -0.99191, -0.99066, -0.99191, -0.99091, -0.99167, -0.99191, -0.99118, -0.99219, -0.99091, -0.99191, -0.99142, -0.99142, -0.99243, -0.98865, -0.98764, -0.99219, -0.98083, -0.92517, -0.92770, -0.91486, -0.59042, -0.15189, 0.02945, 0.05667, 0.06195, 0.00629, -0.18008, -0.56497, -0.88010, -0.92770, -0.92871, -0.97705, -0.99167, -0.98663, -0.99118, -0.99042, -0.99219, -0.99142, -0.99118, -0.98941, -0.99219, -1.00000, -0.97580, -0.95993, -0.99948, -0.98236, -0.84659, -0.74860, -0.70679, -0.59747, -0.48035, -0.41687, -0.36826, -0.29745, -0.18185, -0.06219, 0.02164, 0.07907, 0.13123, 0.18033, 0.19620, 0.15692, 0.14053, 0.20251, 0.27530, 0.30905, 0.29092, 0.27252, 0.30402, 0.32416, 0.32214, 0.35239, 0.39670, 0.43198, 0.49420, 0.58487, 0.64154, 0.65967, 0.67050, 0.67026, 0.66522, 0.65540, 0.66119, 0.70627, 0.75842, 0.78738, 0.78940, 0.78763, 0.80402, 0.85944, 0.94559, 0.98990, 0.98160, 0.98007, 0.99368, 0.99393, 0.98538, 0.97580, 0.97101, 0.93802, 0.81812, 0.64633, 0.46649, 0.28613, 0.14685, 0.08966, 0.12543, 0.20325, 0.24557, 0.18866, 0.02795, -0.20175, -0.44205, -0.58713, -0.57629, -0.41385, -0.14255, 0.18033, 0.47882, 0.68311, 0.72314, 0.62064, 0.48309, 0.43073, 0.53577, 0.72794, 0.90250, 0.97354, 0.97000, 0.98083, 0.99191, 0.99319, 0.99493, 0.99393, 0.99521, 0.99393, 0.99545, 0.99420, 0.99493, 0.99493, 0.99445, 0.99545, 0.99420, 0.99545, 0.99243, 0.98917, 0.98386, 0.97781, 0.95844, 0.89066, 0.81561, 0.78134, 0.77277, 0.75995, 0.73022, 0.67126, 0.57178, 0.47000, 0.38361, 0.29419, 0.20703, 0.14734, 0.15866, 0.25162, 0.35818, 0.45062, 0.56750, 0.69748, 0.81232, 0.89697, 0.95062, 0.97656, 0.98615, 0.99191, 0.99219, 0.99243, 0.99368, 0.99368, 0.97028, 0.95566, 0.94559, 0.82617, 0.59973, 0.38361, 0.23901, 0.15338, 0.12921, 0.11206, 0.04382, -0.12946, -0.43552, -0.72644, -0.89847, -0.95465, -0.95541, -0.97229, -0.99268, -0.99319, -0.98840, -0.99142, -0.99167, -0.99091, -0.98840, -0.98965, -0.99368, -0.97455, -0.95010, -0.94684, -0.96219, -0.98514, -0.99243, -0.98889, -0.98917, -0.99142, -0.99219, -0.99091, -0.99191, -0.99142, -0.99142, -0.99191, -0.99066, -0.99167, -0.99091, -0.99142, -0.99191, -0.99091, -0.99191, -0.99091, -0.99167, -0.99167, -0.99091, -0.99219, -0.99091, -0.99191, -0.99142, -0.99118, -0.99191, -0.99066, -0.99191, -0.99091, -0.99118, -0.99243, -0.98941, -0.98462, -0.96976, -0.96320, -0.96194, -0.87305, -0.66196, -0.44809, -0.29495, -0.18085, -0.11813, -0.11334, -0.18564, -0.34885, -0.58237, -0.80450, -0.93726, -0.97806, -0.97354, -0.97531, -0.98990, -0.99368, -0.98941, -0.99219, -0.99091, -0.99142, -0.99167, -0.99091, -0.99191, -0.99118, -0.99219, -0.98236, -0.97781, -0.97656, -0.95135, -0.87204, -0.71335, -0.52139, -0.34232, -0.17783, -0.00906, 0.14886, 0.30450, 0.48889, 0.67404, 0.84030, 0.94128, 0.97681, 0.98462, 0.98337, 0.99142, 0.99521, 0.99493, 0.99420, 0.99445, 0.99521, 0.99393, 0.99545, 0.99445, 0.99521, 0.99521, 0.99445, 0.99570, 0.99445, 0.99521, 0.99469, 0.99445, 0.99521, 0.99420, 0.99521, 0.99445, 0.99445, 0.99521, 0.99445, 0.99545, 0.99445, 0.99469, 0.99493, 0.99393, 0.99493, 0.99445, 0.99393, 0.98285, 0.97781, 0.97479, 0.92844, 0.82114, 0.66095, 0.52417, 0.46826, 0.46722, 0.47934, 0.47379, 0.47076, 0.48209, 0.42014, 0.25439, 0.10074, -0.00302, -0.08966, -0.16068, -0.21436, -0.22040, -0.15137, -0.00476, 0.18536, 0.37631, 0.52292, 0.62164, 0.70425, 0.74835, 0.72366, 0.63928, 0.52567, 0.40805, 0.35666, 0.42896, 0.60175, 0.80200, 0.92743, 0.96548, 0.97632, 0.98337, 0.99066, 0.99521, 0.99420, 0.99368, 0.99292, 0.98840, 0.98083, 0.96774, 0.93323, 0.85440, 0.69470, 0.47202, 0.20425, -0.08890, -0.36423, -0.60025, -0.77481, -0.90173, -0.96017, -0.97028, -0.98108, -0.98840, -0.99219, -0.98990, -0.99219, -0.99142, -0.99142, -0.99219, -0.99091, -0.99243, -0.99066, -0.99142, -0.99142, -0.99118, -0.99191, -0.99066, -0.99167, -0.99142, -0.99142, -0.99219, -0.99091, -0.99191, -0.99118, -0.99142, -0.99191, -0.99091, -0.99191, -0.99091, -0.99167, -0.99191, -0.99118, -0.99219, -0.99091, -0.99167, -0.99142, -0.99142, -0.99219, -0.99091, -0.99191, -0.99142, -0.99118, -0.98917, -0.99042, -0.99445, -0.97330, -0.95590, -0.96219, -0.89670, -0.72241, -0.55112, -0.44809, -0.39319, -0.37833, -0.35641, -0.26270, -0.14230, -0.11282, -0.13525, -0.11536, -0.09671, -0.11511, -0.18060, -0.26874, -0.33374, -0.42215, -0.51358, -0.44785, -0.30450, -0.28613, -0.30527, -0.25037, -0.15390, -0.08286, -0.11157, -0.12592, -0.00327, 0.13803, 0.19141, 0.12820, 0.01788, -0.03952, -0.12592, -0.26773, -0.34634, -0.31384, -0.18060, -0.01080, 0.13574, 0.26120, 0.36975, 0.46573, 0.55087, 0.63626, 0.73022, 0.83072, 0.92014, 0.97177, 0.98587, 0.98413, 0.99167, 0.99445, 0.99292, 0.99219, 0.98740, 0.98007, 0.96472, 0.92239, 0.82166, 0.69067, 0.57959, 0.54962, 0.59695, 0.64255, 0.64633, 0.60629, 0.55942, 0.54910, 0.58966, 0.61887, 0.56952, 0.54181, 0.59518, 0.63248, 0.63876, 0.65463, 0.73398, 0.88312, 0.96927, 0.97101, 0.97958, 0.99344, 0.99420, 0.99268, 0.99493, 0.99469, 0.99445, 0.99521, 0.99445, 0.99545, 0.99420, 0.99493, 0.99493, 0.99420, 0.99545, 0.99420, 0.99493, 0.99420, 0.99393, 0.99420, 0.98840, 0.98309, 0.98309, 0.96069, 0.88461, 0.79370, 0.72064, 0.65765, 0.59998, 0.53247, 0.49268, 0.48615, 0.44205, 0.38034, 0.36447, 0.38715, 0.39294, 0.32645, 0.19595, 0.07782, -0.05893, -0.27832, -0.48309, -0.62619, -0.72995, -0.79999, -0.84583, -0.82166, -0.73575, -0.67227, -0.65491, -0.64960, -0.66397, -0.70175, -0.72894, -0.74658, -0.76724, -0.79520, -0.82846, -0.86523, -0.90527, -0.94382, -0.89948, -0.69849, -0.47479, -0.31662, -0.15414, -0.00729, 0.07077, 0.08237, 0.04431, -0.02292, -0.11761, -0.24307, -0.36926, -0.45087, -0.46170, -0.40250, -0.30679, -0.17529, 0.00000, 0.14331, 0.24179, 0.36774, 0.49545, 0.56522, 0.57907, 0.56775, 0.53851, 0.51132, 0.48688, 0.41913, 0.26044, 0.00955, -0.26297, -0.46396, -0.62341, -0.82214, -0.94684, -0.96774, -0.97531, -0.98413, -0.99017, -0.98990, -0.99219, -0.99066, -0.99142, -0.99167, -0.99118, -0.99219, -0.98990, -0.99118, -0.99368, -0.99142, -0.97757, -0.97403, -0.98007, -0.96170, -0.86826, -0.67783, -0.52719, -0.48788, -0.45490, -0.43146, -0.47681, -0.54105, -0.57983, -0.60904, -0.62317, -0.59949, -0.55566, -0.52063, -0.52115, -0.55112, -0.56244, -0.58337, -0.65540, -0.73373, -0.77228, -0.74759, -0.68890, -0.64609, -0.61887, -0.58060, -0.50351, -0.40729, -0.33929, -0.35110, -0.42944, -0.47028, -0.42267, -0.32718, -0.20224, -0.05640, 0.04556, 0.10529, 0.17630, 0.26169, 0.33197, 0.32138, 0.23776, 0.20956, 0.23148, 0.20352, 0.23325, 0.39267, 0.52719, 0.58438, 0.62289, 0.66345, 0.70023, 0.66296, 0.54330, 0.42618, 0.33475, 0.24533, 0.14105, 0.03851, 0.01358, 0.09143, 0.22845, 0.34961, 0.41711, 0.48740, 0.58914, 0.69519, 0.78186, 0.84357, 0.89822, 0.95389, 0.98135, 0.98615, 0.99167, 0.99243, 0.99445, 0.99420, 0.99469, 0.99493, 0.99393, 0.99545, 0.99445, 0.99521, 0.99469, 0.99445, 0.99521, 0.99420, 0.99469, 0.98965, 0.98715, 0.98563, 0.96295, 0.91736, 0.86624, 0.82367, 0.77554, 0.68411, 0.53549, 0.38916, 0.26120, 0.11435, -0.04053, -0.18161, -0.23172, -0.19394, -0.15237, -0.10730, -0.02997, 0.08588, 0.22620, 0.34305, 0.44104, 0.55740, 0.65765, 0.71259, 0.69217, 0.65363, 0.69748, 0.79572, 0.89368, 0.95514, 0.97733, 0.98413, 0.98816, 0.99243, 0.99445, 0.99243, 0.97302, 0.96674, 0.97983, 0.90378, 0.71005, 0.51056, 0.40451, 0.40982, 0.41559, 0.32996, 0.24356, 0.18866, 0.11411, 0.05365, 0.01157, -0.03247, -0.09216, -0.16095, -0.23248, -0.31662, -0.39771, -0.48663, -0.59647, -0.71536, -0.82013, -0.85287, -0.82947, -0.84937, -0.92215, -0.97177, -0.98663, -0.98816, -0.98438, -0.99091, -0.99219, -0.99091, -0.99191, -0.99042, -0.99191, -0.99091, -0.99142, -0.99191, -0.99091, -0.99191, -0.99091, -0.99167, -0.99142]) },
	{ name: "ultrabox shortened od guitar", expression: 0.5, samples: centerAndNormalizeWave([-0.82785, -0.67621, -0.40268, -0.43817, -0.45468, -0.22531, -0.18329, 0.24750, 0.71246, 0.52155, 0.56082, 0.48395, 0.33990, 0.46957, 0.27744, 0.42313, 0.47104, 0.18796, 0.12930, -0.13901, -0.07431, -0.16348, -0.74857, -0.73206, -0.35181, -0.26227, -0.41882, -0.27786, -0.19806, -0.19867, 0.18643, 0.24808, 0.08847, -0.06964, 0.06912, 0.20474, -0.05304, 0.29416, 0.31967, 0.14243, 0.27521, -0.23932, -0.14752, 0.12360, -0.26123, -0.26111, 0.06616, 0.26520, 0.08090, 0.15240, 0.16254, -0.12061, 0.04562, 0.00131, 0.04050, 0.08182, -0.21729, -0.17041, -0.16312, -0.08563, 0.06390, 0.05099, 0.05627, 0.02728, 0.00726, -0.13028, -0.05673, -0.14969, -0.17645, 0.35492, 0.16766, -0.00897, 0.24326, -0.00461, -0.04456, 0.01776, -0.04950, -0.01221, 0.02039, 0.07684, 0.13397, 0.39850, 0.35962, 0.13754, 0.42310, 0.27161, -0.17609, 0.03659, 0.10635, -0.21909, -0.22046, -0.20258, -0.40973, -0.40280, -0.40521, -0.66284]) },
]);
Config.jummboxWaves = Config.rawChipWaves;
Config.chipNoises = toNameMap([
    { name: "retro", expression: 0.25, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },
    { name: "white", expression: 1.0, basePitch: 69, pitchFilterMult: 8.0, isSoft: true, samples: null },
    { name: "clang", expression: 0.4, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },
    { name: "buzz", expression: 0.3, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },
    { name: "hollow", expression: 1.5, basePitch: 96, pitchFilterMult: 1.0, isSoft: true, samples: null },
    { name: "shine", expression: 1.0, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },
    { name: "deep", expression: 1.5, basePitch: 120, pitchFilterMult: 1024.0, isSoft: true, samples: null },
    { name: "cutter", expression: 0.005, basePitch: 96, pitchFilterMult: 1024.0, isSoft: false, samples: null },
    { name: "metallic", expression: 1.0, basePitch: 96, pitchFilterMult: 1024.0, isSoft: false, samples: null },
    
        { name: "static", expression: 1.0, basePitch: 96, pitchFilterMult: 1024.0, isSoft: false, samples: null },
        { name: "1-bit white", expression: 0.5, basePitch: 74.41, pitchFilterMult: 1024.0, isSoft: false, samples: null },
        { name: "1-bit metallic", expression: 0.5, basePitch: 86.41, pitchFilterMult: 1024.0, isSoft: false, samples: null },
        { name: "crackling", expression: 0.9, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },
        { name: "pink", expression: 1.0, basePitch: 69, pitchFilterMult: 8.0, isSoft: true, samples: null },
        { name: "brownian", expression: 1.0, basePitch: 69, pitchFilterMult: 8.0, isSoft: true, samples: null },
    
]);
  updateSampledWaves = function() {
    if(filesMap){
  const existingNames = new Set(Config.newSet.map(s => s.name));
  const newSamples = [];

  for (const id in filesMap) {
    const entry = filesMap[id];
    if (!existingNames.has(entry.name)) {
      if( ( entry.extradetune )!==undefined){
if(entry.expression!==undefined&&entry.expression&&entry.extradetune!==undefined && entry.extradetune){
      newSamples.push({
        name: entry.name,
        expression: parseInt( entry.expression ) ,
        isSampled: true,
        isPercussion: false,
        extraSampleDetune:parseInt( entry.extradetune ),
        samples: centerWave(entry.buffer)
      });
      }else{
newSamples.push({
  name: entry.name,
  expression:   2.0,
  isSampled: true,
  isPercussion: false,
  extraSampleDetune: 0,
  samples: centerWave(entry.buffer)
});
      }
      }else{
newSamples.push({
  name: entry.name,
  expression: 2.0,
  isSampled: true,
  isPercussion: false,
  extraSampleDetune: parseInt(entry.extradetune) || 0,
  samples: centerWave(entry.buffer)
});
      }
    }
  }
  Config.newSet = toNameMap([
    ...Config.newSet,
]);
Config.rawRawChipWaves = Config.rawChipWaves.concat(Config.sampledWaves,Config.newWaves);
Config.chipWaves = rawChipToIntegrated(Config.newSet).concat(rawChipToIntegrated(Config.rawChipWaves), rawChipToIntegrated(Config.sampledWaves), rawChipToIntegrated(Config.newWaves), rawChipToIntegrated(newSamples) );
Config.jummboxWaves = Config.rawChipWaves;
 const namess = new Set(Config.rawRawChipWaves.map(s => s.name));
 renderFileList() 

}}

  
    


updateSampledWaves()


	
    
    
    Config.filterFreqStep = 1.0 / 4.0;
    Config.filterFreqRange = 34;
    Config.filterFreqReferenceSetting = 28;
    Config.filterFreqReferenceHz = 8000.0;
    Config.filterFreqMaxHz = Config.filterFreqReferenceHz * Math.pow(2.0, Config.filterFreqStep * (Config.filterFreqRange - 1 - Config.filterFreqReferenceSetting));
    Config.filterFreqMinHz = 8.0;
    Config.filterGainRange = 15;
    Config.filterGainCenter = 7;
    Config.filterGainStep = 1.0 / 2.0;
    Config.filterMaxPoints = 8;
    Config.filterTypeNames = ["low-pass", "high-pass", "peak"];
    Config.filterMorphCount = 10;
    Config.filterSimpleCutRange = 11;
    Config.filterSimplePeakRange = 8;
    Config.fadeInRange = 10;
    Config.fadeOutTicks = [-24, -12, -6, -3, -1, 6, 12, 24, 48, 72, 96];
    Config.fadeOutNeutral = 4;
    Config.drumsetFadeOutTicks = 48;
    Config.transitions = toNameMap([
        { name: "normal", isSeamless: false, continues: false, slides: false, slideTicks: 3, includeAdjacentPatterns: false },
        { name: "interrupt", isSeamless: true, continues: false, slides: false, slideTicks: 3, includeAdjacentPatterns: true },
        { name: "continue", isSeamless: true, continues: true, slides: false, slideTicks: 3, includeAdjacentPatterns: true },
        { name: "slide", isSeamless: true, continues: false, slides: true, slideTicks: 3, includeAdjacentPatterns: true },
        { name: "slide in pattern", isSeamless: true, continues: false, slides: true, slideTicks: 3, includeAdjacentPatterns: false },
    ]);
    Config.vibratos = toNameMap([
        { name: "none", amplitude: 0.0, type: 0, delayTicks: 0 },
        { name: "light", amplitude: 0.15, type: 0, delayTicks: 0 },
        { name: "delayed", amplitude: 0.3, type: 0, delayTicks: 37 },
        { name: "heavy", amplitude: 0.45, type: 0, delayTicks: 0 },
        { name: "shaky", amplitude: 0.1, type: 1, delayTicks: 0 },
    ]);
    Config.vibratoTypes = toNameMap([
        { name: "normal", periodsSeconds: [0.14], period: 0.14 },
        { name: "shaky", periodsSeconds: [0.11, 1.618 * 0.11, 3 * 0.11], period: 266.97 },
    ]);
    Config.arpSpeedScale = [0, 0.0625, 0.125, 0.2, 0.25, 1 / 3, 0.4, 0.5, 2 / 3, 0.75, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4, 4.15, 4.3, 4.5, 4.8, 5, 5.5, 6, 8];
    Config.unisons = toNameMap([
        { name: "none", voices: 1, spread: 0.0, offset: 0.0, expression: 1.4, sign: 1.0 },
        { name: "shimmer", voices: 2, spread: 0.018, offset: 0.0, expression: 0.8, sign: 1.0 },
        { name: "hum", voices: 2, spread: 0.045, offset: 0.0, expression: 1.0, sign: 1.0 },
        { name: "honky tonk", voices: 2, spread: 0.09, offset: 0.0, expression: 1.0, sign: 1.0 },
        { name: "dissonant", voices: 2, spread: 0.25, offset: 0.0, expression: 0.9, sign: 1.0 },
        { name: "fifth", voices: 2, spread: 3.5, offset: 3.5, expression: 0.9, sign: 1.0 },
        { name: "octave", voices: 2, spread: 6.0, offset: 6.0, expression: 0.8, sign: 1.0 },
        
        { name: "bowed", voices: 2, spread: 0.02, offset: 0.0, expression: 1.0, sign: -1.0 },
        { name: "piano", voices: 2, spread: 0.01, offset: 0.0, expression: 1.0, sign: 0.7 },
        { name: "warbled", voices: 2, spread: 0.25, offset: 0.05, expression: 0.9, sign: -0.8 },
        { name: "octave/2", voices: 2, spread: 3.0, offset: 3.0, expression: 0.8, sign: -0.8 },
 { name: "super", voices: 6, spread: 0.08, offset: 0.0, expression: 0.9, sign: 1.0 },
{ name: "chorus", voices: 3, spread: 0.02, offset: 0.01, expression: 1.0, sign: 1.0 },
{ name: "phased", voices: 2, spread: 0.1, offset: 0.03, expression: 0.85, sign: -1.0 },
{ name: "inv fifth", voices: 4, spread: 3.5, offset: -3.5, expression: 0.9, sign: 1.0 },

{ name: "inv. sixth", voices: 4, spread: 2, offset: 2, expression: 0.9, sign: 1.0 },
{ name: "detuned", voices: 3, spread: 0.05, offset: 0.0, expression: 1.0, sign: 1.0 },
{ name: "boost", voices: 3, spread: 4.0, offset: 0.0, expression: 0.8, sign: 1.0 },
{ name: "resonance", voices: 2, spread: 0.0025, offset: 0.1, expression: 0.8, sign: -1.5 },
{ name: "resonance 2", voices: 3, spread: 0.015, offset: 0.005, expression: 1.2, sign: 1.0 },

{ name: "spinner", voices: 2, spread: 0.02, offset: 0.0, expression: 1.0, sign: 1.0 },
		{ name: "detune", voices: 1, spread: 0.0, offset: 0.25, expression: 1.0, sign: 1.0 },
		{ name: "rising", voices: 2, spread: 1.0, offset: 0.7, expression: 0.95, sign: 1.0 },
		{ name: "vibrate", voices: 2, spread: 3.5, offset: 7, expression: 0.975, sign: 1.0 },
		{ name: "fourths", voices: 2, spread: 4, offset: 4, expression: 0.95, sign: 1.0 },
		{ name: "bass", voices: 1, spread: 0, offset: -7, expression: 1.0, sign: 1.0 },
		{ name: "dirty", voices: 2, spread: 0, offset: 0.1, expression: 0.975, sign: 1.0 },



		{ name: "stationary", voices: 2, spread: 3.5, offset: 0.0, expression: 0.9, sign: 1.0 },
		{ name: "recurve", voices: 2, spread: 0.005, offset: 0.0, expression: 1.0, sign: 1.0 },
		{ name: "voiced", voices: 2, spread: 9.5, offset: 0.0, expression: 1.0, sign: 1.0 },
		{ name: "fluctuate", voices: 2, spread: 12, offset: 0.0, expression: 1.0, sign: 1.0 },
		{ name: "thin", voices: 1, spread: 0.0, offset: 50.0, expression: 1.0, sign: 1.0 },
		{ name: "inject", voices: 2, spread: 6.0, offset: 0.4, expression: 1.0, sign: 1.0 },
	    { name: "askewed", voices: 2, spread: 0.0, offset: 0.42, expression: 0.7, sign: 1.0 },

{ name: "dirty 2",     voices: 4, spread: 0.12,  offset: 0.02,  expression: 0.85, sign: -0.5 },
        { name: "hecking gosh", voices: 2, spread: 6.25, offset: -6.0, expression: 0.8, sign: -0.7 },
                { name: "FART", voices: 2, spread: 13, offset: -5, expression: 1.0, sign: -3 },
        { name: "augmented", voices: 4, spread: 6, offset: 6, expression: 0.5, sign: 1.0 },
        { name: "diminished", voices: 5, spread: 6, offset: 6, expression: 0.4, sign: 1.0 },
        { name: "chorus 2", voices: 9, spread: 0.22, offset: 0, expression: 0.15, sign: 1.0 },
        { name: "block", voices: 9, spread: 6, offset: 6, expression: 0.15, sign: 0.8 },
        { name: "extraterrestrial", voices: 6, spread: 15.2, offset: -6, expression: 0.35, sign: 0.7 },
        { name: "bow", voices: 9, spread: 0.006, offset: 0, expression: 0.15, sign: 0.5 }
    ]);
     
    Config.effectNames = ["reverb", "chorus", "panning", "distortion", "bitcrusher", "note filter", "echo", "pitch shift", "detune", "vibrato", "transition type", "chord type", "", "ring mod"];
    Config.effectOrder = [2, 10, 11, 7, 8, 9, 5, 3, 4, 1, 6, 0, 13];
  
    Config.noteSizeMax = 6;
    Config.volumeRange = 50;
    Config.volumeLogScale = 0.1428;
    Config.panCenter = 50;
    Config.panMax = Config.panCenter * 2;
    Config.panDelaySecondsMax = 0.001;
    Config.chorusRange = 8;
    Config.chorusPeriodSeconds = 2.0;
    Config.chorusDelayRange = 0.0034;
    Config.chorusDelayOffsets = [[1.51, 2.10, 3.35], [1.47, 2.15, 3.25]];
    
    Config.ringModRange = 8;
    Config.ringModHzRange = 64;
    Config.ringModMinHz = 20;
    Config.ringModMaxHz = 4400;
    
    Config.chorusPhaseOffsets = [[0.0, 2.1, 4.2], [3.2, 5.3, 1.0]];
    Config.chorusMaxDelay = Config.chorusDelayRange * (1.0 + Config.chorusDelayOffsets[0].concat(Config.chorusDelayOffsets[1]).reduce((x, y) => Math.max(x, y)));
    Config.chords = toNameMap([
        { name: "simultaneous", customInterval: false, arpeggiates: false, strumParts: 0, singleTone: false },
        { name: "strum", customInterval: false, arpeggiates: false, strumParts: 1, singleTone: false },
        { name: "arpeggio", customInterval: false, arpeggiates: true, strumParts: 0, singleTone: true },
        { name: "custom interval", customInterval: true, arpeggiates: false, strumParts: 0, singleTone: true },
    ]);
    Config.maxChordSize = 9;
    Config.operatorCount = 6 ;
    Config.maxPitchOrOperatorCount = Math.max(_a$1.maxChordSize, _a$1.operatorCount + 2);
    Config.algorithms = toNameMap([ 
        { name: "1←(2 3 4)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3, 4], [], [], []] },
        { name: "1←(2 3←4)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3], [], [4], []] },
        { name: "1←2←(3 4)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2], [3, 4], [], []] },
        { name: "1←(2 3)←4", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3], [4], [4], []] },
        { name: "1←2←3←4", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2], [3], [4], []] },
        { name: "1←3 2←4", carrierCount: 2, associatedCarrier: [1, 2, 1, 2], modulatedBy: [[3], [4], [], []] },
        { name: "1 2←(3 4)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[], [3, 4], [], []] },
        { name: "1 2←3←4", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[], [3], [4], []] },
        { name: "(1 2)←3←4", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[3], [3], [4], []] },
        { name: "(1 2)←(3 4)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[3, 4], [3, 4], [], []] },
        { name: "1 2 3←4", carrierCount: 3, associatedCarrier: [1, 2, 3, 3], modulatedBy: [[], [], [4], []] },
        { name: "(1 2 3)←4", carrierCount: 3, associatedCarrier: [1, 2, 3, 3], modulatedBy: [[4], [4], [4], []] },
        { name: "1 2 3 4", carrierCount: 4, associatedCarrier: [1, 2, 3, 4], modulatedBy: [[], [], [], []] },
        


        { name: "1←2←3←4←5←6", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2], [3], [4], [5], [6], []] },
        { name: "1←3 2←4←5←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4], [], [5], [6], []] },
        { name: "1←3←4 2←5←6", carrierCount: 2, associatedCarrier: [1, 1, 1, 2, 2, 2], modulatedBy: [[3], [5], [4], [], [6], []] },
        { name: "1←4 2←5 3←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4], [5], [6], [], [], []] },
        { name: "1←3 2←(4 5←6)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4, 5], [], [], [6], []] },
        { name: "1←(3 4) 2←5←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3, 4], [5], [], [], [6], []] },
        { name: "1←3 2←(4 5 6)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4, 5, 6], [], [], [], []] },
        { name: "1←3 2←(4 5)←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4, 5], [], [6], [6], []] },
        { name: "1←3 2←4←(5 6)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4], [], [5, 6], [], []] },
        { name: "1←(2 3 4 5 6)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4, 5, 6], [], [], [], [], []] },
        { name: "1←(2 3←5 4←6)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4], [], [5], [6], [], []] },
        { name: "1←(2 3 4←5←6)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4], [], [], [5], [6], []] },
 
        { name: "1←4←5 (2 3)←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4], [6], [6], [5], [], []] },
        { name: "1←(3 4)←5 2←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3, 4], [6], [5], [5], [], []] },
        { name: "(1 2)←4 3←(5 6)", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4], [4], [5, 6], [], [], []] },
        { name: "(1 2)←5 (3 4)←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[5], [5], [6], [6], [], []] },
        { name: "(1 2 3)←(4 5 6)", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4, 5, 6], [4, 5, 6], [4, 5, 6], [], [], []] },
        { name: "1←5 (2 3 4)←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[5], [6], [6], [6], [], []] },
        { name: "1 2←5 (3 4)←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[], [5], [6], [6], [], []] },
        { name: "1 2←4 3←(5 6)", carrierCount: 3, associatedCarrier: [1, 2, 3, 3, 3, 3], modulatedBy: [[], [4], [5, 6], [], [], []] },
        { name: "1←4 2←(5 6) 3", carrierCount: 3, associatedCarrier: [1, 2, 3, 3, 3, 3,], modulatedBy: [[4], [5, 6], [], [], [], []] },
        { name: "1 2 3←5 4←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[], [], [5], [6], [], []] },
        { name: "1 (2 3)←5←6 4", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4,], modulatedBy: [[], [5], [5], [], [6], []] },
        { name: "1 2 3←5←6 4", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[], [], [5, 6], [], [], []] },
        { name: "1←(2(3(4(5(6", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4, 5, 6], [3, 4, 5, 6], [4, 5, 6], [5, 6], [6], []] },
        { name: "1←4(2←5(3←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[2, 3, 4], [3, 5], [6], [], [], []] },
        { name: "1←4(2←5 3←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[2, 3, 4], [5], [6], [], [], []] },
    
     { name: "1←2←3←4←5←6", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2], [3], [4], [5], [6], []] },
    { name: "1←3 2←4←5←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4], [], [5], [6], []] },
    { name: "1←3←4 2←5←6", carrierCount: 2, associatedCarrier: [1, 1, 1, 2, 2, 2], modulatedBy: [[3], [5], [4], [], [6], []] },
    { name: "1←4 2←5 3←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4], [5], [6], [], [], []] },
    { name: "1←3 2←(4 5←6)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4, 5], [], [], [6], []] },
    { name: "1←(3 4) 2←5←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3, 4], [5], [], [], [6], []] },
    { name: "1←3 2←(4 5 6)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4, 5, 6], [], [], [], []] },
    { name: "1←3 2←(4 5)←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4, 5], [], [6], [6], []] },
    { name: "1←3 2←4←(5 6)", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3], [4], [], [5, 6], [], []] },
    { name: "1←(2 3 4 5 6)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4, 5, 6], [], [], [], [], []] },
    { name: "1←(2 3←5 4←6)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4], [], [5], [6], [], []] },
    { name: "1←(2 3 4←5←6)", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4], [], [], [5], [6], []] },
    { name: "1←4←5 (2 3)←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4], [6], [6], [5], [], []] },
    { name: "1←(3 4)←5 2←6", carrierCount: 2, associatedCarrier: [1, 2, 2, 2, 2, 2], modulatedBy: [[3, 4], [6], [5], [5], [], []] },
    { name: "(1 2)←4 3←(5 6)", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4], [4], [5, 6], [], [], []] },
    { name: "(1 2)←5 (3 4)←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[5], [5], [6], [6], [], []] },
    { name: "(1 2 3)←(4 5 6)", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[4, 5, 6], [4, 5, 6], [4, 5, 6], [], [], []] },
    { name: "1←5 (2 3 4)←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[5], [6], [6], [6], [], []] },
    { name: "1 2←5 (3 4)←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[], [5], [6], [6], [], []] },
    { name: "1 2 (3 4 5)←6", carrierCount: 5, associatedCarrier: [1, 2, 3, 4, 5, 5], modulatedBy: [[], [], [6], [6], [6], []] },
    { name: "1 2 3 (4 5)←6", carrierCount: 5, associatedCarrier: [1, 2, 3, 4, 5, 5], modulatedBy: [[], [], [], [6], [6], []] },
    { name: "1 2←4 3←(5 6)", carrierCount: 3, associatedCarrier: [1, 2, 3, 3, 3, 3], modulatedBy: [[], [4], [5, 6], [], [], []] },
    { name: "1←4 2←(5 6) 3", carrierCount: 3, associatedCarrier: [1, 2, 3, 3, 3, 3,], modulatedBy: [[4], [5, 6], [], [], [], []] },
    { name: "1 2 3←5 4←6", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[], [], [5], [6], [], []] },
    { name: "1 (2 3)←5←6 4", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4,], modulatedBy: [[], [5], [5], [], [6], []] },
    { name: "1 2 3←5←6 4", carrierCount: 4, associatedCarrier: [1, 2, 3, 4, 4, 4], modulatedBy: [[], [], [5, 6], [], [], []] },
    { name: "(1 2 3 4 5)←6", carrierCount: 5, associatedCarrier: [1, 2, 3, 4, 5, 5], modulatedBy: [[6], [6], [6], [6], [6], []] },
    { name: "1 2 3 4 5←6", carrierCount: 5, associatedCarrier: [1, 2, 3, 4, 5, 5], modulatedBy: [[], [], [], [], [6], []] },
    { name: "1 2 3 4 5 6", carrierCount: 6, associatedCarrier: [1, 2, 3, 4, 5, 6], modulatedBy: [[], [], [], [], [], []] },
    { name: "1←(2 (3 (4 (5 (6", carrierCount: 5, associatedCarrier: [1, 2, 3, 4, 5, 5], modulatedBy: [[2, 3, 4, 5, 6], [3, 4, 5, 6], [4, 5, 6], [5, 6], [6], []] },
    { name: "1←(2(3(4(5(6", carrierCount: 1, associatedCarrier: [1, 1, 1, 1, 1, 1], modulatedBy: [[2, 3, 4, 5, 6], [3, 4, 5, 6], [4, 5, 6], [5, 6], [6], []] },
    { name: "1←4(2←5(3←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[2, 3, 4], [3, 5], [6], [], [], []] },
    { name: "1←4(2←5 3←6", carrierCount: 3, associatedCarrier: [1, 2, 3, 1, 2, 3], modulatedBy: [[2, 3, 4], [5], [6], [], [], []] },
    
 
    ]);
    Config.operatorCarrierInterval = [0.0, 0.04, -0.073, 0.091, 0.061, 0.024];
    Config.operatorAmplitudeMax = 15;
    Config.operatorFrequencies = toNameMap([
    	
        { name: "1×", mult: 1.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "~1×", mult: 1.0, hzOffset: 1.5, amplitudeSign: -1.0 },
        { name: "2×", mult: 2.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "~2×", mult: 2.0, hzOffset: -1.3, amplitudeSign: -1.0 },
        { name: "3×", mult: 3.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "3.5×", mult: 3.5, hzOffset: -0.05, amplitudeSign: 1.0 },
      
        { name: "4×", mult: 4.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "5×", mult: 5.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "6×", mult: 6.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "7×", mult: 7.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "8×", mult: 8.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "9×", mult: 9.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "11×", mult: 11.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "13×", mult: 13.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "16×", mult: 16.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "20×", mult: 20.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "~20×", mult: 20.0, hzOffset: -5.0, amplitudeSign: -1.0 },
        
        { name: "-1×", mult: -1.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "-3×", mult: -3.0, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "~-1×", mult: -1.0, hzOffset: 1.5, amplitudeSign: -1.0 },
        { name: "~-3×", mult: -3.0, hzOffset: 1.5, amplitudeSign: -1.0 },
        { name: "+ ~-1×", mult: -1.0, hzOffset: -1.5, amplitudeSign: 1.0 },
        { name: "0.12×", mult: 0.125, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "0.25×", mult: 0.25, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "0.5×", mult: 0.5, hzOffset: 0.0, amplitudeSign: 1.0 },
        { name: "0.75×", mult: 0.75, hzOffset: 0.0, amplitudeSign: 1.0 },
     
  { name: "25×", mult: 25.0, hzOffset: 0.0, amplitudeSign: 1.0 },
	{ name: "50×", mult: 50.0, hzOffset: 0.0, amplitudeSign: 1.0 },
	{ name: "75×", mult: 75.0, hzOffset: 0.0, amplitudeSign: 1.0 },
	{ name: "100×", mult: 100.0, hzOffset: 0.0, amplitudeSign: 1.0 }
    ]);
 function generateEnvelopePresetsO(namePrefix, type, start, end, step, exclude = []) {
  const presets = [];
  for (let val = start; val <= end + 1e-9; val += step) {
    const roundedVal = Number(val.toFixed(5));
    if (exclude.includes(roundedVal)) continue;
    presets.push({
      name: `${namePrefix} ${roundedVal}`,
      type: type,
      speed: roundedVal
    });
  }
  return presets;
}

 


    Config.envelopes = toNameMap([
    { name: "none", type: 1, speed: 0.0 },
    { name: "note size", type: 0, speed: 0.0 },
    { name: "punch", type: 2, speed: 0.0 },

    { name: "flare 1", type: 3, speed: 32.0 },
    { name: "flare 2", type: 3, speed: 8.0 },
    { name: "flare 3", type: 3, speed: 2.0 },


    { name: "twang 1", type: 4, speed: 32.0 },
    { name: "twang 2", type: 4, speed: 8.0 },
    { name: "twang 3", type: 4, speed: 2.0 },


    { name: "swell 1", type: 5, speed: 32.0 },
    { name: "swell 2", type: 5, speed: 8.0 },
    { name: "swell 3", type: 5, speed: 2.0 },
    

    { name: "tremolo1", type: 6, speed: 4.0 },
    { name: "tremolo2", type: 6, speed: 2.0 },
    { name: "tremolo3", type: 6, speed: 1.0 },
    { name: "tremolo4", type: 7, speed: 4.0 },
    { name: "tremolo5", type: 7, speed: 2.0 },
    { name: "tremolo6", type: 7, speed: 1.0 },
    { name: "decay 1", type: 8, speed: 10.0 },
    { name: "decay 2", type: 8, speed: 7.0 },
    { name: "decay 3", type: 8, speed: 4.0 },
    
    
    
    { name: "flare 4", type: 3, speed: 1 },
    { name: "twang 4", type: 4, speed: 1.5 },
    { name: "swell 4", type: 5, speed: 1.5 },
    { name: "decay 4", type: 8, speed: 2.0 },
    { name: "decay 5", type: 8, speed: 1.5 },
    { name: "decay 6", type: 8, speed: 1.0 },
    { name: "decay 7", type: 8, speed: 0.5 },
    
    { name: "adsr slow", type: 9, speed: 1.0 },       
    { name: "adsr fast", type: 9, speed: 4.0 },       
    { name: "adsr pulse", type: 9, speed: 8.0 },      

{ name: "wibble-1", type: 22, speed: 96.0 },
{ name: "wibble 1", type: 22, speed: 24.0 },
{ name: "wibble 2", type: 22, speed: 12.0 },
{ name: "wibble 3", type: 22, speed: 4.0 },
{ name: "linear-2", type: 23, speed: 256.0 },
{ name: "linear-1", type: 23, speed: 128.0 },
{ name: "linear 1", type: 23, speed: 32.0 },
{ name: "linear 2", type: 23, speed: 8.0 },
{ name: "linear 2.5", type: 23, speed: .0 },
{ name: "linear 3", type: 23, speed: 2.0 },
{ name: "rise -2", type: 24, speed: 256.0 },
{ name: "rise -1", type: 24, speed: 128.0 },
{ name: "rise 1", type: 24, speed: 32.0 },
{ name: "rise 2", type: 24, speed: 8.0 },
{ name: "rise 3", type: 24, speed: 2.0 },
{ name: "flute 1", type: 22, speed: 16.0 },
{ name: "flute 2", type: 22, speed: 8.0 },
{ name: "flute 3", type: 22, speed: 4.0 },
{ name: "tripolo1", type: 6, speed: 9.0 },
{ name: "tripolo2", type: 6, speed: 6.0 },
{ name: "tripolo3", type: 6, speed: 3.0 },
{ name: "tripolo4", type: 7, speed: 9.0 },
{ name: "tripolo5", type: 7, speed: 6.0 },
{ name: "tripolo6", type: 7, speed: 3.0 },
{ name: "pentolo1", type: 6, speed: 10.0 },
{ name: "pentolo2", type: 6, speed: 5.0 },
{ name: "pentolo3", type: 6, speed: 2.5 },
{ name: "pentolo4", type: 7, speed: 10.0 },
{ name: "pentolo5", type: 7, speed: 5.0 },
{ name: "pentolo6", type: 7, speed: 2.5 },
{ name: "flutter 1", type: 6, speed: 14.0 },
{ name: "flutter 2", type: 7, speed: 11.0 },
{ name: "water-y flutter", type: 6, speed: 9.0 },
{ name: "blip 1", type: 21, speed: 6.0 },
{ name: "blip 2", type: 21, speed: 16.0 },
{ name: "blip 3", type: 21, speed: 32.0 },

    

    { name: "reverse swell", type: 11, speed: 1.5 },
    { name: "sine lfo slow", type: 12, speed: 0.25 },
    { name: "sine lfo med", type: 12, speed: 1.0 },
    { name: "sine lfo fast", type: 12, speed: 4.0 },
    { name: "ramp up", type: 13, speed: 2.0 },
    { name: "ramp down", type: 14, speed: 2.0 },
    
{ name: "step lfo 1", type: 15, speed: 1.0 },
{ name: "step lfo 2", type: 15, speed: 2.0 },
{ name: "step lfo 3", type: 15, speed: 3.0 },
{ name: "step lfo 4", type: 15, speed: 4.0 },
{ name: "step lfo 5", type: 15, speed: 5.0 },
{ name: "step lfo 6", type: 15, speed: 6.0 },


...generateEnvelopePresetsO("sine ", 12, -1, 10, 0.5, [0]),



 //...generateEnvelopePresetsO("triangle lfo", 16, -3, 3, 0.5, [0]),


...generateEnvelopePresetsO("bounce", 10, -1, 10, 0.25, [0]),

...generateEnvelopePresetsO("ramp up", 13, 0.5, 5, 0.25),

...generateEnvelopePresetsO("ramp down", 14, 0.5, 5, 0.25),

  ...generateEnvelopePresetsO("wibble", 19, 1, 3, 1, [0]),
 	...generateEnvelopePresetsO("water-y flutter", 20, 1, 3, 1, [0]),
 
...generateEnvelopePresetsO("linear", 18, -3, -1, 0.5, [0]),
 ...generateEnvelopePresetsO("linear", 18, -1, 1, 0.2, [0]),
 ...generateEnvelopePresetsO("linear", 18, 1, 3, 0.5, [0]),
]);

Config.newEnvelopes = toNameMap([
 { name: "none", type: 0, speed: 1.0 },
 { name: "note size", type: 1, speed: 1.0 },
 { name: "pitch", type: 2, speed: 1.0 },
 { name: "random", type: 3, speed: 4.0 },
 { name: "punch", type: 4, speed: 1.0 },
 { name: "flare", type: 5, speed: 32.0 },
 { name: "twang", type: 6, speed: 32.0 },
 { name: "swell", type: 7, speed: 32.0 },
 { name: "lfo", type: 8, speed: 4.0 },
 { name: "decay", type: 10, speed: 10.0 },
 { name: "wibble", type: 11, speed: 24.0 },
 { name: "linear", type: 12, speed: 32.0 },
 { name: "rise", type: 13, speed: 32.0 },
 { name: "blip", type: 14, speed: 6.0 },
 { name: "fall", type: 15, speed: 2.0 },
]);


    Config.feedbacks = toNameMap([
    { name: "1⟲", indices: [[1], [], [], []] },
    { name: "2⟲", indices: [[], [2], [], []] },
    { name: "3⟲", indices: [[], [], [3], []] },
    { name: "4⟲", indices: [[], [], [], [4]] },
    { name: "1⟲ 2⟲", indices: [[1], [2], [], []] },
    { name: "3⟲ 4⟲", indices: [[], [], [3], [4]] },
    { name: "1⟲ 2⟲ 3⟲", indices: [[1], [2], [3], []] },
    { name: "2⟲ 3⟲ 4⟲", indices: [[], [2], [3], [4]] },
    { name: "1⟲ 2⟲ 3⟲ 4⟲", indices: [[1], [2], [3], [4]] },
    { name: "1→2", indices: [[], [1], [], []] },
    { name: "1→3", indices: [[], [], [1], []] },
    { name: "1→4", indices: [[], [], [], [1]] },
    { name: "2→3", indices: [[], [], [2], []] },
    { name: "2→4", indices: [[], [], [], [2]] },
    { name: "3→4", indices: [[], [], [], [3]] },
    { name: "1→3 2→4", indices: [[], [], [1], [2]] },
    { name: "1→4 2→3", indices: [[], [], [2], [1]] },
    { name: "1→2→3→4", indices: [[], [1], [2], [3]] },
    { name: "1↔2 3↔4", indices: [[2], [1], [4], [3]] },
    { name: "1↔4 2↔3", indices: [[4], [3], [2], [1]] },
    { name: "2→1→4→3→2", indices: [[2], [3], [4], [1]] },
    { name: "1→2→3→4→1", indices: [[4], [1], [2], [3]] },
    { name: "(1 2 3)→4", indices: [[], [], [], [1, 2, 3]] },
{ name: "ALL-4", indices: [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]] },
    

    { name: "1⟲", indices: [[1], [], [], [], [], []] },
    { name: "2⟲", indices: [[], [2], [], [], [], []] },
    { name: "3⟲", indices: [[], [], [3], [], [], []] },
    { name: "4⟲", indices: [[], [], [], [4], [], []] },
    { name: "5⟲", indices: [[], [], [], [], [5], []] },
    { name: "6⟲", indices: [[], [], [], [], [], [6]] },
    { name: "1⟲ 2⟲", indices: [[1], [2], [], [], [], []] },
    { name: "3⟲ 4⟲", indices: [[], [], [3], [4], [], []] },
    { name: "1⟲ 2⟲ 3⟲", indices: [[1], [2], [3], [], [], []] },
    { name: "2⟲ 3⟲ 4⟲", indices: [[], [2], [3], [4], [], []] },
    { name: "1⟲ 2⟲ 3⟲ 4⟲", indices: [[1], [2], [3], [4], [], []] },
    { name: "1⟲ 2⟲ 3⟲ 4⟲ 5⟲", indices: [[1], [2], [3], [4], [5], []] },
    { name: "1⟲ 2⟲ 3⟲ 4⟲ 5⟲ 6⟲", indices: [[1], [2], [3], [4], [5], [6]] },
    { name: "1→5", indices: [[], [], [], [], [1], []] },
    { name: "1→6", indices: [[], [], [], [], [], [1]] },
    { name: "4→5", indices: [[], [], [], [], [4], []] },
    { name: "1→4 2→5 3→6", indices: [[], [], [], [1], [2], [3]] },
    { name: "1→5 2→6 3→4", indices: [[], [], [], [3], [1], [2]] },
    { name: "1→2→3→4→5→6", indices: [[], [1], [2], [3], [4], [5]] },
    { name: "2→1→6→5→4→3→2", indices: [[2], [3], [4], [5], [6], [1]] },
    { name: "1→2→3→4→5→6→1", indices: [[6], [1], [2], [3], [4], [5]] },
    { name: "1↔2 3↔4 5↔6", indices: [[2], [1], [4], [3], [6], [5]] },
    { name: "1↔4 2↔5 3↔6", indices: [[4], [5], [6], [1], [2], [3]] },
    { name: "(1,2,3,4,5)→6", indices: [[], [], [], [], [], [1, 2, 3, 4, 5]] },
    { name: "ALL-6", indices: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]] },
 


{ name: "2⟲ 3⟲ fb", indices: [[], [2], [3], []] },
{ name: "1⟲ 4⟲ fb", indices: [[1], [], [], [4]] },
{ name: "2→1 3→4 fb", indices: [[2], [], [], [3]] },
{ name: "3→1 4→2 fb", indices: [[3], [4], [], []] },
{ name: "4→1 2→3 fb", indices: [[4], [], [2], []] },
{ name: "4→3→2→1 fb" , indices: [[2], [3], [4], []] },
{ name: "1⟲ 3→1 fb", indices: [[1, 3], [], [ ], [ ]] },
{ name: "2⟲ 4→2 fb", indices: [[], [2, 4], [], []] },
{ name: "3→1 fb", indices: [[3], [], [], []] },
{ name: "4→1 fb", indices: [[4], [], [], []] },
{ name: "4→2 fb", indices: [[], [4], [], []] },
{ name: "3→2 fb", indices: [[], [3], [], []] },
        
    ]);
    Config.chipNoiseLength = 1 << 15;
    Config.spectrumNoiseLength = 1 << 15;
    Config.spectrumBasePitch = 24;
    Config.spectrumControlPoints = 30;
    Config.spectrumControlPointsPerOctave = 7;
    Config.spectrumControlPointBits = 3;
    Config.spectrumMax = (1 << Config.spectrumControlPointBits) - 1;
    Config.harmonicsControlPoints = 28;
    Config.harmonicsRendered = 64;
    Config.harmonicsRenderedForPickedString = 1 << 8;
    Config.harmonicsControlPointBits = 3;
    Config.harmonicsMax = (1 << Config.harmonicsControlPointBits) - 1;
    Config.harmonicsWavelength = 1 << 11;
    Config.pulseWidthRange = 50;
    Config.pulseWidthStepPower = 0.5;
    Config.pitchChannelCountMin = 1;
    Config.pitchChannelCountMax = 640;//40
    Config.noiseChannelCountMin = 0;
    Config.noiseChannelCountMax = 16;
    Config.modChannelCountMin = 0;
    Config.modChannelCountMax = 12;
    Config.noiseInterval = 6;
    Config.pitchesPerOctave = 12;
    Config.drumCount = 12;
    Config.pitchOctaves = 8*1.5;
Config.modCount = 6;


    Config.maxPitch = Config.pitchOctaves * Config.pitchesPerOctave*2;
    Config.maximumTonesPerChannel = Config.maxChordSize * 2;

Config.justIntonationSemitones = Array.from(
  { length: 16 - (-16) + 1 },
  (_, i) => i - 16
);
Config.pitchShiftRange  = Config.justIntonationSemitones.length;   
Config.pitchShiftCenter = Math.floor(16) 

     
    Config.detuneCenter = 200;
    Config.detuneMax = 400;
    Config.detuneMin = 0;
    Config.songDetuneMin = 0;
    Config.songDetuneMax = 500;
    
Config.unisonVoicesMin = 1;
Config.unisonVoicesMax = 10;
Config.unisonSpreadMin = -96;
Config.unisonSpreadMax = 96;
Config.unisonOffsetMin = -96;
Config.unisonOffsetMax = 96;
Config.unisonExpressionMin = -2;
Config.unisonExpressionMax = 2;
Config.unisonSignMin = -2;
Config.unisonSignMax = 2;
    
    Config.sineWaveLength = 1 << 8;
    Config.sineWaveMask = Config.sineWaveLength - 1;
    Config.sineWave = generateSineWave();
    Config.pickedStringDispersionCenterFreq = 6000.0;
    Config.pickedStringDispersionFreqScale = 0.3;
    Config.pickedStringDispersionFreqMult = 4.0;
    Config.pickedStringShelfHz = 4000.0;
    Config.distortionRange = 8;
    Config.stringSustainRange = 15;
    Config.stringDecayRate = 0.12;
    Config.bitcrusherFreqRange = 14;
    Config.bitcrusherOctaveStep = 0.5;
    Config.bitcrusherQuantizationRange = 8;
    Config.maxEnvelopeCount = 12;
    Config.defaultAutomationRange = 13;
    Config.instrumentAutomationTargets = toNameMap([
        { name: "none", computeIndex: null, displayName: "none", interleave: false, isFilter: false, maxCount: 1, effect: null, compatibleInstruments: null },
        { name: "noteVolume", computeIndex: 0, displayName: "note volume", interleave: false, isFilter: false, maxCount: 1, effect: null, compatibleInstruments: null },
        { name: "pulseWidth", computeIndex: 2, displayName: "pulse width", interleave: false, isFilter: false, maxCount: 1, effect: null, compatibleInstruments: [6] },
        { name: "stringSustain", computeIndex: 3, displayName: "sustain", interleave: false, isFilter: false, maxCount: 1, effect: null, compatibleInstruments: [7] },
        { name: "unison", computeIndex: 4, displayName: "unison", interleave: false, isFilter: false, maxCount: 1, effect: null, compatibleInstruments: [0, 5, 7] },
        { name: "operatorFrequency", computeIndex: 5, displayName: "fm# freq", interleave: true, isFilter: false, maxCount: Config.operatorCount, effect: null, compatibleInstruments: [1] },
        { name: "operatorAmplitude", computeIndex: 9, displayName: "fm# volume", interleave: false, isFilter: false, maxCount: Config.operatorCount, effect: null, compatibleInstruments: [1] },
        { name: "feedbackAmplitude", computeIndex: 13, displayName: "fm feedback", interleave: false, isFilter: false, maxCount: 1, effect: null, compatibleInstruments: [1] },
        { name: "pitchShift", computeIndex: 14, displayName: "pitch shift", interleave: false, isFilter: false, maxCount: 1, effect: 7, compatibleInstruments: null },
        { name: "detune", computeIndex: 15, displayName: "detune", interleave: false, isFilter: false, maxCount: 1, effect: 8, compatibleInstruments: null },
        
        { name: "ringModulation", computeIndex: 49, displayName: "ring mod", interleave: false, isFilter: false, maxCount: 1, effect: 13, compatibleInstruments: null },
        { name: "ringModulationHz", computeIndex: 50, displayName: "ring mod hz", interleave: false, isFilter: false, maxCount: 1, effect: 13, compatibleInstruments: null },
        { name: "granular", computeIndex: 51, displayName: "granular", interleave: false, isFilter: false, maxCount: 1, effect: 14, compatibleInstruments: null },
       
       
        { name: "vibratoDepth", computeIndex: 16, displayName: "vibrato range", interleave: false, isFilter: false, maxCount: 1, effect: 9, compatibleInstruments: null },
        { name: "noteFilterAllFreqs", computeIndex: 1, displayName: "n. filter freqs", interleave: false, isFilter: true, maxCount: 1, effect: 5, compatibleInstruments: null },
        { name: "noteFilterFreq", computeIndex: 17, displayName: "n. filter # freq", interleave: false, isFilter: true, maxCount: Config.filterMaxPoints, effect: 5, compatibleInstruments: null },
    ]);
Config.operatorWaves = toNameMap([
 { name: "sine", samples: _a$1.sineWave },
 { name: "triangle", samples: generateTriWave() },
 { name: "pulse width", samples: generateSquareWave(0.5) },
 { name: "sawtooth", samples: generateSawWave() },
 { name: "ramp", samples: generateSawWave(true) },
 { name: "trapezoid", samples: generateTrapezoidWave(2) },
 { name: "quasi-sine", samples: generateQuasiSineWave() },
 { name: "logarithmic", samples: generateLogarithmicWave(true)},

]);
function generateLogarithmicWave(isRising = true) {
 const length = Config.sineWaveLength + 1;
 const wave = new Float32Array(length);
 for (let i = 0; i < length; i++) {
  const x = i / (length - 1);
  wave[i] = isRising ?
   Math.log10(1 + 9 * x) / Math.log10(10) * 2 - 1 
   :
   Math.log10(1 + 9 * (1 - x)) / Math.log10(10) * 2 - 1;
 }
 return wave;
}

    Config.pwmOperatorWaves = toNameMap([
        { name: "1%", samples: generateSquareWave(0.01) },
        { name: "5%", samples: generateSquareWave(0.05) },
        { name: "12.5%", samples: generateSquareWave(0.125) },
        { name: "25%", samples: generateSquareWave(0.25) },
        { name: "33%", samples: generateSquareWave(1 / 3) },
        { name: "50%", samples: generateSquareWave(0.5) },
        { name: "66%", samples: generateSquareWave(2 / 3) },
        { name: "75%", samples: generateSquareWave(0.75) },
        { name: "87.5%", samples: generateSquareWave(0.875) },
        { name: "95%", samples: generateSquareWave(0.95) },
        { name: "99%", samples: generateSquareWave(0.99) },
    ]);
    Config.barEditorHeight = 10;
    Config.modulators = toNameMap([ 
             { name: "envelope speed", pianoName: "EnvelopeSpd", maxRawVol: 50, newNoteVol: 12, forSong: false, convertRealFactor: 0, associatedEffect: 15, maxIndex: 0,
            promptName: "Envelope Speed", promptDesc: ["This setting controls how fast all of the envelopes for the instrument play.", "At $LO, your instrument's envelopes will be frozen, and at values near there they will change very slowly. At 12, the envelopes will work as usual, performing at normal speed. This increases up to $HI, where the envelopes will change very quickly. The speeds are given below:",
                "[0-4]: x0, x1/16, x⅛, x⅕, x¼,", "[5-9]: x⅓, x⅖, x½, x⅔, x¾,", "[10-14]: x⅘, x0.9, x1, x1.1, x1.2,", "[15-19]: x1.3, x1.4, x1.5, x1.6, x1.7,", "[20-24]: x1.8, x1.9, x2, x2.1, x2.2,", "[25-29]: x2.3, x2.4, x2.5, x2.6, x2.7,", "[30-34]: x2.8, x2.9, x3, x3.1, x3.2,", "[35-39]: x3.3, x3.4, x3.5, x3.6, x3.7,", "[40-44]: x3.8, x3.9, x4, x4.15, x4.3,", "[45-50]: x4.5, x4.8, x5, x5.5, x6, x8", "[OVERWRITING] [$LO - $HI]"] },
                
        { name: "none", pianoName: "None", maxRawVol: 6, newNoteVol: 6, forSong: true, convertRealFactor: 0, associatedEffect: 12 },
        { name: "song volume", pianoName: "Volume", maxRawVol: 100, newNoteVol: 100, forSong: true, convertRealFactor: 0, associatedEffect: 12 },
        { name: "tempo", pianoName: "Tempo", maxRawVol: Config.tempoMax - Config.tempoMin, newNoteVol: Math.ceil((Config.tempoMax - Config.tempoMin) / 2), forSong: true, convertRealFactor: Config.tempoMin, associatedEffect: 12 },
        { name: "song reverb", pianoName: "Reverb", maxRawVol: Config.reverbRange * 2, newNoteVol: Config.reverbRange, forSong: true, convertRealFactor: -Config.reverbRange, associatedEffect: 12 },
        { name: "next bar", pianoName: "Next Bar", maxRawVol: 1, newNoteVol: 1, forSong: true, convertRealFactor: 0, associatedEffect: 12 },
        { name: "volume", pianoName: "Volume", maxRawVol: Config.volumeRange, newNoteVol: Math.ceil(Config.volumeRange / 2), forSong: false, convertRealFactor: Math.ceil(-Config.volumeRange / 2.0), associatedEffect: 12 },

        { name: "pan", pianoName: "Pan", maxRawVol: Config.panMax, newNoteVol: Math.ceil(Config.panMax / 2), forSong: false, convertRealFactor: 0, associatedEffect: 2 },
        { name: "reverb", pianoName: "Reverb", maxRawVol: Config.reverbRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 0 },
        { name: "distortion", pianoName: "Distortion", maxRawVol: Config.distortionRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 3 },
        { name: "fm slider 1", pianoName: "FM 1", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "fm slider 2", pianoName: "FM 2", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "fm slider 3", pianoName: "FM 3", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "fm slider 4", pianoName: "FM 4", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "fm feedback", pianoName: "FM Feedback", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "pulse width", pianoName: "Pulse Width", maxRawVol: Config.pulseWidthRange, newNoteVol: Config.pulseWidthRange, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "detune", pianoName: "Detune", maxRawVol: Config.detuneMax - Config.detuneMin, newNoteVol: Config.detuneCenter, forSong: false, convertRealFactor: -Config.detuneCenter, associatedEffect: 8 },
        { name: "vibrato depth", pianoName: "Vibrato Depth", maxRawVol: 50, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 9 },
        { name: "song detune", pianoName: "Detune", maxRawVol: Config.songDetuneMax - Config.songDetuneMin, newNoteVol: Math.ceil((Config.songDetuneMax - Config.songDetuneMin) / 2), forSong: true, convertRealFactor: -250, associatedEffect: 12 },
        
        { name: "song limitratio", pianoName: "LimitRatio", maxRawVol: 50 , newNoteVol: 10, forSong: true, convertRealFactor: -250, associatedEffect: 12 },
        { name: "song mastergain", pianoName: "MasterGain", maxRawVol: 50 , newNoteVol: 5, forSong: true, convertRealFactor: -250, associatedEffect: 12 },
 
        { name: "vibrato speed", pianoName: "Vibrato Speed", maxRawVol: 30, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 9 },
        { name: "vibrato delay", pianoName: "Vibrato Delay", maxRawVol: 50, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 9 },
        { name: "arp speed", pianoName: "Arp Speed", maxRawVol: 50, newNoteVol: 10, forSong: false, convertRealFactor: 0, associatedEffect: 11 },
        { name: "pan delay", pianoName: "Pan Delay", maxRawVol: 20, newNoteVol: 10, forSong: false, convertRealFactor: 0, associatedEffect: 2 },
        { name: "reset arp", pianoName: "Reset Arp", maxRawVol: 1, newNoteVol: 1, forSong: false, convertRealFactor: 0, associatedEffect: 11 },
        { name: "eq filter", pianoName: "EQFlt", maxRawVol: 10, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "note filter", pianoName: "N.Flt", maxRawVol: 10, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 5 },
        { name: "bit crush", pianoName: "Bitcrush", maxRawVol: Config.bitcrusherQuantizationRange, newNoteVol: Math.round(Config.bitcrusherQuantizationRange / 2), forSong: false, convertRealFactor: 0, associatedEffect: 4 },
        { name: "freq crush", pianoName: "Freq Crush", maxRawVol: Config.bitcrusherFreqRange, newNoteVol: Math.round(Config.bitcrusherFreqRange / 2), forSong: false, convertRealFactor: 0, associatedEffect: 4 },
        { name: "echo", pianoName: "Echo", maxRawVol: Config.echoSustainRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 6 },
        { name: "echo delay", pianoName: "Echo Delay", maxRawVol: Config.echoDelayRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "chorus", pianoName: "Chorus", maxRawVol: Config.chorusRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 1 },
        
{ name: "ring pulse mod", pianoName: "Ring Mod (Pulse)", maxRawVol: Config.pwmOperatorWaves.length - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 13, maxIndex: 0,promptName: "Ring Modulation", promptDesc: ["This setting controls the Pulse Width for Ring Modulation effect in your instrument.", "[OVERWRITING] [$LO - $HI]"] },

{ name: "ring modulation", pianoName: "Ring Mod", maxRawVol: _a$1.ringModRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 13, maxIndex: 0,promptName: "Ring Modulation", promptDesc: ["This setting controls the Ring Modulation effect in your instrument.", "[OVERWRITING] [$LO - $HI]"] },

        { name: "ring mod hertz", pianoName: "Ring Mod(Hz)", maxRawVol: _a$1.ringModHzRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 13, maxIndex: 0,
            promptName: "Ring Modulation (Hertz)", promptDesc: ["This setting controls the Hertz (Hz) used in the Ring Modulation effect in your instrument.", "[OVERWRITING] [$LO - $HI]"] },
        { name: "granular", pianoName: "Granular", maxRawVol: _a$1.granularRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 14, maxIndex: 0,
            promptName: "Granular", promptDesc: ["This setting controls the granular effect in your instrument.", "[OVERWRITING] [$LO - $HI]"] },
        
        
        
        { name: "eq filt cut", pianoName: "EQFlt Cut", maxRawVol: Config.filterSimpleCutRange - 1, newNoteVol: Config.filterSimpleCutRange - 1, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "eq filt peak", pianoName: "EQFlt Peak", maxRawVol: Config.filterSimplePeakRange - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "note filt cut", pianoName: "N.Flt Cut", maxRawVol: Config.filterSimpleCutRange - 1, newNoteVol: Config.filterSimpleCutRange - 1, forSong: false, convertRealFactor: 0, associatedEffect: 5 },
        { name: "note filt peak", pianoName: "N.Flt Peak", maxRawVol: Config.filterSimplePeakRange - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 5 },
        { name: "pitch shift", pianoName: "Pitch Shift", maxRawVol: Config.pitchShiftRange - 1, newNoteVol: Config.pitchShiftCenter, forSong: false, convertRealFactor: -Config.pitchShiftCenter, associatedEffect: 7 },
        { name: "sustain", pianoName: "Sustain", maxRawVol: Config.stringSustainRange - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: 12 },
        { name: "extra volume", pianoName: "extra volume", maxRawVol: Config.volumeRange*2, newNoteVol: Math.ceil(Config.volumeRange ), forSong: false, convertRealFactor: Math.ceil(-Config.volumeRange), associatedEffect: 13,
              },
        { name: "unisonVoices", pianoName: "unisonVoices", maxRawVol: Config.unisonVoicesMax*10, newNoteVol: 1, forSong: false, convertRealFactor: 0, associatedEffect: 13,
              },
              
/*
Config.unisonVoicesMin = 1;
Config.unisonVoicesMax = 10;
Config.unisonSpreadMin = -96;
Config.unisonSpreadMax = 96;
Config.unisonOffsetMin = -96;
Config.unisonOffsetMax = 96;
Config.unisonExpressionMin = -2;
Config.unisonExpressionMax = 2;
Config.unisonSignMin = -2;
Config.unisonSignMax = 2;
*/
              
        { name: "unisonSpread", pianoName: "unisonSpread", maxRawVol: Config.unisonSpreadMax*10, newNoteVol: 1, forSong: false, convertRealFactor: 0, valueRealAdd: -(Config.unisonSpreadMax*5), divider:5,  associatedEffect: 13,
              },
        { name: "unisonOffset", pianoName: "unisonOffset", maxRawVol: Config.unisonOffsetMax*10, newNoteVol: 1, forSong: false, convertRealFactor: 0, associatedEffect: 13, valueRealAdd: -(Config.unisonOffsetMax*5), divider:5,
              },
        { name: "unisonExpression", pianoName: "unisonExpression", maxRawVol: Config.unisonExpressionMax*10, newNoteVol: 1, forSong: false, convertRealFactor: 0, associatedEffect: 13, divider:10,
              },
        { name: "unisonSign", pianoName: "unisonSign", maxRawVol: Config.unisonSignMax*10, newNoteVol: 1, forSong: false, convertRealFactor: 0, associatedEffect: 13, valueRealAdd: -(Config.unisonSignMax*5),   divider:5,  
              },
 
    ]);
    function centerWave(wave) {
	let sum = 0.0;
	for (let i = 0; i < wave.length; i++)
		sum += wave[i];
	const average = sum / wave.length;
	for (let i = 0; i < wave.length; i++)
		wave[i] -= average;
	performIntegral(wave);
	wave.push(0);
	return new Float32Array(wave);
}


    function centerAndNormalizeWave(wave) {
        let magn = 0.0;
        centerWave(wave);
        for (let i = 0; i < wave.length - 1; i++) {
            magn += Math.abs(wave[i]);
        }
        const magnAvg = magn / (wave.length - 1);
        for (let i = 0; i < wave.length - 1; i++) {
            wave[i] = wave[i] / magnAvg;
        }
        return new Float64Array(wave);
    }
    function performIntegral(wave) {
        let cumulative = 0.0;
        let newWave = new Float64Array(wave.length);
        for (let i = 0; i < wave.length; i++) {
            newWave[i] = cumulative;
            cumulative += wave[i];
        }
        return newWave;
    }
    function performIntegralOld(wave) {
        let cumulative = 0.0;
        for (let i = 0; i < wave.length; i++) {
            const temp = wave[i];
            wave[i] = cumulative;
            cumulative += temp;
        }
    }
    function getPulseWidthRatio(pulseWidth) {
        return pulseWidth / (Config.pulseWidthRange * 2);
    }
     
    function getDrumWave(index, inverseRealFourierTransform, scaleElementsByFactor) {
        let wave = Config.chipNoises[index].samples;
        if (wave == null) {
            wave = new Float32Array(Config.chipNoiseLength + 1);
            Config.chipNoises[index].samples = wave;
            if (index == 0) {
                let drumBuffer = 1;
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) * 2.0 - 1.0;
                    let newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer += 1 << 14;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 1) {
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = Math.random() * 2.0 - 1.0;
                }
            }
            else if (index == 2) {
                let drumBuffer = 1;
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) * 2.0 - 1.0;
                    let newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer += 2 << 14;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 3) {
                let drumBuffer = 1;
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) * 2.0 - 1.0;
                    let newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer += 10 << 2;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 4) {
                drawNoiseSpectrum(wave, Config.chipNoiseLength, 10, 11, 1, 1, 0);
                drawNoiseSpectrum(wave, Config.chipNoiseLength, 11, 14, .6578, .6578, 0);
                inverseRealFourierTransform(wave, Config.chipNoiseLength);
                scaleElementsByFactor(wave, 1.0 / Math.sqrt(Config.chipNoiseLength));
            }
            else if (index == 5) {
                var drumBuffer = 1;
                for (var i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) * 2.0 - 1.0;
                    var newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer += 10 << 2;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 6) {
                drawNoiseSpectrum(wave, Config.chipNoiseLength, 1, 10, 1, 1, 0);
                drawNoiseSpectrum(wave, Config.chipNoiseLength, 20, 14, -2, -2, 0);
                inverseRealFourierTransform(wave, Config.chipNoiseLength);
                scaleElementsByFactor(wave, 1.0 / Math.sqrt(Config.chipNoiseLength));
            }
            else if (index == 7) {
                var drumBuffer = 1;
                for (var i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) * 4.0 * (Math.random() * 14 + 1) - 8.0;
                    var newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer += 15 << 2;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 8) {
                var drumBuffer = 1;
                for (var i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) / 2.0 - 0.5;
                    var newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer -= 10 << 2;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 9) {
                let drumBuffer = 1;
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = (drumBuffer & 1) * 2.0 - 1.1;
                    let newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer += 8 ^ 2 << 16;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 10) {
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = Math.round(Math.random());
                }
            }
            else if (index == 11) {
                var drumBuffer = 1;
                for (var i = 0; i < Config.chipNoiseLength; i++) {
                    wave[i] = Math.round((drumBuffer & 1));
                    var newBuffer = drumBuffer >> 1;
                    if (((drumBuffer + newBuffer) & 1) == 1) {
                        newBuffer -= 10 << 2;
                    }
                    drumBuffer = newBuffer;
                }
            }
            else if (index == 12) {
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    var ultraboxnewchipnoiserand = Math.random();
                    wave[i] = Math.pow(ultraboxnewchipnoiserand, Math.clz32(ultraboxnewchipnoiserand));
                }
            }
            else if (index == 13) {
                var b0 = 0, b1 = 0, b2 = 0, b3, b4, b5, b6;
                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    var white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    wave[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    wave[i] *= 0.44;
                    b6 = white * 0.115926;
                }
            }
            else if (index == 14) {
                var lastOut = 0.0;
                for (let i = 0; i < Config.chipNoiseLength; i++) {
                    var white = Math.random() * 2 - 1;
                    wave[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = wave[i];
                    wave[i] *= 14;
                }
            }
            else {
                throw new Error("Unrecognized drum index: " + index);
            }
            wave[Config.chipNoiseLength] = wave[0];
        }
        return wave;
    }
    function drawNoiseSpectrum(wave, waveLength, lowOctave, highOctave, lowPower, highPower, overallSlope) {
        const referenceOctave = 11;
        const referenceIndex = 1 << referenceOctave;
        const lowIndex = Math.pow(2, lowOctave) | 0;
        const highIndex = Math.min(waveLength >> 1, Math.pow(2, highOctave) | 0);
        const retroWave = getDrumWave(0, null, null);
        let combinedAmplitude = 0.0;
        for (let i = lowIndex; i < highIndex; i++) {
            let lerped = lowPower + (highPower - lowPower) * (Math.log2(i) - lowOctave) / (highOctave - lowOctave);
            let amplitude = Math.pow(2, (lerped - 1) * 7 + 1) * lerped;
            amplitude *= Math.pow(i / referenceIndex, overallSlope);
            combinedAmplitude += amplitude;
            amplitude *= retroWave[i];
            const radians = 0.61803398875 * i * i * Math.PI * 2.0;
            wave[i] = Math.cos(radians) * amplitude;
            wave[waveLength - i] = Math.sin(radians) * amplitude;
        }
        return combinedAmplitude;
    }
    function generateSineWave() {
        const wave = new Float64Array(Config.sineWaveLength + 1);
        for (let i = 0; i < Config.sineWaveLength + 1; i++) {
            wave[i] = Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength);
        }
        return wave;
    }
    function generateTriWave() {
        const wave = new Float64Array(Config.sineWaveLength + 1);
        for (let i = 0; i < Config.sineWaveLength + 1; i++) {
            wave[i] = Math.asin(Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength)) / (Math.PI / 2);
        }
        return wave;
    }
    function generateTrapezoidWave(drive = 2) {
        const wave = new Float64Array(Config.sineWaveLength + 1);
        for (let i = 0; i < Config.sineWaveLength + 1; i++) {
            wave[i] = Math.max(-1.0, Math.min(1.0, Math.asin(Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength)) * drive));
        }
        return wave;
    }
    function generateSquareWave(phaseWidth = 0) {
        const wave = new Float64Array(Config.sineWaveLength + 1);
        const centerPoint = Config.sineWaveLength / 4;
        for (let i = 0; i < Config.sineWaveLength + 1; i++) {
            wave[i] = +((Math.abs(i - centerPoint) < phaseWidth * Config.sineWaveLength / 2)
                || ((Math.abs(i - Config.sineWaveLength - centerPoint) < phaseWidth * Config.sineWaveLength / 2))) * 2 - 1;
        }
        return wave;
    }
    function generateSawWave(inverse = false) {
        const wave = new Float64Array(Config.sineWaveLength + 1);
        for (let i = 0; i < Config.sineWaveLength + 1; i++) {
            wave[i] = ((i + (Config.sineWaveLength / 4.0)) * 2.0 / Config.sineWaveLength) % 2 - 1;
            wave[i] = inverse ? -wave[i] : wave[i];
        }
        return wave;
    }
    function generateQuasiSineWave() {
 const wave = new Float32Array(Config.sineWaveLength + 1);
 for (let i = 0; i < Config.sineWaveLength + 1; i++) {
  wave[i] = Math.round(Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength));
 }
 return wave;
}
    function getArpeggioPitchIndex(pitchCount, useFastTwoNoteArp, arpeggio) {
        let arpeggioPattern = Config.arpeggioPatterns[pitchCount - 1];
        if (arpeggioPattern != null) {
            if (pitchCount == 2 && useFastTwoNoteArp == false) {
                arpeggioPattern = [0, 0, 1, 1];
            }
            return arpeggioPattern[arpeggio % arpeggioPattern.length];
        }
        else {
            return arpeggio % pitchCount;
        }
    }
    function toNameMap(array) {
        const dictionary = {};
        for (let i = 0; i < array.length; i++) {
            const value = array[i];
            value.index = i;
            dictionary[value.name] = value;
        }
        const result = array;
        result.dictionary = dictionary;
        return result;
    }
    function effectsIncludeTransition(effects) {
        return (effects & (1 << 10)) != 0;
    }
    function effectsIncludeChord(effects) {
        return (effects & (1 << 11)) != 0;
    }
    function effectsIncludePitchShift(effects) {
        return (effects & (1 << 7)) != 0;
    }
    function effectsIncludeDetune(effects) {
        return (effects & (1 << 8)) != 0;
    }
    function effectsIncludeVibrato(effects) {
        return (effects & (1 << 9)) != 0;
    }
    function effectsIncludeNoteFilter(effects) {
        return (effects & (1 << 5)) != 0;
    }
    function effectsIncludeDistortion(effects) {
        return (effects & (1 << 3)) != 0;
    }
    function effectsIncludeBitcrusher(effects) {
        return (effects & (1 << 4)) != 0;
    }
    function effectsIncludePanning(effects) {
        return (effects & (1 << 2)) != 0;
    }
    function effectsIncludeChorus(effects) {
        return (effects & (1 << 1)) != 0;
    }
    function effectsIncludeEcho(effects) {
        return (effects & (1 << 6)) != 0;
    }
    function effectsIncludeReverb(effects) {
        return (effects & (1 << 0)) != 0;
    }
    function effectsIncludeRingModulation(effects) {
       	return (effects & (1 << 13)) != 0;
    }
    function calculateRingModHertz(sliderHz, sliderHzOffset = 0) {
 if (sliderHz == 0)
  return 0;
 if (sliderHz > 0)
  sliderHz -= 1 / Config.ringModHzRange;
 if (sliderHz > 1 / Config.ringModHzRange)
  sliderHz += 1 / Config.ringModHzRange;
 return Math.floor(Config.ringModMinHz * Math.pow(Config.ringModMaxHz / Config.ringModMinHz, sliderHz));
}
    function rawChipToIntegrated(raw) {
        const newArray = new Array(raw.length);
        const dictionary = {};
        for (let i = 0; i < newArray.length; i++) {
            newArray[i] = Object.assign([], raw[i]);
            const value = newArray[i];
            value.index = i;
            dictionary[value.name] = value;
        }
        for (let key in dictionary) {
            dictionary[key].samples = performIntegral(dictionary[key].samples);
        }
        const result = newArray;
        result.dictionary = dictionary;
        return result;
    }

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|android|ipad|playbook|silk/i.test(navigator.userAgent);
    function prettyNumber(value) {
        return value.toFixed(2).replace(/\.?0*$/, "");
    }
     
    class EditorConfig {
        static valueToPreset(presetValue) {
            const categoryIndex = presetValue >> 6;
            const presetIndex = presetValue & 0x3F;
            return EditorConfig.presetCategories[categoryIndex].presets[presetIndex];
        }
        static midiProgramToPresetValue(program) {
            for (let categoryIndex = 0; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {
                const category = EditorConfig.presetCategories[categoryIndex];
                for (let presetIndex = 0; presetIndex < category.presets.length; presetIndex++) {
                    const preset = category.presets[presetIndex];
                    if (preset.generalMidi && preset.midiProgram == program)
                        return (categoryIndex << 6) + presetIndex;
                }
            }
            return null;
        }
        static nameToPresetValue(presetName) {
            for (let categoryIndex = 0; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {
                const category = EditorConfig.presetCategories[categoryIndex];
                for (let presetIndex = 0; presetIndex < category.presets.length; presetIndex++) {
                    const preset = category.presets[presetIndex];
                    if (preset.name == presetName)
                        return (categoryIndex << 6) + presetIndex;
                }
            }
            return null;
        }
    }
    EditorConfig.version = "0.1";
    EditorConfig.versionDisplayName = "FruityBox " + EditorConfig.version;
    EditorConfig.releaseNotesURL = "https://jummbus.bitbucket.io/patch_notes/" + EditorConfig.version + ".html";
    EditorConfig.isOnMac = /^Mac/i.test(navigator.platform) || /Mac OS X/i.test(navigator.userAgent) || /^(iPhone|iPad|iPod)/i.test(navigator.platform) || /(iPhone|iPad|iPod)/i.test(navigator.userAgent);
    EditorConfig.ctrlSymbol = EditorConfig.isOnMac ? "⌘" : "Ctrl+";
    EditorConfig.presetCategories = toNameMap([
        {
            name: "Custom Instruments",
            presets: toNameMap([
                { name: "chip wave", customType: 0 },
                { name: "FM (expert)", customType: 1 },
                
                { name: "basic noise", customType: 2 },
                { name: "spectrum", customType: 3 },
                { name: "drumset", customType: 4 },
                { name: "harmonics", customType: 5 },
                { name: "pulse width", customType: 6 },
                { name: "picked string", customType: 7 },
                { name: "custom chip", customType: 8 },
                
            ])
        },
 

 
 

  
 
        
 
 
        { name: "Some Audio Presets  ", presets: toNameMap([	
          
            { name: "meowsynth", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "meowsynth", "unison": "none", "envelopes": [] } },
            { name: "kickbuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "kickbuff", "unison": "none", "envelopes": [] } },
            { name: "pufbuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "pufbuff", "unison": "none", "envelopes": [] } },
            { name: "slapbuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "slapbuff", "unison": "none", "envelopes": [] } },
            { name: "violinbuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "violinbuff", "unison": "none", "envelopes": [] } },
            { name: "cello1buff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "cello1buff", "unison": "none", "envelopes": [] } },
            { name: "stringsbuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "stringsbuff", "unison": "none", "envelopes": [] } },
            { name: "acousticguitar", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "strum", "wave": "acousticguitar", "unison": "none", "envelopes": [] } },
            { name: "cellobuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "cellobuff", "unison": "none", "envelopes": [] } },
            { name: "buffharp1", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "buffharp1", "unison": "none", "envelopes": [] } },
            { name: "elecpianobuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "elecpianobuff", "unison": "none", "envelopes": [] } },
            { name: "loficlap", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "loficlap", "unison": "none", "envelopes": [] } },
            { name: "pianobuff", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "pianobuff", "unison": "none", "envelopes": [] } },
            { name: "classicharp", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "classicharp", "unison": "none", "envelopes": [] } },
          
 { name: "breakcore drum", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcore drum1", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "breakcore hitdrum", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcore hitdrum", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "breakcore percussion", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcore per1", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "breakcore break", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcore break1", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "breakcore hi-Hit", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcore hihit", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "breakcore cymbals", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcore cymbals", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "Break Core Sample (D1) ", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "breakcoresample", "unison": "none", "envelopes": [] } },
            
            
            { name: "Liver Pad", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "liver pad", "unison": "none", "envelopes": [] } },
            { name: "Dark Retro Bass", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "darkretrobass", "unison": "none", "envelopes": [] } },
            { name: "Brasilian Phonk Laugh", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "phonklaugh", "unison": "none", "envelopes": [] } },
         { name: "Cold Pluck C", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "anotherpluck", "unison": "none", "envelopes": [] } },
{ name: "Phonk Sound Sample", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "phonk sound", "unison": "none", "envelopes": [] } },
            { name: "w-Piano Sample F key", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "piano F key", "unison": "none", "envelopes": [] } },
            { name: "vinyl_noise", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "vinyl_noise", "unison": "none", "envelopes": [] } },
            { name: "Ambient Sound", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "ambientsound", "unison": "none", "envelopes": [] } },
            { name: "Meow", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "neow", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "Marcato Strings", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "marcato", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "Legato Strings", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "legato", "unison": "none", "envelopes": [] , "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 125 } },
            { name: "Cavaco", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "Cavaco", "unison": "none", "envelopes": [] } },
            { name: "Some Piano", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "somepiano", "unison": "none", "envelopes": [] } },
            { name: "Chrome Music Lab Synth", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "clm synth", "unison": "none", "envelopes": [] } },
            { name: "Texture Pad Synth", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "texturepads", "unison": "none", "envelopes": [] } },
            { name: "Texture Pad Synth LoopEditor", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "texturepads2", "unison": "none", "envelopes": [] } },
            { name: "Ambient Plucks", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "ambientplucks", "unison": "none", "envelopes": [] } },
            { name: "Sampled Guitar 1", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "sampledGuitar", "unison": "none", "envelopes": [] } },
            { name: "Piano C6", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "sampledpianoc6", "unison": "none", "envelopes": [] } },
            { name: "Piano C4", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "pianoC42", "unison": "none", "envelopes": [] } },
            { name: "Open Pads", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "SampledOpenPad", "unison": "none", "envelopes": [] } },
             
            { name: "Some Texture 1", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "testbuffer1", "unison": "none", "envelopes": [] } },
            
            ]) 
        },
  
		{ name: "Sampled Instruments", presets: toNameMap([
     { name: "Earthbound O. Guitar", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "overdrive", "unison": "none", "envelopes": [] } },
				{ name: "Earthbound Piano", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "piano1", "unison": "none", "envelopes": [] } },
				{ name: "Zunpet", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "trumpet", "unison": "none", "envelopes": [] } },
				{ name: "Saxophone", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "saxophone", "unison": "none", "envelopes": [] } },
				{ name: "Orchestra Hit", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "orchestrahit", "unison": "none", "envelopes": [] } },
				{ name: "Detatched Violin", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "detatched violin", "unison": "none", "envelopes": [] } },
				{ name: "Synth", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "synth", "unison": "none", "envelopes": [] } },
				{ name: "Choir Lead", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "choir", "unison": "none", "envelopes": [] } },
				{ name: "Overdrive Guitar", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "overdriveguitar", "unison": "none", "envelopes": [] } },
				{ name: "Flute", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "flute", "unison": "none", "envelopes": [] } },
        { name: "Legato Violin", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "legato violin", "unison": "none", "envelopes": [] } },
        { name: "Tremolo Violin", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "tremolo violin", "unison": "none", "envelopes": [] } },
        { name: "Pizzicato Violin", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "pizzicato violin", "unison": "none", "envelopes": [] } },
	{ name: "Tuba", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "tuba", "unison": "none", "envelopes": [] } },
	{ name: "Piano", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "pianoC4", "unison": "none", "envelopes": [] } },
	{ name: "Marimba", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "marimba", "unison": "none", "envelopes": [] } },

	{ name: "Sus.wav", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "susdotwav", "unison": "none", "envelopes": [] } },
        ]) },
		{ name: "Sampled Drums", presets: toNameMap([
				{ name: "Retro Kick", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "kick", "unison": "none", "envelopes": [] } },
				{ name: "Retro Snare", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "snare", "unison": "none", "envelopes": [] } },
				{ name: "Sonic 1 Snare", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "sonic3snare", "unison": "none", "envelopes": [] } },
        			{ name: "Standard Kick", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "standardkick", "unison": "none", "envelopes": [] } },
				{ name: "Standard Snare", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "standardsnare", "unison": "none", "envelopes": [] } },
				{ name: "Standard Closed Hi-hat", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "closedhihat", "unison": "none", "envelopes": [] } },
				{ name: "Standard Foot Hi-hat", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "foothihat", "unison": "none", "envelopes": [] } },
				{ name: "Standard Open Hi-hat", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "openhihat", "unison": "none", "envelopes": [] } },
				{ name: "Standard Crash Cymbal", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "crashcymbal", "unison": "none", "envelopes": [] } },
				{ name: "Looped Cymbal", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "loopingcymbal", "unison": "none", "envelopes": [] } },
				{ name: "Amen Break", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "amen break", "unison": "none", "envelopes": [] } },
				
 
        ]) },
		{ name: "Sampled Sound Effects", presets: toNameMap([
				{ name: "Earthbound WOW", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "WOW", "unison": "none", "envelopes": [] } },
				{ name: "Sonic 3 COME ON", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "come on", "unison": "none", "envelopes": [] } },
				{ name: "Tim Allen Grunt", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "tim allen grunt", "unison": "none", "envelopes": [] } },
				{ name: "Wackybox TTS", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "wackyboxtts", "unison": "none", "envelopes": [] } },
        ]) },
        {
            name: "Retro Presets",
            presets: toNameMap([
                { name: "square wave", midiProgram: 80, settings: { "type": "chip", "eqFilter": [], "effects": ["aliasing"], "transition": "interrupt", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "square", "unison": "none", "envelopes": [] } },
                { name: "triangle wave", midiProgram: 71, settings: { "type": "chip", "eqFilter": [], "effects": ["aliasing"], "transition": "interrupt", "fadeInSeconds": 0, "fadeOutTicks": -1, "chord": "arpeggio", "wave": "triangle", "unison": "none", "envelopes": [] } },
                { name: "square lead", midiProgram: 80, generalMidi: true, settings: { "type": "chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.3536 }], "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "simultaneous", "wave": "square", "unison": "hum", "envelopes": [] } },
                { name: "sawtooth lead 1", midiProgram: 81, generalMidi: true, settings: { "type": "chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 0.5 }], "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "simultaneous", "wave": "sawtooth", "unison": "shimmer", "envelopes": [] } },
                { name: "sawtooth lead 2", midiProgram: 81, settings: { "type": "chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 1 }], "effects": ["vibrato", "aliasing"], "vibrato": "light", "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 72, "chord": "simultaneous", "wave": "sawtooth", "unison": "hum", "envelopes": [] } },
                { name: "chip noise", midiProgram: 116, isNoise: true, settings: { "type": "noise", "transition": "hard", "effects": ["aliasing"], "chord": "arpeggio", "filterCutoffHz": 4000, "filterResonance": 0, "filterEnvelope": "steady", "wave": "retro" } },
                { name: "FM twang", midiProgram: 32, settings: { "type": "FM", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "simultaneous", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 0 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "twang 2", "index": 1 }] } },
                { name: "FM bass", midiProgram: 36, settings: { "type": "FM", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "custom interval", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "2×", "amplitude": 11 }, { "frequency": "1×", "amplitude": 7 }, { "frequency": "1×", "amplitude": 9 }, { "frequency": "20×", "amplitude": 3 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "twang 2", "index": 1 }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 2 }, { "target": "operatorAmplitude", "envelope": "twang 2", "index": 3 }] } },
                { name: "FM flute", midiProgram: 73, settings: { "type": "FM", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "chord": "simultaneous", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 6 }, { "frequency": "1×", "amplitude": 0 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "twang 2", "index": 1 }] } },
                { name: "FM organ", midiProgram: 16, settings: { "type": "FM", "eqFilter": [], "effects": ["vibrato"], "vibrato": "delayed", "transition": "normal", "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "chord": "custom interval", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 14 }, { "frequency": "2×", "amplitude": 14 }, { "frequency": "1×", "amplitude": 11 }, { "frequency": "2×", "amplitude": 11 }], "envelopes": [] } },
                { name: "NES Pulse", midiProgram: 80, settings: { "type": "custom chip", "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "arpeggio", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.5 }], "unison": "none", "vibrato": "none", "envelopes": [], "customChipWave": [-24, -24, -24, -24, -23, -23, -23, -23, -22, -22, -22, -22, -21, -21, -21, -21, -20, -20, -20, -20, -19, -19, -19, -19, -18, -18, -18, -18, -17, -17, -17, -17, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 21, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17] } },
                { name: "Gameboy Pulse", midiProgram: 80, settings: { "type": "custom chip", "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "arpeggio", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.5 }], "unison": "none", "envelopes": [], "customChipWave": [-24, -20, -17, -15, -13, -13, -11, -11, -11, -9, -9, -9, -9, -7, -7, -7, -7, -7, -5, -5, -5, -5, -5, -5, -3, -3, -3, -3, -3, -3, -3, -3, 24, 20, 17, 15, 13, 13, 11, 11, 11, 9, 9, 9, 9, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3] } },
                { name: "VRC6 Sawtooth", midiProgram: 81, settings: { "type": "custom chip", "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "arpeggio", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.5 }], "unison": "none", "envelopes": [], "customChipWave": [-24, -20, -16, -13, -10, -8, -6, -5, -4, -4, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 12, 12, 12, 12, 12, 12, 12, 12, 16, 16, 16, 16, 16, 16, 16, 16, 20, 20, 20, 20, 20, 20, 20, 20, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24] } },
                { name: "Atari Square", midiProgram: 80, settings: { "type": "custom chip", "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "arpeggio", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 0.5 }], "unison": "none", "envelopes": [], "customChipWave": [-24, -24, -24, -23, -23, -23, -22, -22, -22, -21, -21, -21, -20, -20, -20, -19, -19, -19, -18, -18, -18, -17, -17, -17, -16, -16, -16, -15, -15, -15, -14, -14, -14, -13, -13, -13, 24, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 20, 20, 20, 19, 19, 19, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15] } },
                { name: "Atari Bass", midiProgram: 36, settings: { "type": "custom chip", "effects": ["aliasing"], "transition": "interrupt", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "arpeggio", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 0.5 }], "unison": "none", "envelopes": [], "customChipWave": [-24, -24, -24, -24, -24, -24, -24, -24, -24, 24, 24, 24, 24, 24, 24, -24, -24, -24, 24, 24, 24, -24, -24, -24, 24, 24, 24, -24, -24, -24, 24, 24, -24, -24, -24, -24, -24, -24, -24, -24, -24, 24, 24, 24, 24, 24, 24, -24, -24, 24, 24, 24, 24, 24, -24, -24, -24, -24, 24, 24, -24, -24, 24, 24] } },
                { name: "Sunsoft Bass", midiProgram: 36, settings: { "type": "custom chip", "effects": ["aliasing"], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "arpeggio", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 0.5 }], "unison": "none", "envelopes": [], "customChipWave": [24, 24, 15, 15, 9, 9, -4, -4, 0, 0, -13, -13, -19, -19, -24, -24, -24, -24, -10, -10, 0, 0, -7, -7, -7, -7, 0, 0, 6, 6, -4, -4, 3, 3, -4, -4, 3, 3, 3, 3, 9, 9, 15, 15, 15, 15, 6, 6, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, 3, 3, 12, 12, 24, 24] } },
            ])
        },
        {
            name: "Keyboard Presets",
            presets: toNameMap([
            	
                { name: "grand piano 1", midiProgram: 0, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "high-pass", "cutoffHz": 148.65, "linearGain": 0.7071 }, { "type": "peak", "cutoffHz": 2000, "linearGain": 2.8284 }], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.125 }], "reverb": 67, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "harmonics": [100, 100, 86, 86, 86, 71, 71, 71, 0, 86, 71, 71, 71, 57, 57, 71, 57, 14, 57, 57, 57, 57, 57, 57, 57, 57, 29, 57], "unison": "piano", "stringSustain": 79, "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "note size" }] } },
                { name: "grand piano 2", midiProgram: 0, generalMidi: true, settings: { "type": "harmonics", "eqFilter": [{ "type": "high-pass", "cutoffHz": 148.65, "linearGain": 0.7071 }, { "type": "peak", "cutoffHz": 2000, "linearGain": 2.8284 }], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.125 }], "reverb": 67, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "harmonics": [100, 86, 86, 86, 86, 71, 71, 57, 0, 57, 29, 43, 57, 57, 57, 43, 43, 0, 29, 43, 43, 43, 43, 43, 43, 29, 0, 29], "unison": "piano", "stringSustain": 79, "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "note size" }] } },
                { name: "grand piano 3", midiProgram: 0, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "high-pass", "cutoffHz": 148.65, "linearGain": 0.7071 }, { "type": "peak", "cutoffHz": 1681.79, "linearGain": 4 }, { "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.1768 }, { "type": "peak", "cutoffHz": 3363.59, "linearGain": 4 }, { "type": "peak", "cutoffHz": 2378.41, "linearGain": 0.25 }], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 0.3536 }, { "type": "high-pass", "cutoffHz": 125, "linearGain": 0.0884 }], "reverb": 67, "fadeInSeconds": 0, "fadeOutTicks": 48, "harmonics": [100, 100, 86, 86, 86, 71, 71, 71, 0, 71, 71, 71, 71, 57, 57, 71, 57, 14, 57, 57, 57, 57, 57, 57, 57, 57, 29, 57], "unison": "piano", "stringSustain": 86, "stringSustainType": "acoustic", "envelopes": [{ "target": "noteFilterFreq", "envelope": "note size", "index": 0 }, { "target": "noteFilterFreq", "envelope": "twang 1", "index": 1 }, { "target": "noteFilterFreq", "envelope": "twang 1", "index": 1 }] } },
     
                { name: "bright piano", midiProgram: 1, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 1681.79, "linearGain": 0.7071 }, { "type": "high-pass", "cutoffHz": 148.65, "linearGain": 0.5 }, { "type": "peak", "cutoffHz": 3363.59, "linearGain": 1.4142 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 24, "chord": "simultaneous", "harmonics": [100, 100, 86, 86, 71, 71, 0, 71, 71, 71, 71, 71, 71, 14, 57, 57, 57, 57, 57, 57, 29, 57, 57, 57, 57, 57, 57, 57], "unison": "piano", "stringSustain": 86, "envelopes": [] } },
                { name: "electric grand", midiProgram: 2, generalMidi: true, settings: { "type": "chip", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 2378.41, "linearGain": 0.5 }], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "wave": "1/8 pulse", "unison": "shimmer", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }] } },
                { name: "honky-tonk piano", midiProgram: 3, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 5656.85, "linearGain": 0.3536 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "harmonics": [100, 100, 86, 71, 86, 71, 43, 71, 43, 43, 57, 57, 57, 29, 57, 57, 57, 57, 57, 57, 43, 57, 57, 57, 43, 43, 43, 43], "unison": "honky tonk", "stringSustain": 71, "envelopes": [] } },
                { name: "electric piano 1", midiProgram: 4, generalMidi: true, settings: { "type": "harmonics", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 3363.59, "linearGain": 0.5 }], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "simultaneous", "harmonics": [86, 100, 100, 71, 71, 57, 57, 43, 43, 43, 29, 29, 29, 14, 14, 14, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0], "unison": "none", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 2" }] } },
                { name: "electric piano 2", midiProgram: 5, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 13454.34, "linearGain": 0.25 }], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 12 }, { "frequency": "1×", "amplitude": 6 }, { "frequency": "1×", "amplitude": 9 }, { "frequency": "16×", "amplitude": 6 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 3 }] } },
                { name: "harpsichord", midiProgram: 6, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "high-pass", "cutoffHz": 250, "linearGain": 0.3536 }, { "type": "peak", "cutoffHz": 11313.71, "linearGain": 2.8284 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 24, "chord": "simultaneous", "harmonics": [100, 100, 100, 86, 57, 86, 86, 86, 86, 57, 57, 71, 71, 86, 86, 71, 71, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71], "unison": "none", "stringSustain": 79, "envelopes": [] } },
                { name: "clavinet", midiProgram: 7, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 0.3536 }], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "simultaneous", "algorithm": "1←(2 3 4)", "feedbackType": "3⟲", "feedbackAmplitude": 6, "operators": [{ "frequency": "3×", "amplitude": 15 }, { "frequency": "~1×", "amplitude": 6 }, { "frequency": "8×", "amplitude": 4 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 2" }, { "target": "feedbackAmplitude", "envelope": "twang 2" }] } },
                { name: "dulcimer", midiProgram: 15, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.3536 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "strum", "harmonics": [100, 100, 100, 86, 100, 86, 57, 100, 100, 86, 100, 86, 100, 86, 100, 71, 57, 71, 71, 100, 86, 71, 86, 86, 100, 86, 86, 86], "unison": "piano", "stringSustain": 79, "envelopes": [] } },


            ])
        },
        {
            name: "Idiophone Presets",
            presets: toNameMap([
                { name: "celesta", midiProgram: 8, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 5657, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "(1 2)←(3 4)", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "~1×", "amplitude": 11, "envelope": "custom" }, { "frequency": "8×", "amplitude": 6, "envelope": "custom" }, { "frequency": "20×", "amplitude": 3, "envelope": "twang 1" }, { "frequency": "3×", "amplitude": 1, "envelope": "twang 2" }] } },
                { name: "glockenspiel", midiProgram: 9, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 5657, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "decay 1", "operators": [{ "frequency": "1×", "amplitude": 7, "envelope": "custom" }, { "frequency": "5×", "amplitude": 11, "envelope": "custom" }, { "frequency": "8×", "amplitude": 7, "envelope": "custom" }, { "frequency": "20×", "amplitude": 2, "envelope": "twang 1" }] } },
                { name: "music box 1", midiProgram: 10, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 0.5 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "strum", "harmonics": [100, 0, 0, 100, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 71, 0], "unison": "none", "stringSustain": 64, "envelopes": [] } },
                { name: "music box 2", midiProgram: 10, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 0.7071 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "strum", "harmonics": [100, 57, 57, 0, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0], "unison": "none", "stringSustain": 29, "envelopes": [] } },
                { name: "vibraphone", midiProgram: 11, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1→2→3→4", "feedbackAmplitude": 3, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 9, "envelope": "custom" }, { "frequency": "~1×", "amplitude": 9, "envelope": "custom" }, { "frequency": "9×", "amplitude": 3, "envelope": "custom" }, { "frequency": "4×", "amplitude": 9, "envelope": "custom" }] } },
                { name: "marimba", midiProgram: 12, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 29, "filterEnvelope": "decay 1", "vibrato": "none", "algorithm": "1 2←(3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 10, "envelope": "custom" }, { "frequency": "4×", "amplitude": 6, "envelope": "custom" }, { "frequency": "13×", "amplitude": 6, "envelope": "twang 1" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "kalimba", midiProgram: 108, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "decay 1", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 11, "envelope": "custom" }, { "frequency": "5×", "amplitude": 3, "envelope": "twang 2" }, { "frequency": "20×", "amplitude": 3, "envelope": "twang 1" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "xylophone", midiProgram: 13, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 9, "envelope": "custom" }, { "frequency": "6×", "amplitude": 9, "envelope": "custom" }, { "frequency": "11×", "amplitude": 9, "envelope": "custom" }, { "frequency": "20×", "amplitude": 6, "envelope": "twang 1" }] } },
                { name: "tubular bell", midiProgram: 14, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 0.5 }, { "type": "high-pass", "cutoffHz": 105.11, "linearGain": 0.3536 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 96, "chord": "strum", "harmonics": [43, 71, 0, 100, 0, 100, 0, 86, 0, 0, 86, 0, 14, 71, 14, 14, 57, 14, 14, 43, 14, 14, 43, 14, 14, 43, 14, 14], "unison": "shimmer", "stringSustain": 86, "envelopes": [] } },
                { name: "bell synth", midiProgram: 14, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 29, "filterEnvelope": "twang 3", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "~2×", "amplitude": 10, "envelope": "custom" }, { "frequency": "7×", "amplitude": 6, "envelope": "twang 3" }, { "frequency": "20×", "amplitude": 1, "envelope": "twang 1" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "rain drop", midiProgram: 96, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "(1 2)←(3 4)", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 12, "envelope": "custom" }, { "frequency": "6×", "amplitude": 4, "envelope": "custom" }, { "frequency": "20×", "amplitude": 3, "envelope": "twang 1" }, { "frequency": "1×", "amplitude": 6, "envelope": "tremolo1" }] } },
                { name: "crystal", midiProgram: 98, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "delayed", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 4, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 10, "envelope": "custom" }, { "frequency": "3×", "amplitude": 7, "envelope": "custom" }, { "frequency": "6×", "amplitude": 4, "envelope": "custom" }, { "frequency": "13×", "amplitude": 4, "envelope": "custom" }] } },
                { name: "tinkle bell", midiProgram: 112, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1→2→3→4", "feedbackAmplitude": 5, "feedbackEnvelope": "twang 3", "operators": [{ "frequency": "~2×", "amplitude": 7, "envelope": "custom" }, { "frequency": "5×", "amplitude": 7, "envelope": "custom" }, { "frequency": "7×", "amplitude": 7, "envelope": "custom" }, { "frequency": "16×", "amplitude": 7, "envelope": "custom" }] } },
                { name: "agogo", midiProgram: 113, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "decay 1", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1→4", "feedbackAmplitude": 15, "feedbackEnvelope": "decay 1", "operators": [{ "frequency": "2×", "amplitude": 9, "envelope": "custom" }, { "frequency": "5×", "amplitude": 6, "envelope": "custom" }, { "frequency": "8×", "amplitude": 9, "envelope": "custom" }, { "frequency": "13×", "amplitude": 11, "envelope": "custom" }] } },
            ])
        },
        {
            name: "Guitar Presets",
            presets: toNameMap([
                { name: "nylon guitar", midiProgram: 24, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 5657, "filterResonance": 14, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←2←3←4", "feedbackType": "3⟲", "feedbackAmplitude": 6, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }, { "frequency": "5×", "amplitude": 2, "envelope": "steady" }, { "frequency": "7×", "amplitude": 4, "envelope": "steady" }] } },
                { name: "steel guitar", midiProgram: 25, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "strum", "harmonics": [100, 100, 86, 71, 71, 71, 86, 86, 71, 57, 43, 43, 43, 57, 57, 57, 57, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43], "unison": "none", "stringSustain": 71, "envelopes": [] } },
                { name: "jazz guitar", midiProgram: 26, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "twang 2", "interval": "union", "vibrato": "none", "harmonics": [100, 100, 86, 71, 57, 71, 71, 43, 57, 71, 57, 43, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0] } },
                { name: "clean guitar", midiProgram: 27, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 2", "interval": "union", "vibrato": "none", "harmonics": [86, 100, 100, 100, 86, 57, 86, 100, 100, 100, 71, 57, 43, 71, 86, 71, 57, 57, 71, 71, 71, 71, 57, 57, 57, 57, 57, 43] } },
                { name: "muted guitar", midiProgram: 28, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 7, "feedbackEnvelope": "twang 2", "operators": [{ "frequency": "1×", "amplitude": 13, "envelope": "custom" }, { "frequency": "1×", "amplitude": 4, "envelope": "twang 3" }, { "frequency": "4×", "amplitude": 4, "envelope": "twang 2" }, { "frequency": "16×", "amplitude": 4, "envelope": "twang 1" }] } },
            ])
        },
        {
            name: "Picked Bass Presets",
            presets: toNameMap([
                { name: "acoustic bass", midiProgram: 32, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "twang 1", "interval": "union", "vibrato": "none", "harmonics": [100, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14] } },
                { name: "fingered bass", midiProgram: 33, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 1", "interval": "union", "vibrato": "none", "harmonics": [100, 86, 71, 57, 71, 43, 57, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 0] } },
                { name: "picked bass", midiProgram: 34, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 0, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "3⟲", "feedbackAmplitude": 4, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 5, "envelope": "steady" }, { "frequency": "11×", "amplitude": 1, "envelope": "twang 3" }, { "frequency": "1×", "amplitude": 9, "envelope": "steady" }] } },
                { name: "fretless bass", midiProgram: 35, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 1000, "filterResonance": 14, "filterEnvelope": "flare 2", "interval": "union", "vibrato": "none", "harmonics": [100, 100, 86, 71, 71, 57, 57, 71, 71, 71, 57, 57, 57, 57, 57, 57, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 29, 14] } },
                { name: "slap bass 1", midiProgram: 36, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 4000, "filterResonance": 0, "filterEnvelope": "twang 1", "interval": "union", "vibrato": "none", "harmonics": [100, 100, 100, 100, 86, 71, 57, 29, 29, 43, 43, 57, 71, 57, 29, 29, 43, 57, 57, 57, 43, 43, 43, 57, 71, 71, 71, 71] } },
                { name: "slap bass 2", midiProgram: 37, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 5657, "filterResonance": 0, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←2←3←4", "feedbackType": "3⟲", "feedbackAmplitude": 4, "feedbackEnvelope": "steady", "operators": [{ "frequency": "3×", "amplitude": 13, "envelope": "custom" }, { "frequency": "1×", "amplitude": 7, "envelope": "steady" }, { "frequency": "13×", "amplitude": 3, "envelope": "steady" }, { "frequency": "1×", "amplitude": 11, "envelope": "steady" }] } },
                { name: "bass synth 1", midiProgram: 38, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard", "chord": "strum", "filterCutoffHz": 4000, "filterResonance": 43, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "3⟲ 4⟲", "feedbackAmplitude": 9, "feedbackEnvelope": "twang 2", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "custom" }, { "frequency": "1×", "amplitude": 14, "envelope": "twang 1" }, { "frequency": "~1×", "amplitude": 13, "envelope": "twang 2" }] } },
                { name: "bass synth 2", midiProgram: 39, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 1000, "filterResonance": 57, "filterEnvelope": "punch", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "1→2", "feedbackAmplitude": 4, "feedbackEnvelope": "twang 3", "operators": [{ "frequency": "1×", "amplitude": 9, "envelope": "custom" }, { "frequency": "1×", "amplitude": 9, "envelope": "steady" }, { "frequency": "3×", "amplitude": 0, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "bass & lead", midiProgram: 87, generalMidi: true, settings: { "type": "chip", "transition": "hard", "effects": "reverb", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 86, "filterEnvelope": "twang 2", "wave": "sawtooth", "interval": "shimmer", "vibrato": "none" } },
                { name: "dubstep yoi yoi", midiProgram: 87, settings: { "type": "chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 0.7071 }], "effects": ["note filter", "bitcrusher"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 594.6, "linearGain": 11.3137 }], "bitcrusherOctave": 1.5, "bitcrusherQuantization": 0, "transition": "slide", "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "chord": "arpeggio", "wave": "sawtooth", "unison": "none", "envelopes": [{ "target": "noteFilterFreq", "envelope": "flare 2", "index": 0 }] } },
            ])
        },
        {
            name: "Picked String Presets",
            presets: toNameMap([
                { name: "pizzicato strings", midiProgram: 45, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "medium fade", "chord": "harmony", "filterCutoffHz": 1000, "filterResonance": 14, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 7, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "3×", "amplitude": 11, "envelope": "custom" }, { "frequency": "6×", "amplitude": 9, "envelope": "custom" }, { "frequency": "~1×", "amplitude": 10, "envelope": "steady" }] } },
                { name: "harp", midiProgram: 46, generalMidi: true, settings: { "type": "FM", "transition": "hard fade", "effects": "reverb", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 0, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "3⟲", "feedbackAmplitude": 6, "feedbackEnvelope": "twang 2", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "4×", "amplitude": 6, "envelope": "custom" }, { "frequency": "~2×", "amplitude": 3, "envelope": "steady" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }] } },
                { name: "sitar", midiProgram: 104, generalMidi: true, settings: { "type": "FM", "transition": "hard fade", "effects": "reverb", "chord": "strum", "filterCutoffHz": 8000, "filterResonance": 57, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 14, "envelope": "twang 3" }, { "frequency": "9×", "amplitude": 3, "envelope": "twang 3" }, { "frequency": "16×", "amplitude": 9, "envelope": "swell 3" }] } },
                { name: "banjo", midiProgram: 105, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "2⟲", "feedbackAmplitude": 4, "feedbackEnvelope": "steady", "operators": [{ "frequency": "4×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "steady" }, { "frequency": "11×", "amplitude": 3, "envelope": "twang 3" }, { "frequency": "1×", "amplitude": 11, "envelope": "steady" }] } },
                { name: "ukulele", midiProgram: 105, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 0, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "3⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "2×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }, { "frequency": "9×", "amplitude": 4, "envelope": "twang 2" }, { "frequency": "1×", "amplitude": 11, "envelope": "steady" }] } },
                { name: "shamisen", midiProgram: 106, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 8000, "filterResonance": 14, "filterEnvelope": "twang 1", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "3⟲", "feedbackAmplitude": 9, "feedbackEnvelope": "twang 3", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 12, "envelope": "steady" }, { "frequency": "16×", "amplitude": 4, "envelope": "twang 3" }, { "frequency": "1×", "amplitude": 7, "envelope": "steady" }] } },
                { name: "koto", midiProgram: 107, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "twang 2", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "twang 2", "operators": [{ "frequency": "~1×", "amplitude": 12, "envelope": "custom" }, { "frequency": "6×", "amplitude": 10, "envelope": "custom" }, { "frequency": "4×", "amplitude": 8, "envelope": "twang 3" }, { "frequency": "~2×", "amplitude": 8, "envelope": "twang 3" }] } },
            ])
        },
        {
            name: "Distortion Presets",
            presets: toNameMap([
                { name: "overdrive guitar", midiProgram: 29, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 0.7071 }, { "type": "high-pass", "cutoffHz": 210.22, "linearGain": 1 }, { "type": "low-pass", "cutoffHz": 5656.85, "linearGain": 1 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 0.5 }], "effects": ["note filter", "distortion"], "noteFilter": [{ "type": "high-pass", "cutoffHz": 297.3, "linearGain": 2 }, { "type": "low-pass", "cutoffHz": 2378.41, "linearGain": 0.7071 }], "distortion": 71, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 12, "chord": "strum", "harmonics": [86, 100, 100, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57], "unison": "none", "stringSustain": 71, "envelopes": [{ "target": "noteFilterFreq", "envelope": "note size", "index": 1 }] } },
                { name: "distortion guitar", midiProgram: 30, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 0.7071 }, { "type": "high-pass", "cutoffHz": 210.22, "linearGain": 1 }, { "type": "low-pass", "cutoffHz": 5656.85, "linearGain": 1 }, { "type": "peak", "cutoffHz": 594.6, "linearGain": 0.3536 }, { "type": "peak", "cutoffHz": 1000, "linearGain": 0.25 }], "effects": ["note filter", "distortion", "reverb"], "noteFilter": [{ "type": "high-pass", "cutoffHz": 353.55, "linearGain": 2 }, { "type": "low-pass", "cutoffHz": 2000, "linearGain": 1 }], "distortion": 86, "reverb": 67, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 12, "chord": "strum", "harmonics": [86, 100, 100, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57], "unison": "none", "stringSustain": 71, "envelopes": [{ "target": "noteFilterFreq", "envelope": "note size", "index": 1 }] } },
                { name: "charango synth", midiProgram: 84, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 11313.71, "linearGain": 1 }], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "strum", "algorithm": "1←(2 3←4)", "feedbackType": "1→2→3→4", "feedbackAmplitude": 8, "operators": [{ "frequency": "3×", "amplitude": 13 }, { "frequency": "~1×", "amplitude": 5 }, { "frequency": "4×", "amplitude": 6 }, { "frequency": "3×", "amplitude": 7 }], "envelopes": [{ "target": "feedbackAmplitude", "envelope": "twang 3" }] } },
                { name: "guitar harmonics", midiProgram: 31, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 2 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "strum", "algorithm": "1←(2 3)←4", "feedbackType": "1⟲", "feedbackAmplitude": 2, "operators": [{ "frequency": "4×", "amplitude": 12 }, { "frequency": "16×", "amplitude": 5 }, { "frequency": "1×", "amplitude": 2 }, { "frequency": "~1×", "amplitude": 12 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "swell 1", "index": 1 }, { "target": "operatorAmplitude", "envelope": "punch", "index": 2 }, { "target": "operatorAmplitude", "envelope": "twang 1", "index": 3 }] } },
                { name: "PWM overdrive", midiProgram: 29, settings: { "type": "PWM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 5656.85, "linearGain": 1.4142 }], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "strum", "pulseWidth": 17.67767, "envelopes": [{ "target": "pulseWidth", "envelope": "punch" }] } },
                { name: "PWM distortion", midiProgram: 30, settings: { "type": "PWM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 3363.59, "linearGain": 2 }], "effects": ["vibrato"], "vibrato": "delayed", "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "strum", "pulseWidth": 50, "envelopes": [{ "target": "pulseWidth", "envelope": "swell 1" }] } },
                { name: "FM overdrive", midiProgram: 29, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 1 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "strum", "algorithm": "1←(2 3←4)", "feedbackType": "1→2", "feedbackAmplitude": 2, "operators": [{ "frequency": "~1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 12 }, { "frequency": "~2×", "amplitude": 6 }, { "frequency": "1×", "amplitude": 12 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "twang 1", "index": 2 }, { "target": "operatorAmplitude", "envelope": "swell 3", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "punch" }] } },
                { name: "FM distortion", midiProgram: 30, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 2 }], "effects": ["reverb"], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "strum", "algorithm": "1←(2 3←4)", "feedbackType": "1→2", "feedbackAmplitude": 4, "operators": [{ "frequency": "~1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 11 }, { "frequency": "1×", "amplitude": 9 }, { "frequency": "~2×", "amplitude": 4 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "swell 1", "index": 2 }, { "target": "operatorAmplitude", "envelope": "swell 3", "index": 3 }] } },
            ])
        },
        {
            name: "Bellows Presets",
            presets: toNameMap([
                { name: "drawbar organ 1", midiProgram: 16, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "steady", "interval": "union", "vibrato": "none", "harmonics": [86, 86, 0, 86, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },
                { name: "drawbar organ 2", midiProgram: 16, midiSubharmonicOctaves: 1, settings: { "type": "harmonics", "effects": "reverb", "transition": "hard", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "steady", "interval": "union", "vibrato": "none", "harmonics": [86, 29, 71, 86, 71, 14, 0, 100, 0, 0, 0, 86, 0, 0, 0, 71, 0, 0, 0, 57, 0, 0, 0, 29, 0, 0, 0, 0] } },
                { name: "percussive organ", midiProgram: 17, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "FM", "transition": "hard", "effects": "reverb", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "punch", "vibrato": "light", "algorithm": "1 2 3 4", "feedbackType": "1→3 2→4", "feedbackAmplitude": 7, "feedbackEnvelope": "decay 1", "operators": [{ "frequency": "1×", "amplitude": 7, "envelope": "custom" }, { "frequency": "2×", "amplitude": 7, "envelope": "custom" }, { "frequency": "3×", "amplitude": 8, "envelope": "custom" }, { "frequency": "4×", "amplitude": 8, "envelope": "custom" }] } },
                { name: "rock organ", midiProgram: 18, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "hard", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "punch", "vibrato": "delayed", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "flare 1", "operators": [{ "frequency": "1×", "amplitude": 9, "envelope": "custom" }, { "frequency": "4×", "amplitude": 9, "envelope": "custom" }, { "frequency": "6×", "amplitude": 9, "envelope": "custom" }, { "frequency": "2×", "amplitude": 5, "envelope": "steady" }] } },
                { name: "pipe organ", midiProgram: 19, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "FM", "transition": "cross fade", "effects": "reverb", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 8, "envelope": "custom" }, { "frequency": "2×", "amplitude": 9, "envelope": "custom" }, { "frequency": "4×", "amplitude": 9, "envelope": "custom" }, { "frequency": "8×", "amplitude": 8, "envelope": "custom" }] } },
                { name: "reed organ", midiProgram: 20, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 29, "filterEnvelope": "steady", "interval": "union", "vibrato": "none", "harmonics": [71, 86, 100, 86, 71, 100, 57, 71, 71, 71, 43, 43, 43, 71, 43, 71, 57, 57, 57, 57, 57, 57, 57, 29, 43, 29, 29, 14] } },
                { name: "accordion", midiProgram: 21, generalMidi: true, settings: { "type": "chip", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 0, "filterEnvelope": "swell 1", "wave": "double saw", "interval": "honky tonk", "vibrato": "none" } },
                { name: "bandoneon", midiProgram: 23, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 29, "filterEnvelope": "swell 1", "interval": "hum", "vibrato": "none", "harmonics": [86, 86, 86, 57, 71, 86, 57, 71, 71, 71, 57, 43, 57, 43, 71, 43, 71, 57, 57, 43, 43, 43, 57, 43, 43, 29, 29, 29] } },
                { name: "bagpipe", midiProgram: 109, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 43, "filterEnvelope": "punch", "interval": "hum", "vibrato": "none", "harmonics": [71, 86, 86, 100, 100, 86, 57, 100, 86, 71, 71, 71, 57, 57, 57, 71, 57, 71, 57, 71, 43, 57, 57, 43, 43, 43, 43, 43] } },
            ])
        },
        {
            name: "String Presets",
            presets: toNameMap([
                { name: "violin 1", midiProgram: 40, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 1.4142 }, { "type": "high-pass", "cutoffHz": 105.11, "linearGain": 0.3536 }], "effects": ["vibrato", "reverb"], "vibrato": "delayed", "reverb": 67, "transition": "normal", "fadeInSeconds": 0.0413, "fadeOutTicks": 6, "chord": "simultaneous", "algorithm": "(1 2)←(3 4)", "feedbackType": "1→2", "feedbackAmplitude": 5, "operators": [{ "frequency": "4×", "amplitude": 9 }, { "frequency": "3×", "amplitude": 9 }, { "frequency": "2×", "amplitude": 7 }, { "frequency": "7×", "amplitude": 5 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "swell 1", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "twang 3" }] } },
                { name: "viola", midiProgram: 41, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 29, "filterEnvelope": "steady", "vibrato": "delayed", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲", "feedbackAmplitude": 8, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "2×", "amplitude": 11, "envelope": "custom" }, { "frequency": "7×", "amplitude": 7, "envelope": "custom" }, { "frequency": "13×", "amplitude": 4, "envelope": "custom" }, { "frequency": "1×", "amplitude": 5, "envelope": "steady" }] } },
                { name: "cello", midiProgram: 42, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 0.1768 }, { "type": "high-pass", "cutoffHz": 297.3, "linearGain": 0.7071 }, { "type": "peak", "cutoffHz": 4756.83, "linearGain": 5.6569 }], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 16000, "linearGain": 0.0884 }], "reverb": 67, "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 12, "chord": "simultaneous", "algorithm": "(1 2)←3←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 3, "operators": [{ "frequency": "16×", "amplitude": 5 }, { "frequency": "~1×", "amplitude": 10 }, { "frequency": "1×", "amplitude": 9 }, { "frequency": "6×", "amplitude": 3 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "swell 1" }, { "target": "operatorAmplitude", "envelope": "swell 1", "index": 3 }] } },
                { name: "contrabass", midiProgram: 43, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 29, "filterEnvelope": "steady", "vibrato": "delayed", "algorithm": "(1 2)←3←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "16×", "amplitude": 5, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "steady" }, { "frequency": "6×", "amplitude": 3, "envelope": "swell 1" }] } },
                { name: "fiddle", midiProgram: 110, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 29, "filterEnvelope": "steady", "vibrato": "delayed", "algorithm": "(1 2)←(3 4)", "feedbackType": "3⟲ 4⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "2×", "amplitude": 10, "envelope": "custom" }, { "frequency": "8×", "amplitude": 8, "envelope": "custom" }, { "frequency": "1×", "amplitude": 8, "envelope": "steady" }, { "frequency": "16×", "amplitude": 3, "envelope": "steady" }] } },
                { name: "tremolo strings", midiProgram: 44, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "medium fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 0, "filterEnvelope": "tremolo4", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1→2→3→4", "feedbackAmplitude": 12, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 8, "envelope": "custom" }, { "frequency": "~2×", "amplitude": 8, "envelope": "custom" }, { "frequency": "4×", "amplitude": 8, "envelope": "custom" }, { "frequency": "7×", "amplitude": 8, "envelope": "custom" }] } },
                { name: "strings", midiProgram: 48, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "(1 2)←(3 4)", "feedbackType": "4⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "twang 3", "operators": [{ "frequency": "4×", "amplitude": 9, "envelope": "custom" }, { "frequency": "3×", "amplitude": 9, "envelope": "custom" }, { "frequency": "2×", "amplitude": 7, "envelope": "steady" }, { "frequency": "7×", "amplitude": 3, "envelope": "swell 1" }] } },
                { name: "slow strings", midiProgram: 49, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "soft fade", "chord": "harmony", "filterCutoffHz": 1414, "filterResonance": 0, "filterEnvelope": "swell 2", "vibrato": "none", "algorithm": "(1 2)←(3 4)", "feedbackType": "4⟲", "feedbackAmplitude": 6, "feedbackEnvelope": "flare 3", "operators": [{ "frequency": "4×", "amplitude": 10, "envelope": "custom" }, { "frequency": "3×", "amplitude": 10, "envelope": "custom" }, { "frequency": "2×", "amplitude": 7, "envelope": "steady" }, { "frequency": "7×", "amplitude": 4, "envelope": "swell 1" }] } },
                { name: "strings synth 1", midiProgram: 50, generalMidi: true, settings: { "type": "chip", "transition": "soft fade", "effects": "chorus & reverb", "chord": "harmony", "filterCutoffHz": 1414, "filterResonance": 43, "filterEnvelope": "steady", "wave": "sawtooth", "interval": "hum", "vibrato": "delayed" } },
                { name: "strings synth 2", midiProgram: 51, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "soft fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 12, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "3×", "amplitude": 6, "envelope": "custom" }, { "frequency": "2×", "amplitude": 7, "envelope": "custom" }, { "frequency": "1×", "amplitude": 8, "envelope": "custom" }, { "frequency": "1×", "amplitude": 9, "envelope": "custom" }] } },
                { name: "orchestra hit 1", midiProgram: 55, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 8000, "filterResonance": 14, "filterEnvelope": "custom", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 14, "feedbackEnvelope": "twang 3", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "twang 3" }, { "frequency": "2×", "amplitude": 15, "envelope": "flare 3" }, { "frequency": "4×", "amplitude": 15, "envelope": "flare 2" }, { "frequency": "8×", "amplitude": 15, "envelope": "flare 1" }] } },
                { name: "violin 2", midiProgram: 40, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2828, "linearGain": 1.4142 }, { "type": "high-pass", "cutoffHz": 105.11, "linearGain": 0.3536 }], "effects": ["vibrato", "reverb"], "vibrato": "light", "reverb": 67, "transition": "normal", "fadeInSeconds": 0.0413, "fadeOutTicks": 6, "chord": "simultaneous", "algorithm": "(1 2)←(3 4)", "feedbackType": "4⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "twang 3", "operators": [{ "frequency": "4×", "amplitude": 15, "envelope": "custom" }, { "frequency": "3×", "amplitude": 13, "envelope": "custom" }, { "frequency": "2×", "amplitude": 7, "envelope": "steady" }, { "frequency": "7×", "amplitude": 8, "envelope": "swell 1" }] } },
                { name: "orchestra hit 2", midiProgram: 55, midiSubharmonicOctaves: 1, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "medium fade", "chord": "harmony", "filterCutoffHz": 8000, "filterResonance": 0, "filterEnvelope": "decay 1", "vibrato": "delayed", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 14, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 12, "envelope": "custom" }, { "frequency": "2×", "amplitude": 14, "envelope": "custom" }, { "frequency": "3×", "amplitude": 12, "envelope": "custom" }, { "frequency": "4×", "amplitude": 14, "envelope": "custom" }] } },
            ])
        },
        {
            name: "Vocal Presets",
            presets: toNameMap([
                { name: "choir soprano", midiProgram: 94, generalMidi: true, settings: { "type": "harmonics", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 2 }, { "type": "peak", "cutoffHz": 1189.21, "linearGain": 5.6569 }, { "type": "high-pass", "cutoffHz": 707.11, "linearGain": 2.8284 }, { "type": "peak", "cutoffHz": 2000, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 0.25 }, { "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 11.3137 }], "effects": ["vibrato", "chorus", "reverb"], "vibrato": "shaky", "chorus": 100, "reverb": 33, "fadeInSeconds": 0.0413, "fadeOutTicks": 24, "harmonics": [100, 100, 86, 57, 29, 29, 57, 71, 57, 29, 14, 14, 14, 29, 43, 57, 43, 29, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0], "unison": "none", "envelopes": [] } },
                { name: "choir tenor", midiProgram: 52, generalMidi: true, settings: { "type": "harmonics", "eqFilter": [{ "type": "peak", "cutoffHz": 1000, "linearGain": 11.3137 }, { "type": "peak", "cutoffHz": 707.11, "linearGain": 5.6569 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 1681.79, "linearGain": 0.0884 }, { "type": "high-pass", "cutoffHz": 297.3, "linearGain": 0.7071 }, { "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 11.3137 }], "effects": ["vibrato", "chorus", "reverb"], "vibrato": "shaky", "chorus": 100, "reverb": 67, "transition": "normal", "fadeInSeconds": 0.0413, "fadeOutTicks": 48, "chord": "simultaneous", "harmonics": [86, 100, 100, 86, 71, 57, 43, 29, 29, 29, 29, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14], "unison": "none", "envelopes": [] } },
                { name: "choir bass", midiProgram: 52, settings: { "type": "harmonics", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2378.41, "linearGain": 11.3137 }, { "type": "peak", "cutoffHz": 594.6, "linearGain": 5.6569 }, { "type": "peak", "cutoffHz": 1681.79, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 707.11, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 11.3137 }], "effects": ["vibrato", "chorus", "reverb"], "vibrato": "shaky", "chorus": 100, "reverb": 67, "transition": "normal", "fadeInSeconds": 0.0413, "fadeOutTicks": 48, "chord": "simultaneous", "harmonics": [71, 86, 100, 100, 86, 86, 57, 43, 29, 29, 29, 29, 29, 29, 43, 43, 43, 43, 43, 29, 29, 29, 29, 14, 14, 14, 14, 14], "unison": "none", "envelopes": [] } },
                { name: "solo soprano", midiProgram: 85, settings: { "type": "harmonics", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 2 }, { "type": "peak", "cutoffHz": 1189.21, "linearGain": 5.6569 }, { "type": "high-pass", "cutoffHz": 707.11, "linearGain": 2.8284 }, { "type": "peak", "cutoffHz": 2000, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 0.25 }], "effects": ["vibrato", "reverb"], "vibrato": "shaky", "reverb": 33, "fadeInSeconds": 0.0413, "fadeOutTicks": 12, "harmonics": [86, 100, 86, 43, 14, 14, 57, 71, 57, 14, 14, 14, 14, 14, 43, 57, 43, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0], "unison": "none", "envelopes": [] } },
                { name: "solo tenor", midiProgram: 85, settings: { "type": "harmonics", "eqFilter": [{ "type": "peak", "cutoffHz": 1000, "linearGain": 11.3137 }, { "type": "peak", "cutoffHz": 707.11, "linearGain": 5.6569 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 1681.79, "linearGain": 0.0884 }, { "type": "high-pass", "cutoffHz": 297.3, "linearGain": 0.7071 }, { "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 11.3137 }], "effects": ["vibrato", "reverb"], "vibrato": "shaky", "reverb": 33, "fadeInSeconds": 0.0413, "fadeOutTicks": 12, "harmonics": [86, 100, 100, 86, 71, 57, 43, 29, 29, 29, 29, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14], "unison": "none", "envelopes": [] } },
                { name: "solo bass", midiProgram: 85, settings: { "type": "harmonics", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2378.41, "linearGain": 5.6569 }, { "type": "peak", "cutoffHz": 594.6, "linearGain": 8 }, { "type": "peak", "cutoffHz": 1681.79, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 707.11, "linearGain": 0.0884 }, { "type": "peak", "cutoffHz": 840.9, "linearGain": 8 }, { "type": "high-pass", "cutoffHz": 210.22, "linearGain": 1.4142 }], "effects": ["vibrato", "reverb"], "vibrato": "shaky", "reverb": 33, "transition": "normal", "fadeInSeconds": 0.0263, "fadeOutTicks": 12, "chord": "simultaneous", "harmonics": [71, 86, 100, 100, 86, 86, 57, 43, 29, 29, 29, 29, 29, 29, 43, 43, 43, 43, 43, 29, 29, 29, 29, 14, 14, 14, 14, 14], "unison": "none", "envelopes": [] } },
                { name: "voice ooh", midiProgram: 53, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 1414, "filterResonance": 57, "filterEnvelope": "steady", "interval": "union", "vibrato": "shaky", "harmonics": [100, 57, 43, 43, 14, 14, 0, 0, 0, 14, 29, 29, 14, 0, 14, 29, 29, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },
                { name: "voice synth", midiProgram: 54, generalMidi: true, settings: { "type": "chip", "transition": "medium fade", "effects": "chorus & reverb", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 57, "filterEnvelope": "steady", "wave": "rounded", "interval": "union", "vibrato": "light" } },
                { name: "vox synth lead", midiProgram: 85, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "steady", "vibrato": "light", "algorithm": "(1 2 3)←4", "feedbackType": "1→2→3→4", "feedbackAmplitude": 2, "feedbackEnvelope": "punch", "operators": [{ "frequency": "2×", "amplitude": 10, "envelope": "custom" }, { "frequency": "9×", "amplitude": 5, "envelope": "custom" }, { "frequency": "20×", "amplitude": 1, "envelope": "custom" }, { "frequency": "~1×", "amplitude": 4, "envelope": "steady" }] } },
                { name: "tiny robot", midiProgram: 85, settings: { "type": "FM", "eqFilter": [], "effects": ["vibrato", "reverb"], "vibrato": "delayed", "reverb": 33, "transition": "slide", "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "chord": "simultaneous", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 2, "operators": [{ "frequency": "2×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 7 }, { "frequency": "~1×", "amplitude": 7 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "punch", "index": 1 }, { "target": "feedbackAmplitude", "envelope": "twang 3" }] } },
                { name: "yowie", midiProgram: 85, settings: { "type": "FM", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 86, "filterEnvelope": "tremolo5", "vibrato": "none", "algorithm": "1←2←(3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 12, "feedbackEnvelope": "tremolo3", "operators": [{ "frequency": "2×", "amplitude": 12, "envelope": "custom" }, { "frequency": "16×", "amplitude": 5, "envelope": "steady" }, { "frequency": "1×", "amplitude": 5, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "mouse", midiProgram: 85, settings: { "type": "FM", "eqFilter": [], "effects": ["vibrato", "reverb"], "vibrato": "light", "reverb": 33, "transition": "slide in pattern", "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "chord": "simultaneous", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 5, "operators": [{ "frequency": "2×", "amplitude": 13 }, { "frequency": "5×", "amplitude": 12 }, { "frequency": "1×", "amplitude": 0 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "noteVolume", "envelope": "note size" }, { "target": "feedbackAmplitude", "envelope": "flare 2" }] } },
                { name: "gumdrop", midiProgram: 85, settings: { "type": "FM", "effects": "reverb", "transition": "hard", "chord": "harmony", "filterCutoffHz": 8000, "filterResonance": 0, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲", "feedbackAmplitude": 0, "feedbackEnvelope": "steady", "operators": [{ "frequency": "2×", "amplitude": 15, "envelope": "punch" }, { "frequency": "4×", "amplitude": 15, "envelope": "punch" }, { "frequency": "7×", "amplitude": 15, "envelope": "punch" }, { "frequency": "1×", "amplitude": 10, "envelope": "twang 1" }] } },
                { name: "echo drop", midiProgram: 102, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "hard", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "punch", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "steady", "operators": [{ "frequency": "~2×", "amplitude": 11, "envelope": "custom" }, { "frequency": "~1×", "amplitude": 5, "envelope": "steady" }, { "frequency": "11×", "amplitude": 2, "envelope": "steady" }, { "frequency": "16×", "amplitude": 5, "envelope": "swell 3" }] } },
                { name: "dark choir", midiProgram: 85, settings: { "type": "spectrum", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 29, "filterEnvelope": "swell 1", "spectrum": [43, 14, 14, 14, 14, 14, 14, 100, 14, 14, 14, 57, 14, 14, 100, 14, 43, 14, 43, 14, 14, 43, 14, 29, 14, 29, 14, 14, 29, 0] } },
            ])
        },
        {
            name: "Brass Presets",
            presets: toNameMap([
                { name: "trumpet", midiProgram: 56, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 9, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 8, "envelope": "steady" }, { "frequency": "1×", "amplitude": 5, "envelope": "flare 2" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "trombone", midiProgram: 57, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "2⟲", "feedbackAmplitude": 7, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 8, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "tuba", midiProgram: 58, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "2⟲", "feedbackAmplitude": 8, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "muted trumpet", midiProgram: 59, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 2.8284 }, { "type": "peak", "cutoffHz": 4000, "linearGain": 2.8284 }], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 3363.59, "linearGain": 1 }], "reverb": 33, "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 5, "operators": [{ "frequency": "1×", "amplitude": 13 }, { "frequency": "1×", "amplitude": 5 }, { "frequency": "9×", "amplitude": 5 }, { "frequency": "13×", "amplitude": 7 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "swell 1" }, { "target": "operatorAmplitude", "envelope": "swell 1", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "flare 2" }] } },
                { name: "french horn", midiProgram: 60, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 1 }, { "type": "peak", "cutoffHz": 2378.41, "linearGain": 2.8284 }], "effects": ["reverb"], "reverb": 33, "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 3, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 12 }, { "frequency": "1×", "amplitude": 10 }, { "frequency": "~1×", "amplitude": 8 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "swell 1", "index": 2 }, { "target": "operatorAmplitude", "envelope": "flare 2", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "swell 1" }] } },
                { name: "brass section", midiProgram: 61, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "punch", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 6, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 12, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "swell 1" }, { "frequency": "~1×", "amplitude": 10, "envelope": "swell 1" }] } },
                { name: "brass synth 1", midiProgram: 62, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 29, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 11, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 12, "envelope": "flare 1" }, { "frequency": "~1×", "amplitude": 8, "envelope": "flare 2" }] } },
                { name: "brass synth 2", midiProgram: 63, generalMidi: true, settings: { "type": "FM", "transition": "soft", "effects": "reverb", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 43, "filterEnvelope": "twang 3", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 9, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "flare 1" }, { "frequency": "~1×", "amplitude": 7, "envelope": "flare 1" }] } },
                { name: "pulse brass", midiProgram: 62, settings: { "type": "PWM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 29, "filterEnvelope": "swell 1", "pulseWidth": 50, "pulseEnvelope": "flare 3", "vibrato": "none" } },
            ])
        },
        {
            name: "Reed Presets",
            presets: toNameMap([
                { name: "soprano sax", midiProgram: 64, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 29, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←2←3←4", "feedbackType": "4⟲", "feedbackAmplitude": 5, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "1×", "amplitude": 13, "envelope": "custom" }, { "frequency": "4×", "amplitude": 4, "envelope": "swell 1" }, { "frequency": "1×", "amplitude": 7, "envelope": "steady" }, { "frequency": "5×", "amplitude": 4, "envelope": "punch" }] } },
                { name: "alto sax", midiProgram: 65, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 4, "feedbackEnvelope": "punch", "operators": [{ "frequency": "1×", "amplitude": 13, "envelope": "custom" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }, { "frequency": "4×", "amplitude": 6, "envelope": "swell 1" }, { "frequency": "1×", "amplitude": 12, "envelope": "steady" }] } },
                { name: "tenor sax", midiProgram: 66, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 29, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←2←3←4", "feedbackType": "1⟲", "feedbackAmplitude": 6, "feedbackEnvelope": "swell 1", "operators": [{ "frequency": "2×", "amplitude": 12, "envelope": "custom" }, { "frequency": "3×", "amplitude": 7, "envelope": "steady" }, { "frequency": "1×", "amplitude": 3, "envelope": "steady" }, { "frequency": "8×", "amplitude": 3, "envelope": "steady" }] } },
                { name: "baritone sax", midiProgram: 67, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 0, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "swell 2", "operators": [{ "frequency": "1×", "amplitude": 12, "envelope": "custom" }, { "frequency": "8×", "amplitude": 4, "envelope": "steady" }, { "frequency": "4×", "amplitude": 5, "envelope": "steady" }, { "frequency": "1×", "amplitude": 4, "envelope": "punch" }] } },
                { name: "sax synth", midiProgram: 64, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 8000, "filterResonance": 0, "filterEnvelope": "steady", "vibrato": "light", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 4, "feedbackEnvelope": "steady", "operators": [{ "frequency": "4×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 15, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "shehnai", midiProgram: 111, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 8000, "filterResonance": 0, "filterEnvelope": "steady", "vibrato": "light", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 3, "feedbackEnvelope": "steady", "operators": [{ "frequency": "4×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 8, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "oboe", midiProgram: 68, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "swell 1", "vibrato": "none", "algorithm": "1 2←(3 4)", "feedbackType": "2⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "tremolo5", "operators": [{ "frequency": "1×", "amplitude": 7, "envelope": "custom" }, { "frequency": "4×", "amplitude": 12, "envelope": "custom" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }, { "frequency": "6×", "amplitude": 2, "envelope": "steady" }] } },
                { name: "english horn", midiProgram: 69, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1 2←(3 4)", "feedbackType": "2⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "steady", "operators": [{ "frequency": "4×", "amplitude": 12, "envelope": "custom" }, { "frequency": "2×", "amplitude": 10, "envelope": "custom" }, { "frequency": "1×", "amplitude": 8, "envelope": "punch" }, { "frequency": "8×", "amplitude": 4, "envelope": "steady" }] } },
                { name: "bassoon", midiProgram: 70, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 707, "filterResonance": 57, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 2, "feedbackEnvelope": "steady", "operators": [{ "frequency": "2×", "amplitude": 11, "envelope": "custom" }, { "frequency": "1×", "amplitude": 6, "envelope": "steady" }, { "frequency": "6×", "amplitude": 6, "envelope": "swell 1" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
                { name: "clarinet", midiProgram: 71, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 1414, "filterResonance": 14, "filterEnvelope": "steady", "interval": "union", "vibrato": "none", "harmonics": [100, 43, 86, 57, 86, 71, 86, 71, 71, 71, 71, 71, 71, 43, 71, 71, 57, 57, 57, 57, 57, 57, 43, 43, 43, 29, 14, 0] } },
                { name: "harmonica", midiProgram: 22, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 29, "filterEnvelope": "swell 1", "vibrato": "none", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 9, "feedbackEnvelope": "tremolo5", "operators": [{ "frequency": "2×", "amplitude": 14, "envelope": "custom" }, { "frequency": "1×", "amplitude": 15, "envelope": "steady" }, { "frequency": "~2×", "amplitude": 2, "envelope": "twang 3" }, { "frequency": "1×", "amplitude": 0, "envelope": "steady" }] } },
            ])
        },
        {
            name: "Flute Presets",
            presets: toNameMap([
                { name: "flute 1", midiProgram: 73, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 14, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←(2 3 4)", "feedbackType": "4⟲", "feedbackAmplitude": 7, "feedbackEnvelope": "decay 2", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "2×", "amplitude": 4, "envelope": "steady" }, { "frequency": "1×", "amplitude": 3, "envelope": "steady" }, { "frequency": "~1×", "amplitude": 1, "envelope": "punch" }] } },
                { name: "recorder", midiProgram: 74, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 29, "filterEnvelope": "swell 2", "interval": "union", "vibrato": "none", "harmonics": [100, 43, 57, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0] } },
                { name: "whistle", midiProgram: 78, generalMidi: true, settings: { "type": "harmonics", "effects": "chorus & reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 43, "filterEnvelope": "steady", "interval": "union", "vibrato": "delayed", "harmonics": [100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },
                { name: "ocarina", midiProgram: 79, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 43, "filterEnvelope": "steady", "interval": "union", "vibrato": "none", "harmonics": [100, 14, 57, 14, 29, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },
                { name: "piccolo", midiProgram: 72, generalMidi: true, settings: { "type": "FM", "effects": "reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 43, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1←3 2←4", "feedbackType": "4⟲", "feedbackAmplitude": 15, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "1×", "amplitude": 10, "envelope": "custom" }, { "frequency": "~2×", "amplitude": 3, "envelope": "punch" }, { "frequency": "~1×", "amplitude": 5, "envelope": "punch" }] } },
                { name: "shakuhachi", midiProgram: 77, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "steady", "vibrato": "delayed", "algorithm": "1←(2 3←4)", "feedbackType": "3→4", "feedbackAmplitude": 15, "feedbackEnvelope": "steady", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "2×", "amplitude": 3, "envelope": "punch" }, { "frequency": "~1×", "amplitude": 4, "envelope": "twang 1" }, { "frequency": "20×", "amplitude": 15, "envelope": "steady" }] } },
                { name: "pan flute", midiProgram: 75, generalMidi: true, settings: { "type": "spectrum", "eqFilter": [{ "type": "low-pass", "cutoffHz": 9513.66, "linearGain": 5.6569 }], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "high-pass", "cutoffHz": 4756.83, "linearGain": 0.7071 }], "reverb": 33, "fadeInSeconds": 0.0125, "fadeOutTicks": -3, "spectrum": [100, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 71, 0, 0, 14, 0, 57, 0, 29, 14, 29, 14, 14, 29, 14, 29, 14, 14, 29, 14], "envelopes": [{ "target": "noteFilterFreq", "envelope": "twang 1", "index": 0 }, { "target": "noteVolume", "envelope": "punch" }] } },
                { name: "blown bottle", midiProgram: 76, generalMidi: true, settings: { "type": "FM", "effects": "chorus & reverb", "transition": "cross fade", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 57, "filterEnvelope": "steady", "vibrato": "none", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 7, "feedbackEnvelope": "twang 1", "operators": [{ "frequency": "1×", "amplitude": 15, "envelope": "custom" }, { "frequency": "3×", "amplitude": 4, "envelope": "custom" }, { "frequency": "6×", "amplitude": 2, "envelope": "custom" }, { "frequency": "11×", "amplitude": 2, "envelope": "custom" }] } },
                { name: "calliope", midiProgram: 82, generalMidi: true, settings: { "type": "spectrum", "transition": "cross fade", "effects": "reverb", "chord": "harmony", "filterCutoffHz": 5657, "filterResonance": 14, "filterEnvelope": "steady", "spectrum": [100, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 71, 0, 0, 57, 0, 43, 0, 29, 14, 14, 29, 14, 14, 14, 14, 14, 14, 14, 14] } },
                { name: "chiffer", midiProgram: 83, generalMidi: true, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "punch", "spectrum": [86, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 71, 0, 0, 57, 0, 57, 0, 43, 14, 14, 43, 14, 29, 14, 29, 29, 29, 29, 14] } },
                { name: "breath noise", midiProgram: 121, generalMidi: true, settings: { "type": "spectrum", "eqFilter": [], "effects": ["chord type", "note filter", "reverb"], "chord": "strum", "noteFilter": [{ "type": "high-pass", "cutoffHz": 840.9, "linearGain": 0.3536 }, { "type": "low-pass", "cutoffHz": 16000, "linearGain": 0.3536 }], "reverb": 33, "fadeInSeconds": 0.0413, "fadeOutTicks": 12, "spectrum": [71, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 71, 0, 0, 29, 0, 100, 29, 14, 29, 100, 29, 100, 14, 14, 71, 0, 29, 0, 0], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 1" }] } },
                { name: "flute 2", midiProgram: 73, generalMidi: true, settings: { "type": "harmonics", "effects": "reverb", "transition": "seamless", "chord": "harmony", "filterCutoffHz": 1414, "filterResonance": 14, "filterEnvelope": "steady", "interval": "union", "vibrato": "delayed", "harmonics": [100, 43, 86, 57, 86, 71, 86, 71, 71, 71, 71, 71, 71, 43, 71, 71, 57, 57, 57, 57, 57, 57, 43, 43, 43, 29, 14, 0] } },
            ])
        },
        {
            name: "Pad Presets",
            presets: toNameMap([
                { name: "new age pad", midiProgram: 88, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["chorus"], "chorus": 100, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 3, "operators": [{ "frequency": "2×", "amplitude": 14 }, { "frequency": "~1×", "amplitude": 4 }, { "frequency": "6×", "amplitude": 3 }, { "frequency": "13×", "amplitude": 3 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "swell 2", "index": 1 }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 2 }, { "target": "feedbackAmplitude", "envelope": "swell 3" }] } },
                { name: "warm pad", midiProgram: 89, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 3363.59, "linearGain": 1 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0575, "fadeOutTicks": 96, "chord": "simultaneous", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 7, "operators": [{ "frequency": "1×", "amplitude": 14 }, { "frequency": "1×", "amplitude": 6 }, { "frequency": "1×", "amplitude": 0 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "swell 3" }, { "target": "operatorAmplitude", "envelope": "swell 1", "index": 1 }] } },
                { name: "polysynth pad", midiProgram: 90, generalMidi: true, settings: { "type": "chip", "eqFilter": [], "effects": ["vibrato", "note filter", "chorus"], "vibrato": "delayed", "noteFilter": [{ "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 1 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "wave": "sawtooth", "unison": "honky tonk", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }] } },
                { name: "space voice pad", midiProgram: 91, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 5.6569 }, { "type": "peak", "cutoffHz": 2828.43, "linearGain": 5.6569 }, { "type": "peak", "cutoffHz": 1414.21, "linearGain": 0.1768 }], "effects": ["chorus"], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 72, "chord": "simultaneous", "algorithm": "(1 2 3)←4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 5, "operators": [{ "frequency": "1×", "amplitude": 10 }, { "frequency": "2×", "amplitude": 8 }, { "frequency": "3×", "amplitude": 7 }, { "frequency": "11×", "amplitude": 2 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "punch", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "swell 2" }] } },
                { name: "bowed glass pad", midiProgram: 92, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 0.5 }], "transition": "normal", "fadeInSeconds": 0.0575, "fadeOutTicks": 96, "chord": "simultaneous", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 10 }, { "frequency": "2×", "amplitude": 12 }, { "frequency": "3×", "amplitude": 7 }, { "frequency": "7×", "amplitude": 4 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 2 }, { "target": "operatorAmplitude", "envelope": "flare 3", "index": 3 }] } },
                { name: "metallic pad", midiProgram: 93, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 0.5 }], "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 72, "chord": "simultaneous", "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲", "feedbackAmplitude": 13, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "~1×", "amplitude": 9 }, { "frequency": "1×", "amplitude": 7 }, { "frequency": "11×", "amplitude": 7 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }, { "target": "operatorAmplitude", "envelope": "swell 2", "index": 2 }, { "target": "feedbackAmplitude", "envelope": "twang 3" }] } },
                { name: "sweep pad", midiProgram: 95, generalMidi: true, settings: { "type": "chip", "eqFilter": [], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 4 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0575, "fadeOutTicks": 96, "chord": "simultaneous", "wave": "sawtooth", "unison": "hum", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "flare 3" }] } },
                { name: "atmosphere", midiProgram: 99, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 1 }], "effects": ["chorus", "reverb"], "chorus": 100, "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "strum", "algorithm": "1←(2 3 4)", "feedbackType": "3⟲ 4⟲", "feedbackAmplitude": 3, "operators": [{ "frequency": "1×", "amplitude": 14 }, { "frequency": "~1×", "amplitude": 10 }, { "frequency": "3×", "amplitude": 7 }, { "frequency": "1×", "amplitude": 7 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "swell 3", "index": 1 }, { "target": "operatorAmplitude", "envelope": "twang 2", "index": 2 }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 3 }] } },
                { name: "brightness", midiProgram: 100, generalMidi: true, settings: { "type": "Picked String", "eqFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 2 }], "effects": ["chorus"], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 72, "chord": "simultaneous", "harmonics": [100, 86, 86, 86, 43, 57, 43, 71, 43, 43, 43, 57, 43, 43, 57, 71, 57, 43, 29, 43, 57, 57, 43, 29, 29, 29, 29, 14], "unison": "octave", "stringSustain": 86, "envelopes": [] } },
                { name: "goblins", midiProgram: 101, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "peak", "cutoffHz": 2828.43, "linearGain": 11.3137 }], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 1681.79, "linearGain": 0.5 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0575, "fadeOutTicks": 96, "chord": "simultaneous", "algorithm": "1←2←3←4", "feedbackType": "1⟲", "feedbackAmplitude": 10, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "4×", "amplitude": 5 }, { "frequency": "1×", "amplitude": 10 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "swell 2" }, { "target": "operatorAmplitude", "envelope": "swell 3", "index": 1 }, { "target": "operatorAmplitude", "envelope": "tremolo1", "index": 2 }, { "target": "feedbackAmplitude", "envelope": "flare 3" }] } },
                { name: "sci-fi", midiProgram: 103, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "peak", "cutoffHz": 9513.66, "linearGain": 2.8284 }], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 0.5 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 48, "chord": "simultaneous", "algorithm": "(1 2)←3←4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 8, "operators": [{ "frequency": "~1×", "amplitude": 13 }, { "frequency": "2×", "amplitude": 10 }, { "frequency": "5×", "amplitude": 5 }, { "frequency": "11×", "amplitude": 8 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 2 }, { "target": "operatorAmplitude", "envelope": "tremolo5", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "twang 3" }] } },
                { name: "flutter pad", midiProgram: 90, settings: { "type": "FM", "eqFilter": [], "effects": ["vibrato", "note filter", "chorus"], "vibrato": "delayed", "noteFilter": [{ "type": "low-pass", "cutoffHz": 4000, "linearGain": 4 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "algorithm": "(1 2)←(3 4)", "feedbackType": "1⟲ 2⟲ 3⟲", "feedbackAmplitude": 9, "operators": [{ "frequency": "1×", "amplitude": 13 }, { "frequency": "5×", "amplitude": 7 }, { "frequency": "7×", "amplitude": 5 }, { "frequency": "~1×", "amplitude": 6 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }, { "target": "operatorAmplitude", "envelope": "tremolo1", "index": 2 }, { "target": "operatorAmplitude", "envelope": "punch", "index": 3 }] } },
                { name: "feedback pad", midiProgram: 89, settings: { "type": "FM", "eqFilter": [{ "type": "peak", "cutoffHz": 2378.41, "linearGain": 8 }], "effects": [], "transition": "normal", "fadeInSeconds": 0.0575, "fadeOutTicks": 96, "chord": "custom interval", "algorithm": "1 2 3 4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 8, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 15 }, { "frequency": "~1×", "amplitude": 15 }], "envelopes": [{ "target": "feedbackAmplitude", "envelope": "swell 2" }] } },
            ])
        },
        {
            name: "Drum Presets",
            presets: toNameMap([
                { name: "standard drumset", midiProgram: 116, isNoise: true, settings: { "type": "drumset", "effects": "reverb", "drums": [{ "filterEnvelope": "twang 1", "spectrum": [57, 71, 71, 86, 86, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29] }, { "filterEnvelope": "twang 1", "spectrum": [0, 0, 0, 100, 71, 71, 57, 86, 57, 57, 57, 71, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43] }, { "filterEnvelope": "twang 1", "spectrum": [0, 0, 0, 0, 100, 57, 43, 43, 29, 57, 43, 29, 71, 43, 43, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 43, 43, 43] }, { "filterEnvelope": "twang 1", "spectrum": [0, 0, 0, 0, 0, 71, 57, 43, 43, 43, 57, 57, 43, 29, 57, 43, 43, 43, 29, 43, 57, 43, 43, 43, 43, 43, 43, 29, 43, 43] }, { "filterEnvelope": "decay 2", "spectrum": [0, 14, 29, 43, 86, 71, 29, 43, 43, 43, 43, 29, 71, 29, 71, 29, 43, 43, 43, 43, 57, 43, 43, 57, 43, 43, 43, 57, 57, 57] }, { "filterEnvelope": "decay 1", "spectrum": [0, 0, 14, 14, 14, 14, 29, 29, 29, 43, 43, 43, 57, 57, 57, 71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43] }, { "filterEnvelope": "twang 3", "spectrum": [43, 43, 43, 71, 29, 29, 43, 43, 43, 29, 43, 43, 43, 29, 29, 43, 43, 29, 29, 29, 57, 14, 57, 43, 43, 57, 43, 43, 57, 57] }, { "filterEnvelope": "decay 3", "spectrum": [29, 43, 43, 43, 43, 29, 29, 43, 29, 29, 43, 29, 14, 29, 43, 29, 43, 29, 57, 29, 43, 57, 43, 71, 43, 71, 57, 57, 71, 71] }, { "filterEnvelope": "twang 3", "spectrum": [43, 29, 29, 43, 29, 29, 29, 57, 29, 29, 29, 57, 43, 43, 29, 29, 57, 43, 43, 43, 71, 43, 43, 71, 57, 71, 71, 71, 71, 71] }, { "filterEnvelope": "decay 3", "spectrum": [57, 57, 57, 43, 57, 57, 43, 43, 57, 43, 43, 43, 71, 57, 43, 57, 86, 71, 57, 86, 71, 57, 86, 100, 71, 86, 86, 86, 86, 86] }, { "filterEnvelope": "flare 1", "spectrum": [0, 0, 14, 14, 14, 14, 29, 29, 29, 43, 43, 43, 57, 57, 71, 71, 86, 86, 100, 100, 100, 100, 100, 100, 100, 100, 86, 57, 29, 0] }, { "filterEnvelope": "decay 2", "spectrum": [14, 14, 14, 14, 29, 14, 14, 29, 14, 43, 14, 43, 57, 86, 57, 57, 100, 57, 43, 43, 57, 100, 57, 43, 29, 14, 0, 0, 0, 0] }] } },
                { name: "steel pan", midiProgram: 114, generalMidi: true, settings: { "type": "FM", "eqFilter": [{ "type": "high-pass", "cutoffHz": 62.5, "linearGain": 0.1768 }], "effects": ["note filter", "chorus", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 13454.34, "linearGain": 0.25 }], "chorus": 67, "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 24, "chord": "simultaneous", "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "~1×", "amplitude": 14 }, { "frequency": "7×", "amplitude": 3 }, { "frequency": "3×", "amplitude": 5 }, { "frequency": "4×", "amplitude": 4 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "decay 2" }, { "target": "operatorAmplitude", "envelope": "flare 1", "index": 1 }, { "target": "operatorAmplitude", "envelope": "flare 2", "index": 2 }, { "target": "operatorAmplitude", "envelope": "swell 2", "index": 3 }] } },
                { name: "steel pan synth", midiProgram: 114, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 13454.34, "linearGain": 0.25 }], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -3, "chord": "simultaneous", "algorithm": "1 2 3←4", "feedbackType": "1⟲", "feedbackAmplitude": 5, "operators": [{ "frequency": "~1×", "amplitude": 12 }, { "frequency": "2×", "amplitude": 15 }, { "frequency": "4×", "amplitude": 14 }, { "frequency": "~1×", "amplitude": 3 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 1" }, { "target": "operatorAmplitude", "envelope": "note size", "index": 0 }, { "target": "operatorAmplitude", "envelope": "note size", "index": 1 }, { "target": "operatorAmplitude", "envelope": "flare 1", "index": 2 }, { "target": "operatorAmplitude", "envelope": "flare 2", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "flare 1" }] } },
                { name: "timpani", midiProgram: 47, generalMidi: true, settings: { "type": "spectrum", "eqFilter": [{ "type": "peak", "cutoffHz": 6727.17, "linearGain": 5.6569 }], "effects": ["pitch shift", "note filter", "reverb"], "pitchShiftSemitones": 15, "noteFilter": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 0.5 }], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "spectrum": [100, 0, 0, 0, 86, 0, 0, 71, 0, 14, 43, 14, 43, 43, 0, 29, 43, 29, 29, 29, 43, 29, 43, 29, 43, 43, 43, 43, 43, 43], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 1" }, { "target": "pitchShift", "envelope": "twang 1" }] } },
                { name: "dark strike", midiProgram: 47, settings: { "type": "spectrum", "eqFilter": [], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 0.7071 }], "reverb": 33, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "spectrum": [0, 0, 14, 14, 14, 29, 29, 43, 43, 86, 43, 43, 43, 29, 86, 29, 29, 29, 86, 29, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 2" }] } },
                { name: "woodblock", midiProgram: 115, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -2.5, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 14, "filterEnvelope": "twang 1", "spectrum": [0, 14, 29, 43, 43, 57, 86, 86, 71, 57, 57, 43, 43, 57, 86, 86, 43, 43, 71, 57, 57, 57, 57, 57, 86, 86, 71, 71, 71, 71] } },
                { name: "taiko drum", midiProgram: 116, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -0.5, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 29, "filterEnvelope": "twang 1", "spectrum": [71, 100, 100, 43, 43, 71, 71, 43, 43, 43, 43, 43, 43, 57, 29, 57, 43, 57, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43] } },
                { name: "melodic drum", midiProgram: 117, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -1.5, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2828, "filterResonance": 43, "filterEnvelope": "twang 1", "spectrum": [100, 71, 71, 57, 57, 43, 43, 71, 43, 43, 43, 57, 43, 43, 57, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29] } },
                { name: "drum synth", midiProgram: 118, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -2, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 43, "filterEnvelope": "decay 1", "spectrum": [100, 86, 71, 57, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29] } },
                { name: "tom-tom", midiProgram: 116, isNoise: true, midiSubharmonicOctaves: -1, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "twang 1", "spectrum": [100, 29, 14, 0, 0, 86, 14, 43, 29, 86, 29, 14, 29, 57, 43, 43, 43, 43, 57, 43, 43, 43, 29, 57, 43, 43, 43, 43, 43, 43] } },
                { name: "metal pipe", midiProgram: 117, isNoise: true, midiSubharmonicOctaves: -1.5, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 8000, "filterResonance": 14, "filterEnvelope": "twang 2", "spectrum": [29, 43, 86, 43, 43, 43, 43, 43, 100, 29, 14, 14, 100, 14, 14, 0, 0, 0, 0, 0, 14, 29, 29, 14, 0, 0, 14, 29, 0, 0] } },
                { name: "synth kick", midiProgram: 47, settings: { "type": "FM", "eqFilter": [], "effects": [], "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": -6, "chord": "simultaneous", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "8×", "amplitude": 15 }, { "frequency": "1×", "amplitude": 0 }, { "frequency": "1×", "amplitude": 0 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "operatorFrequency", "envelope": "twang 1", "index": 0 }, { "target": "noteVolume", "envelope": "twang 2" }] } },
            ])
        },
        {
            name: "Novelty Presets",
            presets: toNameMap([
                { name: "guitar fret noise", midiProgram: 120, generalMidi: true, settings: { "type": "spectrum", "eqFilter": [{ "type": "high-pass", "cutoffHz": 1000, "linearGain": 0.1768 }], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 5.6569 }], "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": -3, "chord": "simultaneous", "spectrum": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 29, 14, 0, 0, 43, 0, 43, 0, 71, 43, 0, 57, 0], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "flare 1" }, { "target": "noteVolume", "envelope": "twang 2" }] } },
                { name: "fifth saw lead", midiProgram: 86, generalMidi: true, midiSubharmonicOctaves: 1, settings: { "type": "chip", "eqFilter": [], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 1.4142 }], "chorus": 67, "transition": "normal", "fadeInSeconds": 0, "fadeOutTicks": 48, "chord": "simultaneous", "wave": "sawtooth", "unison": "fifth", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 3" }] } },
                { name: "fifth swell", midiProgram: 86, midiSubharmonicOctaves: 1, settings: { "type": "chip", "eqFilter": [], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 2000, "linearGain": 2 }], "chorus": 100, "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 72, "chord": "simultaneous", "wave": "sawtooth", "unison": "fifth", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "swell 3" }] } },
                { name: "soundtrack", midiProgram: 97, generalMidi: true, settings: { "type": "chip", "eqFilter": [], "effects": ["note filter", "chorus"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 2378.41, "linearGain": 0.5 }], "chorus": 67, "transition": "normal", "fadeInSeconds": 0.0413, "fadeOutTicks": 72, "chord": "simultaneous", "wave": "sawtooth", "unison": "fifth", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "flare 3" }] } },
                { name: "reverse cymbal", midiProgram: 119, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -3, settings: { "type": "spectrum", "effects": "none", "transition": "soft", "chord": "harmony", "filterCutoffHz": 4000, "filterResonance": 14, "filterEnvelope": "swell 3", "spectrum": [29, 57, 57, 29, 57, 57, 29, 29, 43, 29, 29, 43, 29, 29, 57, 57, 14, 57, 14, 57, 71, 71, 57, 86, 57, 100, 86, 86, 86, 86] } },
                { name: "seashore", midiProgram: 122, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -3, settings: { "type": "spectrum", "transition": "soft fade", "effects": "reverb", "chord": "harmony", "filterCutoffHz": 2828, "filterResonance": 0, "filterEnvelope": "swell 3", "spectrum": [14, 14, 29, 29, 43, 43, 43, 57, 57, 57, 57, 57, 57, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57] } },
                { name: "bird tweet", midiProgram: 123, generalMidi: true, settings: { "type": "harmonics", "eqFilter": [], "effects": ["chord type", "vibrato", "reverb"], "chord": "strum", "vibrato": "heavy", "reverb": 67, "fadeInSeconds": 0.0575, "fadeOutTicks": -6, "harmonics": [0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "unison": "hum", "envelopes": [{ "target": "noteVolume", "envelope": "decay 1" }] } },
                { name: "telephone ring", midiProgram: 124, generalMidi: true, settings: { "type": "FM", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 5656.85, "linearGain": 1 }], "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": -3, "chord": "arpeggio", "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "2×", "amplitude": 12 }, { "frequency": "1×", "amplitude": 4 }, { "frequency": "20×", "amplitude": 1 }, { "frequency": "1×", "amplitude": 0 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "tremolo4" }, { "target": "operatorAmplitude", "envelope": "tremolo1", "index": 1 }] } },
                { name: "helicopter", midiProgram: 125, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -0.5, settings: { "type": "spectrum", "effects": "reverb", "transition": "seamless", "chord": "arpeggio", "filterCutoffHz": 1414, "filterResonance": 14, "filterEnvelope": "tremolo4", "spectrum": [14, 43, 43, 57, 57, 57, 71, 71, 71, 71, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 57, 57] } },
                { name: "applause", midiProgram: 126, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -3, settings: { "type": "spectrum", "effects": "reverb", "transition": "soft fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "swell 3", "spectrum": [14, 14, 29, 29, 29, 43, 43, 57, 71, 71, 86, 86, 86, 71, 71, 57, 57, 57, 71, 86, 86, 86, 86, 86, 71, 71, 57, 57, 57, 57] } },
                { name: "gunshot", midiProgram: 127, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -2, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "strum", "filterCutoffHz": 1414, "filterResonance": 29, "filterEnvelope": "twang 1", "spectrum": [14, 29, 43, 43, 57, 57, 57, 71, 71, 71, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43] } },
                { name: "scoot", midiProgram: 92, settings: { "type": "chip", "eqFilter": [], "effects": ["note filter"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 707.11, "linearGain": 4 }], "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": -3, "chord": "simultaneous", "wave": "double saw", "unison": "shimmer", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "flare 1" }] } },
                { name: "buzz saw", midiProgram: 30, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 9513.66, "linearGain": 0.5 }], "effects": [], "transition": "normal", "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "chord": "custom interval", "algorithm": "1←2←3←4", "feedbackType": "1⟲", "feedbackAmplitude": 4, "operators": [{ "frequency": "5×", "amplitude": 13 }, { "frequency": "1×", "amplitude": 10 }, { "frequency": "~1×", "amplitude": 6 }, { "frequency": "11×", "amplitude": 12 }], "envelopes": [] } },
                { name: "mosquito", midiProgram: 93, settings: { "type": "PWM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 2828.43, "linearGain": 2 }], "effects": ["vibrato"], "vibrato": "shaky", "transition": "normal", "fadeInSeconds": 0.0575, "fadeOutTicks": -6, "chord": "simultaneous", "pulseWidth": 4.41942, "envelopes": [{ "target": "pulseWidth", "envelope": "tremolo6" }] } },
                { name: "breathing", midiProgram: 126, isNoise: true, midiSubharmonicOctaves: -1, settings: { "type": "spectrum", "effects": "reverb", "transition": "hard fade", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 14, "filterEnvelope": "swell 2", "spectrum": [14, 14, 14, 29, 29, 29, 29, 29, 43, 29, 29, 43, 43, 43, 29, 29, 71, 43, 86, 86, 57, 100, 86, 86, 86, 86, 71, 86, 71, 57] } },
                { name: "klaxon synth", midiProgram: 125, isNoise: true, midiSubharmonicOctaves: -1, settings: { "type": "noise", "effects": "reverb", "transition": "slide", "chord": "harmony", "filterCutoffHz": 2000, "filterResonance": 86, "filterEnvelope": "steady", "wave": "buzz" } },
                { name: "theremin", midiProgram: 40, settings: { "type": "harmonics", "eqFilter": [{ "type": "low-pass", "cutoffHz": 8000, "linearGain": 0.7071 }], "effects": ["vibrato", "reverb"], "vibrato": "heavy", "reverb": 33, "transition": "slide in pattern", "fadeInSeconds": 0.0263, "fadeOutTicks": -6, "chord": "simultaneous", "harmonics": [100, 71, 57, 43, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "unison": "none", "envelopes": [] } },
                { name: "sonar ping", midiProgram: 121, settings: { "type": "spectrum", "eqFilter": [], "effects": ["note filter", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 1681.79, "linearGain": 0.5 }], "reverb": 33, "transition": "normal", "fadeInSeconds": 0.0125, "fadeOutTicks": 72, "chord": "simultaneous", "spectrum": [100, 43, 29, 29, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "twang 2" }] } },
            ])
        },
        
           { name: "UltraBox Presets", presets: toNameMap([
                { name: "nes white", midiProgram: 116, generalMidi: true, isNoise: true, settings: { "type": "noise", "eqFilter": [], "eqFilterType": false, "eqSimpleCut": 8, "eqSimplePeak": 0, "eqSubFilters1": [], "effects": ["panning"], "pan": 0, "panDelay": 10, "fadeInSeconds": 0, "fadeOutTicks": 0, "wave": "1-bit white", "envelopes": [] } },
                { name: "nes ping", midiProgram: 116, generalMidi: true, isNoise: true, settings: { "type": "noise", "eqFilter": [], "eqFilterType": false, "eqSimpleCut": 8, "eqSimplePeak": 0, "eqSubFilters1": [], "effects": ["panning"], "pan": 0, "panDelay": 10, "fadeInSeconds": 0, "fadeOutTicks": 0, "wave": "1-bit metallic", "envelopes": [] } },
                { name: "distorted pulse vocal", generalMidi: false, settings: { "type": "chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 0.0884 }], "eqFilterType": false, "eqSimpleCut": 10, "eqSimplePeak": 0, "eqSubFilters0": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 0.0884 }], "effects": ["panning", "transition type", "pitch shift", "vibrato", "note filter", "bitcrusher", "echo", "reverb"], "transition": "normal", "clicklessTransition": false, "pitchShiftSemitones": 0, "vibrato": "delayed", "vibratoDepth": 0.3, "vibratoDelay": 18.5, "vibratoSpeed": 10, "vibratoType": 0, "noteFilterType": false, "noteSimpleCut": 10, "noteSimplePeak": 0, "noteFilter": [{ "type": "high-pass", "cutoffHz": 840.9, "linearGain": 11.3137 }, { "type": "low-pass", "cutoffHz": 297.3, "linearGain": 8 }, { "type": "peak", "cutoffHz": 500, "linearGain": 11.3137 }, { "type": "high-pass", "cutoffHz": 62.5, "linearGain": 1.4142 }, { "type": "peak", "cutoffHz": 176.78, "linearGain": 11.3137 }, { "type": "high-pass", "cutoffHz": 250, "linearGain": 11.3137 }], "noteSubFilters0": [{ "type": "high-pass", "cutoffHz": 840.9, "linearGain": 11.3137 }, { "type": "low-pass", "cutoffHz": 297.3, "linearGain": 8 }, { "type": "peak", "cutoffHz": 500, "linearGain": 11.3137 }, { "type": "high-pass", "cutoffHz": 62.5, "linearGain": 1.4142 }, { "type": "peak", "cutoffHz": 176.78, "linearGain": 11.3137 }, { "type": "high-pass", "cutoffHz": 250, "linearGain": 11.3137 }], "bitcrusherOctave": 6.5, "bitcrusherQuantization": 71, "pan": 0, "panDelay": 10, "echoSustain": 14, "echoDelayBeats": 0.167, "reverb": 0, "fadeInSeconds": 0, "fadeOutTicks": -3, "wave": "1/8 pulse", "unison": "none", "envelopes": [] } },
                { name: "dubsteb bwah", generalMidi: false, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 0.7071 }], "eqFilterType": true, "eqSimpleCut": 10, "eqSimplePeak": 0, "eqSubFilters1": [], "effects": ["panning", "transition type", "chord type"], "transition": "interrupt", "clicklessTransition": false, "chord": "custom interval", "fastTwoNoteArp": false, "arpeggioSpeed": 12, "pan": 0, "panDelay": 10, "fadeInSeconds": 0, "fadeOutTicks": -1, "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 10, "operators": [{ "frequency": "2×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "4×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 11, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 13, "waveform": "sine", "pulseWidth": 5 }], "envelopes": [{ "target": "noteVolume", "envelope": "note size" }, { "target": "operatorAmplitude", "envelope": "swell 2", "index": 1 }, { "target": "operatorAmplitude", "envelope": "punch", "index": 2 }, { "target": "operatorAmplitude", "envelope": "note size", "index": 3 }] } },
                { name: "FM cool bass", generalMidi: false, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 1 }, { "type": "high-pass", "cutoffHz": 88.39, "linearGain": 1 }, { "type": "peak", "cutoffHz": 1000, "linearGain": 0.7071 }], "eqFilterType": false, "eqSimpleCut": 10, "eqSimplePeak": 0, "eqSubFilters0": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 1 }, { "type": "high-pass", "cutoffHz": 88.39, "linearGain": 1 }, { "type": "peak", "cutoffHz": 1000, "linearGain": 0.7071 }], "effects": ["panning", "transition type", "note filter", "reverb"], "transition": "interrupt", "clicklessTransition": false, "noteFilterType": true, "noteSimpleCut": 9, "noteSimplePeak": 2, "noteFilter": [{ "type": "low-pass", "cutoffHz": 7231.23, "linearGain": 1 }], "noteSubFilters1": [{ "type": "low-pass", "cutoffHz": 7231.23, "linearGain": 1 }], "pan": 0, "panDelay": 10, "reverb": 0, "fadeInSeconds": 0, "fadeOutTicks": -1, "algorithm": "1←(2 3←4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "2×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 8, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 7, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "13×", "amplitude": 11, "waveform": "sine", "pulseWidth": 5 }], "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "punch" }, { "target": "operatorAmplitude", "envelope": "twang 2", "index": 1 }, { "target": "operatorAmplitude", "envelope": "twang 3", "index": 2 }, { "target": "operatorAmplitude", "envelope": "twang 2", "index": 3 }] } },
                { name: "FM funky bass", generalMidi: false, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 9513.66, "linearGain": 0.1768 }], "eqFilterType": true, "eqSimpleCut": 5, "eqSimplePeak": 0, "eqSubFilters1": [], "effects": ["panning", "transition type", "reverb"], "transition": "normal", "clicklessTransition": false, "pan": 0, "panDelay": 10, "reverb": 0, "fadeInSeconds": 0, "fadeOutTicks": -3, "algorithm": "1←(2 3 4)", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "~1×", "amplitude": 8, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 0, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 0, "waveform": "sine", "pulseWidth": 5 }], "envelopes": [{ "target": "noteVolume", "envelope": "punch" }, { "target": "noteVolume", "envelope": "note size" }] } },
                { name: "talking bass", generalMidi: false, settings: { "type": "FM", "eqFilter": [], "effects": ["chord type"], "chord": "custom interval", "fadeInSeconds": 0, "fadeOutTicks": -3, "algorithm": "1←(2 3)←4", "feedbackType": "1⟲", "feedbackAmplitude": 15, "operators": [{ "frequency": "1×", "amplitude": 15 }, { "frequency": "2×", "amplitude": 8 }, { "frequency": "2×", "amplitude": 5 }, { "frequency": "1×", "amplitude": 12 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "note size", "index": 2 }, { "target": "operatorAmplitude", "envelope": "note size", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "note size" }] } },
                { name: "synth marimba", generalMidi: false, settings: { "type": "Picked String", "eqFilter": [{ "type": "high-pass", "cutoffHz": 176.78, "linearGain": 1 }, { "type": "peak", "cutoffHz": 4000, "linearGain": 0.5 }], "effects": ["note filter", "echo"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 6727.17, "linearGain": 1.4142 }], "echoSustain": 71, "echoDelayBeats": 0.5, "fadeInSeconds": 0, "fadeOutTicks": -1, "harmonics": [86, 100, 29, 29, 0, 0, 0, 100, 0, 0, 0, 86, 29, 0, 14, 100, 0, 0, 0, 0, 0, 14, 0, 0, 14, 0, 0, 86], "unison": "fifth", "stringSustain": 7, "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "punch" }] } },
                { name: "italian accordian", generalMidi: false, settings: { "type": "custom chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 6000, "linearGain": 0.5 }], "eqFilterType": true, "eqSimpleCut": 8, "eqSimplePeak": 1, "eqSubFilters1": [], "effects": ["panning", "chorus", "reverb"], "pan": 0, "panDelay": 10, "chorus": 71, "reverb": 45, "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "wave": "square", "unison": "honky tonk", "customChipWave": { "0": -24, "1": -24, "2": -24, "3": -24, "4": -24, "5": -24, "6": -24, "7": -24, "8": -24, "9": -24, "10": -24, "11": -24, "12": -24, "13": -24, "14": -24, "15": -24, "16": 24, "17": 24, "18": 24, "19": 24, "20": 24, "21": 24, "22": 24, "23": 24, "24": -24, "25": -24, "26": -24, "27": -24, "28": -24, "29": -24, "30": -24, "31": -24, "32": -24, "33": -24, "34": -24, "35": -24, "36": -24, "37": -24, "38": -24, "39": -24, "40": 24, "41": 24, "42": 24, "43": 24, "44": 24, "45": 24, "46": 24, "47": 24, "48": -24, "49": -24, "50": -24, "51": -24, "52": -24, "53": -24, "54": -24, "55": -24, "56": -24, "57": -24, "58": -24, "59": -24, "60": -24, "61": -24, "62": -24, "63": -24 }, "customChipWaveIntegral": { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0, "10": 0, "11": 0, "12": 0, "13": 0, "14": 0, "15": 0, "16": 0, "17": 0, "18": 0, "19": 0, "20": 0, "21": 0, "22": 0, "23": 0, "24": 0, "25": 0, "26": 0, "27": 0, "28": 0, "29": 0, "30": 0, "31": 0, "32": 0, "33": 0, "34": 0, "35": 0, "36": 0, "37": 0, "38": 0, "39": 0, "40": 0, "41": 0, "42": 0, "43": 0, "44": 0, "45": 0, "46": 0, "47": 0, "48": 0, "49": 0, "50": 0, "51": 0, "52": 0, "53": 0, "54": 0, "55": 0, "56": 0, "57": 0, "58": 0, "59": 0, "60": 0, "61": 0, "62": 0, "63": 0, "64": 0 }, "envelopes": [] } },
                { name: "chip supersaw", generalMidi: false, settings: { "type": "custom chip", "eqFilter": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 0.7071 }], "eqFilterType": true, "eqSimpleCut": 10, "eqSimplePeak": 0, "eqSubFilters1": [], "effects": ["panning", "transition type", "vibrato", "chorus", "reverb"], "transition": "interrupt", "clicklessTransition": false, "vibrato": "delayed", "vibratoDepth": 0.3, "vibratoDelay": 18.5, "vibratoSpeed": 10, "vibratoType": 0, "pan": 0, "panDelay": 10, "chorus": 29, "reverb": 29, "fadeInSeconds": 0, "fadeOutTicks": -1, "wave": "square", "unison": "dissonant", "customChipWave": { "0": 22, "1": 22, "2": 16, "3": 6, "4": 0, "5": -3, "6": -8, "7": -10, "8": -13, "9": -16, "10": -19, "11": -19, "12": -20, "13": -22, "14": -22, "15": -24, "16": -24, "17": -24, "18": -24, "19": -24, "20": -24, "21": -24, "22": -24, "23": -24, "24": -24, "25": -24, "26": -24, "27": -24, "28": -24, "29": -24, "30": -24, "31": 24, "32": 24, "33": 16, "34": 9, "35": 6, "36": 4, "37": 2, "38": 0, "39": -1, "40": -3, "41": -4, "42": -4, "43": -6, "44": -6, "45": -6, "46": -6, "47": -5, "48": -5, "49": -4, "50": -2, "51": -2, "52": 1, "53": 4, "54": 6, "55": 8, "56": 10, "57": 12, "58": 14, "59": 16, "60": 18, "61": 19, "62": 22, "63": 24 }, "customChipWaveIntegral": { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0, "10": 0, "11": 0, "12": 0, "13": 0, "14": 0, "15": 0, "16": 0, "17": 0, "18": 0, "19": 0, "20": 0, "21": 0, "22": 0, "23": 0, "24": 0, "25": 0, "26": 0, "27": 0, "28": 0, "29": 0, "30": 0, "31": 0, "32": 0, "33": 0, "34": 0, "35": 0, "36": 0, "37": 0, "38": 0, "39": 0, "40": 0, "41": 0, "42": 0, "43": 0, "44": 0, "45": 0, "46": 0, "47": 0, "48": 0, "49": 0, "50": 0, "51": 0, "52": 0, "53": 0, "54": 0, "55": 0, "56": 0, "57": 0, "58": 0, "59": 0, "60": 0, "61": 0, "62": 0, "63": 0, "64": 0 }, "envelopes": [] } },
 
                { name: "fm supersaw", generalMidi: false, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 1.4142 }, { "type": "high-pass", "cutoffHz": 148.65, "linearGain": 0.7071 }], "eqFilterType": false, "eqSimpleCut": 10, "eqSimplePeak": 0, "eqSubFilters0": [{ "type": "low-pass", "cutoffHz": 19027.31, "linearGain": 1.4142 }, { "type": "high-pass", "cutoffHz": 148.65, "linearGain": 0.7071 }], "effects": ["panning", "transition type", "pitch shift", "note filter", "chorus", "reverb"], "transition": "continue", "clicklessTransition": false, "pitchShiftSemitones": 0, "noteFilterType": false, "noteSimpleCut": 10, "noteSimplePeak": 0, "noteFilter": [], "noteSubFilters0": [], "noteSubFilters1": [{ "type": "low-pass", "cutoffHz": 4756.83, "linearGain": 1 }], "pan": 0, "panDelay": 10, "chorus": 71, "reverb": 0, "fadeInSeconds": 0, "fadeOutTicks": -1, "algorithm": "1 2 3 4 5 6", "feedbackType": "1⟲", "feedbackAmplitude": 0, "operators": [{ "frequency": "1×", "amplitude": 13, "waveform": "sawtooth", "pulseWidth": 5 }, { "frequency": "~1×", "amplitude": 15, "waveform": "sawtooth", "pulseWidth": 5 }, { "frequency": "2×", "amplitude": 10, "waveform": "sawtooth", "pulseWidth": 5 }, { "frequency": "3×", "amplitude": 7, "waveform": "sawtooth", "pulseWidth": 5 }, { "frequency": "4×", "amplitude": 9, "waveform": "sawtooth", "pulseWidth": 5 }, { "frequency": "8×", "amplitude": 6, "waveform": "sawtooth", "pulseWidth": 5 }], "envelopes": [] } },
                { name: "wind", generalMidi: false, settings: { "type": "FM", "eqFilter": [{ "type": "low-pass", "cutoffHz": 250.03, "linearGain": 11.3137 }], "eqFilterType": true, "eqSimpleCut": 0, "eqSimplePeak": 7, "envelopeSpeed": 12, "discreteEnvelope": false, "eqSubFilters1": [], "effects": ["transition type", "reverb"], "transition": "continue", "clicklessTransition": false, "panDelay": 10, "reverb": 0, "fadeInSeconds": 0, "fadeOutTicks": -1, "algorithm": "1←(2 3 4)", "feedbackType": "1→3 2→4", "feedbackAmplitude": 15, "operators": [{ "frequency": "16×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "16×", "amplitude": 0, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "16×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "16×", "amplitude": 0, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 0, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "1×", "amplitude": 0, "waveform": "sine", "pulseWidth": 5 }], "envelopes": [] } },
                { name: "mrow", generalMidi: false, settings: { "type": "FM", "eqFilter": [], "eqFilterType": false, "eqSimpleCut": 10, "eqSimplePeak": 0, "eqSubFilters0": [], "effects": ["panning", "chord type", "reverb"], "chord": "custom interval", "fastTwoNoteArp": false, "arpeggioSpeed": 12, "pan": 0, "panDelay": 10, "reverb": 35, "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "algorithm": "1←3 2←4", "feedbackType": "1⟲ 2⟲ 3⟲ 4⟲", "feedbackAmplitude": 5, "operators": [{ "frequency": "4×", "amplitude": 15, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "~2×", "amplitude": 13, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "~2×", "amplitude": 8, "waveform": "sine", "pulseWidth": 5 }, { "frequency": "~2×", "amplitude": 9, "waveform": "sine", "pulseWidth": 5 }], "envelopes": [{ "target": "operatorAmplitude", "envelope": "flare 1", "index": 0 }, { "target": "operatorAmplitude", "envelope": "note size", "index": 1 }, { "target": "operatorAmplitude", "envelope": "note size", "index": 2 }, { "target": "operatorAmplitude", "envelope": "flare 3", "index": 3 }, { "target": "feedbackAmplitude", "envelope": "flare 1" }] } },
                { name: "vocal why", generalMidi: false, settings: { "type": "harmonics", "eqFilter": [], "effects": ["note filter", "panning", "reverb"], "noteFilter": [{ "type": "low-pass", "cutoffHz": 840.9, "linearGain": 11.3137 }], "pan": 0, "reverb": 0, "fadeInSeconds": 0.0263, "fadeOutTicks": -3, "harmonics": [100, 86, 29, 29, 14, 14, 0, 14, 14, 43, 71, 100, 100, 86, 71, 71, 57, 57, 43, 43, 43, 43, 43, 0, 0, 0, 0, 0], "unison": "octave", "envelopes": [{ "target": "noteFilterAllFreqs", "envelope": "note size" }] } },
            ])},
    ]);

    var __values = (exports && exports.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = (exports && exports.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (exports && exports.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    function applyElementArgs(element, args) {
        var e_1, _a, e_2, _b, e_3, _c;
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                if (arg instanceof Node) {
                    element.appendChild(arg);
                }
                else if (typeof arg === "string") {
                    element.appendChild(document.createTextNode(arg));
                }
                else if (typeof arg === "function") {
                    applyElementArgs(element, [arg()]);
                }
                else if (Array.isArray(arg)) {
                    applyElementArgs(element, arg);
                }
                else if (arg && typeof Symbol !== "undefined" && typeof arg[Symbol.iterator] === "function") {
                    applyElementArgs(element, __spread(arg));
                }
                else if (arg && arg.constructor === Object && element instanceof Element) {
                    try {
                        for (var _d = (e_2 = void 0, __values(Object.keys(arg))), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var key = _e.value;
                            var value = arg[key];
                            if (key === "class") {
                                if (typeof value === "string") {
                                    element.setAttribute("class", value);
                                }
                                else if (Array.isArray(arg) || (value && typeof Symbol !== "undefined" && typeof value[Symbol.iterator] === "function")) {
                                    element.setAttribute("class", __spread(value).join(" "));
                                }
                                else {
                                    console.warn("Invalid " + key + " value \"" + value + "\" on " + element.tagName + " element.");
                                }
                            }
                            else if (key === "style") {
                                if (value && value.constructor === Object) {
                                    try {
                                        for (var _f = (e_3 = void 0, __values(Object.keys(value))), _g = _f.next(); !_g.done; _g = _f.next()) {
                                            var styleKey = _g.value;
                                            if (styleKey in element.style) {
                                                element.style[styleKey] = value[styleKey];
                                            }
                                            else {
                                                element.style.setProperty(styleKey, value[styleKey]);
                                            }
                                        }
                                    }
                                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                    finally {
                                        try {
                                            if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                                        }
                                        finally { if (e_3) throw e_3.error; }
                                    }
                                }
                                else {
                                    element.setAttribute(key, value);
                                }
                            }
                            else if (typeof (value) === "function") {
                                element[key] = value;
                            }
                            else if (typeof (value) === "boolean") {
                                if (value)
                                    element.setAttribute(key, "");
                                else
                                    element.removeAttribute(key);
                            }
                            else {
                                element.setAttribute(key, value);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                else {
                    element.appendChild(document.createTextNode(arg));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return element;
    }
    var svgNS = "http://www.w3.org/2000/svg";
    function parseHTML() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return document.createRange().createContextualFragment(args.join());
    }
    function parseSVG() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var fragment = document.createDocumentFragment();
        var svgParser = new DOMParser().parseFromString("<svg xmlns=\"http://www.w3.org/2000/svg\">" + args.join() + "</svg>", "image/svg+xml").documentElement;
        while (svgParser.firstChild !== null) {
            document.importNode(svgParser.firstChild, true);
            fragment.appendChild(svgParser.firstChild);
        }
        return fragment;
    }

    var __values$1 = (exports && exports.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a, e_2, _b;
    var HTML = parseHTML;
    var SVG = parseSVG;
    var _loop_1 = function (name_1) {
        HTML[name_1] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return applyElementArgs(document.createElement(name_1), args);
        };
    };
    try {
        for (var _c = __values$1("a abbr address area article aside audio b base bdi bdo blockquote br button canvas caption cite code col colgroup datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hr i iframe img input ins kbd label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td template textarea tfoot th thead time title tr track u ul var video wbr".split(" ")), _d = _c.next(); !_d.done; _d = _c.next()) {
            var name_1 = _d.value;
            _loop_1(name_1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_2 = function (name_2) {
        SVG[name_2] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return applyElementArgs(document.createElementNS(svgNS, name_2), args);
        };
        if (/-/.test(name_2)) {
            var snakeCaseName = name_2.replace(/-/g, "_");
            SVG[snakeCaseName] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return applyElementArgs(document.createElementNS(svgNS, name_2), args);
            };
        }
    };
    try {
        for (var _e = __values$1("a altGlyph altGlyphDef altGlyphItem animate animateMotion animateTransform circle clipPath color-profile cursor defs desc discard ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence filter font font-face font-face-format font-face-name font-face-src font-face-uri foreignObject g glyph glyphRef hkern image line linearGradient marker mask metadata missing-glyph mpath path pattern polygon polyline radialGradient rect script set stop style svg switch symbol text textPath title tref tspan use view vkern".split(" ")), _f = _e.next(); !_f.done; _f = _e.next()) {
            var name_2 = _f.value;
            _loop_2(name_2);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }

    class ColorConfig {
        static resetColors() {
            this.colorLookup.clear();
        }
        static getComputedChannelColor(song, channel) {
        	
        	
        	
if (!this.usesColorFormula) {
	let base;
	switch (song) {
		case ("noise"): {
			base = ColorConfig.noiseChannels[(channel % +ColorConfig.getComputed("--noise-channel-limit")) % ColorConfig.noiseChannels.length];
			break;
		}
		case ("mod"): {
			base = ColorConfig.modChannels[(channel % +ColorConfig.getComputed("--mod-channel-limit")) % ColorConfig.modChannels.length];
			break;
		}
		case ("pitch"):
		default: {
			base = ColorConfig.pitchChannels[(channel % +ColorConfig.getComputed("--pitch-channel-limit")) % ColorConfig.pitchChannels.length];
			break;
		}
	}
	var regex = /\(([^\,)]+)/;
	let newChannelSecondary = ColorConfig.getComputed(regex.exec(base.secondaryChannel)[1]);
	let newChannelPrimary = ColorConfig.getComputed(regex.exec(base.primaryChannel)[1]);
	let newNoteSecondary = ColorConfig.getComputed(regex.exec(base.secondaryNote)[1]);
	let newNotePrimary = ColorConfig.getComputed(regex.exec(base.primaryNote)[1]);
	return { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
}
let colorFormulaPitchLimit = +ColorConfig.getComputed("--formula-pitch-channel-limit");
let colorFormulaNoiseLimit = +ColorConfig.getComputed("--formula-noise-channel-limit");
let colorFormulaModLimit = +ColorConfig.getComputed("--formula-mod-channel-limit");
switch (song) {
	case ("noise"): {
		let newChannelSecondary = "hsl(" + ((this.c_noiseSecondaryChannelHue + ((channel * this.c_noiseSecondaryChannelHueScale) / this.c_noiseChannelCountOverride) * 256) % colorFormulaNoiseLimit) + "," +
			(this.c_noiseSecondaryChannelSat + channel * this.c_noiseSecondaryChannelSatScale) + "%," +
			(this.c_noiseSecondaryChannelLum + channel * this.c_noiseSecondaryChannelLumScale) + "%)";
		let newChannelPrimary = "hsl(" + ((this.c_noisePrimaryChannelHue + ((channel * this.c_noisePrimaryChannelHueScale) / this.c_noiseChannelCountOverride) * 256) % colorFormulaNoiseLimit) + "," +
			(this.c_noisePrimaryChannelSat + channel * this.c_noisePrimaryChannelSatScale) + "%," +
			(this.c_noisePrimaryChannelLum + channel * this.c_noisePrimaryChannelLumScale) + "%)";
		let newNoteSecondary = "hsl(" + ((this.c_noiseSecondaryNoteHue + ((channel * this.c_noiseSecondaryNoteHueScale) / this.c_noiseChannelCountOverride) * 256) % colorFormulaNoiseLimit) + "," +
			(this.c_noiseSecondaryNoteSat + channel * this.c_noiseSecondaryNoteSatScale) + "%," +
			(this.c_noiseSecondaryNoteLum + channel * this.c_noiseSecondaryNoteLumScale) + "%)";
		let newNotePrimary = "hsl(" + ((this.c_noisePrimaryNoteHue + ((channel * this.c_noisePrimaryNoteHueScale) / this.c_noiseChannelCountOverride) * 256) % colorFormulaNoiseLimit) + "," +
			(this.c_noisePrimaryNoteSat + channel * this.c_noisePrimaryNoteSatScale) + "%," +
			(this.c_noisePrimaryNoteLum + channel * this.c_noisePrimaryNoteLumScale) + "%)";
		let newChannelColors = { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
		return newChannelColors;
	}
	case ("mod"): {
		let newChannelSecondary = "hsl(" + ((this.c_modSecondaryChannelHue + ((channel * this.c_modSecondaryChannelHueScale) / this.c_modChannelCountOverride) * 256) % colorFormulaModLimit) + "," +
			(this.c_modSecondaryChannelSat + channel * this.c_modSecondaryChannelSatScale) + "%," +
			(this.c_modSecondaryChannelLum + channel * this.c_modSecondaryChannelLumScale) + "%)";
		let newChannelPrimary = "hsl(" + ((this.c_modPrimaryChannelHue + ((channel * this.c_modPrimaryChannelHueScale) / this.c_modChannelCountOverride) * 256) % colorFormulaModLimit) + "," +
			(this.c_modPrimaryChannelSat + channel * this.c_modPrimaryChannelSatScale) + "%," +
			(this.c_modPrimaryChannelLum + channel * this.c_modPrimaryChannelLumScale) + "%)";
		let newNoteSecondary = "hsl(" + ((this.c_modSecondaryNoteHue + ((channel * this.c_modSecondaryNoteHueScale) / this.c_modChannelCountOverride) * 256) % colorFormulaModLimit) + "," +
			(this.c_modSecondaryNoteSat + channel * this.c_modSecondaryNoteSatScale) + "%," +
			(this.c_modSecondaryNoteLum + channel * this.c_modSecondaryNoteLumScale) + "%)";
		let newNotePrimary = "hsl(" + ((this.c_modPrimaryNoteHue + ((channel * this.c_modPrimaryNoteHueScale) / this.c_modChannelCountOverride) * 256) % colorFormulaModLimit) + "," +
			(this.c_modPrimaryNoteSat + channel * this.c_modPrimaryNoteSatScale) + "%," +
			(this.c_modPrimaryNoteLum + channel * this.c_modPrimaryNoteLumScale) + "%)";
		let newChannelColors = { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
		return newChannelColors;
	}
	case ("pitch"):
	default: {
		let newChannelSecondary = "hsl(" + ((this.c_pitchSecondaryChannelHue + (channel * this.c_pitchSecondaryChannelHueScale / this.c_pitchChannelCountOverride) * 256) % colorFormulaPitchLimit) + "," +
			(this.c_pitchSecondaryChannelSat * (1 - (this.c_pitchSecondaryChannelSatScale * Math.floor(channel / 7)))) + "%," +
			(this.c_pitchSecondaryChannelLum * (1 - (this.c_pitchSecondaryChannelLumScale * Math.floor(channel / 7)))) + "%)";
		let newChannelPrimary = "hsl(" + ((this.c_pitchPrimaryChannelHue + (channel * this.c_pitchPrimaryChannelHueScale / this.c_pitchChannelCountOverride) * 256) % colorFormulaPitchLimit) + "," +
			(this.c_pitchPrimaryChannelSat * (1 - (this.c_pitchPrimaryChannelSatScale * Math.floor(channel / 7)))) + "%," +
			(this.c_pitchPrimaryChannelLum * (1 - (this.c_pitchPrimaryChannelLumScale * Math.floor(channel / 7)))) + "%)";
		let newNoteSecondary = "hsl(" + ((this.c_pitchSecondaryNoteHue + (channel * this.c_pitchSecondaryNoteHueScale / this.c_pitchChannelCountOverride) * 256) % colorFormulaPitchLimit) + "," +
			(this.c_pitchSecondaryNoteSat * (1 - (this.c_pitchSecondaryNoteSatScale * Math.floor(channel / 7)))) + "%," +
			(this.c_pitchSecondaryNoteLum * (1 - (this.c_pitchSecondaryNoteLumScale * Math.floor(channel / 7)))) + "%)";
		let newNotePrimary = "hsl(" + ((this.c_pitchPrimaryNoteHue + (channel * this.c_pitchPrimaryNoteHueScale / this.c_pitchChannelCountOverride) * 256) % colorFormulaPitchLimit) + "," +
			(this.c_pitchPrimaryNoteSat * (1 - (this.c_pitchPrimaryNoteSatScale * Math.floor(channel / 7)))) + "%," +
			(this.c_pitchPrimaryNoteLum * (1 - (this.c_pitchPrimaryNoteLumScale * Math.floor(channel / 7)))) + "%)";
		let newChannelColors = { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
		return newChannelColors;
	}
}}

        static getChannelColor(song, channel) {
        	
        	
   if (!this.usesColorFormula) {
   	if (channel < song.pitchChannelCount) {
   		return ColorConfig.pitchChannels[(channel % +(ColorConfig.getComputed("--pitch-channel-limit"))) % ColorConfig.pitchChannels.length];
   	}
   	else if (channel < song.pitchChannelCount + song.noiseChannelCount) {
   		return ColorConfig.noiseChannels[((channel - song.pitchChannelCount) % +(ColorConfig.getComputed("--noise-channel-limit"))) % ColorConfig.noiseChannels.length];
   	}
   	else {
   		return ColorConfig.modChannels[((channel - song.pitchChannelCount - song.noiseChannelCount) % +(ColorConfig.getComputed("--mod-channel-limit"))) % ColorConfig.modChannels.length];
   	}
   }
        	
            if (getComputedStyle(this._styleElement).getPropertyValue("--use-color-formula").trim() == "false") {
                if (channel < song.pitchChannelCount) {
                    return ColorConfig.pitchChannels[channel % ColorConfig.pitchChannels.length];
                }
                else if (channel < song.pitchChannelCount + song.noiseChannelCount) {
                    return ColorConfig.noiseChannels[(channel - song.pitchChannelCount) % ColorConfig.noiseChannels.length];
                }
                else {
                    return ColorConfig.modChannels[(channel - song.pitchChannelCount - song.noiseChannelCount) % ColorConfig.modChannels.length];
                }
            }
            else {
                if (ColorConfig.colorLookup.has(channel)) {
                    return ColorConfig.colorLookup.get(channel);
                }
                else {
                    if (channel < song.pitchChannelCount) {
                        const pitchSecondaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-hue");
                        const pitchSecondaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-hue-scale");
                        const pitchSecondaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-sat");
                        const pitchSecondaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-sat-scale");
                        const pitchSecondaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-lum");
                        const pitchSecondaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-lum-scale");
                        const pitchPrimaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-hue");
                        const pitchPrimaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-hue-scale");
                        const pitchPrimaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-sat");
                        const pitchPrimaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-sat-scale");
                        const pitchPrimaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-lum");
                        const pitchPrimaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-lum-scale");
                        const pitchSecondaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-hue");
                        const pitchSecondaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-hue-scale");
                        const pitchSecondaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-sat");
                        const pitchSecondaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-sat-scale");
                        const pitchSecondaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-lum");
                        const pitchSecondaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-lum-scale");
                        const pitchPrimaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-hue");
                        const pitchPrimaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-hue-scale");
                        const pitchPrimaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-sat");
                        const pitchPrimaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-sat-scale");
                        const pitchPrimaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-lum");
                        const pitchPrimaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-lum-scale");
                        let newChannelSecondary = "hsl(" + ((+pitchSecondaryChannelHue + (channel * +pitchSecondaryChannelHueScale / Config.pitchChannelCountMax) * 256) % 256) + ","
                            + (+pitchSecondaryChannelSat * (1 - (+pitchSecondaryChannelSatScale * Math.floor(channel / 7)))) + "%,"
                            + (+pitchSecondaryChannelLum * (1 - (+pitchSecondaryChannelLumScale * Math.floor(channel / 7)))) + "%)";
                        let newChannelPrimary = "hsl(" + ((+pitchPrimaryChannelHue + (channel * +pitchPrimaryChannelHueScale / Config.pitchChannelCountMax) * 256) % 256) + ","
                            + (+pitchPrimaryChannelSat * (1 - (+pitchPrimaryChannelSatScale * Math.floor(channel / 7)))) + "%,"
                            + (+pitchPrimaryChannelLum * (1 - (+pitchPrimaryChannelLumScale * Math.floor(channel / 7)))) + "%)";
                        let newNoteSecondary = "hsl(" + ((+pitchSecondaryNoteHue + (channel * +pitchSecondaryNoteHueScale / Config.pitchChannelCountMax) * 256) % 256) + ","
                            + (+pitchSecondaryNoteSat * (1 - (+pitchSecondaryNoteSatScale * Math.floor(channel / 7)))) + "%,"
                            + (+pitchSecondaryNoteLum * (1 - (+pitchSecondaryNoteLumScale * Math.floor(channel / 7)))) + "%)";
                        let newNotePrimary = "hsl(" + ((+pitchPrimaryNoteHue + (channel * +pitchPrimaryNoteHueScale / Config.pitchChannelCountMax) * 256) % 256) + ","
                            + (+pitchPrimaryNoteSat * (1 - (+pitchPrimaryNoteSatScale * Math.floor(channel / 7)))) + "%,"
                            + (+pitchPrimaryNoteLum * (1 - (+pitchPrimaryNoteLumScale * Math.floor(channel / 7)))) + "%)";
                        let newChannelColors = { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
                        ColorConfig.colorLookup.set(channel, newChannelColors);
                        return newChannelColors;
                    }
                    else if (channel < song.pitchChannelCount + song.noiseChannelCount) {
                        const noiseSecondaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-hue");
                        const noiseSecondaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-hue-scale");
                        const noiseSecondaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-sat");
                        const noiseSecondaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-sat-scale");
                        const noiseSecondaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-lum");
                        const noiseSecondaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-lum-scale");
                        
                          
                        const noisePrimaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-hue");
                        const noisePrimaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-hue-scale");
                        const noisePrimaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-sat");
                        const noisePrimaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-sat-scale");
                        const noisePrimaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-lum");
                        const noisePrimaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-lum-scale");
                        const noiseSecondaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-hue");
                        const noiseSecondaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-hue-scale");
                        const noiseSecondaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-sat");
                        const noiseSecondaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-sat-scale");
                        const noiseSecondaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-lum");
                        const noiseSecondaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-lum-scale");
                        const noisePrimaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-hue");
                        const noisePrimaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-hue-scale");
                        const noisePrimaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-sat");
                        const noisePrimaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-sat-scale");
                        const noisePrimaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-lum");
                        const noisePrimaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-lum-scale");
                        let newChannelSecondary = "hsl(" + ((+noiseSecondaryChannelHue + (((channel - song.pitchChannelCount) * +noiseSecondaryChannelHueScale) / Config.noiseChannelCountMax) * 256) % 256) + ","
                            + (+noiseSecondaryChannelSat + channel * +noiseSecondaryChannelSatScale) + "%,"
                            + (+noiseSecondaryChannelLum + channel * +noiseSecondaryChannelLumScale) + "%)";
                        let newChannelPrimary = "hsl(" + ((+noisePrimaryChannelHue + (((channel - song.pitchChannelCount) * +noisePrimaryChannelHueScale) / Config.noiseChannelCountMax) * 256) % 256) + ","
                            + (+noisePrimaryChannelSat + channel * +noisePrimaryChannelSatScale) + "%,"
                            + (+noisePrimaryChannelLum + channel * +noisePrimaryChannelLumScale) + "%)";
                        let newNoteSecondary = "hsl(" + ((+noiseSecondaryNoteHue + (((channel - song.pitchChannelCount) * +noiseSecondaryNoteHueScale) / Config.noiseChannelCountMax) * 256) % 256) + ","
                            + (+noiseSecondaryNoteSat + channel * +noiseSecondaryNoteSatScale) + "%,"
                            + (+noiseSecondaryNoteLum + channel * +noiseSecondaryNoteLumScale) + "%)";
                        let newNotePrimary = "hsl(" + ((+noisePrimaryNoteHue + (((channel - song.pitchChannelCount) * +noisePrimaryNoteHueScale) / Config.noiseChannelCountMax) * 256) % 256) + ","
                            + (+noisePrimaryNoteSat + channel * +noisePrimaryNoteSatScale) + "%,"
                            + (+noisePrimaryNoteLum + channel * +noisePrimaryNoteLumScale) + "%)";
                        let newChannelColors = { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
                        ColorConfig.colorLookup.set(channel, newChannelColors);
                        return newChannelColors;
                    }
                    else {
                        const modSecondaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-hue");
                        const modSecondaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-hue-scale");
                        const modSecondaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-sat");
                        const modSecondaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-sat-scale");
                        const modSecondaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-lum");
                        const modSecondaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-lum-scale");
                        const modPrimaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-hue");
                        const modPrimaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-hue-scale");
                        const modPrimaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-sat");
                        const modPrimaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-sat-scale");
                        const modPrimaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-lum");
                        const modPrimaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-lum-scale");
                        const modSecondaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-hue");
                        const modSecondaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-hue-scale");
                        const modSecondaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-sat");
                        const modSecondaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-sat-scale");
                        const modSecondaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-lum");
                        const modSecondaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-lum-scale");
                        const modPrimaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-hue");
                        const modPrimaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-hue-scale");
                        const modPrimaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-sat");
                        const modPrimaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-sat-scale");
                        const modPrimaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-lum");
                        const modPrimaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-lum-scale");
                        let newChannelSecondary = "hsl(" + ((+modSecondaryChannelHue + (((channel - song.pitchChannelCount - song.noiseChannelCount) * +modSecondaryChannelHueScale) / Config.modChannelCountMax) * 256) % 256) + ","
                            + (+modSecondaryChannelSat + channel * +modSecondaryChannelSatScale) + "%,"
                            + (+modSecondaryChannelLum + channel * +modSecondaryChannelLumScale) + "%)";
                        let newChannelPrimary = "hsl(" + ((+modPrimaryChannelHue + (((channel - song.pitchChannelCount - song.noiseChannelCount) * +modPrimaryChannelHueScale) / Config.modChannelCountMax) * 256) % 256) + ","
                            + (+modPrimaryChannelSat + channel * +modPrimaryChannelSatScale) + "%,"
                            + (+modPrimaryChannelLum + channel * +modPrimaryChannelLumScale) + "%)";
                        let newNoteSecondary = "hsl(" + ((+modSecondaryNoteHue + (((channel - song.pitchChannelCount - song.noiseChannelCount) * +modSecondaryNoteHueScale) / Config.modChannelCountMax) * 256) % 256) + ","
                            + (+modSecondaryNoteSat + channel * +modSecondaryNoteSatScale) + "%,"
                            + (+modSecondaryNoteLum + channel * +modSecondaryNoteLumScale) + "%)";
                        let newNotePrimary = "hsl(" + ((+modPrimaryNoteHue + (((channel - song.pitchChannelCount - song.noiseChannelCount) * +modPrimaryNoteHueScale) / Config.modChannelCountMax) * 256) % 256) + ","
                            + (+modPrimaryNoteSat + channel * +modPrimaryNoteSatScale) + "%,"
                            + (+modPrimaryNoteLum + channel * +modPrimaryNoteLumScale) + "%)";
                        let newChannelColors = { secondaryChannel: newChannelSecondary, primaryChannel: newChannelPrimary, secondaryNote: newNoteSecondary, primaryNote: newNotePrimary };
                        ColorConfig.colorLookup.set(channel, newChannelColors);
                        return newChannelColors;
                    }
                }
            }
        }
          static setTheme(name) {
            let theme = this.themes[name];
            if (theme == undefined)
                theme = ColorConfig.defaultTheme;
            this._styleElement.textContent = theme;
            let valuesToAdd = ":root{";
            if (getComputedStyle(this._styleElement).getPropertyValue("--oscilloscope-line-L") == "")
                valuesToAdd += "--oscilloscope-line-L:var(--primary-text,white);";
            if (getComputedStyle(this._styleElement).getPropertyValue("--oscilloscope-line-R") == "")
                valuesToAdd += "--oscilloscope-line-R:var(--text-selection,rgba(119,68,255,0.99));";
            if (getComputedStyle(this._styleElement).getPropertyValue("--text-enabled-icon") == "")
                valuesToAdd += "--text-enabled-icon:✓ ;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--text-disabled-icon") == "")
                valuesToAdd += "--text-disabled-icon:　;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--text-spacing-icon") == "")
                valuesToAdd += "--text-spacing-icon:　;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--note-flash") == "")
                valuesToAdd += "--note-flash:#ffffff;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--note-flash-secondary") == "")
                valuesToAdd += "--note-flash-secondary:#ffffff77;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch-channel-limit") == "")
                valuesToAdd += "--pitch-channel-limit:" + Config.pitchChannelCountMax + ";";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise-channel-limit") == "")
                valuesToAdd += "--noise-channel-limit:" + Config.noiseChannelCountMax + ";";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod-channel-limit") == "")
                valuesToAdd += "--mod-channel-limit:" + Config.modChannelCountMax + ";";
            if (getComputedStyle(this._styleElement).getPropertyValue("--formula-pitch-channel-limit") == "")
                valuesToAdd += "--formula-pitch-channel-limit:360;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--formula-noise-channel-limit") == "")
                valuesToAdd += "--formula-noise-channel-limit:360;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--formula-mod-channel-limit") == "")
                valuesToAdd += "--formula-mod-channel-limit:360;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--editor-background") == "")
                valuesToAdd += "--editor-background:black;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pattern-background") == "")
	valuesToAdd += "--pattern-background: transparent;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--ui-widget-background") == "")
                valuesToAdd += "--ui-widget-background:#444;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--loop-accent") == "")
                valuesToAdd += "--loop-accent:#74f;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--box-selection-fill") == "")
                valuesToAdd += "--box-selection-fill:rgba(255,255,255,0.2);";
            if (getComputedStyle(this._styleElement).getPropertyValue("--primary-text") == "")
                valuesToAdd += "--primary-text:white;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--inverted-text") == "")
                valuesToAdd += "--inverted-text:black;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-pitch") == "")
                valuesToAdd += "--track-editor-bg-pitch:#444;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-pitch-dim") == "")
                valuesToAdd += "--track-editor-bg-pitch-dim:#333;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-noise") == "")
                valuesToAdd += "--track-editor-bg-noise:#444;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-noise-dim") == "")
                valuesToAdd += "--track-editor-bg-noise-dim:#333;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-mod") == "")
                valuesToAdd += "--track-editor-bg-mod:#234;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-mod-dim") == "")
                valuesToAdd += "--track-editor-bg-mod-dim:#123;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mute-button-normal") == "")
                valuesToAdd += "--mute-button-normal:#ffa033;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mute-button-mod") == "")
                valuesToAdd += "--mute-button-mod:#9a6bff;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch1-secondary-channel") == "")
                valuesToAdd += "--pitch1-secondary-channel:#0099A1;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch1-primary-channel") == "")
                valuesToAdd += "--pitch1-primary-channel:#25F3FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch1-secondary-note") == "")
                valuesToAdd += "--pitch1-secondary-note:#00BDC7;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch1-primary-note") == "")
                valuesToAdd += "--pitch1-primary-note:#92F9FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch2-secondary-channel") == "")
                valuesToAdd += "--pitch2-secondary-channel:#A1A100;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch2-primary-channel") == "")
                valuesToAdd += "--pitch2-primary-channel:#FFFF25;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch2-secondary-note") == "")
                valuesToAdd += "--pitch2-secondary-note:#C7C700;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch2-primary-note") == "")
                valuesToAdd += "--pitch2-primary-note:#FFFF92;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch3-secondary-channel") == "")
                valuesToAdd += "--pitch3-secondary-channel:#C75000;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch3-primary-channel") == "")
                valuesToAdd += "--pitch3-primary-channel:#FF9752;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch3-secondary-note") == "")
                valuesToAdd += "--pitch3-secondary-note:#FF771C;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch3-primary-note") == "")
                valuesToAdd += "--pitch3-primary-note:#FFCDAB;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch4-secondary-channel") == "")
                valuesToAdd += "--pitch4-secondary-channel:#00A100;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch4-primary-channel") == "")
                valuesToAdd += "--pitch4-primary-channel:#50FF50;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch4-secondary-note") == "")
                valuesToAdd += "--pitch4-secondary-note:#00C700;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch4-primary-note") == "")
                valuesToAdd += "--pitch4-primary-note:#A0FFA0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch5-secondary-channel") == "")
                valuesToAdd += "--pitch5-secondary-channel:#D020D0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch5-primary-channel") == "")
                valuesToAdd += "--pitch5-primary-channel:#FF90FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch5-secondary-note") == "")
                valuesToAdd += "--pitch5-secondary-note:#E040E0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch5-primary-note") == "")
                valuesToAdd += "--pitch5-primary-note:#FFC0FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch6-secondary-channel") == "")
                valuesToAdd += "--pitch6-secondary-channel:#7777B0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch6-primary-channel") == "")
                valuesToAdd += "--pitch6-primary-channel:#A0A0FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch6-secondary-note") == "")
                valuesToAdd += "--pitch6-secondary-note:#8888D0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch6-primary-note") == "")
                valuesToAdd += "--pitch6-primary-note:#D0D0FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch7-secondary-channel") == "")
                valuesToAdd += "--pitch7-secondary-channel:#8AA100;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch7-primary-channel") == "")
                valuesToAdd += "--pitch7-primary-channel:#DEFF25;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch7-secondary-note") == "")
                valuesToAdd += "--pitch7-secondary-note:#AAC700;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch7-primary-note") == "")
                valuesToAdd += "--pitch7-primary-note:#E6FF92;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch8-secondary-channel") == "")
                valuesToAdd += "--pitch8-secondary-channel:#DF0019;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch8-primary-channel") == "")
                valuesToAdd += "--pitch8-primary-channel:#FF98A4;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch8-secondary-note") == "")
                valuesToAdd += "--pitch8-secondary-note:#FF4E63;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch8-primary-note") == "")
                valuesToAdd += "--pitch8-primary-note:#FFB2BB;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch9-secondary-channel") == "")
                valuesToAdd += "--pitch9-secondary-channel:#00A170;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch9-primary-channel") == "")
                valuesToAdd += "--pitch9-primary-channel:#50FFC9;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch9-secondary-note") == "")
                valuesToAdd += "--pitch9-secondary-note:#00C78A;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch9-primary-note") == "")
                valuesToAdd += "--pitch9-primary-note:#83FFD9;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch10-secondary-channel") == "")
                valuesToAdd += "--pitch10-secondary-channel:#A11FFF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch10-primary-channel") == "")
                valuesToAdd += "--pitch10-primary-channel:#CE8BFF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch10-secondary-note") == "")
                valuesToAdd += "--pitch10-secondary-note:#B757FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--pitch10-primary-note") == "")
                valuesToAdd += "--pitch10-primary-note:#DFACFF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise1-secondary-channel") == "")
                valuesToAdd += "--noise1-secondary-channel:#6F6F6F;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise1-primary-channel") == "")
                valuesToAdd += "--noise1-primary-channel:#AAAAAA;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise1-secondary-note") == "")
                valuesToAdd += "--noise1-secondary-note:#A7A7A7;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise1-primary-note") == "")
                valuesToAdd += "--noise1-primary-note:#E0E0E0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise2-secondary-channel") == "")
                valuesToAdd += "--noise2-secondary-channel:#996633;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise2-primary-channel") == "")
                valuesToAdd += "--noise2-primary-channel:#DDAA77;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise2-secondary-note") == "")
                valuesToAdd += "--noise2-secondary-note:#CC9966;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise2-primary-note") == "")
                valuesToAdd += "--noise2-primary-note:#F0D0BB;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise3-secondary-channel") == "")
                valuesToAdd += "--noise3-secondary-channel:#4A6D8F;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise3-primary-channel") == "")
                valuesToAdd += "--noise3-primary-channel:#77AADD;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise3-secondary-note") == "")
                valuesToAdd += "--noise3-secondary-note:#6F9FCF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise3-primary-note") == "")
                valuesToAdd += "--noise3-primary-note:#BBD7FF;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise4-secondary-channel") == "")
                valuesToAdd += "--noise4-secondary-channel:#7A4F9A;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise4-primary-channel") == "")
                valuesToAdd += "--noise4-primary-channel:#AF82D2;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise4-secondary-note") == "")
                valuesToAdd += "--noise4-secondary-note:#9E71C1;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise4-primary-note") == "")
                valuesToAdd += "--noise4-primary-note:#D4C1EA;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise5-secondary-channel") == "")
                valuesToAdd += "--noise5-secondary-channel:#607837;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise5-primary-channel") == "")
                valuesToAdd += "--noise5-primary-channel:#A2BB77;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise5-secondary-note") == "")
                valuesToAdd += "--noise5-secondary-note:#91AA66;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--noise5-primary-note") == "")
                valuesToAdd += "--noise5-primary-note:#C5E2B2;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod1-secondary-channel") == "")
                valuesToAdd += "--mod1-secondary-channel:#339955;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod1-primary-channel") == "")
                valuesToAdd += "--mod1-primary-channel:#77fc55;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod1-secondary-note") == "")
                valuesToAdd += "--mod1-secondary-note:#77ff8a;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod1-primary-note") == "")
                valuesToAdd += "--mod1-primary-note:#cdffee;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod2-secondary-channel") == "")
                valuesToAdd += "--mod2-secondary-channel:#993355;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod2-primary-channel") == "")
                valuesToAdd += "--mod2-primary-channel:#f04960;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod2-secondary-note") == "")
                valuesToAdd += "--mod2-secondary-note:#f057a0;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod2-primary-note") == "")
                valuesToAdd += "--mod2-primary-note:#ffb8de;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod3-secondary-channel") == "")
                valuesToAdd += "--mod3-secondary-channel:#553399;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod3-primary-channel") == "")
                valuesToAdd += "--mod3-primary-channel:#8855fc;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod3-secondary-note") == "")
                valuesToAdd += "--mod3-secondary-note:#aa64ff;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod3-primary-note") == "")
                valuesToAdd += "--mod3-primary-note:#f8ddff;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod4-secondary-channel") == "")
                valuesToAdd += "--mod4-secondary-channel:#a86436;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod4-primary-channel") == "")
                valuesToAdd += "--mod4-primary-channel:#c8a825;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod4-secondary-note") == "")
                valuesToAdd += "--mod4-secondary-note:#e8ba46;";
            if (getComputedStyle(this._styleElement).getPropertyValue("--mod4-primary-note") == "")
                valuesToAdd += "--mod4-primary-note:#fff6d3;";
            valuesToAdd += "}";
            this._styleElement.textContent = valuesToAdd + this._styleElement.textContent;
            const themeColor = document.querySelector("meta[name='theme-color']");
            if (themeColor != null) {
                themeColor.setAttribute("content", getComputedStyle(document.documentElement).getPropertyValue('--ui-widget-background'));
            }
            this.resetColors();
            this.usesColorFormula = (getComputedStyle(this._styleElement).getPropertyValue("--use-color-formula").trim() == "true");
            this.c_invertedText = getComputedStyle(this._styleElement).getPropertyValue("--inverted-text");
            this.c_trackEditorBgNoiseDim = getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-noise-dim");
            this.c_trackEditorBgNoise = getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-noise");
            this.c_trackEditorBgModDim = getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-mod-dim");
            this.c_trackEditorBgMod = getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-mod");
            this.c_trackEditorBgPitchDim = getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-pitch-dim");
            this.c_trackEditorBgPitch = getComputedStyle(this._styleElement).getPropertyValue("--track-editor-bg-pitch");
            if (this.usesColorFormula) {
                this.c_pitchSecondaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-hue");
                this.c_pitchSecondaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-hue-scale");
                this.c_pitchSecondaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-sat");
                this.c_pitchSecondaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-sat-scale");
                this.c_pitchSecondaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-lum");
                this.c_pitchSecondaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-channel-lum-scale");
                this.c_pitchPrimaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-hue");
                this.c_pitchPrimaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-hue-scale");
                this.c_pitchPrimaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-sat");
                this.c_pitchPrimaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-sat-scale");
                this.c_pitchPrimaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-lum");
                this.c_pitchPrimaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-channel-lum-scale");
                this.c_pitchSecondaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-hue");
                this.c_pitchSecondaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-hue-scale");
                this.c_pitchSecondaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-sat");
                this.c_pitchSecondaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-sat-scale");
                this.c_pitchSecondaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-lum");
                this.c_pitchSecondaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-secondary-note-lum-scale");
                this.c_pitchPrimaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-hue");
                this.c_pitchPrimaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-hue-scale");
                this.c_pitchPrimaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-sat");
                this.c_pitchPrimaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-sat-scale");
                this.c_pitchPrimaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-lum");
                this.c_pitchPrimaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--pitch-primary-note-lum-scale");
                this.c_noiseSecondaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-hue");
                this.c_noiseSecondaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-hue-scale");
                this.c_noiseSecondaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-sat");
                this.c_noiseSecondaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-sat-scale");
                this.c_noiseSecondaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-lum");
                this.c_noiseSecondaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-channel-lum-scale");
                this.c_noisePrimaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-hue");
                this.c_noisePrimaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-hue-scale");
                this.c_noisePrimaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-sat");
                this.c_noisePrimaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-sat-scale");
                this.c_noisePrimaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-lum");
                this.c_noisePrimaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-channel-lum-scale");
                this.c_noiseSecondaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-hue");
                this.c_noiseSecondaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-hue-scale");
                this.c_noiseSecondaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-sat");
                this.c_noiseSecondaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-sat-scale");
                this.c_noiseSecondaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-lum");
                this.c_noiseSecondaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-secondary-note-lum-scale");
                this.c_noisePrimaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-hue");
                this.c_noisePrimaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-hue-scale");
                this.c_noisePrimaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-sat");
                this.c_noisePrimaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-sat-scale");
                this.c_noisePrimaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-lum");
                this.c_noisePrimaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--noise-primary-note-lum-scale");
                this.c_modSecondaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-hue");
                this.c_modSecondaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-hue-scale");
                this.c_modSecondaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-sat");
                this.c_modSecondaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-sat-scale");
                this.c_modSecondaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-lum");
                this.c_modSecondaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-channel-lum-scale");
                this.c_modPrimaryChannelHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-hue");
                this.c_modPrimaryChannelHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-hue-scale");
                this.c_modPrimaryChannelSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-sat");
                this.c_modPrimaryChannelSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-sat-scale");
                this.c_modPrimaryChannelLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-lum");
                this.c_modPrimaryChannelLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-channel-lum-scale");
                this.c_modSecondaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-hue");
                this.c_modSecondaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-hue-scale");
                this.c_modSecondaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-sat");
                this.c_modSecondaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-sat-scale");
                this.c_modSecondaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-lum");
                this.c_modSecondaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-secondary-note-lum-scale");
                this.c_modPrimaryNoteHue = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-hue");
                this.c_modPrimaryNoteHueScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-hue-scale");
                this.c_modPrimaryNoteSat = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-sat");
                this.c_modPrimaryNoteSatScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-sat-scale");
                this.c_modPrimaryNoteLum = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-lum");
                this.c_modPrimaryNoteLumScale = +getComputedStyle(this._styleElement).getPropertyValue("--mod-primary-note-lum-scale");
                if (getComputedStyle(this._styleElement).getPropertyValue("--formula-pitch-channel-count-override") != "")
                    this.c_pitchChannelCountOverride = +getComputedStyle(this._styleElement).getPropertyValue("--formula-pitch-channel-count-override");
                if (getComputedStyle(this._styleElement).getPropertyValue("--formula-noise-channel-count-override") != "")
                    this.c_noiseChannelCountOverride = +getComputedStyle(this._styleElement).getPropertyValue("--formula-noise-channel-count-override");
                if (getComputedStyle(this._styleElement).getPropertyValue("--formula-mod-channel-count-override") != "")
                    this.c_modChannelCountOverride = +getComputedStyle(this._styleElement).getPropertyValue("--formula-mod-channel-count-override");
            }
        }
        static getComputed(name) {
            return getComputedStyle(this._styleElement).getPropertyValue(name);
        }
    }
    
    
    
    
    ColorConfig.colorLookup = new Map();
    ColorConfig.themes = {
        "nerdbox": `
			:root {
					--pitch-channel-limit: 9;
					--noise-channel-limit: 3;
				--pitch1-secondary-channel: #139620;
				--pitch1-primary-channel:   #25ff3a;
				--pitch1-secondary-note:    #139620;
				--pitch1-primary-note:      #25ff3a;
				--pitch2-secondary-channel: #109986;
				--pitch2-primary-channel:   #1cffe0;
				--pitch2-secondary-note:    #109986;
				--pitch2-primary-note:      #1cffe0;
				--pitch3-secondary-channel: #127296;
				--pitch3-primary-channel:   #21c3ff;
				--pitch3-secondary-note:    #127296;
				--pitch3-primary-note:      #21c3ff;
				--pitch4-secondary-channel: #6038a5;
				--pitch4-primary-channel:   #9456ff;
				--pitch4-secondary-note:    #6038a5;
				--pitch4-primary-note:      #ff35e0;
				--pitch5-secondary-channel: #a52491;
				--pitch5-primary-channel:   #ff35e0;
				--pitch5-secondary-note:    #a52491;
				--pitch5-primary-note:      #af3221;
				--pitch6-secondary-channel: #af3221;
				--pitch6-primary-channel:   #ff4a32;
				--pitch6-secondary-note:    #af3221;
				--pitch6-primary-note:      #ff4a32;
				--pitch7-secondary-channel: #ad6e0f;
				--pitch7-primary-channel:   #ffa216;
				--pitch7-secondary-note:    #ad6e0f;
				--pitch7-primary-note:      #ffa216;
				--pitch8-secondary-channel: #ad6e0f;
				--pitch8-primary-channel:   #ffa216;
				--pitch8-secondary-note:    #ad6e0f;
				--pitch8-primary-note:      #ffa216;
				--pitch9-secondary-channel: #a7b512;
				--pitch9-primary-channel:   #ebff19;
				--pitch9-secondary-note:    #a7b512;
				--pitch9-primary-note:      #ebff19;
				--pitch10-secondary-channel:#70ad1b;
				--pitch10-primary-channel:  #a4ff26;
				--pitch10-secondary-note:   #70ad1b;
				--pitch10-primary-note:     #a4ff26;
				--noise1-secondary-channel: #68706f;
				--noise1-primary-channel:   #a6b2b1;
				--noise1-secondary-note:    #68706f;
				--noise1-primary-note:      #a6b2b1;
				--noise2-secondary-channel: #665c64;
				--noise2-primary-channel:   #a396a1;
				--noise2-secondary-note:    #665c64;
				--noise2-primary-note:      #a396a1;
				--noise3-secondary-channel: #60605a;
				--noise3-primary-channel:   #afaea3;
				--noise3-secondary-note:    #60605a;
				--noise3-primary-note:      #afaea3;
			--noise4-secondary-channel: #665c64;
			--noise4-primary-channel:   #a396a1;
				--noise4-secondary-note:    #665c64;
				--noise4-primary-note:      #a396a1;
				--noise5-secondary-channel: #60605a;
				--noise5-primary-channel:   #afaea3;
				--noise5-secondary-note:    #60605a;
				--noise5-primary-note:      #afaea3;
         --mod1-secondary-channel: #139620;
				--mod1-primary-channel:   #25ff3a;
				--mod1-secondary-note:    #139620;
				--mod1-primary-note:      #25ff3a;
				--mod2-secondary-channel: #109986;
				--mod2-primary-channel:   #1cffe0;
				--mod2-secondary-note:    #109986;
				--mod2-primary-note:      #1cffe0;
				--mod3-secondary-channel: #127296;
				--mod3-primary-channel:   #21c3ff;
				--mod3-secondary-note:    #127296;
				--mod3-primary-note:      #21c3ff;
				--mod4-secondary-channel: #6038a5;
				--mod4-primary-channel:   #9456ff;
				--mod4-secondary-note:    #6038a5;
				--mod4-primary-note:      #ff35e0;
				}
			`,
          "moonlight": `
			:root {
			--page-margin: #020514;
			--editor-background: #020514;
			--primary-text: #D4DCE9;
			--secondary-text: #3E87DA;
			--text-selection: #03599bd9;
			--box-selection-fill: hsl(206deg 66% 41% / 85%);
			--loop-accent: #639BD6;
			--link-accent: #A8C6E8;
			--ui-widget-background: #1e2940;
			--ui-widget-focus: #324b81;
			--pitch-background: #223849;
			--tonic: #33536c;
			--fifth-note: hsl(206deg 36% 16%);
			--white-piano-key: #c1bfe9;
			--black-piano-key: #454354;
			--track-editor-bg-pitch: #25568d80;
			--track-editor-bg-pitch-dim: #10253c80;
			--track-editor-bg-noise: #25568d80;
			--track-editor-bg-noise-dim: #10253c80;
			--track-editor-bg-mod: #25568d80;
			--track-editor-bg-mod-dim: #10253c80;
			--multiplicative-mod-slider: #0476cd;
			--overwriting-mod-slider: #035899;
			--indicator-primary: #57a1f4;
			--indicator-secondary: #2e5684;
			--select2-opt-group: #24355c;
			--input-box-outline: #141e34;
			--mute-button-normal: #6ebffc;
			--mute-button-mod: #0a92fa;
			--pitch1-secondary-channel: #47425c;
			--pitch1-primary-channel: #918bac;
			--pitch1-secondary-note: #6b6489;
			--pitch1-primary-note: #a8a3bf;
			--pitch2-secondary-channel: #626493;
			--pitch2-primary-channel: #bdbed3;
			--pitch2-secondary-note: #626493;
			--pitch2-primary-note: #bdbed3;
			--pitch3-secondary-channel: #6e89b4;
			--pitch3-primary-channel: #d4dce9;
			--pitch3-secondary-note: #6e89b4;
			--pitch3-primary-note: #d4dce9;
			--pitch4-secondary-channel: #4c77a9;
			--pitch4-primary-channel: #a8c6e8;
			--pitch4-secondary-note: #4c77a9;
			--pitch4-primary-note: #a8c6e8;
			--pitch5-secondary-channel: #314e6d;
			--pitch5-primary-channel: #639bd6;
			--pitch5-secondary-note: #46698f;
			--pitch5-primary-note: #639bd6;
			--pitch6-secondary-channel: #143d6b;
			--pitch6-primary-channel: #3e87da;
			--pitch6-secondary-note: #143d6b;
			--pitch6-primary-note: #3e87da;
			--pitch7-secondary-channel: #314e6d;
			--pitch7-primary-channel: #639bd6;
			--pitch7-secondary-note: #314e6d;
			--pitch7-primary-note: #639bd6;
			--pitch8-secondary-channel: #4c77a9;
			--pitch8-primary-channel: #a8c6e8;
			--pitch8-secondary-note: #4c77a9;
			--pitch8-primary-note: #a8c6e8;
			--pitch9-secondary-channel: #6e89b4;
			--pitch9-primary-channel: #d4dce9;
			--pitch9-secondary-note: #6e89b4;
			--pitch9-primary-note: #d4dce9;
			--pitch10-secondary-channel: #626493;
			--pitch10-primary-channel: #bdbed3;
			--pitch10-secondary-note: #626493;
			--pitch10-primary-note: #bdbed3;
			--noise1-secondary-channel: #4b4a55;
			--noise1-primary-channel: #9795a3;
			--noise1-secondary-note: #4b4a55;
			--noise1-primary-note: #9795a3;
			--noise2-secondary-channel: #858e9d;
			--noise2-primary-channel: #d7dce5;
			--noise2-secondary-note: #858e9d;
			--noise2-primary-note: #d7dce5;
			--noise3-secondary-channel: #394e65;
			--noise3-primary-channel: #809bb7;
			--noise3-secondary-note: #394e65;
			--noise3-primary-note: #809bb7;
			--noise4-secondary-channel: #37577b;
			--noise4-primary-channel: #6189b8;
			--noise4-secondary-note: #37577b;
			--noise4-primary-note: #6189b8;
			--noise5-secondary-channel: #223849;
			--noise5-primary-channel: #5588af;
			--noise5-secondary-note: #223849;
			--noise5-primary-note: #5588af;
			--mod1-secondary-channel: #3e336c;
			--mod1-primary-channel: #6d60a4;
			--mod1-secondary-note: #3e336c;
			--mod1-primary-note: #6d60a4;
			--mod2-secondary-channel: #716791;
			--mod2-primary-channel: #bdbed3;
			--mod2-secondary-note: #716791;
			--mod2-primary-note: #bdbed3;
			--mod3-secondary-channel: #6b91bd;
			--mod3-primary-channel: #4b8fdd;
			--mod3-secondary-note: #597ca7;
			--mod3-primary-note: #7eade3;
			--mod4-secondary-channel: #14559f;
			--mod4-primary-channel: #3386e6;
			--mod4-secondary-note: #14559f;
			--mod4-primary-note: #3386e6;
			--mod-label-primary: #1e2940;
			--mod-label-secondary-text: #748ebe;
			--mod-label-primary-text: white;
			--disabled-note-primary: #828282;
			--disabled-note-secondary: #4f4f4f;
			}`,
			
			
    "matrix": `
 .fbox {
 color: #38554E;
 }
 html{
 color: #111;
	background-color: #000;
	font-family: 'Fire Code', monospace;

}
 :root {
 --page-margin: #000000;
 --editor-background: #000000;
 --playhead: rgba(0, 255, 22, 0.44);
 --secondary-text: #7EFF80;
 --text-selection: rgba(0, 255, 75, 0.99);
 --box-selection-fill: #3CB003;
 --loop-accent: #008A3B;
 --link-accent: #006918;
 --ui-widget-background: #1A291F;
 --ui-widget-focus: #191F1E;
 --pitch-background: #000000;
 --tonic: #0C4F0C;
 --fifth-note: #0B1F0F;
 --white-piano-key: #edc;
 --black-piano-key: #456;
 --use-color-formula: true;
 --track-editor-bg-pitch: #333333;
 --track-editor-bg-pitch-dim: #000000;
 --track-editor-bg-noise: #463400;
 --track-editor-bg-noise-dim: #000000;
 --track-editor-bg-mod: #004634;
 --track-editor-bg-mod-dim: #000000;
 --multiplicative-mod-slider: #FFC800;
 --overwriting-mod-slider: #17FF00;
 --indicator-primary: #1EFF00;
 --indicator-secondary: #000000;
 --select2-opt-group: #2B2B2B;
 --input-box-outline: #00FF2F;
 --mute-button-normal: #00FF06;
 --mute-button-mod: #00FF0D;
 --mod-label-primary: #38554E;
 --mod-label-secondary-text: rgb(0, 43, 45);
 --mod-label-primary-text: white;
 --pitch-secondary-channel-hue: 100;
 --pitch-secondary-channel-hue-scale: 0;
 --pitch-secondary-channel-sat: 83.3;
 --pitch-secondary-channel-sat-scale: 0.1;
 --pitch-secondary-channel-lum: 40;
 --pitch-secondary-channel-lum-scale: 0.05;
 --pitch-primary-channel-hue: 100;
 --pitch-primary-channel-hue-scale: 0;
 --pitch-primary-channel-sat: 100;
 --pitch-primary-channel-sat-scale: 0.1;
 --pitch-primary-channel-lum: 67.5;
 --pitch-primary-channel-lum-scale: 0.05;
 --pitch-secondary-note-hue: 100;
 --pitch-secondary-note-hue-scale: 0;
 --pitch-secondary-note-sat: 93.9;
 --pitch-secondary-note-sat-scale: 0.1;
 --pitch-secondary-note-lum: 25;
 --pitch-secondary-note-lum-scale: 0.05;
 --pitch-primary-note-hue: 100;
 --pitch-primary-note-hue-scale: 0;
 --pitch-primary-note-sat: 100;
 --pitch-primary-note-sat-scale: 0.05;
 --pitch-primary-note-lum: 85.6;
 --pitch-primary-note-lum-scale: 0.025;
 
 
 --noise-secondary-channel-hue: 100;
 --noise-secondary-channel-hue-scale: 0;
 --noise-secondary-channel-sat: 25;
 --noise-secondary-channel-sat-scale: 0;
 --noise-secondary-channel-lum: 42;
 --noise-secondary-channel-lum-scale: 0;
 --noise-primary-channel-hue: 100;
 --noise-primary-channel-hue-scale: 0;
 --noise-primary-channel-sat: 33;
 --noise-primary-channel-sat-scale: 0;
 --noise-primary-channel-lum: 63.5;
 --noise-primary-channel-lum-scale: 0;
 --noise-secondary-note-hue: 100;
 --noise-secondary-note-hue-scale: 0;
 --noise-secondary-note-sat: 33.5;
 --noise-secondary-note-sat-scale: 0;
 --noise-secondary-note-lum: 55;
 --noise-secondary-note-lum-scale: 0;
 --noise-primary-note-hue: 100;
 --noise-primary-note-hue-scale: 0;
 --noise-primary-note-sat: 46.5;
 --noise-primary-note-sat-scale: 0;
 --noise-primary-note-lum: 74;
 --noise-primary-note-lum-scale: 0;
 --mod-secondary-channel-hue: 350;
 --mod-secondary-channel-hue-scale: 0;
 --mod-secondary-channel-sat: 88;
 --mod-secondary-channel-sat-scale: 0;
 --mod-secondary-channel-lum: 50;
 --mod-secondary-channel-lum-scale: 0;
 --mod-primary-channel-hue: 350;
 --mod-primary-channel-hue-scale: 0;
 --mod-primary-channel-sat: 96;
 --mod-primary-channel-sat-scale: 0;
 --mod-primary-channel-lum: 80;
 --mod-primary-channel-lum-scale: 0;
 --mod-secondary-note-hue: 350;
 --mod-secondary-note-hue-scale: 0;
 --mod-secondary-note-sat: 92;
 --mod-secondary-note-sat-scale: 0;
 --mod-secondary-note-lum: 45;
 --mod-secondary-note-lum-scale: 0;
 --mod-primary-note-hue: 350;
 --mod-primary-note-hue-scale: 0;
 --mod-primary-note-sat: 96;
 --mod-primary-note-sat-scale: 0;
 --mod-primary-note-lum: 85;
 --mod-primary-note-lum-scale: 0;
 }
			`,
			
"typebox": `
.fbox {
	color: #3178c6;
}
html{
 color: #3178c6;
	background-color: #1e1e1e;
	font-family: 'Fira Code', monospace;

}
:root {
	--page-margin: #1e1e1e;
	--editor-background: #1b1b1b;
	--playhead: rgba(255, 255, 255, 0.9);
	--secondary-text: #9cdcfe;
	--text-selection: rgba(0, 122, 204, 0.3);
	--box-selection-fill: #007acc;
	--loop-accent: #dcdcaa;
	--link-accent: #ce9178;
	--ui-widget-background: #252526;
	--ui-widget-focus: #007acc;
	--pitch-background: #202020;
	--tonic: #569cd6;
	--fifth-note: #dcdcaa;
	--white-piano-key: #f3f3f3;
	--black-piano-key: #3c3c3c;
	--use-color-formula: true;
	--track-editor-bg-pitch: #2d2d30;
	--track-editor-bg-pitch-dim: #1e1e1e;
	--track-editor-bg-noise: #373737;
	--track-editor-bg-noise-dim: #1a1a1a;
	--track-editor-bg-mod: #004f88;
	--track-editor-bg-mod-dim: #002b4d;
	--multiplicative-mod-slider: #ce9178;
	--overwriting-mod-slider: #c586c0;
	--indicator-primary: #d7ba7d;
	--indicator-secondary: #808080;
	--select2-opt-group: #2b2b2b;
	--input-box-outline: #3794ff;
	--mute-button-normal: #c586c0;
	--mute-button-mod: #569cd6;
	--mod-label-primary: #1e1e1e;
	--mod-label-secondary-text: #d4d4d4;
	--mod-label-primary-text: #ffffff;

	--pitch-primary-channel-hue: 212;
	--pitch-primary-channel-hue-scale: 0;
	--pitch-primary-channel-sat: 100;
	--pitch-primary-channel-sat-scale: 0.1;
	--pitch-primary-channel-lum: 67.5;
	--pitch-primary-channel-lum-scale: 0.05;

	--pitch-secondary-channel-hue: 212;
	--pitch-secondary-channel-hue-scale: 0;
	--pitch-secondary-channel-sat: 90.3;
	--pitch-secondary-channel-sat-scale: 0.1;
	--pitch-secondary-channel-lum: 70;
	--pitch-secondary-channel-lum-scale: 0.05;

	--pitch-primary-note-hue: 212;
	--pitch-primary-note-hue-scale:0;
	--pitch-primary-note-sat: 100;
	--pitch-primary-note-sat-scale: 0.05;
	--pitch-primary-note-lum: 85.6;
	--pitch-primary-note-lum-scale: 0.025;

	--pitch-secondary-note-hue: 212;
	--pitch-secondary-note-hue-scale: 0;
	--pitch-secondary-note-sat: 93.9;
	--pitch-secondary-note-sat-scale: 0.1;
	--pitch-secondary-note-lum: 70;
	--pitch-secondary-note-lum-scale: 0.05;

	--noise-primary-channel-hue: 45;
	--noise-primary-channel-hue-scale: 2;
	--noise-primary-channel-sat: 33;
	--noise-primary-channel-sat-scale: 0;
	--noise-primary-channel-lum: 70;
	--noise-primary-channel-lum-scale: 0;

	--noise-secondary-channel-hue: 45;
	--noise-secondary-channel-hue-scale: 2;
	--noise-secondary-channel-sat: 25;
	--noise-secondary-channel-sat-scale: 0;
	--noise-secondary-channel-lum: 70;
	--noise-secondary-channel-lum-scale: 0;

	--noise-primary-note-hue: 45;
	--noise-primary-note-hue-scale: 2;
	--noise-primary-note-sat: 46.5;
	--noise-primary-note-sat-scale: 0;
	--noise-primary-note-lum: 70;
	--noise-primary-note-lum-scale: 0;

	--noise-secondary-note-hue: 45;
	--noise-secondary-note-hue-scale: 2;
	--noise-secondary-note-sat: 33.5;
	--noise-secondary-note-sat-scale: 0;
	--noise-secondary-note-lum: 70;
	--noise-secondary-note-lum-scale: 0;

	--mod-primary-channel-hue: 280;
	--mod-primary-channel-hue-scale: 1.5;
	--mod-primary-channel-sat: 96;
	--mod-primary-channel-sat-scale: 0;
	--mod-primary-channel-lum: 70;
	--mod-primary-channel-lum-scale: 0;

	--mod-secondary-channel-hue: 280;
	--mod-secondary-channel-hue-scale: 1.5;
	--mod-secondary-channel-sat: 88;
	--mod-secondary-channel-sat-scale: 0;
	--mod-secondary-channel-lum: 70;
	--mod-secondary-channel-lum-scale: 0;

	--mod-primary-note-hue: 280;
	--mod-primary-note-hue-scale: 1.5;
	--mod-primary-note-sat: 96;
	--mod-primary-note-sat-scale: 0;
	--mod-primary-note-lum: 70;
	--mod-primary-note-lum-scale: 0;

	--mod-secondary-note-hue: 280;
	--mod-secondary-note-hue-scale: 1.5;
	--mod-secondary-note-sat: 92;
	--mod-secondary-note-sat-scale: 0;
	--mod-secondary-note-lum: 70;
	--mod-secondary-note-lum-scale: 0;
}
`,

			
			
    "microbox": `
 .fbox {
	color: #38554E;
}
				:root {
					--page-margin: #000000;
					--editor-background: #000000;
					--playhead: rgba(255, 255, 255, 0.9);
					--secondary-text: #93B6AD;
					--text-selection: rgba(47,255,250,0.99);
					--box-selection-fill: #03B068;
					--loop-accent: #FF0061;
					--link-accent: #FFC800;
					--ui-widget-background: #38554E;
					--ui-widget-focus: #2A7E69;
					--pitch-background: #281F23;
					--tonic: #004634;
					--fifth-note: #463400;
					--white-piano-key: #edc;
					--black-piano-key: #456;
					--use-color-formula: true;
					--track-editor-bg-pitch: #333333;
					--track-editor-bg-pitch-dim: #000000;
					--track-editor-bg-noise: #463400;
					--track-editor-bg-noise-dim: #000000;
					--track-editor-bg-mod: #004634;
					--track-editor-bg-mod-dim: #000000;
					--multiplicative-mod-slider: #FFC800;
					--overwriting-mod-slider: #00ffc0;
					--indicator-primary: #00ffc0;
					--indicator-secondary: #333333;
					--select2-opt-group: #2B2B2B;
					--input-box-outline: #69BFC6;
					--mute-button-normal: #00ffc0;
					--mute-button-mod: #FFC800;
					--mod-label-primary: #38554E;
					--mod-label-secondary-text: rgb(0, 43, 45);
					--mod-label-primary-text: white;
					--pitch-secondary-channel-hue: 0;
					--pitch-secondary-channel-hue-scale: 6.1;
					--pitch-secondary-channel-sat: 83.3;
					--pitch-secondary-channel-sat-scale: 0.1;
					--pitch-secondary-channel-lum: 40;
					--pitch-secondary-channel-lum-scale: 0.05;
					--pitch-primary-channel-hue: 0;
					--pitch-primary-channel-hue-scale: 6.1;
					--pitch-primary-channel-sat: 100;
					--pitch-primary-channel-sat-scale: 0.1;
					--pitch-primary-channel-lum: 67.5;
					--pitch-primary-channel-lum-scale: 0.05;
					--pitch-secondary-note-hue: 0;
					--pitch-secondary-note-hue-scale: 6.1;
					--pitch-secondary-note-sat: 93.9;
					--pitch-secondary-note-sat-scale: 0.1;
					--pitch-secondary-note-lum: 25;
					--pitch-secondary-note-lum-scale: 0.05;
					--pitch-primary-note-hue: 0;
					--pitch-primary-note-hue-scale: 6.1;
					--pitch-primary-note-sat: 100;
					--pitch-primary-note-sat-scale: 0.05;
					--pitch-primary-note-lum: 85.6;
					--pitch-primary-note-lum-scale: 0.025;
					--noise-secondary-channel-hue: 0;
					--noise-secondary-channel-hue-scale: 2;
					--noise-secondary-channel-sat: 25;
					--noise-secondary-channel-sat-scale: 0;
					--noise-secondary-channel-lum: 42;
					--noise-secondary-channel-lum-scale: 0;
					--noise-primary-channel-hue: 0;
					--noise-primary-channel-hue-scale: 2;
					--noise-primary-channel-sat: 33;
					--noise-primary-channel-sat-scale: 0;
					--noise-primary-channel-lum: 63.5;
					--noise-primary-channel-lum-scale: 0;
					--noise-secondary-note-hue: 0;
					--noise-secondary-note-hue-scale: 2;
					--noise-secondary-note-sat: 33.5;
					--noise-secondary-note-sat-scale: 0;
					--noise-secondary-note-lum: 55;
					--noise-secondary-note-lum-scale: 0;
					--noise-primary-note-hue: 0;
					--noise-primary-note-hue-scale: 2;
					--noise-primary-note-sat: 46.5;
					--noise-primary-note-sat-scale: 0;
					--noise-primary-note-lum: 74;
					--noise-primary-note-lum-scale: 0;
					--mod-secondary-channel-hue: 192;
					--mod-secondary-channel-hue-scale: 1.5;
					--mod-secondary-channel-sat: 88;
					--mod-secondary-channel-sat-scale: 0;
					--mod-secondary-channel-lum: 50;
					--mod-secondary-channel-lum-scale: 0;
					--mod-primary-channel-hue: 192;
					--mod-primary-channel-hue-scale: 1.5;
					--mod-primary-channel-sat: 96;
					--mod-primary-channel-sat-scale: 0;
					--mod-primary-channel-lum: 80;
					--mod-primary-channel-lum-scale: 0;
					--mod-secondary-note-hue: 192;
					--mod-secondary-note-hue-scale: 1.5;
					--mod-secondary-note-sat: 92;
					--mod-secondary-note-sat-scale: 0;
					--mod-secondary-note-lum: 45;
					--mod-secondary-note-lum-scale: 0;
					--mod-primary-note-hue: 192;
					--mod-primary-note-hue-scale: 1.5;
					--mod-primary-note-sat: 96;
					--mod-primary-note-sat-scale: 0;
					--mod-primary-note-lum: 85;
					--mod-primary-note-lum-scale: 0;
				}
			`,
"copperblue": `
.fbox {
	color: #A3C8BD;
}
	:root {
		--page-margin: #0a1a17;
		--editor-background: #081412;
		--playhead: rgba(255, 255, 255, 0.9);
		--secondary-text: #A3C8BD;
		--text-selection: rgba(60,255,200,0.4);
		--box-selection-fill: #2C8C78;
		--loop-accent: #00ffc0;
		--link-accent: #FFC800;
		--ui-widget-background: #38554E;
		--ui-widget-focus: #2A7E69;
		--pitch-background: #1D2E2A;
		--tonic: #2A7E69;
		--fifth-note: #406B5D;
		--white-piano-key: #e4f1ee;
		--black-piano-key: #3a5b53;
		--use-color-formula: true;
		--track-editor-bg-pitch: #2A3E3A;
		--track-editor-bg-pitch-dim: #13211f;
		--track-editor-bg-noise: #375E52;
		--track-editor-bg-noise-dim: #0e1a18;
		--track-editor-bg-mod: #1F4A40;
		--track-editor-bg-mod-dim: #0c1b17;
		--multiplicative-mod-slider: #ffcc66;
		--overwriting-mod-slider: #5ce0c0;
		--indicator-primary: #00ffd0;
		--indicator-secondary: #2C8C78;
		--select2-opt-group: #2f4a45;
		--input-box-outline: #6ADACB;
		--mute-button-normal: #00ffc0;
		--mute-button-mod: #ffcc66;
		--mod-label-primary: #38554E;
		--mod-label-secondary-text: #082825;
		--mod-label-primary-text: #ffffff;
		--pitch-secondary-channel-hue: 160;
		--pitch-secondary-channel-hue-scale: 5.8;
		--pitch-secondary-channel-sat: 75;
		--pitch-secondary-channel-sat-scale: 0.08;
		--pitch-secondary-channel-lum: 42;
		--pitch-secondary-channel-lum-scale: 0.04;
		--pitch-primary-channel-hue: 160;
		--pitch-primary-channel-hue-scale: 5.8;
		--pitch-primary-channel-sat: 95;
		--pitch-primary-channel-sat-scale: 0.1;
		--pitch-primary-channel-lum: 67;
		--pitch-primary-channel-lum-scale: 0.05;
		--pitch-secondary-note-hue: 160;
		--pitch-secondary-note-hue-scale: 5.8;
		--pitch-secondary-note-sat: 88;
		--pitch-secondary-note-sat-scale: 0.1;
		--pitch-secondary-note-lum: 28;
		--pitch-secondary-note-lum-scale: 0.05;
		--pitch-primary-note-hue: 160;
		--pitch-primary-note-hue-scale: 5.8;
		--pitch-primary-note-sat: 98;
		--pitch-primary-note-sat-scale: 0.05;
		--pitch-primary-note-lum: 82;
		--pitch-primary-note-lum-scale: 0.025;
		--noise-secondary-channel-hue: 170;
		--noise-secondary-channel-hue-scale: 1.5;
		--noise-secondary-channel-sat: 40;
		--noise-secondary-channel-sat-scale: 0;
		--noise-secondary-channel-lum: 42;
		--noise-secondary-channel-lum-scale: 0;
		--noise-primary-channel-hue: 170;
		--noise-primary-channel-hue-scale: 1.5;
		--noise-primary-channel-sat: 52;
		--noise-primary-channel-sat-scale: 0;
		--noise-primary-channel-lum: 68;
		--noise-primary-channel-lum-scale: 0;
		--mod-secondary-channel-hue: 180;
		--mod-secondary-channel-hue-scale: 1.5;
		--mod-secondary-channel-sat: 88;
		--mod-secondary-channel-sat-scale: 0;
		--mod-secondary-channel-lum: 50;
		--mod-secondary-channel-lum-scale: 0;
		--mod-primary-channel-hue: 180;
		--mod-primary-channel-hue-scale: 1.5;
		--mod-primary-channel-sat: 96;
		--mod-primary-channel-sat-scale: 0;
		--mod-primary-channel-lum: 80;
		--mod-primary-channel-lum-scale: 0;
		--mod-secondary-note-hue: 180;
		--mod-secondary-note-hue-scale: 1.5;
		--mod-secondary-note-sat: 92;
		--mod-secondary-note-sat-scale: 0;
		--mod-secondary-note-lum: 45;
		--mod-secondary-note-lum-scale: 0;
		--mod-primary-note-hue: 180;
		--mod-primary-note-hue-scale: 1.5;
		--mod-primary-note-sat: 96;
		--mod-primary-note-sat-scale: 0;
		--mod-primary-note-lum: 85;
		--mod-primary-note-lum-scale: 0;
	}
`,

"copper": `
	:root {
		--page-margin: #1a0f08;
		--editor-background: #120a05;
		--playhead: rgba(255, 224, 192, 0.9);
		--secondary-text: #cfa67a;
		--text-selection: rgba(255, 128, 64, 0.5);
		--box-selection-fill: #804d1f;
		--loop-accent: #ff914d;
		--link-accent: #ffc66e;
		--ui-widget-background: #3a2414;
		--ui-widget-focus: #c4732b;
		--pitch-background: #1e120a;
		--tonic: #5e2f10;
		--fifth-note: #473019;
		--white-piano-key: #fbe5cc;
		--black-piano-key: #7a4a22;
		--use-color-formula: true;
		--track-editor-bg-pitch: #332319;
		--track-editor-bg-pitch-dim: #1c120c;
		--track-editor-bg-noise: #5b3213;
		--track-editor-bg-noise-dim: #26160a;
		--track-editor-bg-mod: #3b1f0d;
		--track-editor-bg-mod-dim: #140a04;
		--multiplicative-mod-slider: #ffc66e;
		--overwriting-mod-slider: #ff914d;
		--indicator-primary: #ffc66e;
		--indicator-secondary: #3a2414;
		--select2-opt-group: #2d1b12;
		--input-box-outline: #c68449;
		--mute-button-normal: #ffc66e;
		--mute-button-mod: #ff914d;
		--mod-label-primary: #5e3b20;
		--mod-label-secondary-text: #1e1008;
		--mod-label-primary-text: #fff5e6;
		--pitch-secondary-channel-hue: 25;
		--pitch-secondary-channel-hue-scale: 4;
		--pitch-secondary-channel-sat: 80;
		--pitch-secondary-channel-sat-scale: 0.1;
		--pitch-secondary-channel-lum: 30;
		--pitch-secondary-channel-lum-scale: 0.05;
		--pitch-primary-channel-hue: 25;
		--pitch-primary-channel-hue-scale: 4;
		--pitch-primary-channel-sat: 100;
		--pitch-primary-channel-sat-scale: 0.1;
		--pitch-primary-channel-lum: 60;
		--pitch-primary-channel-lum-scale: 0.05;
		--pitch-secondary-note-hue: 25;
		--pitch-secondary-note-hue-scale: 4;
		--pitch-secondary-note-sat: 95;
		--pitch-secondary-note-sat-scale: 0.1;
		--pitch-secondary-note-lum: 25;
		--pitch-secondary-note-lum-scale: 0.05;
		--pitch-primary-note-hue: 25;
		--pitch-primary-note-hue-scale: 4;
		--pitch-primary-note-sat: 100;
		--pitch-primary-note-sat-scale: 0.05;
		--pitch-primary-note-lum: 80;
		--pitch-primary-note-lum-scale: 0.025;
		--noise-secondary-channel-hue: 30;
		--noise-secondary-channel-hue-scale: 1.5;
		--noise-secondary-channel-sat: 45;
		--noise-secondary-channel-sat-scale: 0;
		--noise-secondary-channel-lum: 40;
		--noise-secondary-channel-lum-scale: 0;
		--noise-primary-channel-hue: 30;
		--noise-primary-channel-hue-scale: 1.5;
		--noise-primary-channel-sat: 60;
		--noise-primary-channel-sat-scale: 0;
		--noise-primary-channel-lum: 65;
		--noise-primary-channel-lum-scale: 0;
		--noise-secondary-note-hue: 30;
		--noise-secondary-note-hue-scale: 1.5;
		--noise-secondary-note-sat: 60;
		--noise-secondary-note-sat-scale: 0;
		--noise-secondary-note-lum: 55;
		--noise-secondary-note-lum-scale: 0;
		--noise-primary-note-hue: 30;
		--noise-primary-note-hue-scale: 1.5;
		--noise-primary-note-sat: 70;
		--noise-primary-note-sat-scale: 0;
		--noise-primary-note-lum: 75;
		--noise-primary-note-lum-scale: 0;
		--mod-secondary-channel-hue: 30;
		--mod-secondary-channel-hue-scale: 1;
		--mod-secondary-channel-sat: 85;
		--mod-secondary-channel-sat-scale: 0;
		--mod-secondary-channel-lum: 45;
		--mod-secondary-channel-lum-scale: 0;
		--mod-primary-channel-hue: 30;
		--mod-primary-channel-hue-scale: 1;
		--mod-primary-channel-sat: 95;
		--mod-primary-channel-sat-scale: 0;
		--mod-primary-channel-lum: 75;
		--mod-primary-channel-lum-scale: 0;
		--mod-secondary-note-hue: 30;
		--mod-secondary-note-hue-scale: 1;
		--mod-secondary-note-sat: 85;
		--mod-secondary-note-sat-scale: 0;
		--mod-secondary-note-lum: 45;
		--mod-secondary-note-lum-scale: 0;
		--mod-primary-note-hue: 30;
		--mod-primary-note-hue-scale: 1;
		--mod-primary-note-sat: 95;
		--mod-primary-note-sat-scale: 0;
		--mod-primary-note-lum: 80;
		--mod-primary-note-lum-scale: 0;
	}
`,

			
        "energized": `
		:root {
			--page-margin: #000a08;
			--editor-background: #000a08;
			--hover-preview: #ffffcc;
			--playhead: #ccfff5;
			--secondary-text: #d9d98c;
			--text-selection: #ffff6659;
			--box-selection-fill: #ffffff33;
			--loop-accent: #ffff00;
			--link-accent: #00ffcc;
			--ui-widget-background: #141f1d;
			--ui-widget-focus: #24423d;
			--pitch-background: #001410;
			--tonic: #00241d;
			--fifth-note: #ffff6633;
			--white-piano-key: #66998f;
			--black-piano-key: #141f1d;
			--track-editor-bg-pitch: #66998f40;
			--track-editor-bg-pitch-dim: #293d3940;
			--track-editor-bg-noise: #66998f40;
			--track-editor-bg-noise-dim: #293d3940;
			--track-editor-bg-mod: #99996640;
			--track-editor-bg-mod-dim: #3d3d2940;
			--multiplicative-mod-slider: #ffff00;
			--overwriting-mod-slider: #00ffcc;
			--indicator-primary: #ffff00;
			--indicator-secondary: #141f1d;
			--select2-opt-group: #1b312e;
			--input-box-outline: #141f1d;
			--mute-button-normal: #00ffcc;
			--mute-button-mod: #00997a;
			--pitch1-secondary-channel: #bfbf40;
			--pitch1-primary-channel: #ffff64;
			--pitch1-secondary-note: #bfbf40;
			--pitch1-primary-note: #ffff64;
			--pitch2-secondary-channel: #a2bf40;
			--pitch2-primary-channel: #e0ff7d;
			--pitch2-secondary-note: #a2bf40;
			--pitch2-primary-note: #e0ff7d;
			--pitch3-secondary-channel: #75bf40;
			--pitch3-primary-channel: #c1ff96;
			--pitch3-secondary-note: #75bf40;
			--pitch3-primary-note: #c1ff96;
			--pitch4-secondary-channel: #40bf51;
			--pitch4-primary-channel: #a2ffaf;
			--pitch4-secondary-note: #40bf51;
			--pitch4-primary-note: #a2ffaf;
			--pitch5-secondary-channel: #40bf86;
			--pitch5-primary-channel: #83ffc8;
			--pitch5-secondary-note: #40bf86;
			--pitch5-primary-note: #83ffc8;
			--pitch6-secondary-channel: #40bfa6;
			--pitch6-primary-channel: #64ffe1;
			--pitch6-secondary-note: #40bfa6;
			--pitch6-primary-note: #64ffe1;
			--pitch7-secondary-channel: #40bf86;
			--pitch7-primary-channel: #83ffc8;
			--pitch7-secondary-note: #40bf86;
			--pitch7-primary-note: #83ffc8;
			--pitch8-secondary-channel: #40bf51;
			--pitch8-primary-channel: #a2ffaf;
			--pitch8-secondary-note: #40bf51;
			--pitch8-primary-note: #a2ffaf;
			--pitch9-secondary-channel: #75bf40;
			--pitch9-primary-channel: #c1ff96;
			--pitch9-secondary-note: #75bf40;
			--pitch9-primary-note: #c1ff96;
			--pitch10-secondary-channel: #a2bf40;
			--pitch10-primary-channel: #e0ff7d;
			--pitch10-secondary-note: #a2bf40;
			--pitch10-primary-note: #e0ff7d;
			--noise1-secondary-channel: #a6a659;
			--noise1-primary-channel: #ffffcc;
			--noise1-secondary-note: #a6a659;
			--noise1-primary-note: #ffffcc;
			--noise2-secondary-channel: #94a659;
			--noise2-primary-channel: #f3ffcc;
			--noise2-secondary-note: #94a659;
			--noise2-primary-note: #f3ffcc;
			--noise3-secondary-channel: #79a659;
			--noise3-primary-channel: #e1ffcc;
			--noise3-secondary-note: #79a659;
			--noise3-primary-note: #e1ffcc;
			--noise4-secondary-channel: #94a659;
			--noise4-primary-channel: #f3ffcc;
			--noise4-secondary-note: #94a659;
			--noise4-primary-note: #f3ffcc;
			--noise5-secondary-channel: #a6a659;
			--noise5-primary-channel: #ffffcc;
			--noise5-secondary-note: #a6a659;
			--noise5-primary-note: #ffffcc;
			--mod1-secondary-channel: #a3a329;
			--mod1-primary-channel: #ffff00;
			--mod1-secondary-note: #a3a329;
			--mod1-primary-note: #ffff00;
			--mod2-secondary-channel: #a38529;
			--mod2-primary-channel: #ffbf00;
			--mod2-secondary-note: #a38529;
			--mod2-primary-note: #ffbf00;
			--mod3-secondary-channel: #a36629;
			--mod3-primary-channel: #ff7f00;
			--mod3-secondary-note: #a36629;
			--mod3-primary-note: #ff7f00;
			--mod4-secondary-channel: #a38529;
			--mod4-primary-channel: #ffbf00;
			--mod4-secondary-note: #a38529;
			--mod4-primary-note: #ffbf00;
			--mod-label-primary: #141f1d;
			--mod-label-secondary-text: #d9d98c;
			--mod-label-primary-text: white;
			--disabled-note-primary: #808080;
			--disabled-note-secondary: #666666;
		}`,
        "neapolitan": `:root {
			--page-margin: #120807;
			--editor-background: #120807;
			--hover-preview: #e79a82;
			--playhead: #e79a82;
			--primary-text: #decdbf;
			--secondary-text: #fa99bb;
			--text-selection: #990036;
			--loop-accent: #f6377a;
			--link-accent: #f6377a;
			--ui-widget-background: #24160f;
			--ui-widget-focus: #362217;
			--pitch-background: #1e1106;
			--tonic: #382414;
			--fifth-note: #41240c;
			--white-piano-key: #e1c5b7;
			--black-piano-key: #482c1e;
			--white-piano-key-text: black;
			--black-piano-key-text: white;
			--track-editor-bg-pitch: #4d2a19;
			--track-editor-bg-pitch-dim: #27150c;
			--track-editor-bg-noise: #4d2a19;
			--track-editor-bg-noise-dim: #27150c;
			--track-editor-bg-mod: #4d2a19;
			--track-editor-bg-mod-dim: #27150c;
			--multiplicative-mod-slider: #decdbf;
			--overwriting-mod-slider: #decdbf;
			--indicator-primary: #decdbf;
			--indicator-secondary: #362217;
			--select2-opt-group: #24160f;
			--input-box-outline: #24160f;
			--mute-button-normal: #ff66a1;
			--mute-button-mod: #e61968;
			--pitch1-secondary-channel: #680029;
			--pitch1-primary-channel: #cc0052;
			--pitch1-secondary-note: #660029;
			--pitch1-primary-note: #cc0052;
			--pitch2-secondary-channel: #7e1b43;
			--pitch2-primary-channel: #d32e71;
			--pitch2-secondary-note: #7e1b43;
			--pitch2-primary-note: #d32e71;
			--pitch3-secondary-channel: #aa275e;
			--pitch3-primary-channel: #da5d91;
			--pitch3-secondary-note: #aa275e;
			--pitch3-primary-note: #da5d91;
			--pitch4-secondary-channel: #cc3878;
			--pitch4-primary-channel: #e18bb0;
			--pitch4-secondary-note: #cc3878;
			--pitch4-primary-note: #e18bb0;
			--pitch5-secondary-channel: #d06c9b;
			--pitch5-primary-channel: #e9bad0;
			--pitch5-secondary-note: #d06c9b;
			--pitch5-primary-note: #e9bad0;
			--pitch6-secondary-channel: #c9acc5;
			--pitch6-primary-channel: #f0e8ef;
			--pitch6-secondary-note: #c9acc5;
			--pitch6-primary-note: #f0e8ef;
			--pitch7-secondary-channel: #d06c9b;
			--pitch7-primary-channel: #e9bad0;
			--pitch7-secondary-note: #d06c9b;
			--pitch7-primary-note: #e9bad0;
			--pitch8-secondary-channel: #cc3878;
			--pitch8-primary-channel: #e18bb0;
			--pitch8-secondary-note: #cc3878;
			--pitch8-primary-note: #e18bb0;
			--pitch9-secondary-channel: #aa275e;
			--pitch9-primary-channel: #da5d91;
			--pitch9-secondary-note: #aa275e;
			--pitch9-primary-note: #da5d91;
			--pitch10-secondary-channel: #7e1b43;
			--pitch10-primary-channel: #d32e71;
			--pitch10-secondary-note: #7e1b43;
			--pitch10-primary-note: #d32e71;
			--noise1-secondary-channel: #683a37;
			--noise1-primary-channel: #A85F5A;
			--noise1-secondary-note: #683a37;
			--noise1-primary-note: #A85F5A;
			--noise2-secondary-channel: #7c4a41;
			--noise2-primary-channel: #B47A70;
			--noise2-secondary-note: #7c4a41;
			--noise2-primary-note: #B47A70;
			--noise3-secondary-channel: #935f4d;
			--noise3-primary-channel: #c09587;
			--noise3-secondary-note: #935f4d;
			--noise3-primary-note: #C09587;
			--noise4-secondary-channel: #aa795a;
			--noise4-primary-channel: #cdb09d;
			--noise4-secondary-note: #aa795a;
			--noise4-primary-note: #CDAF9D;
			--noise5-secondary-channel: #bb987c;
			--noise5-primary-channel: #decdbf;
			--noise5-secondary-note: #bb987c;
			--noise5-primary-note: #decdbf;
			--mod1-secondary-channel: #6ca784;
			--mod1-primary-channel: #accdb9;
			--mod1-secondary-note: #6ca784;
			--mod1-primary-note: #accdb9;
			--mod2-secondary-channel: #7daa9f;
			--mod2-primary-channel: #bbd3cd;
			--mod2-secondary-note: #7daa9f;
			--mod2-primary-note: #bbd3cd;
			--mod3-secondary-channel: #70a3a9;
			--mod3-primary-channel: #afcccf;
			--mod3-secondary-note: #70a3a9;
			--mod3-primary-note: #afcccf;
			--mod4-secondary-channel: #5698b8;
			--mod4-primary-channel: #9ec3d6;
			--mod4-secondary-note: #5698b8;
			--mod4-primary-note: #9ec3d6;
			--mod-label-primary: #24160f;
			--mod-label-secondary-text: #E5AFC2;
			--mod-label-primary-text: #decdbf;
			--disabled-note-primary: #bababa;
			--disabled-note-secondary: #878787;
		}`,
        "poly": `:root {
			--page-margin: #000;
			--editor-background: #000;
			--hover-preview: #808080;
			--playhead: #808080;
			--secondary-text: #cccccc;
			--text-selection: #696969;
			--box-selection-fill: #cccccc40;
			--loop-accent: #808080;
			--link-accent: white;
			--ui-widget-background: #232323;
			--ui-widget-focus: #303030;
			--pitch-background: #1a1a1a;
			--tonic: #262626;
			--fifth-note: #0d0d0d;
			--white-piano-key: #808080;
			--black-piano-key: #232323;
			--use-color-formula: true;
			--track-editor-bg-pitch: #262626;
			--track-editor-bg-pitch-dim: #1a1a1a;
			--track-editor-bg-noise: #262626;
			--track-editor-bg-noise-dim: #1a1a1a;
			--track-editor-bg-mod: #262626;
			--track-editor-bg-mod-dim: #1a1a1a;
			--multiplicative-mod-slider: #808080;
			--overwriting-mod-slider: #808080;
			--indicator-primary: #808080;
			--indicator-secondary: #333333;
			--select2-opt-group: #232323;
			--input-box-outline: #222;
			--mute-button-normal: #808080;
			--mute-button-mod: #808080;
			--mod-label-primary: #232323;
			--mod-label-secondary-text: #696969;
			--mod-label-primary-text: #cdcdcd;
			--pitch-secondary-channel-hue: 208;
			--pitch-secondary-channel-hue-scale: 10;
			--pitch-secondary-channel-sat: 100;
			--pitch-secondary-channel-sat-scale: 0;
			--pitch-secondary-channel-lum: 88;
			--pitch-secondary-channel-lum-scale: 0;
			--pitch-primary-channel-hue: 207;
			--pitch-primary-channel-hue-scale: 10;
			--pitch-primary-channel-sat: 100;
			--pitch-primary-channel-sat-scale: 0;
			--pitch-primary-channel-lum: 910;
			--pitch-primary-channel-lum-scale: 0;
			--pitch-secondary-note-hue: 208;
			--pitch-secondary-note-hue-scale: 10;
			--pitch-secondary-note-sat: 100;
			--pitch-secondary-note-sat-scale: 0;
			--pitch-secondary-note-lum: 88;
			--pitch-secondary-note-lum-scale: 0;
			--pitch-primary-note-hue: 208;
			--pitch-primary-note-hue-scale: 10;
			--pitch-primary-note-sat: 100;
			--pitch-primary-note-sat-scale: 0;
			--pitch-primary-note-lum: 910;
			--pitch-primary-note-lum-scale: 0;
			--noise-secondary-channel-hue: 328;
			--noise-secondary-channel-hue-scale: 10;
			--noise-secondary-channel-sat: 100;
			--noise-secondary-channel-sat-scale: 0;
			--noise-secondary-channel-lum: 88;
			--noise-secondary-channel-lum-scale: 0;
			--noise-primary-channel-hue: 327;
			--noise-primary-channel-hue-scale: 10;
			--noise-primary-channel-sat: 100;
			--noise-primary-channel-sat-scale: 0;
			--noise-primary-channel-lum: 910;
			--noise-primary-channel-lum-scale: 0;
			--noise-secondary-note-hue: 328;
			--noise-secondary-note-hue-scale: 10;
			--noise-secondary-note-sat: 100;
			--noise-secondary-note-sat-scale: 0;
			--noise-secondary-note-lum: 88;
			--noise-secondary-note-lum-scale: 0;
			--noise-primary-note-hue: 327;
			--noise-primary-note-hue-scale: 10;
			--noise-primary-note-sat: 100;
			--noise-primary-note-sat-scale: 0;
			--noise-primary-note-lum: 910;
			--noise-primary-note-lum-scale: 0;
			--mod-secondary-channel-hue: 87;
			--mod-secondary-channel-hue-scale: 10;
			--mod-secondary-channel-sat: 100;
			--mod-secondary-channel-sat-scale: 0;
			--mod-secondary-channel-lum: 88;
			--mod-secondary-channel-lum-scale: 0;
			--mod-primary-channel-hue: 88;
			--mod-primary-channel-hue-scale: 10;
			--mod-primary-channel-sat: 100;
			--mod-primary-channel-sat-scale: 0;
			--mod-primary-channel-lum: 910;
			--mod-primary-channel-lum-scale: 0;
			--mod-secondary-note-hue: 87;
			--mod-secondary-note-hue-scale: 10;
			--mod-secondary-note-sat: 100;
			--mod-secondary-note-sat-scale: 0;
			--mod-secondary-note-lum: 88;
			--mod-secondary-note-lum-scale: 0;
			--mod-primary-note-hue: 88;
			--mod-primary-note-hue-scale: 10;
			--mod-primary-note-sat: 100;
			--mod-primary-note-sat-scale: 0;
			--mod-primary-note-lum: 910;
			--mod-primary-note-lum-scale: 0;
			--disabled-note-primary: #c6c6c6;
			--disabled-note-secondary: #8c8c8c;
		}`,
        "blutonium": `:root {
			--page-margin: #02070D;
			--editor-background: #02070D;
			--primary-text: #9bd1ee;
			--secondary-text: #5a6da8;
			--text-selection: rgb(68 68 255 / 99%);
			--box-selection-fill: rgb(0 0 255 / 30%);
			--loop-accent: #024aca;
			--link-accent: #024aca;
			--ui-widget-background: #161c2e;
			--ui-widget-focus: #262c3e;
			--pitch-background: #22272D;
			--tonic: #1b3056;
			--fifth-note: #344051;
			--white-piano-key: #a6c6ed;
			--black-piano-key: #2f4687;
			--track-editor-bg-pitch: #25284c;
			--track-editor-bg-pitch-dim: #211c26;
			--track-editor-bg-noise: #261f42;
			--track-editor-bg-noise-dim: #1a152d;
			--track-editor-bg-mod: #183049;
			--track-editor-bg-mod-dim: #102132;
			--multiplicative-mod-slider: #344a7f;
			--overwriting-mod-slider: #344a7f;
			--indicator-primary: #024aca;
			--indicator-secondary: #00177d;
			--select2-opt-group: #141e34;
			--input-box-outline: #141e34;
			--mute-button-normal: #273b9d;
			--mute-button-mod: #27989d;
			--pitch1-secondary-channel: hsl(200, 100%, 40%);
			--pitch1-primary-channel: #99ddff;
			--pitch1-secondary-note: hsl(200, 100%, 40%);
			--pitch1-primary-note: #99ddff;
			--pitch2-secondary-channel: 	hsl(212, 100%, 34%);
			--pitch2-primary-channel: #5BA8FF;
			--pitch2-secondary-note: hsl(212, 100%, 34%);
			--pitch2-primary-note: #5BA8FF;
			--pitch3-secondary-channel: #024ACA;
			--pitch3-primary-channel: #0A89FF;
			--pitch3-secondary-note: #024ACA;
			--pitch3-primary-note: #0A89FF;
			--pitch4-secondary-channel: #00177D;
			--pitch4-primary-channel: #024ACA;
			--pitch4-secondary-note: #00177D;
			--pitch4-primary-note: #024ACA;
			--pitch5-secondary-channel: #000e4e;
			--pitch5-primary-channel: #0023bf;
			--pitch5-secondary-note: #000e4e;
			--pitch5-primary-note: #0023bf;
			--pitch6-secondary-channel: #8990FE;
			--pitch6-primary-channel: #C2C6FF;
			--pitch6-secondary-note: #8990FE;
			--pitch6-primary-note: #C2C6FF;
			--pitch7-secondary-channel: #5E65D3;
			--pitch7-primary-channel: #8990FE;
			--pitch7-secondary-note: #5E65D3;
			--pitch7-primary-note: #8990FE;
			--pitch8-secondary-channel: #3138A6;
			--pitch8-primary-channel: #5E65D3;
			--pitch8-secondary-note: #3138A6;
			--pitch8-primary-note: #5E65D3;
			--pitch9-secondary-channel: #1B0B7F;
			--pitch9-primary-channel: #3138A6;
			--pitch9-secondary-note: #1B0B7F;
			--pitch9-primary-note: #3138A6;
			--pitch10-secondary-channel: #13015D;
			--pitch10-primary-channel: #1c02bd;
			--pitch10-secondary-note: #13015D;
			--pitch10-primary-note: #1c02bd;
			--noise1-secondary-channel: #A675FE;
			--noise1-primary-channel: #E2C9FF;
			--noise1-secondary-note: #A675FE;
			--noise1-primary-note: #E2C9FF;
			--noise2-secondary-channel: #6A31CA;
			--noise2-primary-channel: #A675FE;
			--noise2-secondary-note: #6A31CA;
			--noise2-primary-note: #A675FE;
			--noise3-secondary-channel: #5A1991;
			--noise3-primary-channel: #6A31CA;
			--noise3-secondary-note: #5A1991;
			--noise3-primary-note: #6A31CA;
			--noise4-secondary-channel: #2f1a68;
			--noise4-primary-channel: #5A1991;
			--noise4-secondary-note: #2f1a68;
			--noise4-primary-note: #5A1991;
			--noise5-secondary-channel: #211640;
			--noise5-primary-channel: #391b8d;
			--noise5-secondary-note: #211640;
			--noise5-primary-note: #391b8d;
			--mod1-secondary-channel: #25E2CD;
			--mod1-primary-channel: #BDFFCA;
			--mod1-secondary-note: #25E2CD;
			--mod1-primary-note: #BDFFCA;
			--mod2-secondary-channel: #0A98AC;
			--mod2-primary-channel: #25E2CD;
			--mod2-secondary-note: #0A98AC;
			--mod2-primary-note: #25E2CC;
			--mod3-secondary-channel: #005280;
			--mod3-primary-channel: #0A98AC;
			--mod3-secondary-note: #005280;
			--mod3-primary-note: #0A98AC;
			--mod4-secondary-channel: #0f3670;
			--mod4-primary-channel: #1369c1;
			--mod4-secondary-note: #0f3670;
			--mod4-primary-note: #1369c1;
			--mod-label-primary: #191d26;
			--mod-label-secondary-text: #024aca;
			--mod-label-primary-text: #ffffffa6;
			--disabled-note-primary: #c9c9c9;
			--disabled-note-secondary: #616161;
	}`,
    	
    "sandbox classic": `
			:root {
				--loop-accent: #198195;
					--pitch-channel-limit: 6;
					--noise-channel-limit: 4;
				--pitch1-secondary-channel: #539999;
				--pitch1-primary-channel:   #5EB1B1;
				--pitch1-secondary-note:    #539999;
				--pitch1-primary-note:      #5EB1B1;
				--pitch2-secondary-channel: #95933C;
				--pitch2-primary-channel:   #B0AD44;
				--pitch2-secondary-note:    #95933C;
				--pitch2-primary-note:      #B0AD44;
				--pitch3-secondary-channel: #E75566;
				--pitch3-primary-channel:   #FF9AA6;
				--pitch3-secondary-note:    #E75566;
				--pitch3-primary-note:      #FF9AA6;
				--pitch4-secondary-channel: #8B4343;
				--pitch4-primary-channel:   #FF8844;
				--pitch4-secondary-note:    #8B4343;
				--pitch4-primary-note:      #FF8844;
				--pitch5-secondary-channel: #888888;
				--pitch5-primary-channel:   #BBBBBB;
				--pitch5-secondary-note:    #888888;
				--pitch5-primary-note:      #BBBBBB;
				--pitch6-secondary-channel: #BB6906;
				--pitch6-primary-channel:   #FE8D00;
				--pitch6-secondary-note:    #BB6906;
				--pitch6-primary-note:      #FE8D00;
				--pitch7-secondary-channel: #539999;
				--pitch7-primary-channel:   #5EB1B1;
				--pitch7-secondary-note:    #539999;
				--pitch7-primary-note:      #5EB1B1;
				--pitch8-secondary-channel: #95933C;
				--pitch8-primary-channel:   #B0AD44;
				--pitch8-secondary-note:    #95933C;
				--pitch8-primary-note:      #B0AD44;
				--pitch9-secondary-channel: #E75566;
				--pitch9-primary-channel:   #FF9AA6;
				--pitch9-secondary-note:    #E75566;
				--pitch9-primary-note:      #FF9AA6;
				--pitch10-secondary-channel: #8B4343;
				--pitch10-primary-channel:   #FF8844;
				--pitch10-secondary-note:    #8B4343;
				--pitch10-primary-note:      #FF8844;			
				--noise1-secondary-channel: #ABABAB;
				--noise1-primary-channel:   #D6D6D6;
				--noise1-secondary-note:    #ABABAB;
				--noise1-primary-note:      #D6D6D6;
				--noise2-secondary-channel: #A18F51;
				--noise2-primary-channel:   #F6BB6A;
				--noise2-secondary-note:    #A18F51;
				--noise2-primary-note:      #F6BB6A;
				--noise3-secondary-channel: #5869BD;
				--noise3-primary-channel:   #768DFC;
				--noise3-secondary-note:    #5869BD;
				--noise3-primary-note:      #768DFC;
				--noise4-secondary-channel: #8888D0;
				--noise4-primary-channel:   #D0D0FF;
				--noise4-secondary-note:    #8888D0;
				--noise4-primary-note:      #D0D0FF;
				--noise5-secondary-channel: #A18F51;
				--noise5-primary-channel:   #F6BB6A;
				--noise5-secondary-note:    #A18F51;
				--noise5-primary-note:      #F6BB6A;			
         	--mod1-secondary-channel: #539999;
				--mod1-primary-channel:   #5EB1B1;
				--mod1-secondary-note:    #539999;
				--mod1-primary-note:      #5EB1B1;
				--mod2-secondary-channel: #95933C;
				--mod2-primary-channel:   #B0AD44;
				--mod2-secondary-note:    #95933C;
				--mod2-primary-note:      #B0AD44;
				--mod3-secondary-channel: #E75566;
				--mod3-primary-channel:   #FF9AA6;
				--mod3-secondary-note:    #E75566;
				--mod3-primary-note:      #FF9AA6;
				--mod4-secondary-channel: #8B4343;
				--mod4-primary-channel:   #FF8844;
				--mod4-secondary-note:    #8B4343;
				--mod4-primary-note:      #FF8844;
				}
			`,
	"axobox": `
		:root {
		--use-color-formula: false;
		--loop-accent: #003366;
			--page-margin: #000e1c;
			--editor-background: #000e1c;
			--playhead: rgba(255, 255, 255, 0.9);
			--secondary-text: #84859a;
			--box-selection-fill: #044b94;
			--ui-widget-background: #2a3045;
			--ui-widget-focus: #4f4a68;
			--pitch-background: #3c5773;
			--tonic: #453e80;
			--fifth-note: #545498;
			--white-piano-key: #eee;
			--black-piano-key: #666;
			--use-color-formula: true;
			--track-editor-bg-pitch: #393e4f;
			--track-editor-bg-pitch-dim: #1c1d28;
			--track-editor-bg-noise: #3d3535;
			--track-editor-bg-noise-dim: #161313;
			--track-editor-bg-mod: #283560;
			--track-editor-bg-mod-dim: #0a101f;
			--multiplicative-mod-slider: #606c9f;
			--overwriting-mod-slider: #6850b5;
			--indicator-primary: #1E90FF;
			--indicator-secondary: #1560BD;
			--select2-opt-group: #3f3951;
			--input-box-outline: #222;
			--mute-button-normal: #dda85d;
			--mute-button-mod: #886eae;
			--mod-label-primary: #282840;
			--mod-label-secondary-text: rgb(87, 86, 120);
			--mod-label-primary-text: white;
			--pitch-secondary-channel-hue: 210;
			--pitch-secondary-channel-hue-scale: 6.5;
			--pitch-secondary-channel-sat: 100;
			--pitch-secondary-channel-sat-scale: 0.1;
			--pitch-secondary-channel-lum: 50;
			--pitch-secondary-channel-lum-scale: 0.05;
			--pitch-primary-channel-hue: 205;
			--pitch-primary-channel-hue-scale: 6.5;
			--pitch-primary-channel-sat: 39;
			--pitch-primary-channel-sat-scale: 0.1;
			--pitch-primary-channel-lum: 60;
			--pitch-primary-channel-lum-scale: 0.05;
			--pitch-secondary-note-hue: 225;
			--pitch-secondary-note-hue-scale: 6.5;
			--pitch-secondary-note-sat: 55;
			--pitch-secondary-note-sat-scale: 0.1;
			--pitch-secondary-note-lum: 37;
			--pitch-secondary-note-lum-scale: 0.05;
			--pitch-primary-note-hue: 204;
			--pitch-primary-note-hue-scale: 6.5;
			--pitch-primary-note-sat: 100;
			--pitch-primary-note-sat-scale: 0.05;
			--pitch-primary-note-lum: 37;
			--pitch-primary-note-lum-scale: 0.025;
			--noise-secondary-channel-hue: 138;
			--noise-secondary-channel-hue-scale: 2;
			--noise-secondary-channel-sat: 97;
			--noise-secondary-channel-sat-scale: 0;
			--noise-secondary-channel-lum: 38;
			--noise-secondary-channel-lum-scale: 0;
			--noise-primary-channel-hue: 74;
			--noise-primary-channel-hue-scale: 2;
			--noise-primary-channel-sat: 100;
			--noise-primary-channel-sat-scale: 0;
			--noise-primary-channel-lum: 36;
			--noise-primary-channel-lum-scale: 0;
			--noise-secondary-note-hue: 175;
			--noise-secondary-note-hue-scale: 2;
			--noise-secondary-note-sat: 98;
			--noise-secondary-note-sat-scale: 0;
			--noise-secondary-note-lum: 24;
			--noise-secondary-note-lum-scale: 0;
			--noise-primary-note-hue: 149;
			--noise-primary-note-hue-scale: 2;
			--noise-primary-note-sat: 100;
			--noise-primary-note-sat-scale: 0;
			--noise-primary-note-lum: 32;
			--noise-primary-note-lum-scale: 0;
			--mod-secondary-channel-hue: 44;
			--mod-secondary-channel-hue-scale: 1.5;
			--mod-secondary-channel-sat: 100;
			--mod-secondary-channel-sat-scale: 0;
			--mod-secondary-channel-lum: 50;
			--mod-secondary-channel-lum-scale: 0;
			--mod-primary-channel-hue: 45;
			--mod-primary-channel-hue-scale: 1.5;
			--mod-primary-channel-sat: 90;
			--mod-primary-channel-sat-scale: 0;
			--mod-primary-channel-lum: 57;
			--mod-primary-channel-lum-scale: 0;
			--mod-secondary-note-hue: 33;
			--mod-secondary-note-hue-scale: 1.5;
			--mod-secondary-note-sat: 100;
			--mod-secondary-note-sat-scale: 0;
			--mod-secondary-note-lum: 47;
			--mod-secondary-note-lum-scale: 0;
			--mod-primary-note-hue: 45;
			--mod-primary-note-hue-scale: 1.5;
			--mod-primary-note-sat: 100;
			--mod-primary-note-sat-scale: 0;
			--mod-primary-note-lum: 60;
			--mod-primary-note-lum-scale: 0;
			--disabled-note-primary:    #9187d1;
			--disabled-note-secondary:  #6a67ac;
		}`,
"Paper": `
.fbox {
  color: #111111;
}
:root {
  -webkit-text-stroke-width: 0.3px;
  --page-margin: #EAEAEA;
  --editor-background: #EAEAEA;
--pattern-background: url("https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTYQurAtfrC7QXo9iadsZVc6eJzdcERpn2ClA&s");
  
  --hover-preview: #FFFFFF;
  --playhead: #EAEAEA;
  --primary-text: #000000;
  --secondary-text: #000000;
  --inverted-text: #FFFFFF;
  --text-selection: #000000;
  --box-selection-fill: #353535;
  --loop-accent: #606060;
  --link-accent: #C1C1C1;
  --ui-widget-background: #E4E4E4;
  --ui-widget-focus: #8B8B8B;
  --pitch-background: #FAFAFA;
  --tonic: #E8E8E8;
  --fifth-note: #434343;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #FFFFFF;
  --white-piano-key: #FFFFFF;
  --black-piano-key: #000000;
  --use-color-formula: false;
  --track-editor-bg-pitch: #CCCCCC;
  --track-editor-bg-pitch-dim: #3D3D3D;
  --track-editor-bg-noise: #D4D4D4;
  --track-editor-bg-noise-dim: #1F1F1F;
  --track-editor-bg-mod: #717171;
  --track-editor-bg-mod-dim: #CECECE;
  --multiplicative-mod-slider: #4F4F4F;
  --overwriting-mod-slider: #434343;
  --indicator-primary: #373737;
  --indicator-secondary: #0D0D0D;
  --select2-opt-group: #C6C6C6;
  --input-box-outline: #000000;
  --mute-button-normal: #0A0A0A;
  --mute-button-mod: #040404;
  
  /* pitch */
  --pitch1-primary-channel: #000000;
  --pitch1-secondary-channel: #484848;
  --pitch1-primary-note: #000000;
  --pitch1-secondary-note: #484848;
  
  --pitch2-primary-channel: #000000;
  --pitch2-secondary-channel: #484848;
  --pitch2-primary-note: #000000;
  --pitch2-secondary-note: #484848;
  
  --pitch3-primary-channel: #000000;
  --pitch3-secondary-channel: #484848;
  --pitch3-primary-note: #000000;
  --pitch3-secondary-note: #484848;
  
  --pitch4-primary-channel: #000000;
  --pitch4-secondary-channel: #484848;
  --pitch4-primary-note: #000000;
  --pitch4-secondary-note: #484848;
  
  --pitch5-primary-channel: #000000;
  --pitch5-secondary-channel: #484848;
  --pitch5-primary-note: #000000;
  --pitch5-secondary-note: #484848;
  
  --pitch6-primary-channel: #000000;
  --pitch6-secondary-channel: #484848;
  --pitch6-primary-note: #000000;
  --pitch6-secondary-note: #484848;
  
  --pitch7-primary-channel: #000000;
  --pitch7-secondary-channel: #484848;
  --pitch7-primary-note: #000000;
  --pitch7-secondary-note: #484848;
  
  --pitch8-primary-channel: #000000;
  --pitch8-secondary-channel: #484848;
  --pitch8-primary-note: #000000;
  --pitch8-secondary-note: #484848;
  
  --pitch9-primary-channel: #000000;
  --pitch9-secondary-channel: #484848;
  --pitch9-primary-note: #000000;
  --pitch9-secondary-note: #484848;
  
  --pitch10-primary-channel: #000000;
  --pitch10-secondary-channel: #484848;
  --pitch10-primary-note: #000000;
  --pitch10-secondary-note: #484848;
  
  /* noise */
  --noise1-primary-channel: #000000;
  --noise1-secondary-channel: #484848;
  --noise1-primary-note: #000000;
  --noise1-secondary-note: #484848;
  
  --noise2-primary-channel: #000000;
  --noise2-secondary-channel: #484848;
  --noise2-primary-note: #000000;
  --noise2-secondary-note: #484848;
  
  --noise3-primary-channel: #000000;
  --noise3-secondary-channel: #484848;
  --noise3-primary-note: #000000;
  --noise3-secondary-note: #484848;
  
  --noise4-primary-channel: #000000;
  --noise4-secondary-channel: #484848;
  --noise4-primary-note: #000000;
  --noise4-secondary-note: #484848;
  
  --noise5-primary-channel: #000000;
  --noise5-secondary-channel: #484848;
  --noise5-primary-note: #000000;
  --noise5-secondary-note: #484848;
  
  /* mod */
  --mod1-primary-channel: #000000;
  --mod1-secondary-channel: #484848;
  --mod1-primary-note: #000000;
  --mod1-secondary-note: #484848;
  
  --mod2-primary-channel: #000000;
  --mod2-secondary-channel: #484848;
  --mod2-primary-note: #000000;
  --mod2-secondary-note: #484848;
  
  --mod3-primary-channel: #000000;
  --mod3-secondary-channel: #484848;
  --mod3-primary-note: #000000;
  --mod3-secondary-note: #484848;
  
  --mod4-primary-channel: #000000;
  --mod4-secondary-channel: #484848;
  --mod4-primary-note: #000000;
  --mod4-secondary-note: #484848;
  
  --mod-label-primary: #000000;
  --mod-label-secondary-text: #484848;
  --mod-label-primary-text: #000000;
  
  --disabled-note-primary: #484848;
  --disabled-note-secondary: #1A0E08;
}
.beepboxEditor button, .beepboxEditor select {
  box-shadow: inset 0 0 0 1px var(--secondary-text);
  opacity:0.4;
}

.select2-selection__rendered {
  box-shadow: inset 0 0 0 1px var(--secondary-text);
  opacity:0.4;
}
`,


"Halloween": `
:root {
  --page-margin: #402020;
  --editor-background: #0A0404;
  --hover-preview: #FFA74F;
  --playhead: #FF4F00;
  --primary-text: #FFDDBB;
  --secondary-text: #FFB878;
  --inverted-text: #120808;
  --text-selection: #803300;
  --box-selection-fill: #5A1C00;
  --loop-accent: #FF7518;
  --link-accent: #FF934F;
  --ui-widget-background: #2B0D0D;
  --ui-widget-focus: #FF6018;
  --pitch-background: #1A0B0B;
  --tonic: #FF8C00;
  --fifth-note: #CC6600;
  --white-piano-key-color: #100000;
  --black-piano-key-color: #FFB878;
  --white-piano-key: #803300;
  --black-piano-key: #220000;
  --use-color-formula: false;
  --track-editor-bg-pitch: #3A1A1A;
  --track-editor-bg-pitch-dim: #2A1212;
  --track-editor-bg-noise: #3C2A1A;
  --track-editor-bg-noise-dim: #2E1C0F;
  --track-editor-bg-mod: #4A1E1E;
  --track-editor-bg-mod-dim: #311818;
  --multiplicative-mod-slider: #FF9944;
  --overwriting-mod-slider: #CC7733;
  --indicator-primary: #FFBB66;
  --indicator-secondary: #D67A2E;
  --select2-opt-group: #803300;
  --input-box-outline: #B84F0D;
  --mute-button-normal: #FFBB88;
  --mute-button-mod: #FFCCAA;

  /* pitch */
  --pitch1-primary-channel: #FF5C5C;
  --pitch1-secondary-channel: #B22222;
  --pitch1-primary-note: #FFA0A0;
  --pitch1-secondary-note: #7A1A1A;

  --pitch2-primary-channel: #FF9933;
  --pitch2-secondary-channel: #CC6600;
  --pitch2-primary-note: #FFD4A3;
  --pitch2-secondary-note: #8A4B00;

  --pitch3-primary-channel: #FFE066;
  --pitch3-secondary-channel: #E6B800;
  --pitch3-primary-note: #FFF2B3;
  --pitch3-secondary-note: #A68200;

  --pitch4-primary-channel: #A3FF57;
  --pitch4-secondary-channel: #6ABB2F;
  --pitch4-primary-note: #D0FFAA;
  --pitch4-secondary-note: #467C1D;

  --pitch5-primary-channel: #4FFFCF;
  --pitch5-secondary-channel: #2FBBA5;
  --pitch5-primary-note: #AAFFF3;
  --pitch5-secondary-note: #1D7C6B;

  --pitch6-primary-channel: #4F9BFF;
  --pitch6-secondary-channel: #2F6ABB;
  --pitch6-primary-note: #A3D0FF;
  --pitch6-secondary-note: #1D467C;

  --pitch7-primary-channel: #AE57FF;
  --pitch7-secondary-channel: #722FBB;
  --pitch7-primary-note: #D7AAFF;
  --pitch7-secondary-note: #4F1D7C;

  --pitch8-primary-channel: #FF57D8;
  --pitch8-secondary-channel: #BB2F9D;
  --pitch8-primary-note: #FFAADF;
  --pitch8-secondary-note: #7C1D61;

  --pitch9-primary-channel: #FF6A8A;
  --pitch9-secondary-channel: #BB3F5E;
  --pitch9-primary-note: #FFB3C6;
  --pitch9-secondary-note: #7A2D41;

  --pitch10-primary-channel: #FFB347;
  --pitch10-secondary-channel: #CC7722;
  --pitch10-primary-note: #FFD9A3;
  --pitch10-secondary-note: #8A571D;

  /* noise */
  --noise1-primary-channel: #FF6A00;
  --noise1-secondary-channel: #B34700;
  --noise1-primary-note: #FFA366;
  --noise1-secondary-note: #803300;

  --noise2-primary-channel: #FF9933;
  --noise2-secondary-channel: #B36200;
  --noise2-primary-note: #FFD8A3;
  --noise2-secondary-note: #814B00;

  --noise3-primary-channel: #FFDA00;
  --noise3-secondary-channel: #C6AA00;
  --noise3-primary-note: #FFF6B3;
  --noise3-secondary-note: #A69200;

  --noise4-primary-channel: #8AFF00;
  --noise4-secondary-channel: #5EBB00;
  --noise4-primary-note: #C6FFA3;
  --noise4-secondary-note: #478000;

  --noise5-primary-channel: #FF44AA;
  --noise5-secondary-channel: #BB2F78;
  --noise5-primary-note: #FFAAD8;
  --noise5-secondary-note: #7C1D52;

  /* mod */
  --mod1-primary-channel: #FF8040;
  --mod1-secondary-channel: #B34F00;
  --mod1-primary-note: #FFC699;
  --mod1-secondary-note: #8A3D00;

  --mod2-primary-channel: #FFCC00;
  --mod2-secondary-channel: #B39C00;
  --mod2-primary-note: #FFEB99;
  --mod2-secondary-note: #8A7000;

  --mod3-primary-channel: #6AFF69;
  --mod3-secondary-channel: #3FBB3F;
  --mod3-primary-note: #B3FFB3;
  --mod3-secondary-note: #297C29;

  --mod4-primary-channel: #B266FF;
  --mod4-secondary-channel: #7F3DBB;
  --mod4-primary-note: #DAB3FF;
  --mod4-secondary-note: #55297C;

  --mod-label-primary: #FFD6AA;
  --mod-label-secondary-text: #1A0A00;
  --mod-label-primary-text: #773C00;
  --disabled-note-primary: #2C1A10;
  --disabled-note-secondary: #1A0E08;
}
`,

"FioletPower": `
:root {
  --page-margin: #5C2E7E;
  --editor-background: #12051C;
  --hover-preview: #B967FF;
  --playhead: #FF5CE8;
  --primary-text: #EBD0FF;
  --secondary-text: #C9A5F8;
  --inverted-text: #180C2C;
  --text-selection: #824C9F;
  --box-selection-fill: #672C91;
  --loop-accent: #A14DD3;
  --link-accent: #B25CFF;
  --ui-widget-background: #2D103F;
  --ui-widget-focus: #B45AFF;
  --pitch-background: #1D0B2A;
  --tonic: #9D4FE9;
  --fifth-note: #823CC8;
  --white-piano-key-color: #0B0012;
  --black-piano-key-color: #F5E6FF;
  --white-piano-key: #4A2A6D;
  --black-piano-key: #12051C;
  --use-color-formula: false;
  --track-editor-bg-pitch: #32114D;
  --track-editor-bg-pitch-dim: #2B0D42;
  --track-editor-bg-noise: #3B1657;
  --track-editor-bg-noise-dim: #2E0D44;
  --track-editor-bg-mod: #462063;
  --track-editor-bg-mod-dim: #2A0F38;
  --multiplicative-mod-slider: #C678F7;
  --overwriting-mod-slider: #AC4AE0;
  --indicator-primary: #D68BFF;
  --indicator-secondary: #9B4CD6;
  --select2-opt-group: #822EA9;
  --input-box-outline: #A446D1;
  --mute-button-normal: #D3B8F1;
  --mute-button-mod: #E6C7FF;

  /* pitch */
  --pitch1-primary-channel: #9B30FF;
  --pitch1-secondary-channel: #7B25D1;
  --pitch1-primary-note: #C285FF;
  --pitch1-secondary-note: #692A9C;

  --pitch2-primary-channel: #C24DFF;
  --pitch2-secondary-channel: #9D30D1;
  --pitch2-primary-note: #E89BFF;
  --pitch2-secondary-note: #7A2C9C;

  --pitch3-primary-channel: #F76AFF;
  --pitch3-secondary-channel: #D34ED1;
  --pitch3-primary-note: #FFB3FF;
  --pitch3-secondary-note: #A144A0;

  --pitch4-primary-channel: #FF79C6;
  --pitch4-secondary-channel: #D743A3;
  --pitch4-primary-note: #FFB2E8;
  --pitch4-secondary-note: #8C3C70;

  --pitch5-primary-channel: #FF79A8;
  --pitch5-secondary-channel: #D74285;
  --pitch5-primary-note: #FFB0D5;
  --pitch5-secondary-note: #7A2C55;

  --pitch6-primary-channel: #8C6AFF;
  --pitch6-secondary-channel: #6549D1;
  --pitch6-primary-note: #BDAAFF;
  --pitch6-secondary-note: #4A2C9C;

  --pitch7-primary-channel: #6A7EFF;
  --pitch7-secondary-channel: #495FD1;
  --pitch7-primary-note: #AABEFF;
  --pitch7-secondary-note: #2C3E9C;

  --pitch8-primary-channel: #5C9BFF;
  --pitch8-secondary-channel: #3C7AD1;
  --pitch8-primary-note: #90BFFF;
  --pitch8-secondary-note: #2A549C;

  --pitch9-primary-channel: #79FFF5;
  --pitch9-secondary-channel: #4DCCC1;
  --pitch9-primary-note: #AAFFFA;
  --pitch9-secondary-note: #44A29D;

  --pitch10-primary-channel: #99FFCC;
  --pitch10-secondary-channel: #66DDAA;
  --pitch10-primary-note: #BBFFDD;
  --pitch10-secondary-note: #44A477;

  /* noise */
  --noise1-primary-channel: #C25CD3;
  --noise1-secondary-channel: #9B3C9C;
  --noise1-primary-note: #E897FF;
  --noise1-secondary-note: #7A2A6A;

  --noise2-primary-channel: #9C5CF0;
  --noise2-secondary-channel: #6A3CA3;
  --noise2-primary-note: #C797FF;
  --noise2-secondary-note: #502A7A;

  --noise3-primary-channel: #C05CFF;
  --noise3-secondary-channel: #8D3CA3;
  --noise3-primary-note: #DBA0FF;
  --noise3-secondary-note: #6A2A7A;

  --noise4-primary-channel: #8C5CF0;
  --noise4-secondary-channel: #623CA3;
  --noise4-primary-note: #B897FF;
  --noise4-secondary-note: #452A7A;

  --noise5-primary-channel: #6A4CFF;
  --noise5-secondary-channel: #4D39D1;
  --noise5-primary-note: #9C8CFF;
  --noise5-secondary-note: #3C2C9C;

  /* mod */
  --mod1-primary-channel: #C867FF;
  --mod1-secondary-channel: #A044C6;
  --mod1-primary-note: #E4B2FF;
  --mod1-secondary-note: #823C9C;

  --mod2-primary-channel: #A267FF;
  --mod2-secondary-channel: #7B44C6;
  --mod2-primary-note: #CBB2FF;
  --mod2-secondary-note: #5F3C9C;

  --mod3-primary-channel: #67A0FF;
  --mod3-secondary-channel: #4481C6;
  --mod3-primary-note: #B2CEFF;
  --mod3-secondary-note: #3C589C;

  --mod4-primary-channel: #67FFD5;
  --mod4-secondary-channel: #44C6A3;
  --mod4-primary-note: #B2FFEB;
  --mod4-secondary-note: #3C9C80;

  --mod-label-primary: #F2E0FF;
  --mod-label-secondary-text: #14091E;
  --mod-label-primary-text: #D6A9FF;
  --disabled-note-primary: #201424;
  --disabled-note-secondary: #0A060C;
}
`,

    	
"DreamyPink": `
:root {
  --page-margin: #ffe0f0;
  --editor-background: #fff8fa;
  --hover-preview: #ffcce5;
  --playhead: #ff99cc;
  --primary-text: #704070;
  --secondary-text: #a06699;
  --inverted-text: #fff5f9;
  --text-selection: #ffd9ec;
  --box-selection-fill: #aae6f2;
  --loop-accent: #ffb3d9;
  --link-accent: #ff80bf;
  --ui-widget-background: #ffb3d9;
  --ui-widget-focus: #ffb3d9;
  --pitch-background: #fff0f5;
  --tonic: #ff99cc;
  --fifth-note: #ffb3d9;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #ffecf5;
  --black-piano-key: #d9aacc;
  --use-color-formula: false;
  --track-editor-bg-pitch: #ffe6f2;
  --track-editor-bg-pitch-dim: #f5d1e6;
  --track-editor-bg-noise: #fce0ec;
  --track-editor-bg-noise-dim: #f0c5db;
  --track-editor-bg-mod: #f8d3e2;
  --track-editor-bg-mod-dim: #eebad1;
  --multiplicative-mod-slider: #ffaad4;
  --overwriting-mod-slider: #ff99cc;
  --indicator-primary: #ff66b2;
  --indicator-secondary: #ff85c1;
  --select2-opt-group: #ff99cc;
  --input-box-outline: #ff80bf;
  --mute-button-normal: #ffd9ec;
  --mute-button-mod: #ffe0f0;

  /* pitch */
  --pitch1-primary-channel: #ffb3c6;
  --pitch1-secondary-channel: #ffa3b6;
  --pitch1-primary-note: #ffe6ec;
  --pitch1-secondary-note: #ffccd9;

  --pitch2-primary-channel: #ffdfb3;
  --pitch2-secondary-channel: #ffd699;
  --pitch2-primary-note: #fff2e6;
  --pitch2-secondary-note: #ffe0cc;

  --pitch3-primary-channel: #d0ffcc;
  --pitch3-secondary-channel: #b2ffb2;
  --pitch3-primary-note: #f0fff0;
  --pitch3-secondary-note: #ccffcc;

  --pitch4-primary-channel: #ccf2ff;
  --pitch4-secondary-channel: #b3ecff;
  --pitch4-primary-note: #e6faff;
  --pitch4-secondary-note: #cceeff;

  --pitch5-primary-channel: #d9ccff;
  --pitch5-secondary-channel: #c2b3ff;
  --pitch5-primary-note: #f0e6ff;
  --pitch5-secondary-note: #dccfff;

  --pitch6-primary-channel: #ffcce6;
  --pitch6-secondary-channel: #ffb3d9;
  --pitch6-primary-note: #ffe6f2;
  --pitch6-secondary-note: #ffccdf;

  --pitch7-primary-channel: #ffffcc;
  --pitch7-secondary-channel: #ffffb3;
  --pitch7-primary-note: #ffffe6;
  --pitch7-secondary-note: #ffffcc;

  --pitch8-primary-channel: #e6f9ff;
  --pitch8-secondary-channel: #ccf2ff;
  --pitch8-primary-note: #f2fcff;
  --pitch8-secondary-note: #d6f8ff;

  --pitch9-primary-channel: #ffe6cc;
  --pitch9-secondary-channel: #ffd1b3;
  --pitch9-primary-note: #fff2e6;
  --pitch9-secondary-note: #ffe6cc;

  --pitch10-primary-channel: #ffc2e2;
  --pitch10-secondary-channel: #ffaad4;
  --pitch10-primary-note: #ffe5f1;
  --pitch10-secondary-note: #ffccdf;

  /* noise */
  --noise1-primary-channel: #ffb3c6;
  --noise1-secondary-channel: #ffa3b6;
  --noise1-primary-note: #ffe6ec;
  --noise1-secondary-note: #ffcce0;

  --noise2-primary-channel: #ffe0b3;
  --noise2-secondary-channel: #ffd699;
  --noise2-primary-note: #fff5e6;
  --noise2-secondary-note: #ffeacc;

  --noise3-primary-channel: #d0ffcc;
  --noise3-secondary-channel: #b3ffb3;
  --noise3-primary-note: #f0fff0;
  --noise3-secondary-note: #ccffcc;

  --noise4-primary-channel: #b3f2ff;
  --noise4-secondary-channel: #99ebff;
  --noise4-primary-note: #e0faff;
  --noise4-secondary-note: #c0f0ff;

  --noise5-primary-channel: #e6d9ff;
  --noise5-secondary-channel: #d1c2ff;
  --noise5-primary-note: #f2eaff;
  --noise5-secondary-note: #e0d4ff;

  /* mod */
  --mod1-primary-channel: #ffcce6;
  --mod1-secondary-channel: #ffb3d9;
  --mod1-primary-note: #ffe6f2;
  --mod1-secondary-note: #ffccdf;

  --mod2-primary-channel: #ffdfb3;
  --mod2-secondary-channel: #ffd699;
  --mod2-primary-note: #fff2e6;
  --mod2-secondary-note: #ffe0cc;

  --mod3-primary-channel: #ccffcc;
  --mod3-secondary-channel: #b2ffb2;
  --mod3-primary-note: #f0fff0;
  --mod3-secondary-note: #ccffcc;

  --mod4-primary-channel: #ccf2ff;
  --mod4-secondary-channel: #b3ecff;
  --mod4-primary-note: #e6faff;
  --mod4-secondary-note: #cceeff;

  --mod-label-primary: #fff0f8;
  --mod-label-secondary-text: #704070;
  --mod-label-primary-text: #a06699;
  --disabled-note-primary: #f0e0e8;
  --disabled-note-secondary: #e0cbd9;
}
`,
"Rock": `
:root {
  --page-margin: #3e3e3e;
  --editor-background: #1c1c1c;
  --hover-preview: #585858;
  --playhead: #a64242;
  --primary-text: #e0e0e0;
  --secondary-text: #a0a0a0;
  --inverted-text: #111111;
  --text-selection: #444444;
  --box-selection-fill: #333333;
  --loop-accent: #8e2e2e;
  --link-accent: #ac5c5c;
  --ui-widget-background: #292929;
  --ui-widget-focus: #5c2c2c;
  --pitch-background: #2a2a2a;
  --tonic: #703535;
  --fifth-note: #593030;
  --white-piano-key-color: #aaa;
  --black-piano-key-color: #eee;
  --white-piano-key: #3b3b3b;
  --black-piano-key: #1e1e1e;
  --use-color-formula: false;
  --track-editor-bg-pitch: #303030;
  --track-editor-bg-pitch-dim: #262626;
  --track-editor-bg-noise: #353535;
  --track-editor-bg-noise-dim: #2c2c2c;
  --track-editor-bg-mod: #403030;
  --track-editor-bg-mod-dim: #372727;
  --multiplicative-mod-slider: #804040;
  --overwriting-mod-slider: #a65252;
  --indicator-primary: #b95c5c;
  --indicator-secondary: #734343;
  --select2-opt-group: #642828;
  --input-box-outline: #a64646;
  --mute-button-normal: #555;
  --mute-button-mod: #666;

  /* pitch */
  --pitch1-primary-channel: #995555;
  --pitch1-secondary-channel: #7a3a3a;
  --pitch1-primary-note: #c06c6c;
  --pitch1-secondary-note: #5a2a2a;

  --pitch2-primary-channel: #998555;
  --pitch2-secondary-channel: #7a693a;
  --pitch2-primary-note: #c0a26c;
  --pitch2-secondary-note: #5a492a;

  --pitch3-primary-channel: #799955;
  --pitch3-secondary-channel: #5a7a3a;
  --pitch3-primary-note: #a5c06c;
  --pitch3-secondary-note: #3a5a2a;

  --pitch4-primary-channel: #55997a;
  --pitch4-secondary-channel: #3a7a63;
  --pitch4-primary-note: #6cc0a2;
  --pitch4-secondary-note: #2a5a4c;

  --pitch5-primary-channel: #557a99;
  --pitch5-secondary-channel: #3a5a7a;
  --pitch5-primary-note: #6ca5c0;
  --pitch5-secondary-note: #2a3e5a;

  --pitch6-primary-channel: #665599;
  --pitch6-secondary-channel: #4f3a7a;
  --pitch6-primary-note: #8b6cc0;
  --pitch6-secondary-note: #382a5a;

  --pitch7-primary-channel: #8a5599;
  --pitch7-secondary-channel: #6f3a7a;
  --pitch7-primary-note: #b06cc0;
  --pitch7-secondary-note: #502a5a;

  --pitch8-primary-channel: #995570;
  --pitch8-secondary-channel: #7a3a5a;
  --pitch8-primary-note: #c06c99;
  --pitch8-secondary-note: #5a2a3e;

  --pitch9-primary-channel: #aa5540;
  --pitch9-secondary-channel: #803a2c;
  --pitch9-primary-note: #c06c5a;
  --pitch9-secondary-note: #5a2a1c;

  --pitch10-primary-channel: #aaaa55;
  --pitch10-secondary-channel: #7a7a3a;
  --pitch10-primary-note: #c0c06c;
  --pitch10-secondary-note: #5a5a2a;

  /* noise */
  --noise1-primary-channel: #a65555;
  --noise1-secondary-channel: #7a3a3a;
  --noise1-primary-note: #c06c6c;
  --noise1-secondary-note: #5a2a2a;

  --noise2-primary-channel: #a67c55;
  --noise2-secondary-channel: #7a5a3a;
  --noise2-primary-note: #c08f6c;
  --noise2-secondary-note: #5a402a;

  --noise3-primary-channel: #88a655;
  --noise3-secondary-channel: #667a3a;
  --noise3-primary-note: #a6c06c;
  --noise3-secondary-note: #4a5a2a;

  --noise4-primary-channel: #55a67a;
  --noise4-secondary-channel: #3a7a5a;
  --noise4-primary-note: #6cc0a2;
  --noise4-secondary-note: #2a5a4c;

  --noise5-primary-channel: #558aa6;
  --noise5-secondary-channel: #3a6a7a;
  --noise5-primary-note: #6ca0c0;
  --noise5-secondary-note: #2a4a5a;

  /* mod */
  --mod1-primary-channel: #664040;
  --mod1-secondary-channel: #503030;
  --mod1-primary-note: #8c5c5c;
  --mod1-secondary-note: #3c2020;

  --mod2-primary-channel: #665540;
  --mod2-secondary-channel: #504430;
  --mod2-primary-note: #8c6c5c;
  --mod2-secondary-note: #3c3020;

  --mod3-primary-channel: #406640;
  --mod3-secondary-channel: #305030;
  --mod3-primary-note: #5c8c5c;
  --mod3-secondary-note: #203c20;

  --mod4-primary-channel: #404066;
  --mod4-secondary-channel: #303050;
  --mod4-primary-note: #5c5c8c;
  --mod4-secondary-note: #20203c;

  --mod-label-primary: #aaaaaa;
  --mod-label-secondary-text: #222222;
  --mod-label-primary-text: #eeeeee;
  --disabled-note-primary: #1a1a1a;
  --disabled-note-secondary: #0f0f0f;
}
`,

    	
    	"Void": `
:root {
  --page-margin: #0a0a1a;
  --editor-background: #0e0b20;
  --hover-preview: #7b00ff;
  --playhead: #aa00ff;
  --primary-text: #ccccff;
  --secondary-text: #9999cc;
  --inverted-text: #1a0033;
  --text-selection: #aa66ff;
  --box-selection-fill: #330066;
  --loop-accent: #8000ff;
  --link-accent: #6600cc;
  --ui-widget-background: #1a0033;
  --ui-widget-focus: #9933ff;
  --pitch-background: #140a33;
  --tonic: #9900cc;
  --fifth-note: #7a00b3;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #553377;
  --black-piano-key: #1c0c2e;
  --use-color-formula: false;
  --track-editor-bg-pitch: #2a0055;
  --track-editor-bg-pitch-dim: #1c0040;
  --track-editor-bg-noise: #1a0033;
  --track-editor-bg-noise-dim: #2a1a3d;
  --track-editor-bg-mod: #33004d;
  --track-editor-bg-mod-dim: #3d2a5c;
  --multiplicative-mod-slider: #b366ff;
  --overwriting-mod-slider: #9955ff;
  --indicator-primary: #cc66ff;
  --indicator-secondary: #9933cc;
  --select2-opt-group: #5a00a3;
  --input-box-outline: #aa33ff;
  --mute-button-normal: #d1c2ff;
  --mute-button-mod: #bbaaff;

  /* pitch */
  --pitch1-primary-channel: #5500aa;
  --pitch1-secondary-channel: #440088;
  --pitch1-primary-note: #aa88ff;
  --pitch1-secondary-note: #7733cc;

  --pitch2-primary-channel: #005577;
  --pitch2-secondary-channel: #004455;
  --pitch2-primary-note: #66ccff;
  --pitch2-secondary-note: #337799;

  --pitch3-primary-channel: #007744;
  --pitch3-secondary-channel: #005533;
  --pitch3-primary-note: #66ffcc;
  --pitch3-secondary-note: #339977;

  --pitch4-primary-channel: #444444;
  --pitch4-secondary-channel: #333333;
  --pitch4-primary-note: #999999;
  --pitch4-secondary-note: #666666;

  --pitch5-primary-channel: #990033;
  --pitch5-secondary-channel: #660022;
  --pitch5-primary-note: #ff6699;
  --pitch5-secondary-note: #cc3366;

  --pitch6-primary-channel: #222266;
  --pitch6-secondary-channel: #1a1a4d;
  --pitch6-primary-note: #6666ff;
  --pitch6-secondary-note: #4444aa;

  --pitch7-primary-channel: #330066;
  --pitch7-secondary-channel: #220044;
  --pitch7-primary-note: #9966ff;
  --pitch7-secondary-note: #6633cc;

  --pitch8-primary-channel: #550055;
  --pitch8-secondary-channel: #330033;
  --pitch8-primary-note: #cc66cc;
  --pitch8-secondary-note: #993399;

  --pitch9-primary-channel: #111111;
  --pitch9-secondary-channel: #000000;
  --pitch9-primary-note: #333333;
  --pitch9-secondary-note: #1a1a1a;

  --pitch10-primary-channel: #003344;
  --pitch10-secondary-channel: #001f2e;
  --pitch10-primary-note: #5599aa;
  --pitch10-secondary-note: #336677;

  /* noise */
  --noise1-primary-channel: #550077;
  --noise1-secondary-channel: #330055;
  --noise1-primary-note: #aa66cc;
  --noise1-secondary-note: #774499;

  --noise2-primary-channel: #003355;
  --noise2-secondary-channel: #001f33;
  --noise2-primary-note: #6699cc;
  --noise2-secondary-note: #336688;

  --noise3-primary-channel: #555555;
  --noise3-secondary-channel: #333333;
  --noise3-primary-note: #999999;
  --noise3-secondary-note: #666666;

  --noise4-primary-channel: #220022;
  --noise4-secondary-channel: #110011;
  --noise4-primary-note: #774477;
  --noise4-secondary-note: #552255;

  --noise5-primary-channel: #222244;
  --noise5-secondary-channel: #1a1a33;
  --noise5-primary-note: #666699;
  --noise5-secondary-note: #444466;

  /* mod */
  --mod1-primary-channel: #660099;
  --mod1-secondary-channel: #440066;
  --mod1-primary-note: #bb66ff;
  --mod1-secondary-note: #9944cc;

  --mod2-primary-channel: #004466;
  --mod2-secondary-channel: #002233;
  --mod2-primary-note: #66aaff;
  --mod2-secondary-note: #3377aa;

  --mod3-primary-channel: #333333;
  --mod3-secondary-channel: #1a1a1a;
  --mod3-primary-note: #888888;
  --mod3-secondary-note: #555555;

  --mod4-primary-channel: #770066;
  --mod4-secondary-channel: #550044;
  --mod4-primary-note: #cc66aa;
  --mod4-secondary-note: #993377;

  --mod-label-primary: #eeeeff;
  --mod-label-secondary-text: #0d0d1a;
  --mod-label-primary-text: #5a3399;
  --disabled-note-primary: #0f0f0f;
  --disabled-note-secondary: #080808;
}
`,

 "Inferno": `
 
:root {
  --page-margin: #3d0000;
  --editor-background: #1a0000;
  --hover-preview: #ff4d00;
  --playhead: #ff0000;
  --primary-text: #ffcccc;
  --secondary-text: #ff9999;
  --inverted-text: #330000;
  --text-selection: #ff4444;
  --box-selection-fill: #990000;
  --loop-accent: #ff1a1a;
  --link-accent: #ff3300;
  --ui-widget-background: #300000;
  --ui-widget-focus: #cc0000;
  --pitch-background: #2a0000;
  --tonic: #ff0000;
  --fifth-note: #cc0000;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #ff9999;
  --black-piano-key: #1a0000;
  --use-color-formula: false;
  --track-editor-bg-pitch: #800000;
  --track-editor-bg-pitch-dim: #5c0000;
  --track-editor-bg-noise: #660000;
  --track-editor-bg-noise-dim: #4d0000;
  --track-editor-bg-mod: #7a0000;
  --track-editor-bg-mod-dim: #520000;
  --multiplicative-mod-slider: #ff4d4d;
  --overwriting-mod-slider: #ff1a1a;
  --indicator-primary: #ff3300;
  --indicator-secondary: #cc1a00;
  --select2-opt-group: #b30000;
  --input-box-outline: #ff4d4d;
  --mute-button-normal: #ffcccc;
  --mute-button-mod: #ff9999;

  /* pitch */
  --pitch1-primary-channel: #ff4d4d;
  --pitch1-secondary-channel: #ff1a1a;
  --pitch1-primary-note: #ff9999;
  --pitch1-secondary-note: #cc4444;

  --pitch2-primary-channel: #ff9933;
  --pitch2-secondary-channel: #ff6600;
  --pitch2-primary-note: #ffcc99;
  --pitch2-secondary-note: #cc7744;

  --pitch3-primary-channel: #ffff66;
  --pitch3-secondary-channel: #ffcc00;
  --pitch3-primary-note: #ffffaa;
  --pitch3-secondary-note: #999933;

  --pitch4-primary-channel: #ffb366;
  --pitch4-secondary-channel: #ff944d;
  --pitch4-primary-note: #ffd9b3;
  --pitch4-secondary-note: #bb7744;

  --pitch5-primary-channel: #ff6b6b;
  --pitch5-secondary-channel: #ff3333;
  --pitch5-primary-note: #ffaaaa;
  --pitch5-secondary-note: #bb4444;

  --pitch6-primary-channel: #b30000;
  --pitch6-secondary-channel: #800000;
  --pitch6-primary-note: #ff6666;
  --pitch6-secondary-note: #992222;

  --pitch7-primary-channel: #99004d;
  --pitch7-secondary-channel: #800040;
  --pitch7-primary-note: #ff99cc;
  --pitch7-secondary-note: #bb4488;

  --pitch8-primary-channel: #cc0066;
  --pitch8-secondary-channel: #99004d;
  --pitch8-primary-note: #ff99bb;
  --pitch8-secondary-note: #bb4477;

  --pitch9-primary-channel: #ff3300;
  --pitch9-secondary-channel: #cc2900;
  --pitch9-primary-note: #ffb399;
  --pitch9-secondary-note: #993322;

  --pitch10-primary-channel: #ff6600;
  --pitch10-secondary-channel: #cc5200;
  --pitch10-primary-note: #ffc299;
  --pitch10-secondary-note: #995522;

  /* noise */
  --noise1-primary-channel: #b30000;
  --noise1-secondary-channel: #800000;
  --noise1-primary-note: #ff6666;
  --noise1-secondary-note: #992222;

  --noise2-primary-channel: #ff9933;
  --noise2-secondary-channel: #ff6600;
  --noise2-primary-note: #ffd6aa;
  --noise2-secondary-note: #bb7733;

  --noise3-primary-channel: #ffee33;
  --noise3-secondary-channel: #ffcc00;
  --noise3-primary-note: #ffffaa;
  --noise3-secondary-note: #999933;

  --noise4-primary-channel: #ff4d4d;
  --noise4-secondary-channel: #cc0000;
  --noise4-primary-note: #ffaaaa;
  --noise4-secondary-note: #994444;

  --noise5-primary-channel: #ff6600;
  --noise5-secondary-channel: #cc3300;
  --noise5-primary-note: #ffbb99;
  --noise5-secondary-note: #aa5533;

  /* mod */
  --mod1-primary-channel: #ff3333;
  --mod1-secondary-channel: #cc1a1a;
  --mod1-primary-note: #ffaaaa;
  --mod1-secondary-note: #994444;

  --mod2-primary-channel: #cc3300;
  --mod2-secondary-channel: #991a00;
  --mod2-primary-note: #ffbb99;
  --mod2-secondary-note: #993322;

  --mod3-primary-channel: #800000;
  --mod3-secondary-channel: #4d0000;
  --mod3-primary-note: #cc6666;
  --mod3-secondary-note: #662222;

  --mod4-primary-channel: #ff1a1a;
  --mod4-secondary-channel: #cc0000;
  --mod4-primary-note: #ff9999;
  --mod4-secondary-note: #993333;

  --mod-label-primary: #fff0f0;
  --mod-label-secondary-text: #330000;
  --mod-label-primary-text: #770000;
  --disabled-note-primary: #1a0a0a;
  --disabled-note-secondary: #0d0000;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 5;
  pointer-events: none;
  border-radius: 0;
  background: radial-gradient(
    circle at center,
    rgba(0, 0, 0, 0) 60%,
    rgba(255, 255, 0, 0.1) 75%,
    rgba(255, 255, 0, 0.2) 85%,
    rgba(255, 255, 0, 0.3) 95%,
    rgba(255, 255, 0, 0.4) 100%
  );
  animation: yellowGlow 6s ease-in-out infinite;
  backdrop-filter: blur(6px);
}
@keyframes yellowGlow {
  0%   { opacity: 0.1; }
  50%  { opacity: 0.35; }
  100% { opacity: 0.1; }
}


`,

"Synthwave": `
:root {
  --page-margin: #2d004d;
  --editor-background: #0d0b1a;
  --hover-preview: #ff6ec7;
  --playhead: #ff00ff;
  --primary-text: #ffe0ff;
  --secondary-text: #ff99ff;
  --inverted-text: #1a001f;
  --text-selection: #ff66c4;
  --box-selection-fill: #aa33ff;
  --loop-accent: #ff00aa;
  --link-accent: #d94dff;
  --ui-widget-background: #300033;
  --ui-widget-focus: #9900cc;
  --pitch-background: #1a0033;
  --tonic: #6600ff;
  --fifth-note: #9900ff;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #d1b3ff;
  --black-piano-key: #190033;
  --use-color-formula: false;
  --track-editor-bg-pitch: #47006b;
  --track-editor-bg-pitch-dim: #3b005a;
  --track-editor-bg-noise: #36004d;
  --track-editor-bg-noise-dim: #2b0044;
  --track-editor-bg-mod: #4a0066;
  --track-editor-bg-mod-dim: #3a0052;
  --multiplicative-mod-slider: #cc66ff;
  --overwriting-mod-slider: #9933ff;
  --indicator-primary: #ff33cc;
  --indicator-secondary: #cc33aa;
  --select2-opt-group: #aa00ff;
  --input-box-outline: #cc33ff;
  --mute-button-normal: #ffccff;
  --mute-button-mod: #ffccf2;

  /* pitch */
  --pitch1-primary-channel: #ff4d6d;
  --pitch1-secondary-channel: #ff003c;
  --pitch1-primary-note: #ff99aa;
  --pitch1-secondary-note: #cc4466;

  --pitch2-primary-channel: #ffa94d;
  --pitch2-secondary-channel: #ff7300;
  --pitch2-primary-note: #ffd6aa;
  --pitch2-secondary-note: #bb7744;

  --pitch3-primary-channel: #ffee33;
  --pitch3-secondary-channel: #ffcc00;
  --pitch3-primary-note: #ffffaa;
  --pitch3-secondary-note: #999933;

  --pitch4-primary-channel: #33ffaa;
  --pitch4-secondary-channel: #00cc88;
  --pitch4-primary-note: #aaffcc;
  --pitch4-secondary-note: #339977;

  --pitch5-primary-channel: #33ffff;
  --pitch5-secondary-channel: #00ccff;
  --pitch5-primary-note: #aaffff;
  --pitch5-secondary-note: #3399aa;

  --pitch6-primary-channel: #6699ff;
  --pitch6-secondary-channel: #3366ff;
  --pitch6-primary-note: #aac8ff;
  --pitch6-secondary-note: #4466bb;

  --pitch7-primary-channel: #aa66ff;
  --pitch7-secondary-channel: #9933ff;
  --pitch7-primary-note: #d1aaff;
  --pitch7-secondary-note: #7744bb;

  --pitch8-primary-channel: #ff66ff;
  --pitch8-secondary-channel: #ff33cc;
  --pitch8-primary-note: #ffb3ff;
  --pitch8-secondary-note: #cc66bb;

  --pitch9-primary-channel: #ff6699;
  --pitch9-secondary-channel: #ff3377;
  --pitch9-primary-note: #ff99bb;
  --pitch9-secondary-note: #bb4466;

  --pitch10-primary-channel: #ffaa66;
  --pitch10-secondary-channel: #ff8844;
  --pitch10-primary-note: #ffd1aa;
  --pitch10-secondary-note: #bb7744;

  /* noise */
  --noise1-primary-channel: #ff4d6d;
  --noise1-secondary-channel: #ff003c;
  --noise1-primary-note: #ff99aa;
  --noise1-secondary-note: #cc4466;

  --noise2-primary-channel: #ffa94d;
  --noise2-secondary-channel: #ff7300;
  --noise2-primary-note: #ffd6aa;
  --noise2-secondary-note: #bb7744;

  --noise3-primary-channel: #ffee33;
  --noise3-secondary-channel: #ffcc00;
  --noise3-primary-note: #ffffaa;
  --noise3-secondary-note: #999933;

  --noise4-primary-channel: #33ffaa;
  --noise4-secondary-channel: #00cc88;
  --noise4-primary-note: #aaffcc;
  --noise4-secondary-note: #339977;

  --noise5-primary-channel: #33ffff;
  --noise5-secondary-channel: #00ccff;
  --noise5-primary-note: #aaffff;
  --noise5-secondary-note: #3399aa;

  /* mod */
  --mod1-primary-channel: #00ffd9;
  --mod1-secondary-channel: #00cccc;
  --mod1-primary-note: #aaffee;
  --mod1-secondary-note: #339999;

  --mod2-primary-channel: #0099ff;
  --mod2-secondary-channel: #0066ff;
  --mod2-primary-note: #aaccff;
  --mod2-secondary-note: #4466bb;

  --mod3-primary-channel: #cc66ff;
  --mod3-secondary-channel: #9933ff;
  --mod3-primary-note: #e0b3ff;
  --mod3-secondary-note: #8855cc;

  --mod4-primary-channel: #ff33cc;
  --mod4-secondary-channel: #ff00aa;
  --mod4-primary-note: #ffb3ee;
  --mod4-secondary-note: #cc66aa;

  --mod-label-primary: #ffe6ff;
  --mod-label-secondary-text: #331a33;
  --mod-label-primary-text: #661177;
  --disabled-note-primary: #1a1a1a;
  --disabled-note-secondary: #0d0d0d;
}
`,

"VintageSepia":`
:root {
  -webkit-text-stroke-width: 0.3px;
  --page-margin: #3B2B20;
  --editor-background: #2F251D;
  --hover-preview: #A97C50;
  --playhead: #C6A772;
  --primary-text: #F5E7D0;
  --secondary-text: #DCC3A3;
  --inverted-text: #1D130B;
  --text-selection: #A67B5B;
  --box-selection-fill: #D4B07C;
  --loop-accent: #C09C6B;
  --link-accent: #C9A874;
  --ui-widget-background: #4A3A2B;
  --ui-widget-focus: #D2A670;
  --pitch-background: #3C2E22;
  --tonic: #E7C78A;
  --fifth-note: #B89A6F;
  --white-piano-key-color: #1A130D;
  --black-piano-key-color: #F5E0BA;
  --white-piano-key: #D3BFA4;
  --black-piano-key: #2C2117;
  --use-color-formula: false;
  --track-editor-bg-pitch: #4E3A28;
  --track-editor-bg-pitch-dim: #453223;
  --track-editor-bg-noise: #594330;
  --track-editor-bg-noise-dim: #6E503A;
  --track-editor-bg-mod: #6A4F38;
  --track-editor-bg-mod-dim: #A17855;
  --multiplicative-mod-slider: #D6B88A;
  --overwriting-mod-slider: #B99870;
  --indicator-primary: #E0C38F;
  --indicator-secondary: #A37F54;
  --select2-opt-group: #916A45;
  --input-box-outline: #B38A5D;
  --mute-button-normal: #F5E8D3;
  --mute-button-mod: #F2DBB6;

  /* pitch */
  --pitch1-primary-channel: #D1A177;
  --pitch1-secondary-channel: #B07854;
  --pitch1-primary-note: #EAC3A0;
  --pitch1-secondary-note: #825C3C;

  --pitch2-primary-channel: #D1B177;
  --pitch2-secondary-channel: #B89C54;
  --pitch2-primary-note: #EAD7A0;
  --pitch2-secondary-note: #847B3C;

  --pitch3-primary-channel: #C4AD82;
  --pitch3-secondary-channel: #A3945F;
  --pitch3-primary-note: #E4D5B0;
  --pitch3-secondary-note: #776743;

  --pitch4-primary-channel: #B79D77;
  --pitch4-secondary-channel: #9C7F54;
  --pitch4-primary-note: #DDC4A0;
  --pitch4-secondary-note: #6A553C;

  --pitch5-primary-channel: #A88566;
  --pitch5-secondary-channel: #8F6B45;
  --pitch5-primary-note: #D2B295;
  --pitch5-secondary-note: #5F4733;

  --pitch6-primary-channel: #987657;
  --pitch6-secondary-channel: #77563C;
  --pitch6-primary-note: #C9A88A;
  --pitch6-secondary-note: #4F3928;

  --pitch7-primary-channel: #8C674A;
  --pitch7-secondary-channel: #6E4D35;
  --pitch7-primary-note: #BF9C7C;
  --pitch7-secondary-note: #422E22;

  --pitch8-primary-channel: #805B40;
  --pitch8-secondary-channel: #65422F;
  --pitch8-primary-note: #B79070;
  --pitch8-secondary-note: #392619;

  --pitch9-primary-channel: #755038;
  --pitch9-secondary-channel: #593C29;
  --pitch9-primary-note: #AD8367;
  --pitch9-secondary-note: #2F1F14;

  --pitch10-primary-channel: #6A4631;
  --pitch10-secondary-channel: #4E3424;
  --pitch10-primary-note: #A2785C;
  --pitch10-secondary-note: #25160D;

  /* noise */
  --noise1-primary-channel: #C0946E;
  --noise1-secondary-channel: #A0704B;
  --noise1-primary-note: #DFBA97;
  --noise1-secondary-note: #7B5335;

  --noise2-primary-channel: #D1B077;
  --noise2-secondary-channel: #B18F54;
  --noise2-primary-note: #E9D09D;
  --noise2-secondary-note: #826C3C;

  --noise3-primary-channel: #C2A66E;
  --noise3-secondary-channel: #9E7C4B;
  --noise3-primary-note: #DEC298;
  --noise3-secondary-note: #735835;

  --noise4-primary-channel: #A9835F;
  --noise4-secondary-channel: #876140;
  --noise4-primary-note: #CDA486;
  --noise4-secondary-note: #60462F;

  --noise5-primary-channel: #977351;
  --noise5-secondary-channel: #745434;
  --noise5-primary-note: #BE977D;
  --noise5-secondary-note: #4C3927;

  /* mod */
  --mod1-primary-channel: #B68C66;
  --mod1-secondary-channel: #926946;
  --mod1-primary-note: #DAB79B;
  --mod1-secondary-note: #6B4831;

  --mod2-primary-channel: #A0805F;
  --mod2-secondary-channel: #7F6146;
  --mod2-primary-note: #C9A58C;
  --mod2-secondary-note: #5B3E2F;

  --mod3-primary-channel: #997B5B;
  --mod3-secondary-channel: #765C42;
  --mod3-primary-note: #C5A084;
  --mod3-secondary-note: #523A2A;

  --mod4-primary-channel: #8C6D4D;
  --mod4-secondary-channel: #6B5238;
  --mod4-primary-note: #B88F76;
  --mod4-secondary-note: #403226;

  --mod-label-primary: #F6E6C8;
  --mod-label-secondary-text: #2E2116;
  --mod-label-primary-text: #614A2E;
  --disabled-note-primary: #33261C;
  --disabled-note-secondary: #22170F;
}
`,
"TimeForVacation":`
:root {
  -webkit-text-stroke-width: 0.3px;
  --page-margin: #4AC6B7;
  --editor-background: #FFF5E1;
  --hover-preview: #FFBC91;
  --playhead: #FF7B54;
  --primary-text: #2A3D45;
  --secondary-text: #497C6D;
  --inverted-text: #FFFFFF;
  --text-selection: #FFD5A6;
  --box-selection-fill: #FFF0C2;
  --loop-accent: #FFAE00;
  --link-accent: #F78E69;
  --ui-widget-background: #E0F6F1;
  --ui-widget-focus: #FFBA88;
  --pitch-background: #FDEBD0;
  --tonic: #FF8C61;
  --fifth-note: #FFA85A;
  --white-piano-key-color: #423B36;
  --black-piano-key-color: #FFFFFF;
  --white-piano-key: #FFF6E3;
  --black-piano-key: #FDD69E;
  --use-color-formula: false;
  --track-editor-bg-pitch: #FFF0D6;
  --track-editor-bg-pitch-dim: #FAD7A0;
  --track-editor-bg-noise: #EAFCE5;
  --track-editor-bg-noise-dim: #CFF5D6;
  --track-editor-bg-mod: #D0F1FF;
  --track-editor-bg-mod-dim: #B4E9FF;
  --multiplicative-mod-slider: #89D4E6;
  --overwriting-mod-slider: #68C1D8;
  --indicator-primary: #FF9A76;
  --indicator-secondary: #FFCD9E;
  --select2-opt-group: #FFB067;
  --input-box-outline: #FF9E73;
  --mute-button-normal: #FDEBD0;
  --mute-button-mod: #F8D6B6;

  /* pitch */
  --pitch1-primary-channel: #FF9494;
  --pitch1-secondary-channel: #FF6B6B;
  --pitch1-primary-note: #FFD3D3;
  --pitch1-secondary-note: #B25555;

  --pitch2-primary-channel: #FFD37D;
  --pitch2-secondary-channel: #FFBB3F;
  --pitch2-primary-note: #FFEAB5;
  --pitch2-secondary-note: #B8963B;

  --pitch3-primary-channel: #AFFC9F;
  --pitch3-secondary-channel: #83F28F;
  --pitch3-primary-note: #D9FFD3;
  --pitch3-secondary-note: #68B861;

  --pitch4-primary-channel: #9FF9F9;
  --pitch4-secondary-channel: #64EDEB;
  --pitch4-primary-note: #CCFFFF;
  --pitch4-secondary-note: #50B7B5;

  --pitch5-primary-channel: #A8CFFF;
  --pitch5-secondary-channel: #7FB6FF;
  --pitch5-primary-note: #DAE8FF;
  --pitch5-secondary-note: #5E88C2;

  --pitch6-primary-channel: #D9A8FF;
  --pitch6-secondary-channel: #C57CFF;
  --pitch6-primary-note: #EDD9FF;
  --pitch6-secondary-note: #9E63C4;

  --pitch7-primary-channel: #FFA8E6;
  --pitch7-secondary-channel: #FF7BCF;
  --pitch7-primary-note: #FFD6F1;
  --pitch7-secondary-note: #B7639A;

  --pitch8-primary-channel: #FFB88A;
  --pitch8-secondary-channel: #FF8A54;
  --pitch8-primary-note: #FFE0C4;
  --pitch8-secondary-note: #C46E42;

  --pitch9-primary-channel: #FFF38A;
  --pitch9-secondary-channel: #FFEC54;
  --pitch9-primary-note: #FFFBD1;
  --pitch9-secondary-note: #C4B842;

  --pitch10-primary-channel: #A8FFEB;
  --pitch10-secondary-channel: #76FFD9;
  --pitch10-primary-note: #D6FFF6;
  --pitch10-secondary-note: #5CC7B4;

  /* noise */
  --noise1-primary-channel: #F6B89B;
  --noise1-secondary-channel: #F29872;
  --noise1-primary-note: #FFD6C2;
  --noise1-secondary-note: #BB6F52;

  --noise2-primary-channel: #F4D98B;
  --noise2-secondary-channel: #F1C852;
  --noise2-primary-note: #FFF3C8;
  --noise2-secondary-note: #A88A43;

  --noise3-primary-channel: #C6F69B;
  --noise3-secondary-channel: #9FF16B;
  --noise3-primary-note: #E2FFD1;
  --noise3-secondary-note: #7AB862;

  --noise4-primary-channel: #A6F1F6;
  --noise4-secondary-channel: #82EAF2;
  --noise4-primary-note: #D5FBFF;
  --noise4-secondary-note: #5DB3B7;

  --noise5-primary-channel: #A6C7F6;
  --noise5-secondary-channel: #7FAAF2;
  --noise5-primary-note: #D6E4FF;
  --noise5-secondary-note: #5985B8;

  /* mod */
  --mod1-primary-channel: #94E6C5;
  --mod1-secondary-channel: #6FDDB0;
  --mod1-primary-note: #C3F5E1;
  --mod1-secondary-note: #4CB893;

  --mod2-primary-channel: #94DFF6;
  --mod2-secondary-channel: #6ACCF2;
  --mod2-primary-note: #C6F1FF;
  --mod2-secondary-note: #519DBE;

  --mod3-primary-channel: #BFA6F6;
  --mod3-secondary-channel: #A37CF2;
  --mod3-primary-note: #E6D9FF;
  --mod3-secondary-note: #8160C0;

  --mod4-primary-channel: #F6A6D6;
  --mod4-secondary-channel: #F27CB7;
  --mod4-primary-note: #FFD6EE;
  --mod4-secondary-note: #B6608D;

  --mod-label-primary: #FFFAF0;
  --mod-label-secondary-text: #3A3A3A;
  --mod-label-primary-text: #FF835A;
  --disabled-note-primary: #D9CBBF;
  --disabled-note-secondary: #C7B8AA;
}
`,

"BlackAndWhite":`
:root {
  --page-margin: #000000;
  --editor-background: #000000;
  --hover-preview: #1a1a1a;
  --playhead: #ffffff;
  --primary-text: #ffffff;
  --secondary-text: #cccccc;
  --inverted-text: #000000;
  --text-selection: #444444;
  --box-selection-fill: #666666;
  --loop-accent: #ffffff;
  --link-accent: #ffffff;
  --ui-widget-background: #111111;
  --ui-widget-focus: #333333;
  --pitch-background: #000000;
  --tonic: #ffffff;
  --fifth-note: #aaaaaa;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #ffffff;
  --black-piano-key: #000000;
  --use-color-formula: false;
  --track-editor-bg-pitch: #111111;
  --track-editor-bg-pitch-dim: #0a0a0a;
  --track-editor-bg-noise: #1a1a1a;
  --track-editor-bg-noise-dim: #2a2a2a;
  --track-editor-bg-mod: #222222;
  --track-editor-bg-mod-dim: #333333;
  --multiplicative-mod-slider: #ffffff;
  --overwriting-mod-slider: #ffffff;
  --indicator-primary: #ffffff;
  --indicator-secondary: #aaaaaa;
  --select2-opt-group: #111111;
  --input-box-outline: #888888;
  --mute-button-normal: #ffffff;
  --mute-button-mod: #dddddd;

  /* pitch */
  --pitch1-primary-channel: #111111;
  --pitch1-secondary-channel: #000000;
  --pitch1-primary-note: #ffffff;
  --pitch1-secondary-note: #222222;

  --pitch2-primary-channel: #222222;
  --pitch2-secondary-channel: #111111;
  --pitch2-primary-note: #ffffff;
  --pitch2-secondary-note: #333333;

  --pitch3-primary-channel: #333333;
  --pitch3-secondary-channel: #222222;
  --pitch3-primary-note: #ffffff;
  --pitch3-secondary-note: #444444;

  --pitch4-primary-channel: #444444;
  --pitch4-secondary-channel: #333333;
  --pitch4-primary-note: #ffffff;
  --pitch4-secondary-note: #555555;

  --pitch5-primary-channel: #555555;
  --pitch5-secondary-channel: #444444;
  --pitch5-primary-note: #ffffff;
  --pitch5-secondary-note: #666666;

  --pitch6-primary-channel: #666666;
  --pitch6-secondary-channel: #555555;
  --pitch6-primary-note: #ffffff;
  --pitch6-secondary-note: #777777;

  --pitch7-primary-channel: #777777;
  --pitch7-secondary-channel: #666666;
  --pitch7-primary-note: #ffffff;
  --pitch7-secondary-note: #888888;

  --pitch8-primary-channel: #888888;
  --pitch8-secondary-channel: #777777;
  --pitch8-primary-note: #ffffff;
  --pitch8-secondary-note: #999999;

  --pitch9-primary-channel: #999999;
  --pitch9-secondary-channel: #888888;
  --pitch9-primary-note: #ffffff;
  --pitch9-secondary-note: #aaaaaa;

  --pitch10-primary-channel: #aaaaaa;
  --pitch10-secondary-channel: #999999;
  --pitch10-primary-note: #ffffff;
  --pitch10-secondary-note: #bbbbbb;

  /* noise */
  --noise1-primary-channel: #111111;
  --noise1-secondary-channel: #000000;
  --noise1-primary-note: #ffffff;
  --noise1-secondary-note: #222222;

  --noise2-primary-channel: #222222;
  --noise2-secondary-channel: #111111;
  --noise2-primary-note: #ffffff;
  --noise2-secondary-note: #333333;

  --noise3-primary-channel: #333333;
  --noise3-secondary-channel: #222222;
  --noise3-primary-note: #ffffff;
  --noise3-secondary-note: #444444;

  --noise4-primary-channel: #444444;
  --noise4-secondary-channel: #333333;
  --noise4-primary-note: #ffffff;
  --noise4-secondary-note: #555555;

  --noise5-primary-channel: #555555;
  --noise5-secondary-channel: #444444;
  --noise5-primary-note: #ffffff;
  --noise5-secondary-note: #666666;

  /* mod */
  --mod1-primary-channel: #333333;
  --mod1-secondary-channel: #111111;
  --mod1-primary-note: #ffffff;
  --mod1-secondary-note: #222222;

  --mod2-primary-channel: #444444;
  --mod2-secondary-channel: #222222;
  --mod2-primary-note: #ffffff;
  --mod2-secondary-note: #333333;

  --mod3-primary-channel: #555555;
  --mod3-secondary-channel: #333333;
  --mod3-primary-note: #ffffff;
  --mod3-secondary-note: #444444;

  --mod4-primary-channel: #666666;
  --mod4-secondary-channel: #444444;
  --mod4-primary-note: #ffffff;
  --mod4-secondary-note: #555555;

  --mod-label-primary: #ffffff;
  --mod-label-secondary-text: #000000;
  --mod-label-primary-text: #111111;
  --disabled-note-primary: #222222;
  --disabled-note-secondary: #000000;
}
`,
"WinterIsComing":`
:root {
  -webkit-text-stroke-width: 0.3px;
  --page-margin: #0B1B2B;
  --editor-background: #101C2E;
  --hover-preview: #3C5A75;
  --playhead: #A0C8FF;
  --primary-text: #E0F4FF;
  --secondary-text: #B3D7F0;
  --inverted-text: #0E1A24;
  --text-selection: #39556F;
  --box-selection-fill: #5078A1;
  --loop-accent: #7FB6FF;
  --link-accent: #A5D4FF;
  --ui-widget-background: #1A2C40;
  --ui-widget-focus: #3E6C91;
  --pitch-background: #132535;
  --tonic: #B7DAFF;
  --fifth-note: #89B6D6;
  --white-piano-key-color: #0D1B29;
  --black-piano-key-color: #EAF6FF;
  --white-piano-key: #D0E4F2;
  --black-piano-key: #1C2C3C;
  --use-color-formula: false;
  --track-editor-bg-pitch: #1B3550;
  --track-editor-bg-pitch-dim: #1A2F44;
  --track-editor-bg-noise: #1C3B58;
  --track-editor-bg-noise-dim: #2B4F6C;
  --track-editor-bg-mod: #2C4968;
  --track-editor-bg-mod-dim: #4A6C89;
  --multiplicative-mod-slider: #A0C8FF;
  --overwriting-mod-slider: #85B5E2;
  --indicator-primary: #A9D7FF;
  --indicator-secondary: #6C99B8;
  --select2-opt-group: #345066;
  --input-box-outline: #6699BB;
  --mute-button-normal: #E2F3FF;
  --mute-button-mod: #CDEBFF;

  /* pitch */
  --pitch1-primary-channel: #A6D9FF;
  --pitch1-secondary-channel: #7AB8E6;
  --pitch1-primary-note: #C6E7FF;
  --pitch1-secondary-note: #527D9A;

  --pitch2-primary-channel: #90C4F0;
  --pitch2-secondary-channel: #6CA2D3;
  --pitch2-primary-note: #B8DEF7;
  --pitch2-secondary-note: #4C7594;

  --pitch3-primary-channel: #78B0D6;
  --pitch3-secondary-channel: #568FB8;
  --pitch3-primary-note: #A7CCE7;
  --pitch3-secondary-note: #3A6C87;

  --pitch4-primary-channel: #6BA2C8;
  --pitch4-secondary-channel: #4A7CA5;
  --pitch4-primary-note: #9FC0DD;
  --pitch4-secondary-note: #325E7A;

  --pitch5-primary-channel: #5D92B7;
  --pitch5-secondary-channel: #3D6F89;
  --pitch5-primary-note: #8FB3D0;
  --pitch5-secondary-note: #2A526B;

  --pitch6-primary-channel: #4C819F;
  --pitch6-secondary-channel: #345E73;
  --pitch6-primary-note: #7AA5C2;
  --pitch6-secondary-note: #22475A;

  --pitch7-primary-channel: #3F6E89;
  --pitch7-secondary-channel: #2D5369;
  --pitch7-primary-note: #6991AD;
  --pitch7-secondary-note: #1B3B4B;

  --pitch8-primary-channel: #325C73;
  --pitch8-secondary-channel: #26475A;
  --pitch8-primary-note: #5A7D99;
  --pitch8-secondary-note: #152E3A;

  --pitch9-primary-channel: #26475A;
  --pitch9-secondary-channel: #1B3A49;
  --pitch9-primary-note: #4C6B83;
  --pitch9-secondary-note: #0F222E;

  --pitch10-primary-channel: #1C3441;
  --pitch10-secondary-channel: #12242D;
  --pitch10-primary-note: #3A5466;
  --pitch10-secondary-note: #0A151C;

  /* noise */
  --noise1-primary-channel: #A6D9FF;
  --noise1-secondary-channel: #7AB8E6;
  --noise1-primary-note: #C6E7FF;
  --noise1-secondary-note: #527D9A;

  --noise2-primary-channel: #90C4F0;
  --noise2-secondary-channel: #6CA2D3;
  --noise2-primary-note: #B8DEF7;
  --noise2-secondary-note: #4C7594;

  --noise3-primary-channel: #78B0D6;
  --noise3-secondary-channel: #568FB8;
  --noise3-primary-note: #A7CCE7;
  --noise3-secondary-note: #3A6C87;

  --noise4-primary-channel: #5D92B7;
  --noise4-secondary-channel: #3D6F89;
  --noise4-primary-note: #8FB3D0;
  --noise4-secondary-note: #2A526B;

  --noise5-primary-channel: #4C819F;
  --noise5-secondary-channel: #345E73;
  --noise5-primary-note: #7AA5C2;
  --noise5-secondary-note: #22475A;

  /* mod */
  --mod1-primary-channel: #7FC5E9;
  --mod1-secondary-channel: #5EAED9;
  --mod1-primary-note: #A8E0FA;
  --mod1-secondary-note: #3A84A9;

  --mod2-primary-channel: #6CB0D4;
  --mod2-secondary-channel: #4C94BB;
  --mod2-primary-note: #9BD4ED;
  --mod2-secondary-note: #2C6D8F;

  --mod3-primary-channel: #5C9DC0;
  --mod3-secondary-channel: #3E7CA3;
  --mod3-primary-note: #8AC2DD;
  --mod3-secondary-note: #255B75;

  --mod4-primary-channel: #4D8BAE;
  --mod4-secondary-channel: #346C8A;
  --mod4-primary-note: #7AB0CC;
  --mod4-secondary-note: #1E4A60;

  --mod-label-primary: #D5F4FF;
  --mod-label-secondary-text: #13212A;
  --mod-label-primary-text: #316D8A;
  --disabled-note-primary: #202F3C;
  --disabled-note-secondary: #101C2A;
}
`,
"Mirage": `
:root {
  -webkit-text-stroke-width: 0.5px;
  --page-margin: #3C3C5F;
  --editor-background: #181825;
  --hover-preview: #7FE4E4;
  --playhead: #9FF1F1;
  --primary-text: #D0F6FF;
  --secondary-text: #A3D9F5;
  --inverted-text: #0E1E2E;
  --text-selection: #3FA3C4;
  --box-selection-fill: #5AD1F5;
  --loop-accent: #5EEBEA;
  --link-accent: #67C3F3;
  --ui-widget-background: #23344A;
  --ui-widget-focus: #5EDFF2;
  --pitch-background: #1D2A3B;
  --tonic: #38D1F2;
  --fifth-note: #44B9FF;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #9FE4FF;
  --black-piano-key: #14202F;
  --use-color-formula: false;
  --track-editor-bg-pitch: #204B6F;
  --track-editor-bg-pitch-dim: #1B3C59;
  --track-editor-bg-noise: #265A75;
  --track-editor-bg-noise-dim: #2C6C85;
  --track-editor-bg-mod: #2F6D8A;
  --track-editor-bg-mod-dim: #70BFEF;
  --multiplicative-mod-slider: #5AD1F5;
  --overwriting-mod-slider: #3FBCE4;
  --indicator-primary: #71F4F9;
  --indicator-secondary: #48C0DB;
  --select2-opt-group: #42A8C7;
  --input-box-outline: #3A9BC9;
  --mute-button-normal: #DDF9FF;
  --mute-button-mod: #C9F3FF;

  /* pitch */
  --pitch1-primary-channel: #7FE8FF;
  --pitch1-secondary-channel: #4DDFFF;
  --pitch1-primary-note: #AAEFFC;
  --pitch1-secondary-note: #44B3BB;

  --pitch2-primary-channel: #7FBEFF;
  --pitch2-secondary-channel: #4D98FF;
  --pitch2-primary-note: #AAD7FF;
  --pitch2-secondary-note: #4473BB;

  --pitch3-primary-channel: #9D79FF;
  --pitch3-secondary-channel: #6F4DFF;
  --pitch3-primary-note: #C3AAFF;
  --pitch3-secondary-note: #6A44BB;

  --pitch4-primary-channel: #FF79EC;
  --pitch4-secondary-channel: #FF4DD0;
  --pitch4-primary-note: #FFA8F3;
  --pitch4-secondary-note: #BB44A5;

  --pitch5-primary-channel: #FF799A;
  --pitch5-secondary-channel: #FF4D8B;
  --pitch5-primary-note: #FFAAC3;
  --pitch5-secondary-note: #BB4470;

  --pitch6-primary-channel: #FFD279;
  --pitch6-secondary-channel: #FFC04D;
  --pitch6-primary-note: #FFEAAA;
  --pitch6-secondary-note: #BB9B44;

  --pitch7-primary-channel: #C5FF79;
  --pitch7-secondary-channel: #AFFF4D;
  --pitch7-primary-note: #E6FFAA;
  --pitch7-secondary-note: #93BB44;

  --pitch8-primary-channel: #79FFC8;
  --pitch8-secondary-channel: #4DFFBA;
  --pitch8-primary-note: #AAFFE5;
  --pitch8-secondary-note: #44BB9E;

  --pitch9-primary-channel: #79F0FF;
  --pitch9-secondary-channel: #4DDAFF;
  --pitch9-primary-note: #AAEFFF;
  --pitch9-secondary-note: #44A0BB;

  --pitch10-primary-channel: #ADB5FF;
  --pitch10-secondary-channel: #94A1FF;
  --pitch10-primary-note: #D1D4FF;
  --pitch10-secondary-note: #6F73BB;

  /* noise */
  --noise1-primary-channel: #78C8FF;
  --noise1-secondary-channel: #4DB9FF;
  --noise1-primary-note: #A7E5FF;
  --noise1-secondary-note: #4599BB;

  --noise2-primary-channel: #79E8FF;
  --noise2-secondary-channel: #4DE2FF;
  --noise2-primary-note: #AAF1FF;
  --noise2-secondary-note: #44AABB;

  --noise3-primary-channel: #79FFF1;
  --noise3-secondary-channel: #4DFFEA;
  --noise3-primary-note: #AAFFF5;
  --noise3-secondary-note: #44BBA7;

  --noise4-primary-channel: #B4FF79;
  --noise4-secondary-channel: #9AFF4D;
  --noise4-primary-note: #DAFFAA;
  --noise4-secondary-note: #93BB44;

  --noise5-primary-channel: #FF79C1;
  --noise5-secondary-channel: #FF4DAB;
  --noise5-primary-note: #FFAADB;
  --noise5-secondary-note: #BB4484;

  /* mod */
  --mod1-primary-channel: #A6FFF9;
  --mod1-secondary-channel: #8DFFF3;
  --mod1-primary-note: #CFFAF9;
  --mod1-secondary-note: #61BBBB;

  --mod2-primary-channel: #8FB8FF;
  --mod2-secondary-channel: #79A8FF;
  --mod2-primary-note: #B9D5FF;
  --mod2-secondary-note: #6B8DBB;

  --mod3-primary-channel: #D2B7FF;
  --mod3-secondary-channel: #C38CFF;
  --mod3-primary-note: #EAD5FF;
  --mod3-secondary-note: #9C6ABB;

  --mod4-primary-channel: #FFE4A6;
  --mod4-secondary-channel: #FFD38C;
  --mod4-primary-note: #FFF2C9;
  --mod4-secondary-note: #BB9F61;

  --mod-label-primary: #D6FFF3;
  --mod-label-secondary-text: #0E1A20;
  --mod-label-primary-text: #2A6A7F;
  --disabled-note-primary: #2C2C2C;
  --disabled-note-secondary: #1A1A1A;
}
`,



"FruityBox":`
:root {
				-webkit-text-stroke-width: 0.5px;
  --page-margin: #764FCE;
  --editor-background: #1A1D3D;
  --hover-preview: #E998B2;
  --playhead: #BC60FF;
  --primary-text: #F8C0FD;
  --secondary-text: #FF99EA;
  --inverted-text: #3C0D47;
  --text-selection: #BF90C5;
  --box-selection-fill: #E39EFF;
  --loop-accent: #9F24FF;
  --link-accent: #A95AFF;
  --ui-widget-background: #622C6E;
  --ui-widget-focus: #BB66FF;
  --pitch-background: #2A1F4E;
  --tonic: #7A4CFF;
  --fifth-note: #7B50FF;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #B6A3FF;
  --black-piano-key: #1E1733;
  --use-color-formula: false;
  --track-editor-bg-pitch: #472CC8;
  --track-editor-bg-pitch-dim: #423E9B;
  --track-editor-bg-noise: #4C3C9C;
  --track-editor-bg-noise-dim: #585DB1;
  --track-editor-bg-mod: #5C55A0;
  --track-editor-bg-mod-dim: #9B90FF;
  --multiplicative-mod-slider: #A099FF;
  --overwriting-mod-slider: #808EFF;
  --indicator-primary: #B566FF;
  --indicator-secondary: #9366CC;
  --select2-opt-group: #7D4CFF;
  --input-box-outline: #8B4DAF;
  --mute-button-normal: #DFDDFF;
  --mute-button-mod: #DDDEFF;
  
  /* pitch */
  --pitch1-primary-channel: #FF7979;
  --pitch1-secondary-channel: #FF4D4D;
  --pitch1-primary-note: #FFAAAA;
  --pitch1-secondary-note: #BB4444;
  
  --pitch2-primary-channel: #FFC879;
  --pitch2-secondary-channel: #FFDC4D;
  --pitch2-primary-note: #FFFEAA;
  --pitch2-secondary-note: #7F8B39;
  
  --pitch3-primary-channel: #94EA69;
  --pitch3-secondary-channel: #62FF4D;
  --pitch3-primary-note: #B3FFAA;
  --pitch3-secondary-note: #5BBB44;
  
  --pitch4-primary-channel: #79FFBB;
  --pitch4-secondary-channel: #4DFFB7;
  --pitch4-primary-note: #AAFFD4;
  --pitch4-secondary-note: #44BB94;
  
  --pitch5-primary-channel: #79FCFF;
  --pitch5-secondary-channel: #4DFFE5;
  --pitch5-primary-note: #AAFFF7;
  --pitch5-secondary-note: #44BBB8;
  
  --pitch6-primary-channel: #798FFF;
  --pitch6-secondary-channel: #4DB7FF;
  --pitch6-primary-note: #AAD5FF;
  --pitch6-secondary-note: #4487BB;
  
  --pitch7-primary-channel: #8F79FF;
  --pitch7-secondary-channel: #504DFF;
  --pitch7-primary-note: #BFAAFF;
  --pitch7-secondary-note: #6F44BB;
  
  --pitch8-primary-channel: #F779FF;
  --pitch8-secondary-channel: #FF4DFB;
  --pitch8-primary-note: #F8AAFF;
  --pitch8-secondary-note: #BB44BA;
  
  --pitch9-primary-channel: #FF79A8;
  --pitch9-secondary-channel: #FF4DB2;
  --pitch9-primary-note: #FFAAD3;
  --pitch9-secondary-note: #BB447B;
  --pitch10-primary-channel: #FFA679;
  --pitch10-secondary-channel: #FF984D;
  --pitch10-primary-note: #FFD7AA;
  --pitch10-secondary-note: #BB8644;
  
  /* noise */
  --noise1-primary-channel: #FF7979;
  --noise1-secondary-channel: #FF4D4D;
  --noise1-primary-note: #FFAAAA;
  
  --noise1-secondary-note: #BB8444;
  --noise2-primary-channel: #FFC279;
  --noise2-secondary-channel: #FFAA4D;
  --noise2-primary-note: #FFE0AA;
  --noise2-secondary-note: #BB8D44;
  
  --noise3-primary-channel: #DFFF79;
  --noise3-secondary-channel: #DFFF4D;
  --noise3-primary-note: #F7FFAA;
  --noise3-secondary-note: #B6BB44;
  
  --noise4-primary-channel: #8DFF79;
  --noise4-secondary-channel: #4DFF52;
  --noise4-primary-note: #AAFFB7;
  --noise4-secondary-note: #5BBB44;
  
  --noise5-primary-channel: #79F4FF;
  --noise5-secondary-channel: #4DF8FF;
  --noise5-primary-note: #AAF5FF;
  --noise5-secondary-note: #44B4BB;
  
  /* mod */
  --mod1-primary-channel: #79FFF0;
  --mod1-secondary-channel: #4DFFEC;
  --mod1-primary-note: #AAFFF9;
  --mod1-secondary-note: #44B1BB;
  
  --mod2-primary-channel: #79BEFF;
  --mod2-secondary-channel: #4D78FF;
  --mod2-primary-note: #AAE2FF;
  --mod2-secondary-note: #448DBB;
  
  --mod3-primary-channel: #79FFF8;
  --mod3-secondary-channel: #4DF7FF;
  --mod3-primary-note: #AAF7FF;
  --mod3-secondary-note: #44BBB1;
  
  --mod4-primary-channel: #79BCFF;
  --mod4-secondary-channel: #4DCDFF;
  --mod4-primary-note: #AAD6FF;
  --mod4-secondary-note: #449EBB;
  
  --mod-label-primary: #D6FFF3;
  --mod-label-secondary-text: #1C3A3F;
  --mod-label-primary-text: #316D7D;
  --disabled-note-primary: #2C2C2C;
  --disabled-note-secondary: #1A1A1A;
}
`,
"FruityBox Dark": `
:root {
  -webkit-text-stroke-width: 0.6px;
  --page-margin: #5A3EB0;
  --editor-background: #0C0C1C;
  --hover-preview: #FFB7D7;
  --playhead: #D680FF;
  --primary-text: #FFFFFF;
  --secondary-text: #FFD0FB;
  --inverted-text: #200020;
  --text-selection: #DCA3E5;
  --box-selection-fill: #F0A9FF;
  --loop-accent: #BB44FF;
  --link-accent: #C06AFF;
  --ui-widget-background: #431547;
  --ui-widget-focus: #D38EFF;
  --pitch-background: #1B1333;
  --tonic: #9A66FF;
  --fifth-note: #9C6EFF;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #A390FF;
  --black-piano-key: #140D22;
  --use-color-formula: false;
  --track-editor-bg-pitch: #361B99;
  --track-editor-bg-pitch-dim: #2A2575;
  --track-editor-bg-noise: #392675;
  --track-editor-bg-noise-dim: #464A91;
  --track-editor-bg-mod: #4A438B;
  --track-editor-bg-mod-dim: #A398FF;
  --multiplicative-mod-slider: #B3A9FF;
  --overwriting-mod-slider: #9FADFF;
  --indicator-primary: #D780FF;
  --indicator-secondary: #B066D6;
  --select2-opt-group: #9A66FF;
  --input-box-outline: #A55DC5;
  --mute-button-normal: #FFFFFF;
  --mute-button-mod: #EEEFFF;

  /* pitch */
  --pitch1-primary-channel: #FF4D4D;
  --pitch1-secondary-channel: #FF0000;
  --pitch1-primary-note: #FF9999;
  --pitch1-secondary-note: #990000;

  --pitch2-primary-channel: #FFC94D;
  --pitch2-secondary-channel: #FFD700;
  --pitch2-primary-note: #FFF4AA;
  --pitch2-secondary-note: #7F6B00;

  --pitch3-primary-channel: #8DFF4D;
  --pitch3-secondary-channel: #4DFF00;
  --pitch3-primary-note: #C8FFAA;
  --pitch3-secondary-note: #448800;

  --pitch4-primary-channel: #4DFFC9;
  --pitch4-secondary-channel: #00FFAA;
  --pitch4-primary-note: #AAFFE8;
  --pitch4-secondary-note: #008866;

  --pitch5-primary-channel: #4DFAFF;
  --pitch5-secondary-channel: #00E5FF;
  --pitch5-primary-note: #AAFAFF;
  --pitch5-secondary-note: #0088AA;

  --pitch6-primary-channel: #4D6BFF;
  --pitch6-secondary-channel: #005EFF;
  --pitch6-primary-note: #AAB8FF;
  --pitch6-secondary-note: #003C88;

  --pitch7-primary-channel: #6B4DFF;
  --pitch7-secondary-channel: #3F00FF;
  --pitch7-primary-note: #D2AAFF;
  --pitch7-secondary-note: #3C0088;

  --pitch8-primary-channel: #FF4DFF;
  --pitch8-secondary-channel: #FF00FB;
  --pitch8-primary-note: #FFAAFF;
  --pitch8-secondary-note: #990099;

  --pitch9-primary-channel: #FF4D8D;
  --pitch9-secondary-channel: #FF0070;
  --pitch9-primary-note: #FFAACB;
  --pitch9-secondary-note: #880044;

  --pitch10-primary-channel: #FF894D;
  --pitch10-secondary-channel: #FF6600;
  --pitch10-primary-note: #FFCCAA;
  --pitch10-secondary-note: #884400;

  /* noise */
  --noise1-primary-channel: #FF3D3D;
  --noise1-secondary-channel: #CC0000;
  --noise1-primary-note: #FF8888;
  --noise1-secondary-note: #992200;

  --noise2-primary-channel: #FFA54D;
  --noise2-secondary-channel: #FF8800;
  --noise2-primary-note: #FFDD99;
  --noise2-secondary-note: #885500;

  --noise3-primary-channel: #CFFF3D;
  --noise3-secondary-channel: #BFFF00;
  --noise3-primary-note: #F0FFAA;
  --noise3-secondary-note: #6C8800;

  --noise4-primary-channel: #6DFF3D;
  --noise4-secondary-channel: #3DFF00;
  --noise4-primary-note: #B9FFAA;
  --noise4-secondary-note: #448800;

  --noise5-primary-channel: #3DDBFF;
  --noise5-secondary-channel: #00D1FF;
  --noise5-primary-note: #AADDFF;
  --noise5-secondary-note: #006688;

  /* mod */
  --mod1-primary-channel: #3DFFED;
  --mod1-secondary-channel: #00FFE0;
  --mod1-primary-note: #AAFFF8;
  --mod1-secondary-note: #00887A;

  --mod2-primary-channel: #3DAAFF;
  --mod2-secondary-channel: #007BFF;
  --mod2-primary-note: #AAD8FF;
  --mod2-secondary-note: #0055AA;

  --mod3-primary-channel: #3DFFE9;
  --mod3-secondary-channel: #00FFDE;
  --mod3-primary-note: #AAFFED;
  --mod3-secondary-note: #008877;

  --mod4-primary-channel: #3DADFF;
  --mod4-secondary-channel: #00BBFF;
  --mod4-primary-note: #AAD3FF;
  --mod4-secondary-note: #0070AA;

  --mod-label-primary: #E8FFF9;
  --mod-label-secondary-text: #002830;
  --mod-label-primary-text: #258699;

  --disabled-note-primary: #151515;
  --disabled-note-secondary: #0A0A0A;
}

`,

"FruityBoxLight":`
:root {
  --page-margin: #D7C8FF;
  --editor-background: #F8F7FF;
  --hover-preview: #FFB6CE;
  --playhead: #9A3DD9;
  --primary-text: #3D0842;
  --secondary-text: #5B2E51;
  --inverted-text: #FFFFFF;
  --text-selection: #EFC4E9;
  --box-selection-fill: #D9B3FF;
  --loop-accent: #8B2CE6;
  --link-accent: #A347DF;
  --ui-widget-background: #EFD3E7;
  --ui-widget-focus: #D5A8FF;
  --pitch-background: #F2ECFF;
  --tonic: #A579FF;
  --fifth-note: #9F83FF;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #FFFFFF;
  --black-piano-key: #D4C4FF;
  --use-color-formula: false;
  --track-editor-bg-pitch: #D7CCFF;
  --track-editor-bg-pitch-dim: #E3DFFF;
  --track-editor-bg-noise: #DED0FF;
  --track-editor-bg-noise-dim: #EAE2FF;
  --track-editor-bg-mod: #E2D8FF;
  --track-editor-bg-mod-dim: #F0E7FF;
  --multiplicative-mod-slider: #C2B8FF;
  --overwriting-mod-slider: #B0B6FF;
  --indicator-primary: #AD66FF;
  --indicator-secondary: #B799D9;
  --select2-opt-group: #C6B1FF;
  --input-box-outline: #C09DE9;
  --mute-button-normal: #3C3C3C;
  --mute-button-mod: #4A4A4A;

  /* pitch - saturated */
  --pitch1-primary-channel: #FF1A1A;
  --pitch1-secondary-channel: #FF4D4D;
  --pitch1-primary-note: #FFA0A0;
  --pitch1-secondary-note: #D94C4C;

  --pitch2-primary-channel: #FF9500;
  --pitch2-secondary-channel: #FFD000;
  --pitch2-primary-note: #FFE4AA;
  --pitch2-secondary-note: #C48300;

  --pitch3-primary-channel: #7EE600;
  --pitch3-secondary-channel: #BFFF66;
  --pitch3-primary-note: #DAFFB0;
  --pitch3-secondary-note: #64AA00;

  --pitch4-primary-channel: #00E6C0;
  --pitch4-secondary-channel: #66FFE5;
  --pitch4-primary-note: #B2FFF4;
  --pitch4-secondary-note: #00AA8F;

  --pitch5-primary-channel: #00C9FF;
  --pitch5-secondary-channel: #66E0FF;
  --pitch5-primary-note: #B3ECFF;
  --pitch5-secondary-note: #0094CC;

  --pitch6-primary-channel: #597EFF;
  --pitch6-secondary-channel: #8FAFFF;
  --pitch6-primary-note: #C9D5FF;
  --pitch6-secondary-note: #3B5BCC;

  --pitch7-primary-channel: #7A4DFF;
  --pitch7-secondary-channel: #B088FF;
  --pitch7-primary-note: #DAC9FF;
  --pitch7-secondary-note: #5C2ECC;

  --pitch8-primary-channel: #E600E6;
  --pitch8-secondary-channel: #FF80FF;
  --pitch8-primary-note: #FFCCFF;
  --pitch8-secondary-note: #B800B8;

  --pitch9-primary-channel: #FF4D8D;
  --pitch9-secondary-channel: #FF99C2;
  --pitch9-primary-note: #FFCFE3;
  --pitch9-secondary-note: #B8406A;

  --pitch10-primary-channel: #FFA04D;
  --pitch10-secondary-channel: #FFCCA6;
  --pitch10-primary-note: #FFE4C9;
  --pitch10-secondary-note: #CC7633;

  /* noise - saturated */
  --noise1-primary-channel: #FF6666;
  --noise1-secondary-channel: #FF9999;
  --noise1-primary-note: #FFD9D9;
  --noise1-secondary-note: #CC7040;

  --noise2-primary-channel: #FFB347;
  --noise2-secondary-channel: #FFD180;
  --noise2-primary-note: #FFEEC0;
  --noise2-secondary-note: #C28534;

  --noise3-primary-channel: #E6FF33;
  --noise3-secondary-channel: #F7FF66;
  --noise3-primary-note: #FDFFB0;
  --noise3-secondary-note: #C0C040;

  --noise4-primary-channel: #66FF66;
  --noise4-secondary-channel: #B2FFB2;
  --noise4-primary-note: #DAFFDA;
  --noise4-secondary-note: #66BB66;

  --noise5-primary-channel: #66E6FF;
  --noise5-secondary-channel: #B2F5FF;
  --noise5-primary-note: #D9FAFF;
  --noise5-secondary-note: #40AACC;

  /* mod - saturated */
  --mod1-primary-channel: #80FFF9;
  --mod1-secondary-channel: #B3FFF9;
  --mod1-primary-note: #D1FFFC;
  --mod1-secondary-note: #339999;

  --mod2-primary-channel: #6699FF;
  --mod2-secondary-channel: #A3C2FF;
  --mod2-primary-note: #D1E0FF;
  --mod2-secondary-note: #4066CC;

  --mod3-primary-channel: #66FFFF;
  --mod3-secondary-channel: #B3FFFF;
  --mod3-primary-note: #D1FFFF;
  --mod3-secondary-note: #40CCCC;

  --mod4-primary-channel: #66CCFF;
  --mod4-secondary-channel: #A3E0FF;
  --mod4-primary-note: #D1F0FF;
  --mod4-secondary-note: #3399CC;

  --mod-label-primary: #004A3F;
  --mod-label-secondary-text: #F0FFF9;
  --mod-label-primary-text: #D8FDF5;
  --disabled-note-primary: #CCCCCC;
  --disabled-note-secondary: #EEEEEE;
}

.beepboxEditor button, .beepboxEditor select {
  box-shadow: inset 0 0 0 1px var(--secondary-text);
}

.select2-selection__rendered {
  box-shadow: inset 0 0 0 1px var(--secondary-text);
}
`,

"coolred":`:root {
  --page-margin: #BB1717;
  --editor-background: #3D1A1A;
  --hover-preview: #FFD7D7;
  --playhead: #FF6060;
  --primary-text: #FFE3E3;
  --secondary-text: #FF9999;
  --inverted-text: #320A0A;
  --text-selection: #FFC8C8;
  --box-selection-fill: #FF9E9E;
  --loop-accent: #FF6969;
  --link-accent: #FF5A5A;
  --ui-widget-background: #6E2C2C;
  --ui-widget-focus: #FF6666;
  --pitch-background: #4E1F1F;
  --tonic: #FF4C4C;
  --fifth-note: #FF5050;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #FFA3A3;
  --black-piano-key: #331717;
  --use-color-formula: false;
  --track-editor-bg-pitch: #8A2C2C;
  --track-editor-bg-pitch-dim: #9B3E3E;
  --track-editor-bg-noise: #9C3C3C;
  --track-editor-bg-noise-dim: #B15858;
  --track-editor-bg-mod: #A05555;
  --track-editor-bg-mod-dim: #FF9090;
  --multiplicative-mod-slider: #FF9999;
  --overwriting-mod-slider: #FF8080;
  --indicator-primary: #FF6666;
  --indicator-secondary: #CC6666;
  --select2-opt-group: #FF4C4C;
  --input-box-outline: #AF4D4D;
  --mute-button-normal: #FFDDDD;
  --mute-button-mod: #FFDDDD;
  
  /* pitch */
  --pitch1-primary-channel: #FF7979;
  --pitch1-secondary-channel: #FF4D4D;
  --pitch1-primary-note: #FFAAAA;
  --pitch1-secondary-note: #BB4444;
  --pitch2-primary-channel: #FF7979;
  --pitch2-secondary-channel: #FF4D4D;
  --pitch2-primary-note: #FFAAAA;
  --pitch2-secondary-note: #8B3939;
  --pitch3-primary-channel: #EA6969;
  --pitch3-secondary-channel: #FF4D4D;
  --pitch3-primary-note: #FFAAAA;
  --pitch3-secondary-note: #BB4444;
  --pitch4-primary-channel: #FF7979;
  --pitch4-secondary-channel: #FF4D4D;
  --pitch4-primary-note: #FFAAAA;
  --pitch4-secondary-note: #BB4444;
  --pitch5-primary-channel: #FF7979;
  --pitch5-secondary-channel: #FF4D4D;
  --pitch5-primary-note: #FFAAAA;
  --pitch5-secondary-note: #BB4444;
  --pitch6-primary-channel: #FF7979;
  --pitch6-secondary-channel: #FF4D4D;
  --pitch6-primary-note: #FFAAAA;
  --pitch6-secondary-note: #BB4444;
  --pitch7-primary-channel: #FF7979;
  --pitch7-secondary-channel: #FF4D4D;
  --pitch7-primary-note: #FFAAAA;
  --pitch7-secondary-note: #BB4444;
  --pitch8-primary-channel: #FF7979;
  --pitch8-secondary-channel: #FF4D4D;
  --pitch8-primary-note: #FFAAAA;
  --pitch8-secondary-note: #BB4444;
  --pitch9-primary-channel: #FF7979;
  --pitch9-secondary-channel: #FF4D4D;
  --pitch9-primary-note: #FFAAAA;
  --pitch9-secondary-note: #BB4444;
  --pitch10-primary-channel: #FF7979;
  --pitch10-secondary-channel: #FF4D4D;
  --pitch10-primary-note: #FFAAAA;
  --pitch10-secondary-note: #BB4444;
  
  /* noise */
  --noise1-primary-channel: #FF7979;
  --noise1-secondary-channel: #FF4D4D;
  --noise1-primary-note: #FFAAAA;
  --noise1-secondary-note: #BB4444;
  --noise2-primary-channel: #FF7979;
  --noise2-secondary-channel: #FF4D4D;
  --noise2-primary-note: #FFAAAA;
  --noise2-secondary-note: #BB4444;
  --noise3-primary-channel: #FF7979;
  --noise3-secondary-channel: #FF4D4D;
  --noise3-primary-note: #FFAAAA;
  --noise3-secondary-note: #BB4444;
  --noise4-primary-channel: #FF7979;
  --noise4-secondary-channel: #FF4D4D;
  --noise4-primary-note: #FFAAAA;
  --noise4-secondary-note: #BB4444;
  --noise5-primary-channel: #FF7979;
  --noise5-secondary-channel: #FF4D4D;
  --noise5-primary-note: #FFAAAA;
  --noise5-secondary-note: #BB4444;
  
  /* mod */
  --mod1-primary-channel: #FF7979;
  --mod1-secondary-channel: #FF4D4D;
  --mod1-primary-note: #FFAAAA;
  --mod1-secondary-note: #BB4444;
  --mod2-primary-channel: #FF7979;
  --mod2-secondary-channel: #FF4D4D;
  --mod2-primary-note: #FFAAAA;
  --mod2-secondary-note: #BB4444;
  --mod3-primary-channel: #FF7979;
  --mod3-secondary-channel: #FF4D4D;
  --mod3-primary-note: #FFAAAA;
  --mod3-secondary-note: #BB4444;
  --mod4-primary-channel: #FF7979;
  --mod4-secondary-channel: #FF4D4D;
  --mod4-primary-note: #FFAAAA;
  --mod4-secondary-note: #BB4444;
  
  --mod-label-primary: #FFD6D6;
  --mod-label-secondary-text: #3F1C1C;
  --mod-label-primary-text: #7A3E3E;
  --disabled-note-primary: #2C2C2C;
  --disabled-note-secondary: #1A1A1A;
}`,
"coollime":`
:root {
  --page-margin: #4CBB17;
  --editor-background: #1A3D1A;
  --hover-preview: #D7FFD9;
  --playhead: #A8FF60;
  --primary-text: #E8FFE3;
  --secondary-text: #B2FF99;
  --inverted-text: #0A320A;
  --text-selection: #C8FFC8;
  --box-selection-fill: #9EFF9E;
  --loop-accent: #B6FF69;
  --link-accent: #A2FF5A;
  --ui-widget-background: #2C6E2C;
  --ui-widget-focus: #66FF66;
  --pitch-background: #1F4E1F;
  --tonic: #C4FF4C;
  --fifth-note: #7FFF50;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #C7FFA3;
  --black-piano-key: #173317;
  --use-color-formula: false;
  --track-editor-bg-pitch: #2C8A2C;
  --track-editor-bg-pitch-dim: #3E9B3E;
  --track-editor-bg-noise: #3C9C3C;
  --track-editor-bg-noise-dim: #58B158;
  --track-editor-bg-mod: #55A055;
  --track-editor-bg-mod-dim: #90FF90;
  --multiplicative-mod-slider: #99FF99;
  --overwriting-mod-slider: #AFFF80;
  --indicator-primary: #88FF66;
  --indicator-secondary: #66CC66;
  --select2-opt-group: #75FF4C;
  --input-box-outline: #5DAF4D;
  --mute-button-normal: #EBFFDD;
  --mute-button-mod: #EBFFDD;

  /* pitch */
  --pitch1-primary-channel: #B9FF79;
  --pitch1-secondary-channel: #8CFF4D;
  --pitch1-primary-note: #CCFFAA;
  --pitch1-secondary-note: #66BB44;
  --pitch2-primary-channel: #B9FF79;
  --pitch2-secondary-channel: #8CFF4D;
  --pitch2-primary-note: #CCFFAA;
  --pitch2-secondary-note: #66BB44;
  --pitch3-primary-channel: #B9FF79;
  --pitch3-secondary-channel: #8CFF4D;
  --pitch3-primary-note: #CCFFAA;
  --pitch3-secondary-note: #66BB44;
  --pitch4-primary-channel: #B9FF79;
  --pitch4-secondary-channel: #8CFF4D;
  --pitch4-primary-note: #CCFFAA;
  --pitch4-secondary-note: #66BB44;
  --pitch5-primary-channel: #B9FF79;
  --pitch5-secondary-channel: #8CFF4D;
  --pitch5-primary-note: #CCFFAA;
  --pitch5-secondary-note: #66BB44;
  --pitch6-primary-channel: #B9FF79;
  --pitch6-secondary-channel: #8CFF4D;
  --pitch6-primary-note: #CCFFAA;
  --pitch6-secondary-note: #66BB44;
  --pitch7-primary-channel: #B9FF79;
  --pitch7-secondary-channel: #8CFF4D;
  --pitch7-primary-note: #CCFFAA;
  --pitch7-secondary-note: #66BB44;
  --pitch8-primary-channel: #B9FF79;
  --pitch8-secondary-channel: #8CFF4D;
  --pitch8-primary-note: #CCFFAA;
  --pitch8-secondary-note: #66BB44;
  --pitch9-primary-channel: #B9FF79;
  --pitch9-secondary-channel: #8CFF4D;
  --pitch9-primary-note: #CCFFAA;
  --pitch9-secondary-note: #66BB44;
  --pitch10-primary-channel: #B9FF79;
  --pitch10-secondary-channel: #8CFF4D;
  --pitch10-primary-note: #CCFFAA;
  --pitch10-secondary-note: #66BB44;

  /* noise */
  --noise1-primary-channel: #B9FF79;
  --noise1-secondary-channel: #8CFF4D;
  --noise1-primary-note: #CCFFAA;
  --noise1-secondary-note: #66BB44;
  --noise2-primary-channel: #B9FF79;
  --noise2-secondary-channel: #8CFF4D;
  --noise2-primary-note: #CCFFAA;
  --noise2-secondary-note: #66BB44;
  --noise3-primary-channel: #B9FF79;
  --noise3-secondary-channel: #8CFF4D;
  --noise3-primary-note: #CCFFAA;
  --noise3-secondary-note: #66BB44;
  --noise4-primary-channel: #B9FF79;
  --noise4-secondary-channel: #8CFF4D;
  --noise4-primary-note: #CCFFAA;
  --noise4-secondary-note: #66BB44;
  --noise5-primary-channel: #B9FF79;
  --noise5-secondary-channel: #8CFF4D;
  --noise5-primary-note: #CCFFAA;
  --noise5-secondary-note: #66BB44;

  /* mod */
  --mod1-primary-channel: #B9FF79;
  --mod1-secondary-channel: #8CFF4D;
  --mod1-primary-note: #CCFFAA;
  --mod1-secondary-note: #66BB44;
  --mod2-primary-channel: #B9FF79;
  --mod2-secondary-channel: #8CFF4D;
  --mod2-primary-note: #CCFFAA;
  --mod2-secondary-note: #66BB44;
  --mod3-primary-channel: #B9FF79;
  --mod3-secondary-channel: #8CFF4D;
  --mod3-primary-note: #CCFFAA;
  --mod3-secondary-note: #66BB44;
  --mod4-primary-channel: #B9FF79;
  --mod4-secondary-channel: #8CFF4D;
  --mod4-primary-note: #CCFFAA;
  --mod4-secondary-note: #66BB44;

  --mod-label-primary: #D6FFD6;
  --mod-label-secondary-text: #1C3F1C;
  --mod-label-primary-text: #3E7A3E;
  --disabled-note-primary: #2C2C2C;
  --disabled-note-secondary: #1A1A1A;
}
`,
"grayscale":`
:root {
  --page-margin: #444444;
  --editor-background: #1A1A1A;
  --hover-preview: #E0E0E0;
  --playhead: #BFBFBF;
  --primary-text: #FFFFFF;
  --secondary-text: #CCCCCC;
  --inverted-text: #000000;
  --text-selection: #AAAAAA;
  --box-selection-fill: #777777;
  --loop-accent: #999999;
  --link-accent: #BBBBBB;
  --ui-widget-background: #333333;
  --ui-widget-focus: #555555;
  --pitch-background: #2A2A2A;
  --tonic: #999999;
  --fifth-note: #666666;
  --white-piano-key-color: #FFFFFF;
  --black-piano-key-color: #000000;
  --white-piano-key: #CCCCCC;
  --black-piano-key: #1A1A1A;
  --use-color-formula: false;
  --track-editor-bg-pitch: #3F3F3F;
  --track-editor-bg-pitch-dim: #2E2E2E;
  --track-editor-bg-noise: #4A4A4A;
  --track-editor-bg-noise-dim: #3D3D3D;
  --track-editor-bg-mod: #5C5C5C;
  --track-editor-bg-mod-dim: #6A6A6A;
  --multiplicative-mod-slider: #888888;
  --overwriting-mod-slider: #A0A0A0;
  --indicator-primary: #999999;
  --indicator-secondary: #777777;
  --select2-opt-group: #555555;
  --input-box-outline: #666666;
  --mute-button-normal: #DDDDDD;
  --mute-button-mod: #DDDDDD;

  /* kanały pitch */
  --pitch1-primary-channel: #999999;
  --pitch1-secondary-channel: #777777;
  --pitch1-primary-note: #AAAAAA;
  --pitch1-secondary-note: #555555;
  --pitch2-primary-channel: #999999;
  --pitch2-secondary-channel: #777777;
  --pitch2-primary-note: #AAAAAA;
  --pitch2-secondary-note: #555555;
  --pitch3-primary-channel: #999999;
  --pitch3-secondary-channel: #777777;
  --pitch3-primary-note: #AAAAAA;
  --pitch3-secondary-note: #555555;
  --pitch4-primary-channel: #999999;
  --pitch4-secondary-channel: #777777;
  --pitch4-primary-note: #AAAAAA;
  --pitch4-secondary-note: #555555;
  --pitch5-primary-channel: #999999;
  --pitch5-secondary-channel: #777777;
  --pitch5-primary-note: #AAAAAA;
  --pitch5-secondary-note: #555555;
  --pitch6-primary-channel: #999999;
  --pitch6-secondary-channel: #777777;
  --pitch6-primary-note: #AAAAAA;
  --pitch6-secondary-note: #555555;
  --pitch7-primary-channel: #999999;
  --pitch7-secondary-channel: #777777;
  --pitch7-primary-note: #AAAAAA;
  --pitch7-secondary-note: #555555;
  --pitch8-primary-channel: #999999;
  --pitch8-secondary-channel: #777777;
  --pitch8-primary-note: #AAAAAA;
  --pitch8-secondary-note: #555555;
  --pitch9-primary-channel: #999999;
  --pitch9-secondary-channel: #777777;
  --pitch9-primary-note: #AAAAAA;
  --pitch9-secondary-note: #555555;
  --pitch10-primary-channel: #999999;
  --pitch10-secondary-channel: #777777;
  --pitch10-primary-note: #AAAAAA;
  --pitch10-secondary-note: #555555;

  /* kanały noise */
  --noise1-primary-channel: #999999;
  --noise1-secondary-channel: #777777;
  --noise1-primary-note: #AAAAAA;
  --noise1-secondary-note: #555555;
  --noise2-primary-channel: #999999;
  --noise2-secondary-channel: #777777;
  --noise2-primary-note: #AAAAAA;
  --noise2-secondary-note: #555555;
  --noise3-primary-channel: #999999;
  --noise3-secondary-channel: #777777;
  --noise3-primary-note: #AAAAAA;
  --noise3-secondary-note: #555555;
  --noise4-primary-channel: #999999;
  --noise4-secondary-channel: #777777;
  --noise4-primary-note: #AAAAAA;
  --noise4-secondary-note: #555555;
  --noise5-primary-channel: #999999;
  --noise5-secondary-channel: #777777;
  --noise5-primary-note: #AAAAAA;
  --noise5-secondary-note: #555555;

  /* kanały mod */
  --mod1-primary-channel: #999999;
  --mod1-secondary-channel: #777777;
  --mod1-primary-note: #AAAAAA;
  --mod1-secondary-note: #555555;
  --mod2-primary-channel: #999999;
  --mod2-secondary-channel: #777777;
  --mod2-primary-note: #AAAAAA;
  --mod2-secondary-note: #555555;
  --mod3-primary-channel: #999999;
  --mod3-secondary-channel: #777777;
  --mod3-primary-note: #AAAAAA;
  --mod3-secondary-note: #555555;
  --mod4-primary-channel: #999999;
  --mod4-secondary-channel: #777777;
  --mod4-primary-note: #AAAAAA;
  --mod4-secondary-note: #555555;

  --mod-label-primary: #BBBBBB;
  --mod-label-secondary-text: #000000;
  --mod-label-primary-text: #666666;
  --disabled-note-primary: #444444;
  --disabled-note-secondary: #222222;
}
`,
 "coolblue":`
 :root {
  --page-margin: #0A3D80;
  --editor-background: #1A2C51;
  --hover-preview: #CFE8FF;
  --playhead: #00BFFF;
  --primary-text: #FFFFFF;
  --secondary-text: #A0CFFF;
  --inverted-text: #000000;
  --text-selection: #99CCFF;
  --box-selection-fill: #3377CC;
  --loop-accent: #66B2FF;
  --link-accent: #3399FF;
  --ui-widget-background: #264D80;
  --ui-widget-focus: #3A75C4;
  --pitch-background: #123466;
  --tonic: #4DA6FF;
  --fifth-note: #1E90FF;
  --white-piano-key-color: #000000;
  --black-piano-key-color: #ffffff;
  --white-piano-key: #A3D1FF;
  --black-piano-key: #1B2E4A;
  --use-color-formula: false;
  --track-editor-bg-pitch: #205BA6;
  --track-editor-bg-pitch-dim: #1A4A8C;
  --track-editor-bg-noise: #194780;
  --track-editor-bg-noise-dim: #336699;
  --track-editor-bg-mod: #2E5D99;
  --track-editor-bg-mod-dim: #4D88CC;
  --multiplicative-mod-slider: #3399FF;
  --overwriting-mod-slider: #66B2FF;
  --indicator-primary: #5599FF;
  --indicator-secondary: #4477CC;
  --select2-opt-group: #3A75C4;
  --input-box-outline: #1F4D99;
  --mute-button-normal: #DDEEFF;
  --mute-button-mod: #DDEEFF;

  /* kanały pitch */
  --pitch1-primary-channel: #3399FF;
  --pitch1-secondary-channel: #66B2FF;
  --pitch1-primary-note: #99CCFF;
  --pitch1-secondary-note: #336699;
  --pitch2-primary-channel: #3399FF;
  --pitch2-secondary-channel: #66B2FF;
  --pitch2-primary-note: #99CCFF;
  --pitch2-secondary-note: #336699;
  --pitch3-primary-channel: #3399FF;
  --pitch3-secondary-channel: #66B2FF;
  --pitch3-primary-note: #99CCFF;
  --pitch3-secondary-note: #336699;
  --pitch4-primary-channel: #3399FF;
  --pitch4-secondary-channel: #66B2FF;
  --pitch4-primary-note: #99CCFF;
  --pitch4-secondary-note: #336699;
  --pitch5-primary-channel: #3399FF;
  --pitch5-secondary-channel: #66B2FF;
  --pitch5-primary-note: #99CCFF;
  --pitch5-secondary-note: #336699;
  --pitch6-primary-channel: #3399FF;
  --pitch6-secondary-channel: #66B2FF;
  --pitch6-primary-note: #99CCFF;
  --pitch6-secondary-note: #336699;
  --pitch7-primary-channel: #3399FF;
  --pitch7-secondary-channel: #66B2FF;
  --pitch7-primary-note: #99CCFF;
  --pitch7-secondary-note: #336699;
  --pitch8-primary-channel: #3399FF;
  --pitch8-secondary-channel: #66B2FF;
  --pitch8-primary-note: #99CCFF;
  --pitch8-secondary-note: #336699;
  --pitch9-primary-channel: #3399FF;
  --pitch9-secondary-channel: #66B2FF;
  --pitch9-primary-note: #99CCFF;
  --pitch9-secondary-note: #336699;
  --pitch10-primary-channel: #3399FF;
  --pitch10-secondary-channel: #66B2FF;
  --pitch10-primary-note: #99CCFF;
  --pitch10-secondary-note: #336699;

  /* kanały noise */
  --noise1-primary-channel: #3399FF;
  --noise1-secondary-channel: #66B2FF;
  --noise1-primary-note: #99CCFF;
  --noise1-secondary-note: #336699;
  --noise2-primary-channel: #3399FF;
  --noise2-secondary-channel: #66B2FF;
  --noise2-primary-note: #99CCFF;
  --noise2-secondary-note: #336699;
  --noise3-primary-channel: #3399FF;
  --noise3-secondary-channel: #66B2FF;
  --noise3-primary-note: #99CCFF;
  --noise3-secondary-note: #336699;
  --noise4-primary-channel: #3399FF;
  --noise4-secondary-channel: #66B2FF;
  --noise4-primary-note: #99CCFF;
  --noise4-secondary-note: #336699;
  --noise5-primary-channel: #3399FF;
  --noise5-secondary-channel: #66B2FF;
  --noise5-primary-note: #99CCFF;
  --noise5-secondary-note: #336699;

  /* kanały mod */
  --mod1-primary-channel: #3399FF;
  --mod1-secondary-channel: #66B2FF;
  --mod1-primary-note: #99CCFF;
  --mod1-secondary-note: #336699;
  --mod2-primary-channel: #3399FF;
  --mod2-secondary-channel: #66B2FF;
  --mod2-primary-note: #99CCFF;
  --mod2-secondary-note: #336699;
  --mod3-primary-channel: #3399FF;
  --mod3-secondary-channel: #66B2FF;
  --mod3-primary-note: #99CCFF;
  --mod3-secondary-note: #336699;
  --mod4-primary-channel: #3399FF;
  --mod4-secondary-channel: #66B2FF;
  --mod4-primary-note: #99CCFF;
  --mod4-secondary-note: #336699;

  --mod-label-primary: #A3C2FF;
  --mod-label-secondary-text: #000000;
  --mod-label-primary-text: #336699;
  --disabled-note-primary: #445566;
  --disabled-note-secondary: #223344;
}
`,

        "dark classic": `
			:root {
				--page-margin: black;
				--editor-background: black;
				--hover-preview: white;
				--playhead: white;
				--primary-text: white;
				--secondary-text: #999;
				--inverted-text: black;
				--text-selection: rgba(119,68,255,0.99);
				--box-selection-fill: rgba(255,255,255,0.2);
				--loop-accent: #74f;
				--link-accent: #98f;
				--ui-widget-background: #444;
				--ui-widget-focus: #777;
				--pitch-background: #444;
				--tonic: #864;
				--fifth-note: #468;
				--white-piano-key: #bbb;
				--black-piano-key: #444;
					--use-color-formula: false;
					--track-editor-bg-pitch: #444;
					--track-editor-bg-pitch-dim: #333;
					--track-editor-bg-noise: #444;
					--track-editor-bg-noise-dim: #333;
					--track-editor-bg-mod: #234;
					--track-editor-bg-mod-dim: #123;
					--multiplicative-mod-slider: #456;
					--overwriting-mod-slider: #654;
					--indicator-primary: #74f;
					--indicator-secondary: #444;
					--select2-opt-group: #585858;
					--input-box-outline: #333;
					--mute-button-normal: #ffa033;
					--mute-button-mod: #9a6bff;
				--pitch1-secondary-channel: #0099A1;
				--pitch1-primary-channel:   #25F3FF;
				--pitch1-secondary-note:    #00BDC7;
				--pitch1-primary-note:      #92F9FF;
				--pitch2-secondary-channel: #A1A100;
				--pitch2-primary-channel:   #FFFF25;
				--pitch2-secondary-note:    #C7C700;
				--pitch2-primary-note:      #FFFF92;
				--pitch3-secondary-channel: #C75000;
				--pitch3-primary-channel:   #FF9752;
				--pitch3-secondary-note:    #FF771C;
				--pitch3-primary-note:      #FFCDAB;
				--pitch4-secondary-channel: #00A100;
				--pitch4-primary-channel:   #50FF50;
				--pitch4-secondary-note:    #00C700;
				--pitch4-primary-note:      #A0FFA0;
				--pitch5-secondary-channel: #D020D0;
				--pitch5-primary-channel:   #FF90FF;
				--pitch5-secondary-note:    #E040E0;
				--pitch5-primary-note:      #FFC0FF;
				--pitch6-secondary-channel: #7777B0;
				--pitch6-primary-channel:   #A0A0FF;
				--pitch6-secondary-note:    #8888D0;
				--pitch6-primary-note:      #D0D0FF;
				--pitch7-secondary-channel: #8AA100;
				--pitch7-primary-channel:   #DEFF25;
				--pitch7-secondary-note:    #AAC700;
				--pitch7-primary-note:      #E6FF92;
				--pitch8-secondary-channel: #DF0019;
				--pitch8-primary-channel:   #FF98A4;
				--pitch8-secondary-note:    #FF4E63;
				--pitch8-primary-note:      #FFB2BB;
				--pitch9-secondary-channel: #00A170;
				--pitch9-primary-channel:   #50FFC9;
				--pitch9-secondary-note:    #00C78A;
				--pitch9-primary-note:      #83FFD9;
				--pitch10-secondary-channel:#A11FFF;
				--pitch10-primary-channel:  #CE8BFF;
				--pitch10-secondary-note:   #B757FF;
				--pitch10-primary-note:     #DFACFF;
				--noise1-secondary-channel: #6F6F6F;
				--noise1-primary-channel:   #AAAAAA;
				--noise1-secondary-note:    #A7A7A7;
				--noise1-primary-note:      #E0E0E0;
				--noise2-secondary-channel: #996633;
				--noise2-primary-channel:   #DDAA77;
				--noise2-secondary-note:    #CC9966;
				--noise2-primary-note:      #F0D0BB;
				--noise3-secondary-channel: #4A6D8F;
				--noise3-primary-channel:   #77AADD;
				--noise3-secondary-note:    #6F9FCF;
				--noise3-primary-note:      #BBD7FF;
				--noise4-secondary-channel: #7A4F9A;
				--noise4-primary-channel:   #AF82D2;
				--noise4-secondary-note:    #9E71C1;
				--noise4-primary-note:      #D4C1EA;
				--noise5-secondary-channel: #607837;
				--noise5-primary-channel:   #A2BB77;
				--noise5-secondary-note:    #91AA66;
				--noise5-primary-note:      #C5E2B2;
          --mod1-secondary-channel:   #339955;
					--mod1-primary-channel:     #77fc55;
					--mod1-secondary-note:      #77ff8a;
					--mod1-primary-note:        #cdffee;
					--mod2-secondary-channel:   #993355;
					--mod2-primary-channel:     #f04960;
					--mod2-secondary-note:      #f057a0;
					--mod2-primary-note:        #ffb8de;
					--mod3-secondary-channel:   #553399;
					--mod3-primary-channel:     #8855fc;
					--mod3-secondary-note:      #aa64ff;
					--mod3-primary-note:	    #f8ddff;
					--mod4-secondary-channel:   #a86436;
					--mod4-primary-channel:     #c8a825;
					--mod4-secondary-note:      #e8ba46;
					--mod4-primary-note:        #fff6d3;
					--mod-label-primary:        #999;
					--mod-label-secondary-text: #333;
					--mod-label-primary-text:   black;
					--disabled-note-primary:    #999;
					--disabled-note-secondary:  #666;
				}
			`,
"neon":`
:root {
  --page-margin: #000000;
  --editor-background: #000000;
  --hover-preview: #ffffff;
  --playhead: #00faff;
  --primary-text: #ccffff;
  --secondary-text: #66ffff;
  --inverted-text: #000000;
  --text-selection: rgba(0,255,255,0.3);
  --box-selection-fill: rgba(0,255,255,0.1);
  --loop-accent: #00faff;
  --link-accent: #66ffff;
  --ui-widget-background: #001030;
  --ui-widget-focus: #050505;
  --pitch-background: #101515;
  --tonic: #00faff;
  --fifth-note: #005f5f;
  --white-piano-key-color: #0ff;
  --black-piano-key-color: #0af;
  --white-piano-key: #003565;
  --black-piano-key: #001010;
  --use-color-formula: false;
  --track-editor-bg-pitch: #000000;
  --track-editor-bg-pitch-dim: #050505;
  --track-editor-bg-noise: #000000;
  --track-editor-bg-noise-dim: #050505;
  --track-editor-bg-mod: #000000;
  --track-editor-bg-mod-dim: #050505;
  --multiplicative-mod-slider: #00faff;
  --overwriting-mod-slider: #66ffff;
  --indicator-primary: #00faff;
  --indicator-secondary: #050505;
  --select2-opt-group: #050505;
  --input-box-outline: #050505;
  --mute-button-normal: #00cccc;
  --mute-button-mod: #66ffff;

  --pitch1-secondary-channel: #0ff;
  --pitch1-primary-channel: #00faff;
  --pitch1-secondary-note: #00dddd;
  --pitch1-primary-note: #ccffff;
  --pitch2-secondary-channel: #00cccc;
  --pitch2-primary-channel: #00faff;
  --pitch2-secondary-note: #00dddd;
  --pitch2-primary-note: #ccffff;
  --pitch3-secondary-channel: #00cccc;
  --pitch3-primary-channel: #00faff;
  --pitch3-secondary-note: #00dddd;
  --pitch3-primary-note: #ccffff;
  --pitch4-secondary-channel: #00cccc;
  --pitch4-primary-channel: #00faff;
  --pitch4-secondary-note: #00dddd;
  --pitch4-primary-note: #ccffff;
  --pitch5-secondary-channel: #00cccc;
  --pitch5-primary-channel: #00faff;
  --pitch5-secondary-note: #00dddd;
  --pitch5-primary-note: #ccffff;
  --pitch6-secondary-channel: #00cccc;
  --pitch6-primary-channel: #00faff;
  --pitch6-secondary-note: #00dddd;
  --pitch6-primary-note: #ccffff;
  --pitch7-secondary-channel: #00cccc;
  --pitch7-primary-channel: #00faff;
  --pitch7-secondary-note: #00dddd;
  --pitch7-primary-note: #ccffff;
  --pitch8-secondary-channel: #00cccc;
  --pitch8-primary-channel: #00faff;
  --pitch8-secondary-note: #00dddd;
  --pitch8-primary-note: #ccffff;
  --pitch9-secondary-channel: #00cccc;
  --pitch9-primary-channel: #00faff;
  --pitch9-secondary-note: #00dddd;
  --pitch9-primary-note: #ccffff;
  --pitch10-secondary-channel: #00cccc;
  --pitch10-primary-channel: #00faff;
  --pitch10-secondary-note: #00dddd;
  --pitch10-primary-note: #ccffff;

  --noise1-secondary-channel: #00cccc;
  --noise1-primary-channel: #00faff;
  --noise1-secondary-note: #00dddd;
  --noise1-primary-note: #ccffff;
  --noise2-secondary-channel: #00cccc;
  --noise2-primary-channel: #00faff;
  --noise2-secondary-note: #00dddd;
  --noise2-primary-note: #ccffff;
  --noise3-secondary-channel: #00cccc;
  --noise3-primary-channel: #00faff;
  --noise3-secondary-note: #00dddd;
  --noise3-primary-note: #ccffff;
  --noise4-secondary-channel: #00cccc;
  --noise4-primary-channel: #00faff;
  --noise4-secondary-note: #00dddd;
  --noise4-primary-note: #ccffff;
  --noise5-secondary-channel: #00cccc;
  --noise5-primary-channel: #00faff;
  --noise5-secondary-note: #00dddd;
  --noise5-primary-note: #ccffff;

  --mod1-secondary-channel: #00cccc;
  --mod1-primary-channel: #00faff;
  --mod1-secondary-note: #00dddd;
  --mod1-primary-note: #ccffff;
  --mod2-secondary-channel: #00cccc;
  --mod2-primary-channel: #00faff;
  --mod2-secondary-note: #00dddd;
  --mod2-primary-note: #ccffff;
  --mod3-secondary-channel: #00cccc;
  --mod3-primary-channel: #00faff;
  --mod3-secondary-note: #00dddd;
  --mod3-primary-note: #ccffff;
  --mod4-secondary-channel: #00cccc;
  --mod4-primary-channel: #00faff;
  --mod4-secondary-note: #00dddd;
  --mod4-primary-note: #ccffff;

  --mod-label-primary: #66ffff;
  --mod-label-secondary-text: #000000;
  --mod-label-primary-text: #ccffff;
  --disabled-note-primary: #444;
  --disabled-note-secondary: #222;
}


`,
"yellowed":`
:root {
  --page-margin: #79840A;
  --editor-background: #514418;
  --hover-preview: #ffffff;
  --playhead: #FFF600;
  --primary-text: #FFFFFF;
  --secondary-text: #FFFFFF;
  --inverted-text: #FFFFFF;
  --text-selection: #FFFFFF;
  --box-selection-fill: #999999;
  --loop-accent: #F2C80D;
  --link-accent: #FDCF08;
  --ui-widget-background: #B99219;
  --ui-widget-focus: #FFB237;
  --pitch-background: #736412;
  --tonic: #F5D43A;
  --fifth-note: #BEBA00;
  --white-piano-key-color: #FFFFFF;
  --black-piano-key-color: #000000;
  --white-piano-key: #FFB901;
  --black-piano-key: #403517;
  --use-color-formula: false;
  --track-editor-bg-pitch: #B28510;
  --track-editor-bg-pitch-dim: #9B732A;
  --track-editor-bg-noise: #A57B1A;
  --track-editor-bg-noise-dim: #D1841A;
  --track-editor-bg-mod: #97880C;
  --track-editor-bg-mod-dim: #D9C33C;
  --multiplicative-mod-slider: #EBAF05;
  --overwriting-mod-slider: #FFBD0D;
  --indicator-primary: #D0AB1A;
  --indicator-secondary: #A99D0A;
  --select2-opt-group: #C89C1B;
  --input-box-outline: #A48618;
  --mute-button-normal: #FFF2CA;
  --mute-button-mod: #FFF2CA;

  --pitch1-secondary-channel: #FFDD0D;
  --pitch1-primary-channel: #E8CA41;
  --pitch1-secondary-note: #AF7D15;
  --pitch1-primary-note: #F9E77A;
  --pitch2-secondary-channel: #FFDD0D;
  --pitch2-primary-channel: #E8CA41;
  --pitch2-secondary-note: #AF7D15;
  --pitch2-primary-note: #F9E77A;
  --pitch3-secondary-channel: #FFDD0D;
  --pitch3-primary-channel: #E8CA41;
  --pitch3-secondary-note: #AF7D15;
  --pitch3-primary-note: #F9E77A;
  --pitch4-secondary-channel: #FFDD0D;
  --pitch4-primary-channel: #E8CA41;
  --pitch4-secondary-note: #AF7D15;
  --pitch4-primary-note: #F9E77A;
  --pitch5-secondary-channel: #FFDD0D;
  --pitch5-primary-channel: #E8CA41;
  --pitch5-secondary-note: #AF7D15;
  --pitch5-primary-note: #F9E77A;
  --pitch6-secondary-channel: #FFDD0D;
  --pitch6-primary-channel: #E8CA41;
  --pitch6-secondary-note: #AF7D15;
  --pitch6-primary-note: #F9E77A;
  --pitch7-secondary-channel: #FFDD0D;
  --pitch7-primary-channel: #E8CA41;
  --pitch7-secondary-note: #AF7D15;
  --pitch7-primary-note: #F9E77A;
  --pitch8-secondary-channel: #FFDD0D;
  --pitch8-primary-channel: #E8CA41;
  --pitch8-secondary-note: #AF7D15;
  --pitch8-primary-note: #F9E77A;
  --pitch9-secondary-channel: #FFDD0D;
  --pitch9-primary-channel: #E8CA41;
  --pitch9-secondary-note: #AF7D15;
  --pitch9-primary-note: #F9E77A;
  --pitch10-secondary-channel: #FFDD0D;
  --pitch10-primary-channel: #E8CA41;
  --pitch10-secondary-note: #AF7D15;
  --pitch10-primary-note: #F9E77A;

  --noise1-secondary-channel: #FFDD0D;
  --noise1-primary-channel: #E8CA41;
  --noise1-secondary-note: #AF7D15;
  --noise1-primary-note: #F9E77A;
  --noise2-secondary-channel: #FFDD0D;
  --noise2-primary-channel: #E8CA41;
  --noise2-secondary-note: #AF7D15;
  --noise2-primary-note: #F9E77A;
  --noise3-secondary-channel: #FFDD0D;
  --noise3-primary-channel: #E8CA41;
  --noise3-secondary-note: #AF7D15;
  --noise3-primary-note: #F9E77A;
  --noise4-secondary-channel: #FFDD0D;
  --noise4-primary-channel: #E8CA41;
  --noise4-secondary-note: #AF7D15;
  --noise4-primary-note: #F9E77A;
  --noise5-secondary-channel: #FFDD0D;
  --noise5-primary-channel: #E8CA41;
  --noise5-secondary-note: #AF7D15;
  --noise5-primary-note: #F9E77A;

  --mod1-secondary-channel: #FFDD0D;
  --mod1-primary-channel: #E8CA41;
  --mod1-secondary-note: #AF7D15;
  --mod1-primary-note: #F9E77A;
  --mod2-secondary-channel: #FFDD0D;
  --mod2-primary-channel: #E8CA41;
  --mod2-secondary-note: #AF7D15;
  --mod2-primary-note: #F9E77A;
  --mod3-secondary-channel: #FFDD0D;
  --mod3-primary-channel: #E8CA41;
  --mod3-secondary-note: #AF7D15;
  --mod3-primary-note: #F9E77A;
  --mod4-secondary-channel: #FFDD0D;
  --mod4-primary-channel: #E8CA41;
  --mod4-secondary-note: #AF7D15;
  --mod4-primary-note: #F9E77A;

  --mod-label-primary: #BBC1C1;
  --mod-label-secondary-text: #000000;
  --mod-label-primary-text: #747878;
  --disabled-note-primary: #444;
  --disabled-note-secondary: #222;
}

`,
"greenish":`

:root {
  --page-margin: #000000;
  --editor-background: #121212;
  --hover-preview: #ffffff;
  --playhead: #424643;
  --primary-text: #979797;
  --secondary-text: #979797;
  --inverted-text: #979797;
  --text-selection: #979797;
  --box-selection-fill: #4D4D4D;
  --loop-accent: #384239;
  --link-accent: #303932;
  --ui-widget-background: #202020;
  --ui-widget-focus: #232322;
  --pitch-background: #181A18;
  --tonic: #3C3F3C;
  --fifth-note: #292D29;
  --white-piano-key-color: #202020;
  --black-piano-key-color: #B3B3B3;
  --white-piano-key: #606560;
  --black-piano-key: #1C1D1C;
  --use-color-formula: false;
  --track-editor-bg-pitch: #222222;
  --track-editor-bg-pitch-dim: #050505;
  --track-editor-bg-noise: #0B0B0A;
  --track-editor-bg-noise-dim: #050505;
  --track-editor-bg-mod: #000000;
  --track-editor-bg-mod-dim: #050505;
  --multiplicative-mod-slider: #363B37;
  --overwriting-mod-slider: #2B2E2B;
  --indicator-primary: #454D46;
  --indicator-secondary: #121212;
  --select2-opt-group: #0D0D0D;
  --input-box-outline: #050505;
  --mute-button-normal: #3A403C;
  --mute-button-mod: #3B3F3A;

  --pitch1-secondary-channel: #333534;
  --pitch1-primary-channel: #383B38;
  --pitch1-secondary-note: #262926;
  --pitch1-primary-note: #8A8A8A;
  --pitch2-secondary-channel: #333534;
  --pitch2-primary-channel: #383B38;
  --pitch2-secondary-note: #262926;
  --pitch2-primary-note: #8A8A8A;
  --pitch3-secondary-channel: #333534;
  --pitch3-primary-channel: #383B38;
  --pitch3-secondary-note: #262926;
  --pitch3-primary-note: #8A8A8A;
  --pitch4-secondary-channel: #333534;
  --pitch4-primary-channel: #383B38;
  --pitch4-secondary-note: #262926;
  --pitch4-primary-note: #8A8A8A;
  --pitch5-secondary-channel: #333534;
  --pitch5-primary-channel: #383B38;
  --pitch5-secondary-note: #262926;
  --pitch5-primary-note: #8A8A8A;
  --pitch6-secondary-channel: #333534;
  --pitch6-primary-channel: #383B38;
  --pitch6-secondary-note: #262926;
  --pitch6-primary-note: #8A8A8A;
  --pitch7-secondary-channel: #333534;
  --pitch7-primary-channel: #383B38;
  --pitch7-secondary-note: #262926;
  --pitch7-primary-note: #8A8A8A;
  --pitch8-secondary-channel: #333534;
  --pitch8-primary-channel: #383B38;
  --pitch8-secondary-note: #262926;
  --pitch8-primary-note: #8A8A8A;
  --pitch9-secondary-channel: #333534;
  --pitch9-primary-channel: #383B38;
  --pitch9-secondary-note: #262926;
  --pitch9-primary-note: #8A8A8A;
  --pitch10-secondary-channel: #333534;
  --pitch10-primary-channel: #383B38;
  --pitch10-secondary-note: #262926;
  --pitch10-primary-note: #8A8A8A;

  --noise1-secondary-channel: #333534;
  --noise1-primary-channel: #383B38;
  --noise1-secondary-note: #262926;
  --noise1-primary-note: #8A8A8A;
  --noise2-secondary-channel: #333534;
  --noise2-primary-channel: #383B38;
  --noise2-secondary-note: #262926;
  --noise2-primary-note: #8A8A8A;
  --noise3-secondary-channel: #333534;
  --noise3-primary-channel: #383B38;
  --noise3-secondary-note: #262926;
  --noise3-primary-note: #8A8A8A;
  --noise4-secondary-channel: #333534;
  --noise4-primary-channel: #383B38;
  --noise4-secondary-note: #262926;
  --noise4-primary-note: #8A8A8A;
  --noise5-secondary-channel: #333534;
  --noise5-primary-channel: #383B38;
  --noise5-secondary-note: #262926;
  --noise5-primary-note: #8A8A8A;

  --mod1-secondary-channel: #333534;
  --mod1-primary-channel: #383B38;
  --mod1-secondary-note: #262926;
  --mod1-primary-note: #8A8A8A;
  --mod2-secondary-channel: #333534;
  --mod2-primary-channel: #383B38;
  --mod2-secondary-note: #262926;
  --mod2-primary-note: #8A8A8A;
  --mod3-secondary-channel: #333534;
  --mod3-primary-channel: #383B38;
  --mod3-secondary-note: #262926;
  --mod3-primary-note: #8A8A8A;
  --mod4-secondary-channel: #333534;
  --mod4-primary-channel: #383B38;
  --mod4-secondary-note: #262926;
  --mod4-primary-note: #8A8A8A;

  --mod-label-primary: #BBC1C1;
  --mod-label-secondary-text: #000000;
  --mod-label-primary-text: #747878;
  --disabled-note-primary: #444;
  --disabled-note-secondary: #222;
}



`,
        "dark competition": `
				:root {
					--page-margin: black;
					--editor-background: black;
					--hover-preview: #ddd;
					--playhead: #ddd;
					--primary-text: #ddd;
					--secondary-text: #8e695b;
					--inverted-text: black;
					--text-selection: rgba(169,0,255,0.99);
					--box-selection-fill: rgba(221,221,221,0.2);
					--loop-accent: #bf15ba;
					--link-accent: #f888ff;
					--ui-widget-background: #443a3a;
					--ui-widget-focus: #777;
					--pitch-background: #353333;
					--tonic: #884a44;
					--fifth-note: #415498;
					--white-piano-key: #bbb;
					--black-piano-key: #444;
					--use-color-formula: false;
					--track-editor-bg-pitch: #444;
					--track-editor-bg-pitch-dim: #333;
					--track-editor-bg-noise: #444;
					--track-editor-bg-noise-dim: #333;
					--track-editor-bg-mod: #234;
					--track-editor-bg-mod-dim: #123;
					--multiplicative-mod-slider: #456;
					--overwriting-mod-slider: #654;
					--indicator-primary: #74f;
					--indicator-secondary: #444;
					--select2-opt-group: #585858;
					--input-box-outline: #333;
					--mute-button-normal: #ffa033;
					--mute-button-mod: #9a6bff;
					--pitch1-secondary-channel: #0099a1;
					--pitch1-primary-channel:   #25f3ff;
					--pitch1-secondary-note:    #00bdc7;
					--pitch1-primary-note:      #92f9ff;
					--pitch2-secondary-channel: #a1a100;
					--pitch2-primary-channel:   #ffff25;
					--pitch2-secondary-note:    #c7c700;
					--pitch2-primary-note:      #ffff92;
					--pitch3-secondary-channel: #c75000;
					--pitch3-primary-channel:   #ff9752;
					--pitch3-secondary-note:    #ff771c;
					--pitch3-primary-note:      #ffcdab;
					--pitch4-secondary-channel: #00a100;
					--pitch4-primary-channel:   #50ff50;
					--pitch4-secondary-note:    #00c700;
					--pitch4-primary-note:      #a0ffa0;
					--pitch5-secondary-channel: #d020d0;
					--pitch5-primary-channel:   #ff90ff;
					--pitch5-secondary-note:    #e040e0;
					--pitch5-primary-note:      #ffc0ff;
					--pitch6-secondary-channel: #7777b0;
					--pitch6-primary-channel:   #a0a0ff;
					--pitch6-secondary-note:    #8888d0;
					--pitch6-primary-note:      #d0d0ff;
					--pitch7-secondary-channel: #8AA100;
					--pitch7-primary-channel:   #DEFF25;
					--pitch7-secondary-note:	  #AAC700;
					--pitch7-primary-note:			#E6FF92;
					--pitch8-secondary-channel: #DF0019;
					--pitch8-primary-channel:   #FF98A4;
					--pitch8-secondary-note:    #FF4E63;
					--pitch8-primary-note:      #FFB2BB;
					--pitch9-secondary-channel: #00A170;
					--pitch9-primary-channel:   #50FFC9;
					--pitch9-secondary-note:    #00C78A;
					--pitch9-primary-note:			#83FFD9;
					--pitch10-secondary-channel:#A11FFF;
					--pitch10-primary-channel:  #CE8BFF;
					--pitch10-secondary-note:   #B757FF;
					--pitch10-primary-note:     #DFACFF;
					--noise1-secondary-channel: #6f6f6f;
					--noise1-primary-channel:   #aaaaaa;
					--noise1-secondary-note:    #a7a7a7;
					--noise1-primary-note:      #e0e0e0;
					--noise2-secondary-channel: #996633;
					--noise2-primary-channel:   #ddaa77;
					--noise2-secondary-note:    #cc9966;
					--noise2-primary-note:      #f0d0bb;
					--noise3-secondary-channel: #4a6d8f;
					--noise3-primary-channel:   #77aadd;
					--noise3-secondary-note:    #6f9fcf;
					--noise3-primary-note:      #bbd7ff;
					--noise4-secondary-channel: #6B3E8E;
					--noise4-primary-channel:   #AF82D2;
					--noise4-secondary-note:    #9E71C1;
					--noise5-secondary-channel: #607837;
					--noise5-primary-channel:   #A2BB77;
					--noise5-secondary-note:    #91AA66;
					--noise5-primary-note:      #C5E2B2;
          --mod1-secondary-channel:   #339955;
					--mod1-primary-channel:     #77fc55;
					--mod1-secondary-note:      #77ff8a;
					--mod1-primary-note:        #cdffee;
					--mod2-secondary-channel:   #993355;
					--mod2-primary-channel:     #f04960;
					--mod2-secondary-note:      #f057a0;
					--mod2-primary-note:        #ffb8de;
					--mod3-secondary-channel:   #553399;
					--mod3-primary-channel:     #8855fc;
					--mod3-secondary-note:      #aa64ff;
					--mod3-primary-note:			  #f8ddff;
					--mod4-secondary-channel:   #a86436;
					--mod4-primary-channel:     #c8a825;
					--mod4-secondary-note:      #e8ba46;
					--mod4-primary-note:        #fff6d3;
					--mod-label-primary:        #999;
					--mod-label-secondary-text: #333;
					--mod-label-primary-text:   black;
					--disabled-note-primary:    #999;
					--disabled-note-secondary:  #666;

			}
		`,
        "light classic": `
			:root {
				-webkit-text-stroke-width: 0.5px;
				--page-margin: #685d88;
				--editor-background: white;
				--hover-preview: black;
				--playhead: rgba(0,0,0,0.5);
				--primary-text: black;
				--secondary-text: #777;
				--inverted-text: white;
				--text-selection: rgba(200,170,255,0.99);
				--box-selection-fill: rgba(0,0,0,0.1);
				--loop-accent: #98f;
				--link-accent: #74f;
				--ui-widget-background: #ececec;
				--ui-widget-focus: #eee;
				--pitch-background: #ececec;
				--tonic: #f0d6b6;
				--fifth-note: #bbddf0;
				--white-piano-key: #eee;
				--black-piano-key: #666;
					--use-color-formula: false;
					--track-editor-bg-pitch: #ececec;
					--track-editor-bg-pitch-dim: #fdfdfd;
					--track-editor-bg-noise: #ececec;
					--track-editor-bg-noise-dim: #fdfdfd;
					--track-editor-bg-mod: #dbecfd;
					--track-editor-bg-mod-dim: #ecfdff;
					--multiplicative-mod-slider: #789;
					--overwriting-mod-slider: #987;
					--indicator-primary: #98f;
					--indicator-secondary: #cde;
					--select2-opt-group: #cecece;
					--input-box-outline: #ddd;
					--mute-button-normal: #c0b47f;
					--mute-button-mod: #bd7fc0;
				--pitch1-secondary-channel: #6CD9ED;
				--pitch1-primary-channel:   #00A0BD;
				--pitch1-secondary-note:    #34C2DC;
				--pitch1-primary-note:      #00758A;
				--pitch2-secondary-channel: #E3C941;
				--pitch2-primary-channel:   #B49700;
				--pitch2-secondary-note:    #D1B628;
				--pitch2-primary-note:      #836E00;
				--pitch3-secondary-channel: #FF9D61;
				--pitch3-primary-channel:   #E14E00;
				--pitch3-secondary-note:    #F67D3C;
				--pitch3-primary-note:      #B64000;
				--pitch4-secondary-channel: #4BE24B;
				--pitch4-primary-channel:   #00A800;
				--pitch4-secondary-note:    #2DC82D;
				--pitch4-primary-note:      #008000;
				--pitch5-secondary-channel: #FF90FF;
				--pitch5-primary-channel:   #E12EDF;
				--pitch5-secondary-note:    #EC6EEC;
				--pitch5-primary-note:      #A600A5;
				--pitch6-secondary-channel: #B5B5FE;
				--pitch6-primary-channel:   #6969FD;
				--pitch6-secondary-note:    #9393FE;
				--pitch6-primary-note:      #4A4AD7;
				--pitch7-secondary-channel: #C2D848;
				--pitch7-primary-channel:   #8EA800;
				--pitch7-secondary-note:    #B0C82D;
				--pitch7-primary-note:      #6C8000;
				--pitch8-secondary-channel: #FF90A4;
				--pitch8-primary-channel:   #E12E4D;
				--pitch8-secondary-note:    #EC6E85;
				--pitch8-primary-note:      #A6001D;
				--pitch9-secondary-channel: #41E3B5;
				--pitch9-primary-channel:   #00B481;
				--pitch9-secondary-note:    #28D1A1;
				--pitch9-primary-note:      #00835E;
				--pitch10-secondary-channel:#CA77FF;
				--pitch10-primary-channel:  #9609FF;
				--pitch10-secondary-note:   #B54FFF;
				--pitch10-primary-note:     #8400E3;
				--noise1-secondary-channel: #C1C1C1;
				--noise1-primary-channel:   #898989;
				--noise1-secondary-note:    #ADADAD;
				--noise1-primary-note:      #6C6C6C;
				--noise2-secondary-channel: #E8BB8C;
				--noise2-primary-channel:   #BD7D3A;
				--noise2-secondary-note:    #D1A374;
				--noise2-primary-note:      #836342;
				--noise3-secondary-channel: #9BC4EB;
				--noise3-primary-channel:   #4481BE;
				--noise3-secondary-note:    #7CA7D3;
				--noise3-primary-note:      #476685;
				--noise4-secondary-channel: #C5A5E0;
				--noise4-primary-channel:   #8553AE;
				--noise4-secondary-note:    #B290CC;
				--noise4-primary-note:      #684F7D;
				--noise5-secondary-channel: #B8CE93;
				--noise5-primary-channel:   #87A74F;
				--noise5-secondary-note:    #ABC183;
				--noise5-primary-note:      #68784C;
					--mod1-secondary-channel:   #339955;
					--mod1-primary-channel:     #77dd55;
					--mod1-secondary-note:      #77ff8a;
					--mod1-primary-note:        #2ad84a;
					--mod2-secondary-channel:   #993355;
					--mod2-primary-channel:     #f04960;
					--mod2-secondary-note:      #f057a0;
					--mod2-primary-note:        #ba124a;
					--mod3-secondary-channel:   #553399;
					--mod3-primary-channel:     #8855fc;
					--mod3-secondary-note:      #aa64ff;
					--mod3-primary-note:        #7a1caa;
					--mod4-secondary-channel:   #a86436;
					--mod4-primary-channel:     #c8a825;
					--mod4-secondary-note:      #e8ba46;
					--mod4-primary-note:        #a86810;
					--mod-label-primary:        #dddddd;
					--mod-label-secondary-text: #777;
					--mod-label-primary-text:   black;
					--disabled-note-primary:    #666;
					--disabled-note-secondary:  #aaa;
			}
			
			.beepboxEditor button, .beepboxEditor select {
				box-shadow: inset 0 0 0 1px var(--secondary-text);
			}

				.select2-selection__rendered {
					box-shadow: inset 0 0 0 1px var(--secondary-text);
				}
		`,
        "jummbox classic": `
				:root {
					--page-margin: #040410;
					--editor-background: #040410;
					--hover-preview: white;
					--playhead: rgba(255, 255, 255, 0.9);
					--primary-text: white;
					--secondary-text: #84859a;
					--inverted-text: black;
					--text-selection: rgba(119,68,255,0.99);
					--box-selection-fill: #044b94;
					--loop-accent: #74f;
					--link-accent: #98f;
					--ui-widget-background: #393e4f;
					--ui-widget-focus: #6d6886;
					--pitch-background: #393e4f;
					--tonic: #725491;
					--fifth-note: #54547a;
					--white-piano-key: #eee;
					--black-piano-key: #666;
					--use-color-formula: true;
					--track-editor-bg-pitch: #393e4f;
					--track-editor-bg-pitch-dim: #1c1d28;
					--track-editor-bg-noise: #3d3535;
					--track-editor-bg-noise-dim: #161313;
					--track-editor-bg-mod: #283560;
					--track-editor-bg-mod-dim: #0a101f;
					--multiplicative-mod-slider: #606c9f;
					--overwriting-mod-slider: #6850b5;
					--indicator-primary: #9c64f7;
					--indicator-secondary: #393e4f;
					--select2-opt-group: #5d576f;
					--input-box-outline: #222;
					--mute-button-normal: #dda85d;
					--mute-button-mod: #886eae;
					--mod-label-primary: #282840;
					--mod-label-secondary-text: rgb(87, 86, 120);
					--mod-label-primary-text: white;
					--pitch-secondary-channel-hue: 0;
					--pitch-secondary-channel-hue-scale: 6.1;
					--pitch-secondary-channel-sat: 83.3;
					--pitch-secondary-channel-sat-scale: 0.1;
					--pitch-secondary-channel-lum: 40;
					--pitch-secondary-channel-lum-scale: 0.05;
					--pitch-primary-channel-hue: 0;
					--pitch-primary-channel-hue-scale: 6.1;
					--pitch-primary-channel-sat: 100;
					--pitch-primary-channel-sat-scale: 0.1;
					--pitch-primary-channel-lum: 67.5;
					--pitch-primary-channel-lum-scale: 0.05;
					--pitch-secondary-note-hue: 0;
					--pitch-secondary-note-hue-scale: 6.1;
					--pitch-secondary-note-sat: 93.9;
					--pitch-secondary-note-sat-scale: 0.1;
					--pitch-secondary-note-lum: 25;
					--pitch-secondary-note-lum-scale: 0.05;
					--pitch-primary-note-hue: 0;
					--pitch-primary-note-hue-scale: 6.1;
					--pitch-primary-note-sat: 100;
					--pitch-primary-note-sat-scale: 0.05;
					--pitch-primary-note-lum: 85.6;
					--pitch-primary-note-lum-scale: 0.025;
					--noise-secondary-channel-hue: 0;
					--noise-secondary-channel-hue-scale: 2;
					--noise-secondary-channel-sat: 25;
					--noise-secondary-channel-sat-scale: 0;
					--noise-secondary-channel-lum: 42;
					--noise-secondary-channel-lum-scale: 0;
					--noise-primary-channel-hue: 0;
					--noise-primary-channel-hue-scale: 2;
					--noise-primary-channel-sat: 33;
					--noise-primary-channel-sat-scale: 0;
					--noise-primary-channel-lum: 63.5;
					--noise-primary-channel-lum-scale: 0;
					--noise-secondary-note-hue: 0;
					--noise-secondary-note-hue-scale: 2;
					--noise-secondary-note-sat: 33.5;
					--noise-secondary-note-sat-scale: 0;
					--noise-secondary-note-lum: 55;
					--noise-secondary-note-lum-scale: 0;
					--noise-primary-note-hue: 0;
					--noise-primary-note-hue-scale: 2;
					--noise-primary-note-sat: 46.5;
					--noise-primary-note-sat-scale: 0;
					--noise-primary-note-lum: 74;
					--noise-primary-note-lum-scale: 0;
					--mod-secondary-channel-hue: 192;
					--mod-secondary-channel-hue-scale: 1.5;
					--mod-secondary-channel-sat: 88;
					--mod-secondary-channel-sat-scale: 0;
					--mod-secondary-channel-lum: 50;
					--mod-secondary-channel-lum-scale: 0;
					--mod-primary-channel-hue: 192;
					--mod-primary-channel-hue-scale: 1.5;
					--mod-primary-channel-sat: 96;
					--mod-primary-channel-sat-scale: 0;
					--mod-primary-channel-lum: 80;
					--mod-primary-channel-lum-scale: 0;
					--mod-secondary-note-hue: 192;
					--mod-secondary-note-hue-scale: 1.5;
					--mod-secondary-note-sat: 92;
					--mod-secondary-note-sat-scale: 0;
					--mod-secondary-note-lum: 45;
					--mod-secondary-note-lum-scale: 0;
					--mod-primary-note-hue: 192;
					--mod-primary-note-hue-scale: 1.5;
					--mod-primary-note-sat: 96;
					--mod-primary-note-sat-scale: 0;
					--mod-primary-note-lum: 85;
					--mod-primary-note-lum-scale: 0;
					--disabled-note-primary:    #91879f;
					--disabled-note-secondary:  #6a677a;
				}
			`,
			 "paandorasbox": `
			:root {
			 --page-margin: #200000;
			  --editor-background: #200000;
			  --hover-preview: white;
			  --playhead: white;
			  --primary-text: white;
			  --secondary-text: #999;
			  --inverted-text: black;
			  --text-selection: #FF5100;
			  --box-selection-fill: rgba(255,255,255,0.2);
			  --loop-accent: #FF5100;
			  --link-accent: #0F0;
			  --ui-widget-background: #562334;
			  --ui-widget-focus: #6D1B36;
			  --pitch-background: #6D1B36;
			  --tonic: #FF5100;
			  --fifth-note: #00B6FF;
			  --white-piano-key: #bbb;
			  --black-piano-key: #444;
			  --use-color-formula: false;
			  --track-editor-bg-pitch: #380C14;
			  --track-editor-bg-pitch-dim: #200000;
			  --track-editor-bg-noise: #233323;
			  --track-editor-bg-noise-dim: #101A0F;
			  --track-editor-bg-mod: #234C82;
			  --track-editor-bg-mod-dim: #0D1D33;
			  --multiplicative-mod-slider: #456;
			  --overwriting-mod-slider: #654;
			  --indicator-primary: #FF5100;
			  --indicator-secondary: #444;
			  --select2-opt-group: #585858;
			  --input-box-outline: #333;
			  --mute-button-normal: #ffa033;
			  --mute-button-mod: #9a6bff;
			  --pitch1-secondary-channel: #00B200;
			  --pitch1-primary-channel: #0F0;
			  --pitch1-secondary-note: #00B200;
			  --pitch1-primary-note: #0F0;
			  --pitch2-secondary-channel: #00B282;
			  --pitch2-primary-channel: #00FFBF;
			  --pitch2-secondary-note: #00B282;
			  --pitch2-primary-note: #00FFBF;
			  --pitch3-secondary-channel: #00B2B2;
			  --pitch3-primary-channel: #0FF;
			  --pitch3-secondary-note: #00B2B2;
			  --pitch3-primary-note: #0FF;
			  --pitch4-secondary-channel: #2623B2;
			  --pitch4-primary-channel: #3631FF;
			  --pitch4-secondary-note: #2623B2;
			  --pitch4-primary-note: #3631FF;
			  --pitch5-secondary-channel: #7700B2;
			  --pitch5-primary-channel: #A0F;
			  --pitch5-secondary-note: #7700B2;
			  --pitch5-primary-note: #A0F;
			  --pitch6-secondary-channel: #B200B2;
			  --pitch6-primary-channel: #F0F;
			  --pitch6-secondary-note: #B200B2;
			  --pitch6-primary-note: #F0F;
			  --pitch7-secondary-channel: #B20000;
			  --pitch7-primary-channel: #F00;
			  --pitch7-secondary-note: #B20000;
			  --pitch7-primary-note: #F00;
			  --pitch8-secondary-channel: #00B200;
			  --pitch8-primary-channel: #0F0;
			  --pitch8-secondary-note: #00B200;
			  --pitch8-primary-note: #0F0;
			  --pitch9-secondary-channel: #00B282;
			  --pitch9-primary-channel: #0FF;
			  --pitch9-secondary-note: #00B282;
			  --pitch9-primary-note: #0FF;
			  --pitch10-secondary-channel: #0071B2;
			  --pitch10-primary-channel: #009EFF;
			  --pitch10-secondary-note: #0071B2;
			  --pitch10-primary-note: #009EFF;
			  --noise1-secondary-channel: #32B221;
			  --noise1-primary-channel: #44FF2F;
			  --noise1-secondary-note: #32B221;
			  --noise1-primary-note: #44FF2F;
			  --noise2-secondary-channel: #216FB2;
			  --noise2-primary-channel: #2F9DFF;
			  --noise2-secondary-note: #216FB2;
			  --noise2-primary-note: #2F9DFF;
			  --noise3-secondary-channel: #2623B2;
			  --noise3-primary-channel: #3631FF;
			  --noise3-secondary-note: #2623B2;
			  --noise3-primary-note: #3631FF;
			  --noise4-secondary-channel: #7223B2;
			  --noise4-primary-channel: #A531FF;
			  --noise4-secondary-note: #7223B2;
			  --noise4-primary-note: #A531FF;
			  --noise5-secondary-channel: #B2235A;
			  --noise5-primary-channel: #FF317E;
			  --noise5-secondary-note: #B2235A;
			  --noise5-primary-note: #FF317E;
			  --mod1-secondary-channel: #17B274;
			  --mod1-primary-channel: #21FFA8;
			  --mod1-secondary-note: #17B274;
			  --mod1-primary-note: #21FFA8;
			  --mod2-secondary-channel: #1783B2;
			  --mod2-primary-channel: #1FBAFF;
			  --mod2-secondary-note: #1783B2;
			  --mod2-primary-note: #1FBAFF;
			  --mod3-secondary-channel: #553399;
			  --mod3-primary-channel: #8855fc;
			  --mod3-secondary-note: #aa64ff;
			  --mod3-primary-note: #f8ddff;
			  --mod4-secondary-channel: #B20E6B;
			  --mod4-primary-channel: #FF1291;
			  --mod4-secondary-note: #B20E6B;
			  --mod4-primary-note: #FF1291;
			  --mod-label-primary: #994038;
			  --mod-label-secondary-text: #331512;
			  --mod-label-primary-text: #331512;
			  --disabled-note-primary: #994038;
			  --disabled-note-secondary: #331512;
			}
			`,
        "forest": `
				:root {
					--page-margin: #010c03;
					--editor-background: #010c03;
					--hover-preview: #efe;
					--playhead: rgba(232, 255, 232, 0.9);
					--primary-text: #efe;
					--secondary-text: #70A070;
					--inverted-text: #280228;
					--text-selection: rgba(255,68,199,0.99);
					--box-selection-fill: #267aa3;
					--loop-accent: #ffe845;
					--link-accent: #9f8;
					--ui-widget-background: #203829;
					--ui-widget-focus: #487860;
					--pitch-background: #203829;
					--tonic: #2b8d20;
					--fifth-note: #385840;
					--white-piano-key: #bda;
					--black-piano-key: #573;
					--use-color-formula: true;
					--track-editor-bg-pitch: #254820;
					--track-editor-bg-pitch-dim: #102819;
					--track-editor-bg-noise: #304050;
					--track-editor-bg-noise-dim: #102030;
					--track-editor-bg-mod: #506030;
					--track-editor-bg-mod-dim: #2a300a;
					--multiplicative-mod-slider: #205c8f;
					--overwriting-mod-slider: #20ac6f;
					--indicator-primary: #dcd866;
					--indicator-secondary: #203829;
					--select2-opt-group: #1a6f5a;
					--input-box-outline: #242;
					--mute-button-normal: #49e980;
					--mute-button-mod: #c2e502;
					--mod-label-primary: #133613;
					--mod-label-secondary-text: rgb(27, 126, 40);
					--mod-label-primary-text: #efe;
					--pitch-secondary-channel-hue: 120;
					--pitch-secondary-channel-hue-scale: 8.1;
					--pitch-secondary-channel-sat: 59;
					--pitch-secondary-channel-sat-scale: 0.1;
					--pitch-secondary-channel-lum: 50;
					--pitch-secondary-channel-lum-scale: 0.04;
					--pitch-primary-channel-hue: 120;
					--pitch-primary-channel-hue-scale: 8.1;
					--pitch-primary-channel-sat: 86;
					--pitch-primary-channel-sat-scale: 0.1;
					--pitch-primary-channel-lum: 70;
					--pitch-primary-channel-lum-scale: 0.04;
					--pitch-secondary-note-hue: 120;
					--pitch-secondary-note-hue-scale: 8.1;
					--pitch-secondary-note-sat: 85;
					--pitch-secondary-note-sat-scale: 0.1;
					--pitch-secondary-note-lum: 30;
					--pitch-secondary-note-lum-scale: 0.04;
					--pitch-primary-note-hue: 120;
					--pitch-primary-note-hue-scale: 8.1;
					--pitch-primary-note-sat: 90;
					--pitch-primary-note-sat-scale: 0.05;
					--pitch-primary-note-lum: 80;
					--pitch-primary-note-lum-scale: 0.025;
					--noise-secondary-channel-hue: 200;
					--noise-secondary-channel-hue-scale: 1.1;
					--noise-secondary-channel-sat: 25;
					--noise-secondary-channel-sat-scale: 0;
					--noise-secondary-channel-lum: 22;
					--noise-secondary-channel-lum-scale: 0;
					--noise-primary-channel-hue: 200;
					--noise-primary-channel-hue-scale: 1.1;
					--noise-primary-channel-sat: 48;
					--noise-primary-channel-sat-scale: 0;
					--noise-primary-channel-lum: 65;
					--noise-primary-channel-lum-scale: 0;
					--noise-secondary-note-hue: 200;
					--noise-secondary-note-hue-scale: 1.1;
					--noise-secondary-note-sat: 33.5;
					--noise-secondary-note-sat-scale: 0;
					--noise-secondary-note-lum: 33;
					--noise-secondary-note-lum-scale: 0;
					--noise-primary-note-hue: 200;
					--noise-primary-note-hue-scale: 1.1;
					--noise-primary-note-sat: 46.5;
					--noise-primary-note-sat-scale: 0;
					--noise-primary-note-lum: 64;
					--noise-primary-note-lum-scale: 0;
					--mod-secondary-channel-hue: 40;
					--mod-secondary-channel-hue-scale: 1.8;
					--mod-secondary-channel-sat: 44;
					--mod-secondary-channel-sat-scale: 0;
					--mod-secondary-channel-lum: 50;
					--mod-secondary-channel-lum-scale: 0;
					--mod-primary-channel-hue: 40;
					--mod-primary-channel-hue-scale: 1.8;
					--mod-primary-channel-sat: 60;
					--mod-primary-channel-sat-scale: 0;
					--mod-primary-channel-lum: 80;
					--mod-primary-channel-lum-scale: 0;
					--mod-secondary-note-hue: 40;
					--mod-secondary-note-hue-scale: 1.8;
					--mod-secondary-note-sat: 62;
					--mod-secondary-note-sat-scale: 0;
					--mod-secondary-note-lum: 55;
					--mod-secondary-note-lum-scale: 0;
					--mod-primary-note-hue: 40;
					--mod-primary-note-hue-scale: 1.8;
					--mod-primary-note-sat: 66;
					--mod-primary-note-sat-scale: 0;
					--mod-primary-note-lum: 85;
					--mod-primary-note-lum-scale: 0;
					--disabled-note-primary:    #536e5c;
					--disabled-note-secondary:  #395440;
				}
			`,
        "canyon": `
				:root {
					--page-margin: #0a0000;
					--editor-background: #0a0000;
					--hover-preview: white;
					--playhead: rgba(247, 172, 196, 0.9);
					--primary-text: #f5d6bf;
					--secondary-text: #934050;
					--inverted-text: #290505;
					--text-selection: rgba(255, 208, 68, 0.99);
					--box-selection-fill: #94044870;
					--loop-accent: #ff1e1e;
					--link-accent: #da7b76;
					--ui-widget-background: #533137;
					--ui-widget-focus: #743e4b;
					--pitch-background: #4f3939;
					--tonic: #9e4145;
					--fifth-note: #5b3e6b;
					--white-piano-key: #d89898;
					--black-piano-key: #572b29;
					--use-color-formula: true;
					--track-editor-bg-pitch: #5e3a41;
					--track-editor-bg-pitch-dim: #281d1c;
					--track-editor-bg-noise: #3a3551;
					--track-editor-bg-noise-dim: #272732;
					--track-editor-bg-mod: #552045;
					--track-editor-bg-mod-dim: #3e1442;
					--multiplicative-mod-slider: #9f6095;
					--overwriting-mod-slider: #b55050;
					--indicator-primary: #f2f764;
					--indicator-secondary: #4f3939;
					--select2-opt-group: #673030;
					--input-box-outline: #443131;
					--mute-button-normal: #d81833;
					--mute-button-mod: #9e2691;
					--mod-label-primary: #5f2b39;
					--mod-label-secondary-text: rgb(158, 66, 122);
					--mod-label-primary-text: #e6caed;
					--pitch-secondary-channel-hue: 0;
					--pitch-secondary-channel-hue-scale: 11.8;
					--pitch-secondary-channel-sat: 73.3;
					--pitch-secondary-channel-sat-scale: 0.1;
					--pitch-secondary-channel-lum: 40;
					--pitch-secondary-channel-lum-scale: 0.05;
					--pitch-primary-channel-hue: 0;
					--pitch-primary-channel-hue-scale: 11.8;
					--pitch-primary-channel-sat: 90;
					--pitch-primary-channel-sat-scale: 0.1;
					--pitch-primary-channel-lum: 67.5;
					--pitch-primary-channel-lum-scale: 0.05;
					--pitch-secondary-note-hue: 0;
					--pitch-secondary-note-hue-scale: 11.8;
					--pitch-secondary-note-sat: 83.9;
					--pitch-secondary-note-sat-scale: 0.1;
					--pitch-secondary-note-lum: 35;
					--pitch-secondary-note-lum-scale: 0.05;
					--pitch-primary-note-hue: 0;
					--pitch-primary-note-hue-scale: 11.8;
					--pitch-primary-note-sat: 100;
					--pitch-primary-note-sat-scale: 0.05;
					--pitch-primary-note-lum: 85.6;
					--pitch-primary-note-lum-scale: 0.025;
					--noise-secondary-channel-hue: 60;
					--noise-secondary-channel-hue-scale: 2;
					--noise-secondary-channel-sat: 25;
					--noise-secondary-channel-sat-scale: 0;
					--noise-secondary-channel-lum: 42;
					--noise-secondary-channel-lum-scale: 0;
					--noise-primary-channel-hue: 60;
					--noise-primary-channel-hue-scale: 2;
					--noise-primary-channel-sat: 33;
					--noise-primary-channel-sat-scale: 0;
					--noise-primary-channel-lum: 63.5;
					--noise-primary-channel-lum-scale: 0;
					--noise-secondary-note-hue: 60;
					--noise-secondary-note-hue-scale: 2;
					--noise-secondary-note-sat: 33.5;
					--noise-secondary-note-sat-scale: 0;
					--noise-secondary-note-lum: 55;
					--noise-secondary-note-lum-scale: 0;
					--noise-primary-note-hue: 60;
					--noise-primary-note-hue-scale: 2;
					--noise-primary-note-sat: 46.5;
					--noise-primary-note-sat-scale: 0;
					--noise-primary-note-lum: 74;
					--noise-primary-note-lum-scale: 0;
					--mod-secondary-channel-hue: 222;
					--mod-secondary-channel-hue-scale: 1.5;
					--mod-secondary-channel-sat: 88;
					--mod-secondary-channel-sat-scale: 0;
					--mod-secondary-channel-lum: 50;
					--mod-secondary-channel-lum-scale: 0;
					--mod-primary-channel-hue: 222;
					--mod-primary-channel-hue-scale: 1.5;
					--mod-primary-channel-sat: 96;
					--mod-primary-channel-sat-scale: 0;
					--mod-primary-channel-lum: 80;
					--mod-primary-channel-lum-scale: 0;
					--mod-secondary-note-hue: 222;
					--mod-secondary-note-hue-scale: 1.5;
					--mod-secondary-note-sat: 92;
					--mod-secondary-note-sat-scale: 0;
					--mod-secondary-note-lum: 54;
					--mod-secondary-note-lum-scale: 0;
					--mod-primary-note-hue: 222;
					--mod-primary-note-hue-scale: 1.5;
					--mod-primary-note-sat: 96;
					--mod-primary-note-sat-scale: 0;
					--mod-primary-note-lum: 75;
					--mod-primary-note-lum-scale: 0;
					--disabled-note-primary:    #515164;
					--disabled-note-secondary:  #2a2a3a;
				}
			`,
        "midnight": `
		:root {
			--page-margin: #000;
			--editor-background: #000;
			--hover-preview: #757575;
			--playhead: #fff;
			--primary-text: #fff;
			--secondary-text: #acacac;
			--inverted-text: #290505;
			--text-selection: rgba(155, 155, 155, 0.99);
			--box-selection-fill: #79797970;
			--loop-accent: #646464;
			--link-accent: #707070;
			--ui-widget-background: #353535;
			--ui-widget-focus: #464646;
			--pitch-background: #222121;
			--tonic: #1a1818;
			--fifth-note: #555955;
			--white-piano-key: #a89e9e;
			--black-piano-key: #2d2424;
			--use-color-formula: true;
			--track-editor-bg-pitch: #373737;
			--track-editor-bg-pitch-dim: #131313;
			--track-editor-bg-noise: #484848;
			--track-editor-bg-noise-dim: #131313;
			--track-editor-bg-mod: #373737;
			--track-editor-bg-mod-dim: #131313;
			--multiplicative-mod-slider: #555;
			--overwriting-mod-slider: #464545;
			--indicator-primary: #e0e0e0;
			--indicator-secondary: #404040;
			--select2-opt-group: #3c3b3b;
			--input-box-outline: #757575;
			--mute-button-normal: #8e8d8d;
			--mute-button-mod: #ddd;
			--mod-label-primary: #262526;
			--mod-label-secondary-text: rgb(227, 222, 225);
			--mod-label-primary-text: #b9b9b9;
			--pitch-secondary-channel-hue: 240;
			--pitch-secondary-channel-hue-scale: 228;
			--pitch-secondary-channel-sat: 73.3;
			--pitch-secondary-channel-sat-scale: 0.1;
			--pitch-secondary-channel-lum: 25;
			--pitch-secondary-channel-lum-scale: 0.05;
			--pitch-primary-channel-hue: 240;
			--pitch-primary-channel-hue-scale: 228;
			--pitch-primary-channel-sat: 80;
			--pitch-primary-channel-sat-scale: 0.1;
			--pitch-primary-channel-lum: 60.5;
			--pitch-primary-channel-lum-scale: 0.05;
			--pitch-secondary-note-hue: 240;
			--pitch-secondary-note-hue-scale: 228;
			--pitch-secondary-note-sat: 73.9;
			--pitch-secondary-note-sat-scale: 0.1;
			--pitch-secondary-note-lum: 32;
			--pitch-secondary-note-lum-scale: 0.05;
			--pitch-primary-note-hue: 240;
			--pitch-primary-note-hue-scale: 228;
			--pitch-primary-note-sat: 90;
			--pitch-primary-note-sat-scale: 0.05;
			--pitch-primary-note-lum: 80.6;
			--pitch-primary-note-lum-scale: 0.025;
			--noise-secondary-channel-hue: 160;
			--noise-secondary-channel-hue-scale: 2;
			--noise-secondary-channel-sat: 25;
			--noise-secondary-channel-sat-scale: 0;
			--noise-secondary-channel-lum: 42;
			--noise-secondary-channel-lum-scale: 0;
			--noise-primary-channel-hue: 160;
			--noise-primary-channel-hue-scale: 2;
			--noise-primary-channel-sat: 33;
			--noise-primary-channel-sat-scale: 0;
			--noise-primary-channel-lum: 63.5;
			--noise-primary-channel-lum-scale: 0;
			--noise-secondary-note-hue: 160;
			--noise-secondary-note-hue-scale: 2;
			--noise-secondary-note-sat: 33.5;
			--noise-secondary-note-sat-scale: 0;
			--noise-secondary-note-lum: 55;
			--noise-secondary-note-lum-scale: 0;
			--noise-primary-note-hue: 160;
			--noise-primary-note-hue-scale: 2;
			--noise-primary-note-sat: 46.5;
			--noise-primary-note-sat-scale: 0;
			--noise-primary-note-lum: 74;
			--noise-primary-note-lum-scale: 0;
			--mod-secondary-channel-hue: 62;
			--mod-secondary-channel-hue-scale: 1.5;
			--mod-secondary-channel-sat: 88;
			--mod-secondary-channel-sat-scale: 0;
			--mod-secondary-channel-lum: 30;
			--mod-secondary-channel-lum-scale: 0;
			--mod-primary-channel-hue: 62;
			--mod-primary-channel-hue-scale: 1.5;
			--mod-primary-channel-sat: 96;
			--mod-primary-channel-sat-scale: 0;
			--mod-primary-channel-lum: 80;
			--mod-primary-channel-lum-scale: 0;
			--mod-secondary-note-hue: 62;
			--mod-secondary-note-hue-scale: 1.5;
			--mod-secondary-note-sat: 92;
			--mod-secondary-note-sat-scale: 0;
			--mod-secondary-note-lum: 34;
			--mod-secondary-note-lum-scale: 0;
			--mod-primary-note-hue: 62;
			--mod-primary-note-hue-scale: 1.5;
			--mod-primary-note-sat: 96;
			--mod-primary-note-sat-scale: 0;
			--mod-primary-note-lum: 75;
			--mod-primary-note-lum-scale: 0;
			--disabled-note-primary:    #66a;
			--disabled-note-secondary:  #447;
		}
	`,
        "jummbox light": `
				:root {
					-webkit-text-stroke-width: 0.5px;
					--page-margin: #fefdff;
					--editor-background: #fefdff;
					--hover-preview: #302880;
					--playhead: rgba(62, 32, 120, 0.9);
					--primary-text: #401890;
					--secondary-text: #8769af;
					--inverted-text: #fefdff;
					--text-selection: rgba(255,160,235,0.99);
					--box-selection-fill: rgba(30,62,220,0.5);
					--loop-accent: #4c35d4;
					--link-accent: #7af;
					--ui-widget-background: #bf9cec;
					--ui-widget-focus: #e9c4ff;
					--pitch-background: #e2d9f9;
					--tonic: #c288cc;
					--fifth-note: #d8c9fd;
					--white-piano-key: #e2e2ff;
					--black-piano-key: #66667a;
					--use-color-formula: true;
					--track-editor-bg-pitch: #d9e5ec;
					--track-editor-bg-pitch-dim: #eaeef5;
					--track-editor-bg-noise: #ffc3ae;
					--track-editor-bg-noise-dim: #ffe0cf;
					--track-editor-bg-mod: #c9accc;
					--track-editor-bg-mod-dim: #ebe3ef;
					--multiplicative-mod-slider: #807caf;
					--overwriting-mod-slider: #909cdf;
					--indicator-primary: #ae38ff;
					--indicator-secondary: #bbd4ec;
					--select2-opt-group: #c1b7f1;
					--input-box-outline: #bbb;
					--mute-button-normal: #e9b752;
					--mute-button-mod: #9558ee;
					--mod-label-primary: #ececff;
					--mod-label-secondary-text: rgb(197, 145, 247);
					--mod-label-primary-text: #302880;
					--pitch-secondary-channel-hue: 0;
					--pitch-secondary-channel-hue-scale: 8.1;
					--pitch-secondary-channel-sat: 53.3;
					--pitch-secondary-channel-sat-scale: -0.1;
					--pitch-secondary-channel-lum: 72;
					--pitch-secondary-channel-lum-scale: -0.05;
					--pitch-primary-channel-hue: 0;
					--pitch-primary-channel-hue-scale: 8.1;
					--pitch-primary-channel-sat: 97;
					--pitch-primary-channel-sat-scale: -0.1;
					--pitch-primary-channel-lum: 45.5;
					--pitch-primary-channel-lum-scale: -0.05;
					--pitch-secondary-note-hue: 0;
					--pitch-secondary-note-hue-scale: 8.1;
					--pitch-secondary-note-sat: 93.9;
					--pitch-secondary-note-sat-scale: -0.1;
					--pitch-secondary-note-lum: 95;
					--pitch-secondary-note-lum-scale: -0.05;
					--pitch-primary-note-hue: 0;
					--pitch-primary-note-hue-scale: 8.1;
					--pitch-primary-note-sat: 100;
					--pitch-primary-note-sat-scale: 0.05;
					--pitch-primary-note-lum: 43.6;
					--pitch-primary-note-lum-scale: -0.025;
					--noise-secondary-channel-hue: 220;
					--noise-secondary-channel-hue-scale: 2;
					--noise-secondary-channel-sat: 25;
					--noise-secondary-channel-sat-scale: 0;
					--noise-secondary-channel-lum: 62;
					--noise-secondary-channel-lum-scale: -0.1;
					--noise-primary-channel-hue: 220;
					--noise-primary-channel-hue-scale: 2;
					--noise-primary-channel-sat: 53;
					--noise-primary-channel-sat-scale: 0;
					--noise-primary-channel-lum: 53.5;
					--noise-primary-channel-lum-scale: -0.1;
					--noise-secondary-note-hue: 220;
					--noise-secondary-note-hue-scale: 2;
					--noise-secondary-note-sat: 58.5;
					--noise-secondary-note-sat-scale: 0;
					--noise-secondary-note-lum: 85;
					--noise-secondary-note-lum-scale: -1;
					--noise-primary-note-hue: 220;
					--noise-primary-note-hue-scale: 2;
					--noise-primary-note-sat: 56.5;
					--noise-primary-note-sat-scale: 0;
					--noise-primary-note-lum: 54;
					--noise-primary-note-lum-scale: -1;
					--mod-secondary-channel-hue: 90;
					--mod-secondary-channel-hue-scale: 1.5;
					--mod-secondary-channel-sat: 88;
					--mod-secondary-channel-sat-scale: 0;
					--mod-secondary-channel-lum: 60;
					--mod-secondary-channel-lum-scale: 0;
					--mod-primary-channel-hue: 90;
					--mod-primary-channel-hue-scale: 1.5;
					--mod-primary-channel-sat: 100;
					--mod-primary-channel-sat-scale: 0;
					--mod-primary-channel-lum: 65;
					--mod-primary-channel-lum-scale: 0;
					--mod-secondary-note-hue: 90;
					--mod-secondary-note-hue-scale: 1.5;
					--mod-secondary-note-sat: 92;
					--mod-secondary-note-sat-scale: 0;
					--mod-secondary-note-lum: 95;
					--mod-secondary-note-lum-scale: 0;
					--mod-primary-note-hue: 90;
					--mod-primary-note-hue-scale: 1.5;
					--mod-primary-note-sat: 96;
					--mod-primary-note-sat-scale: 0;
					--mod-primary-note-lum: 55;
					--mod-primary-note-lum-scale: 0;
					--disabled-note-primary:    #868;
					--disabled-note-secondary:  #767;
				}

				.beepboxEditor button, .beepboxEditor select {
					box-shadow: inset 0 0 0 1px var(--secondary-text);
				}

				.select2-selection__rendered {
					box-shadow: inset 0 0 0 1px var(--secondary-text);
				}
			`,
"beachcombing": `
			:root {
			--page-margin: #010121;
			--editor-background: #020222;
			--hover-preview: #f3ffff;
			--playhead: #fff;
			--primary-text: #c1f1ff;
			--secondary-text: #546775;
			--inverted-text: black;
			--text-selection: rgba(119,68,255,0.99);
			--box-selection-fill: #3e0028;
			--loop-accent: #5a00ff;
			--link-accent: #ff00c8fc;
			--ui-widget-background: #1f2b52;
			--ui-widget-focus: #384e91;
			--pitch-background: #2c3155;
			--tonic: #a32f6e;
			--fifth-note: #0044a0;
			--white-piano-key: #fff;
			--black-piano-key: #202d42;
			--use-color-formula: false;
			--track-editor-bg-pitch: #34406c;
			--track-editor-bg-pitch-dim: #1c1d28;
			--track-editor-bg-noise: #562e3b;
			--track-editor-bg-noise-dim: #161313;
			--track-editor-bg-mod: #372e66;
			--track-editor-bg-mod-dim: #2a1640;
			--multiplicative-mod-slider: #606c9f;
			--overwriting-mod-slider: #6850b5;
			--indicator-primary: #ff67c2;
			--indicator-secondary: #393e4f;
			--select2-opt-group: #5d576f;
			--input-box-outline: #222;
			--mute-button-normal: #7ce1ff;
			--mute-button-mod: #db519d;
			--pitch1-secondary-channel: #329b70;
			--pitch1-primary-channel: #53ffb8;
			--pitch1-secondary-note: #4cb98c;
			--pitch1-primary-note: #98ffd4;
			--pitch2-secondary-channel: #8e8632;
			--pitch2-primary-channel: #fff36a;
			--pitch2-secondary-note: #afaf22;
			--pitch2-primary-note: #f9f93f;
			--pitch3-secondary-channel: #018e8e;
			--pitch3-primary-channel: #00ffff;
			--pitch3-secondary-note: #24b7b7;
			--pitch3-primary-note: #a7ffff;
			--pitch4-secondary-channel: #6c003d;
			--pitch4-primary-channel: #ff0090;
			--pitch4-secondary-note: #a73c78;
			--pitch4-primary-note: #ff98d2;
			--pitch5-secondary-channel: #0e8153;
			--pitch5-primary-channel: #59ffbd;
			--pitch5-secondary-note: #489979;
			--pitch5-primary-note: #b0ffe0;
			--pitch6-secondary-channel: #185aab;
			--pitch6-primary-channel: #4e7ce5;
			--pitch6-secondary-note: #3e99d9;
			--pitch6-primary-note: #b3e3ff;
			--pitch7-secondary-channel: #4f007d;
			--pitch7-primary-channel: #a200ff;
			--pitch7-secondary-note: #9741c9;
			--pitch7-primary-note: #d386ff;
			--pitch8-secondary-channel: #101c8d;
			--pitch8-primary-channel: #1c5df1;
			--pitch8-secondary-note: #FF4E63;
			--pitch8-primary-note: #FFB2BB;
			--pitch9-secondary-channel: #00A170;
			--pitch9-primary-channel: #50FFC9;
			--pitch9-secondary-note: #00C78A;
			--pitch9-primary-note: #83FFD9;
			--pitch10-secondary-channel: #A11FFF;
			--pitch10-primary-channel: #CE8BFF;
			--pitch10-secondary-note: #B757FF;
			--pitch10-primary-note: #DFACFF;
			--noise1-secondary-channel: #635070;
			--noise1-primary-channel: #9071db;
			--noise1-secondary-note: #915dc1;
			--noise1-primary-note: #c5a5ff;
			--noise2-secondary-channel: #993367;
			--noise2-primary-channel: #dd777c;
			--noise2-secondary-note: #cc6695;
			--noise2-primary-note: #f0bbd1;
			--noise3-secondary-channel: #4a8c8f;
			--noise3-primary-channel: #77c5dd;
			--noise3-secondary-note: #6fb4cf;
			--noise3-primary-note: #bbf2ff;
			--noise4-secondary-channel: #8e3e7d;
			--noise4-primary-channel: #c682d2;
			--noise4-secondary-note: #b871c1;
			--noise4-primary-note: #ffb8f0;
			--noise5-secondary-channel: #785e37;
			--noise5-primary-channel: #bb9d77;
			--noise5-secondary-note: #aa8c66;
			--noise5-primary-note: #e2d1b2;
			--mod1-secondary-channel: #4e8397;
			--mod1-primary-channel: #92e6f3;
			--mod1-secondary-note: #76b9d9;
			--mod1-primary-note: #cde3ff;
			--mod2-secondary-channel: #ad5774;
			--mod2-primary-channel: #eba4ae;
			--mod2-secondary-note: #c9719b;
			--mod2-primary-note: #fdcee7;
			--mod3-secondary-channel: #6f579f;
			--mod3-primary-channel: #b192f7;
			--mod3-secondary-note: #a778e1;
			--mod3-primary-note: #f8ddff;
			--mod4-secondary-channel: #a88a36;
			--mod4-primary-channel: #bec825;
			--mod4-secondary-note: #aecb57;
			--mod4-primary-note: #dee9bd;
			--mod-label-primary: #2c2c56;
			--mod-label-secondary-text: rgb(71,69,147);
			--mod-label-primary-text: white;
			--disabled-note-primary: #91879f;
			--disabled-note-secondary: #6a677a;


			}
		`,

		"roe": `
			:root {
			--page-margin: #050000;
			--editor-background: #050000;
			--hover-preview: white;
			--playhead: white;
			--primary-text: #b8cee0;
			--secondary-text: #cb3434;
			--inverted-text: black;
			--text-selection: rgb(255 68 68 / 99%);
			--box-selection-fill: rgb(255 0 0 / 30%);
			--loop-accent: #7744FF;
			--link-accent: #FF2A2A;
			--ui-widget-background: #1a2642;
			--ui-widget-focus: #2c3f6d;
			--pitch-background: #15111a;
			--tonic: #1b3041;
			--fifth-note: #381818;
			--white-piano-key: #cdcdcd;
			--black-piano-key: #232323;
			--use-color-formula: false;
			--track-editor-bg-pitch: #302938;
			--track-editor-bg-pitch-dim: #211c26;
			--track-editor-bg-noise: #261f42;
			--track-editor-bg-noise-dim: #1a152d;
			--track-editor-bg-mod: #183049;
			--track-editor-bg-mod-dim: #102132;
			--multiplicative-mod-slider: #344a7f;
			--overwriting-mod-slider: #344a7f;
			--indicator-primary: #FF2A2A;
			--indicator-secondary: #800000;
			--select2-opt-group: #141e34;
			--input-box-outline: #141e34;
			--mute-button-normal: #299eff;
			--mute-button-mod: #165a93;
			--pitch1-secondary-channel: #273c90;
			--pitch1-primary-channel: #476BFF;
			--pitch1-secondary-note: #273c90;
			--pitch1-primary-note: #476BFF;
			--pitch2-secondary-channel: #3a3898;
			--pitch2-primary-channel: #625FFB;
			--pitch2-secondary-note: #3a3898;
			--pitch2-primary-note: #625FFB;
			--pitch3-secondary-channel: #542780;
			--pitch3-primary-channel: #9C49EC;
			--pitch3-secondary-note: #542780;
			--pitch3-primary-note: #9C49EC;
			--pitch4-secondary-channel: #84225d;
			--pitch4-primary-channel: #fd3fb1;
			--pitch4-secondary-note: #84225d;
			--pitch4-primary-note: #fd3fb1;
			--pitch5-secondary-channel: #8d2323;
			--pitch5-primary-channel: #ff3f3f;
			--pitch5-secondary-note: #8d2323;
			--pitch5-primary-note: #ff3f3f;
			--pitch6-secondary-channel: #84225d;
			--pitch6-primary-channel: #fd3fb1;
			--pitch6-secondary-note: #84225d;
			--pitch6-primary-note: #fd3fb1;
			--pitch7-secondary-channel: #542780;
			--pitch7-primary-channel: #9C49EC;
			--pitch7-secondary-note: #542780;
			--pitch7-primary-note: #9C49EC;
			--pitch8-secondary-channel: #3a3898;
			--pitch8-primary-channel: #625FFB;
			--pitch8-secondary-note: #3a3898;
			--pitch8-primary-note: #625FFB;
			--pitch9-secondary-channel: #273c90;
			--pitch9-primary-channel: #476BFF;
			--pitch9-secondary-note: #273c90;
			--pitch9-primary-note: #476BFF;
			--pitch10-secondary-channel: #165a93;
			--pitch10-primary-channel: #299EFF;
			--pitch10-secondary-note: #165a93;
			--pitch10-primary-note: #299EFF;
			--noise1-secondary-channel: #4281FF;
			--noise1-primary-channel: #96b9ff;
			--noise1-secondary-note: #4281FF;
			--noise1-primary-note: #96b9ff;
			--noise2-secondary-channel: #7347FF;
			--noise2-primary-channel: #c3b0ff;
			--noise2-secondary-note: #7347FF;
			--noise2-primary-note: #c3b0ff;
			--noise3-secondary-channel: #9F3CBF;
			--noise3-primary-channel: #e29cf9;
			--noise3-secondary-note: #9F3CBF;
			--noise3-primary-note: #e29cf9;
			--noise4-secondary-channel: #D3326F;
			--noise4-primary-channel: #fb9bbf;
			--noise4-secondary-note: #D3326F;
			--noise4-primary-note: #fb9bbf;
			--noise5-secondary-channel: #FF2A2A;
			--noise5-primary-channel: #ffa2a2;
			--noise5-secondary-note: #FF2A2A;
			--noise5-primary-note: #ffa2a2;
			--mod1-secondary-channel: #47587a;
			--mod1-primary-channel: #96b9ff;
			--mod1-secondary-note: #47587a;
			--mod1-primary-note: #96b9ff;
			--mod2-secondary-channel: #716791;
			--mod2-primary-channel: #c3b0ff;
			--mod2-secondary-note: #716791;
			--mod2-primary-note: #c3b0ff;
			--mod3-secondary-channel: #6f4c7b;
			--mod3-primary-channel: #e29cf9;
			--mod3-secondary-note: #6f4c7b;
			--mod3-primary-note: #e29cf9;
			--mod4-secondary-channel: #9e6279;
			--mod4-primary-channel: #fb9bbf;
			--mod4-secondary-note: #9e6279;
			--mod4-primary-note: #fb9bbf;
			--mod-label-primary: #15111a;
			--mod-label-secondary-text: #cb3434;
			--mod-label-primary-text: white;
			--disabled-note-primary: #c9c9c9;
			--disabled-note-secondary: #616161;
		}`,

		"moonlight": `
			:root {
			--page-margin: #020514;
			--editor-background: #020514;
			--hover-preview: white;
			--playhead: white;
			--primary-text: #D4DCE9;
			--secondary-text: #3E87DA;
			--inverted-text: black;
			--text-selection: #03599bd9;
			--box-selection-fill: hsl(206deg 66% 41% / 85%);
			--loop-accent: #639BD6;
			--link-accent: #A8C6E8;
			--ui-widget-background: #1e2940;
			--ui-widget-focus: #324b81;
			--pitch-background: #223849;
			--tonic: #33536c;
			--fifth-note: hsl(206deg 36% 16%);
			--white-piano-key: #c1bfe9;
			--black-piano-key: #454354;
			--use-color-formula: false;
			--track-editor-bg-pitch: #25568d80;
			--track-editor-bg-pitch-dim: #10253c80;
			--track-editor-bg-noise: #25568d80;
			--track-editor-bg-noise-dim: #10253c80;
			--track-editor-bg-mod: #25568d80;
			--track-editor-bg-mod-dim: #10253c80;
			--multiplicative-mod-slider: #0476cd;
			--overwriting-mod-slider: #035899;
			--indicator-primary: #57a1f4;
			--indicator-secondary: #2e5684;
			--select2-opt-group: #24355c;
			--input-box-outline: #141e34;
			--mute-button-normal: #6ebffc;
			--mute-button-mod: #0a92fa;
			--pitch1-secondary-channel: #47425c;
			--pitch1-primary-channel: #918bac;
			--pitch1-secondary-note: #6b6489;
			--pitch1-primary-note: #a8a3bf;
			--pitch2-secondary-channel: #626493;
			--pitch2-primary-channel: #bdbed3;
			--pitch2-secondary-note: #626493;
			--pitch2-primary-note: #bdbed3;
			--pitch3-secondary-channel: #6e89b4;
			--pitch3-primary-channel: #d4dce9;
			--pitch3-secondary-note: #6e89b4;
			--pitch3-primary-note: #d4dce9;
			--pitch4-secondary-channel: #4c77a9;
			--pitch4-primary-channel: #a8c6e8;
			--pitch4-secondary-note: #4c77a9;
			--pitch4-primary-note: #a8c6e8;
			--pitch5-secondary-channel: #314e6d;
			--pitch5-primary-channel: #639bd6;
			--pitch5-secondary-note: #46698f;
			--pitch5-primary-note: #639bd6;
			--pitch6-secondary-channel: #143d6b;
			--pitch6-primary-channel: #3e87da;
			--pitch6-secondary-note: #143d6b;
			--pitch6-primary-note: #3e87da;
			--pitch7-secondary-channel: #314e6d;
			--pitch7-primary-channel: #639bd6;
			--pitch7-secondary-note: #314e6d;
			--pitch7-primary-note: #639bd6;
			--pitch8-secondary-channel: #4c77a9;
			--pitch8-primary-channel: #a8c6e8;
			--pitch8-secondary-note: #4c77a9;
			--pitch8-primary-note: #a8c6e8;
			--pitch9-secondary-channel: #6e89b4;
			--pitch9-primary-channel: #d4dce9;
			--pitch9-secondary-note: #6e89b4;
			--pitch9-primary-note: #d4dce9;
			--pitch10-secondary-channel: #626493;
			--pitch10-primary-channel: #bdbed3;
			--pitch10-secondary-note: #626493;
			--pitch10-primary-note: #bdbed3;
			--noise1-secondary-channel: #4b4a55;
			--noise1-primary-channel: #9795a3;
			--noise1-secondary-note: #4b4a55;
			--noise1-primary-note: #9795a3;
			--noise2-secondary-channel: #858e9d;
			--noise2-primary-channel: #d7dce5;
			--noise2-secondary-note: #858e9d;
			--noise2-primary-note: #d7dce5;
			--noise3-secondary-channel: #394e65;
			--noise3-primary-channel: #809bb7;
			--noise3-secondary-note: #394e65;
			--noise3-primary-note: #809bb7;
			--noise4-secondary-channel: #37577b;
			--noise4-primary-channel: #6189b8;
			--noise4-secondary-note: #37577b;
			--noise4-primary-note: #6189b8;
			--noise5-secondary-channel: #223849;
			--noise5-primary-channel: #5588af;
			--noise5-secondary-note: #223849;
			--noise5-primary-note: #5588af;
			--mod1-secondary-channel: #3e336c;
			--mod1-primary-channel: #6d60a4;
			--mod1-secondary-note: #3e336c;
			--mod1-primary-note: #6d60a4;
			--mod2-secondary-channel: #716791;
			--mod2-primary-channel: #bdbed3;
			--mod2-secondary-note: #716791;
			--mod2-primary-note: #bdbed3;
			--mod3-secondary-channel: #6b91bd;
			--mod3-primary-channel: #4b8fdd;
			--mod3-secondary-note: #597ca7;
			--mod3-primary-note: #7eade3;
			--mod4-secondary-channel: #14559f;
			--mod4-primary-channel: #3386e6;
			--mod4-secondary-note: #14559f;
			--mod4-primary-note: #3386e6;
			--mod-label-primary: #1e2940;
			--mod-label-secondary-text: #748ebe;
			--mod-label-primary-text: white;
			--disabled-note-primary: #828282;
			--disabled-note-secondary: #4f4f4f;
			}`,

		"autumn": `
		:root {
			--page-margin: #060304;
			--editor-background: #060304;
			--hover-preview: white;
			--playhead: white;
			--primary-text: white;
			--secondary-text: #999;
			--inverted-text: black;
			--text-selection: rgb(115 80 76);
			--box-selection-fill: rgb(174 73 81 / 45%);
			--loop-accent: #834A69;
			--link-accent: #98f;
			--ui-widget-background: #2a2523;
			--ui-widget-focus: #4e4c44;
			--pitch-background: #121212;
			--tonic: #4f4f4f;
			--fifth-note: #222;
			--white-piano-key: #b59b9b;
			--black-piano-key: #231e1e;
			--use-color-formula: false;
			--track-editor-bg-pitch: #352f38;
			--track-editor-bg-pitch-dim: #232025;
			--track-editor-bg-noise: #3c3029;
			--track-editor-bg-noise-dim: #251d19;
			--track-editor-bg-mod: #202623;
			--track-editor-bg-mod-dim: #131715;
			--multiplicative-mod-slider: #D9D16E;
			--overwriting-mod-slider: #2D826F;
			--indicator-primary: #D9D16E;
			--indicator-secondary: #444226;
			--select2-opt-group: #20191c;
			--input-box-outline: #20191c;
			--mute-button-normal: var(--pitch2-primary-channel);
			--mute-button-mod: var(--pitch4-primary-channel);
			--pitch1-secondary-channel: #704a34;
			--pitch1-primary-channel: #D9895A;
			--pitch1-secondary-note: #704a34;
			--pitch1-primary-note: #D9895A;
			--pitch2-secondary-channel: #5f3538;
			--pitch2-primary-channel: #AE4951;
			--pitch2-secondary-note: #5f3538;
			--pitch2-primary-note: #AE4951;
			--pitch3-secondary-channel: #5c4336;
			--pitch3-primary-channel: #CA9A81;
			--pitch3-secondary-note: #5c4336;
			--pitch3-primary-note: #CA9A81;
			--pitch4-secondary-channel: #1d3143;
			--pitch4-primary-channel: #386995;
			--pitch4-secondary-note: #1d3143;
			--pitch4-primary-note: #386995;
			--pitch5-secondary-channel: #9c8a58;
			--pitch5-primary-channel: #D9D16E;
			--pitch5-secondary-note: #7c783f;
			--pitch5-primary-note: #D9D16E;
			--pitch6-secondary-channel: #886562;
			--pitch6-primary-channel: #D3A9A5;
			--pitch6-secondary-note: #886562;
			--pitch6-primary-note: #D3A9A5;
			--pitch7-secondary-channel: #1c3f37;
			--pitch7-primary-channel: #2D826F;
			--pitch7-secondary-note: #1c3f37;
			--pitch7-primary-note: #2D826F;
			--pitch8-secondary-channel: #442e2d;
			--pitch8-primary-channel: #815150;
			--pitch8-secondary-note: #442e2d;
			--pitch8-primary-note: #815150;
			--pitch9-secondary-channel: #8e6f60;
			--pitch9-primary-channel: #E5B8A1;
			--pitch9-secondary-note: #8e6f60;
			--pitch9-primary-note: #E5B8A1;
			--pitch10-secondary-channel: #4f3142;
			--pitch10-primary-channel: #834A69;
			--pitch10-secondary-note: #4f3142;
			--pitch10-primary-note: #834A69;
			--noise1-secondary-channel: #6b5346;
			--noise1-primary-channel: #b99c89;
			--noise1-secondary-note: #6b5346;
			--noise1-primary-note: #F0D0BB;
			--noise2-secondary-channel: #4a3839;
			--noise2-primary-channel: #9c6b6e;
			--noise2-secondary-note: #4a3839;
			--noise2-primary-note: #c18b8f;
			--noise3-secondary-channel: #2d3c4a;
			--noise3-primary-channel: #536e86;
			--noise3-secondary-note: #2d3c4a;
			--noise3-primary-note: #8fa8c0;
			--noise4-secondary-channel: #273f3a;
			--noise4-primary-channel: #4e8377;
			--noise4-secondary-note: #273f3a;
			--noise4-primary-note: #87baae;
			--noise5-secondary-channel: #372730;
			--noise5-primary-channel: #7f5e70;
			--noise5-secondary-note: #372730;
			--noise5-primary-note: #cc96b3;
			--mod1-secondary-channel: #783f1f;
			--mod1-primary-channel: #dc6d2c;
			--mod1-secondary-note: #783f1f;
			--mod1-primary-note: #dc6d2c;
			--mod2-secondary-channel: #0b3153;
			--mod2-primary-channel: #1464ac;
			--mod2-secondary-note: #0b3153;
			--mod2-primary-note: #1464ac;
			--mod3-secondary-channel: #075040;
			--mod3-primary-channel: #08a17f;
			--mod3-secondary-note: #075040;
			--mod3-primary-note: #08a17f;
			--mod4-secondary-channel: #631640;
			--mod4-primary-channel: #b4186d;
			--mod4-secondary-note: #631640;
			--mod4-primary-note: #b4186d;
			--mod-label-primary: #000;
			--mod-label-secondary-text: #707070;
			--mod-label-primary-text: white;
			--disabled-note-primary: #5d5d5d;
			--disabled-note-secondary: #292929;
		}`,

		"fruit": `
		:root {
			--page-margin: #040507;
			--editor-background: #040507;
			--hover-preview: white;
			--playhead: white;
			--primary-text: white;
			--secondary-text: #999;
			--inverted-text: black;
			--text-selection: rgb(115 103 76);
			--box-selection-fill: rgb(174 109 73 / 45%);
			--loop-accent: #EC897D;
			--link-accent: #FDE484;
			--ui-widget-background: #22222c;
			--ui-widget-focus: #39394c;
			--pitch-background: #101010;
			--tonic: #2c2d34;
			--fifth-note: #191a20;
			--white-piano-key: #bbbaba;
			--black-piano-key: #2d2d2d;
			--use-color-formula: false;
			--track-editor-bg-pitch: #2b2d40;
			--track-editor-bg-pitch-dim: #191a25;
			--track-editor-bg-noise: #3c3644;
			--track-editor-bg-noise-dim: #26222b;
			--track-editor-bg-mod: #322a2a;
			--track-editor-bg-mod-dim: #191515;
			--multiplicative-mod-slider: #977da9;
			--overwriting-mod-slider: #798FA7;
			--indicator-primary: #EAAC9D;
			--indicator-secondary: #5e413a;
			--select2-opt-group: #191920;
			--input-box-outline: #191920;
			--mute-button-normal: #798FA7;
			--mute-button-mod: #354457;
			--pitch1-secondary-channel: #91655a;
			--pitch1-primary-channel: #EAAC9D;
			--pitch1-secondary-note: #91655a;
			--pitch1-primary-note: #EAAC9D;
			--pitch2-secondary-channel: #8f6513;
			--pitch2-primary-channel: #FFAF12;
			--pitch2-secondary-note: #8f6513;
			--pitch2-primary-note: #FFAF12;
			--pitch3-secondary-channel: #212f46;
			--pitch3-primary-channel: #34558B;
			--pitch3-secondary-note: #212f46;
			--pitch3-primary-note: #34558B;
			--pitch4-secondary-channel: #2e6b5b;
			--pitch4-primary-channel: #4EC5A7;
			--pitch4-secondary-note: #2e6b5b;
			--pitch4-primary-note: #4EC5A7;
			--pitch5-secondary-channel: #555D46;
			--pitch5-primary-channel: #aabf84;
			--pitch5-secondary-note: #555D46;
			--pitch5-primary-note: #aabf84;
			--pitch6-secondary-channel: #A2553B;
			--pitch6-primary-channel: #e59a81;
			--pitch6-secondary-note: #A2553B;
			--pitch6-primary-note: #e59a81;
			--pitch7-secondary-channel: #7b4021;
			--pitch7-primary-channel: #FE813E;
			--pitch7-secondary-note: #7b4021;
			--pitch7-primary-note: #FE813E;
			--pitch8-secondary-channel: #847753;
			--pitch8-primary-channel: #EFDAA3;
			--pitch8-secondary-note: #847753;
			--pitch8-primary-note: #EFDAA3;
			--pitch9-secondary-channel: #2c3642;
			--pitch9-primary-channel: #798FA7;
			--pitch9-secondary-note: #2c3642;
			--pitch9-primary-note: #798FA7;
			--pitch10-secondary-channel: #0d4453;
			--pitch10-primary-channel: #107895;
			--pitch10-secondary-note: #0d4453;
			--pitch10-primary-note: #107895;
			--noise1-secondary-channel: #71617C;
			--noise1-primary-channel: #977da9;
			--noise1-secondary-note: #71617C;
			--noise1-primary-note: #977da9;
			--noise2-secondary-channel: #3B3D4A;
			--noise2-primary-channel: #707591;
			--noise2-secondary-note: #3B3D4A;
			--noise2-primary-note: #707591;
			--noise3-secondary-channel: #625f5e;
			--noise3-primary-channel: #A19D9C;
			--noise3-secondary-note: #625f5e;
			--noise3-primary-note: #A19D9C;
			--noise4-secondary-channel: #ab847b;
			--noise4-primary-channel: #EAAC9D;
			--noise4-secondary-note: #ab847b;
			--noise4-primary-note: #EAAC9D;
			--noise5-secondary-channel: #B49D74;
			--noise5-primary-channel: #dec69b;
			--noise5-secondary-note: #B49D74;
			--noise5-primary-note: #dec69b;
			--mod1-secondary-channel: #722124;
			--mod1-primary-channel: #D13A41;
			--mod1-secondary-note: #722124;
			--mod1-primary-note: #D13A41;
			--mod2-secondary-channel: #213657;
			--mod2-primary-channel: #34558B;
			--mod2-secondary-note: #213657;
			--mod2-primary-note: #34558B;
			--mod3-secondary-channel: #555D46;
			--mod3-primary-channel: #848f6d;
			--mod3-secondary-note: #555D46;
			--mod3-primary-note: #848f6d;
			--mod4-secondary-channel: #71617C;
			--mod4-primary-channel: #a68ab9;
			--mod4-secondary-note: #71617C;
			--mod4-primary-note: #a68ab9;
			--mod-label-primary: #282828;
			--mod-label-secondary-text: #707070;
			--mod-label-primary-text: white;
			--disabled-note-primary: #5d5d5d;
			--disabled-note-secondary: #292929;
		}`,

		"sunset": `
		:root {
			--page-margin: #040300;
			--editor-background: #040300;
			--hover-preview: white;
			--playhead: white;
			--primary-text: white;
			--secondary-text: #999;
			--inverted-text: black;
			--text-selection: rgb(94 0 157);
			--box-selection-fill: rgb(174 173 73 / 45%);
			--loop-accent: #EC897D;
			--link-accent: #FDE484;
			--ui-widget-background: #241b24;
			--ui-widget-focus: #3a2e39;
			--pitch-background: #141414;
			--tonic: #2C212B;
			--fifth-note: #2E2A15;
			--white-piano-key: #bbbaba;
			--black-piano-key: #2d2d2d;
			--use-color-formula: false;
			--track-editor-bg-pitch: #2d2e42;
			--track-editor-bg-pitch-dim: #191a25;
			--track-editor-bg-noise: #393340;
			--track-editor-bg-noise-dim: #26222b;
			--track-editor-bg-mod: #232a2c;
			--track-editor-bg-mod-dim: #151819;
			--multiplicative-mod-slider: #977da9;
			--overwriting-mod-slider: #798FA7;
			--indicator-primary: #F28891;
			--indicator-secondary: #601d23;
			--select2-opt-group: #151015;
			--input-box-outline: #151015;
			--mute-button-normal: #E4739D;
			--mute-button-mod: #9650A6;
			--pitch1-secondary-channel: #7F7721;
			--pitch1-primary-channel: #F3E79A;
			--pitch1-secondary-note: #7F7721;
			--pitch1-primary-note: #F3E79A;
			--pitch2-secondary-channel: #785E20;
			--pitch2-primary-channel: #F7D086;
			--pitch2-secondary-note: #785E20;
			--pitch2-primary-note: #F7D086;
			--pitch3-secondary-channel: #6E4219;
			--pitch3-primary-channel: #F9B881;
			--pitch3-secondary-note: #6E4219;
			--pitch3-primary-note: #F9B881;
			--pitch4-secondary-channel: #79351F;
			--pitch4-primary-channel: #F7A086;
			--pitch4-secondary-note: #79351F;
			--pitch4-primary-note: #F7A086;
			--pitch5-secondary-channel: #81272F;
			--pitch5-primary-channel: #F28891;
			--pitch5-secondary-note: #81272F;
			--pitch5-primary-note: #F28891;
			--pitch6-secondary-channel: #8F224D;
			--pitch6-primary-channel: #E4739D;
			--pitch6-secondary-note: #8F224D;
			--pitch6-primary-note: #E4739D;
			--pitch7-secondary-channel: #611548;
			--pitch7-primary-channel: #CF63A6;
			--pitch7-secondary-note: #611548;
			--pitch7-primary-note: #CF63A6;
			--pitch8-secondary-channel: #561253;
			--pitch8-primary-channel: #B557A9;
			--pitch8-secondary-note: #4D104A;
			--pitch8-primary-note: #B557A9;
			--pitch9-secondary-channel: #4c1260;
			--pitch9-primary-channel: #9650A6;
			--pitch9-secondary-note: #3C0F4C;
			--pitch9-primary-note: #9650A6;
			--pitch10-secondary-channel: #3e1d78;
			--pitch10-primary-channel: #704D9E;
			--pitch10-secondary-note: #27124C;
			--pitch10-primary-note: #704D9E;
			--noise1-secondary-channel: #A7A578;
			--noise1-primary-channel: #EFE9AC;
			--noise1-secondary-note: #A7A578;
			--noise1-primary-note: #EFE9AC;
			--noise2-secondary-channel: #947A5F;
			--noise2-primary-channel: #FBCEA8;
			--noise2-secondary-note: #947A5F;
			--noise2-primary-note: #FBCEA8;
			--noise3-secondary-channel: #A3635D;
			--noise3-primary-channel: #F4A5AB;
			--noise3-secondary-note: #A3635D;
			--noise3-primary-note: #F4A5AB;
			--noise4-secondary-channel: #724D60;
			--noise4-primary-channel: #CD90B6;
			--noise4-secondary-note: #724D60;
			--noise4-primary-note: #CD90B6;
			--noise5-secondary-channel: #503F5C;
			--noise5-primary-channel: #7C6A9E;
			--noise5-secondary-note: #503F5C;
			--noise5-primary-note: #7C6A9E;
			--mod1-secondary-channel: #371883;
			--mod1-primary-channel: #6416C6;
			--mod1-secondary-note: #1F0A52;
			--mod1-primary-note: #6416C6;
			--mod2-secondary-channel: #690645;
			--mod2-primary-channel: #E52FA2;
			--mod2-secondary-note: #690645;
			--mod2-primary-note: #E52FA2;
			--mod3-secondary-channel: #943618;
			--mod3-primary-channel: #eb5b2c;
			--mod3-secondary-note: #943618;
			--mod3-primary-note: #eb5b2c;
			--mod4-secondary-channel: #928409;
			--mod4-primary-channel: #ecd50e;
			--mod4-secondary-note: #928409;
			--mod4-primary-note: #ecd50e;
			--mod-label-primary: #282828;
			--mod-label-secondary-text: #707070;
			--mod-label-primary-text: white;
			--disabled-note-primary: #5d5d5d;
			--disabled-note-secondary: #292929;
		}`,
		"dark-monoKai": `
    :root {
        --page-margin: #272822;
        --editor-background: #272822;
        --hover-preview: #F8F8F2;
        --playhead: #F8F8F2;
        --primary-text: #F8F8F2;
        --secondary-text: #75715E;
        --inverted-text: #272822;
        --text-selection: rgba(119,68,255,0.99);
        --box-selection-fill: rgba(255,255,255,0.2);
        --loop-accent: #A6E22E;
        --link-accent: #66D9EF;
        --ui-widget-background: #3E3D32;
        --ui-widget-focus: #75715E;
        --pitch-background: #3E3D32;
        --tonic: #AE81FF;
        --fifth-note: #F92672;
        --white-piano-key: #F8F8F2;
        --black-piano-key: #75715E;
        --use-color-formula: false;
        --track-editor-bg-pitch: #3E3D32;
        --track-editor-bg-pitch-dim: #272822;
        --track-editor-bg-noise: #3E3D32;
        --track-editor-bg-noise-dim: #272822;
        --track-editor-bg-mod: #A6E22E;
        --track-editor-bg-mod-dim: #7587A6;
        --multiplicative-mod-slider: #66D9EF;
        --overwriting-mod-slider: #F92672;
        --indicator-primary: #A6E22E;
        --indicator-secondary: #272822;
        --select2-opt-group: #585858;
        --input-box-outline: #75715E;
        --mute-button-normal: #FF6600;
        --mute-button-mod: #9A6BFF;
        --pitch1-secondary-channel: #66D9EF;
        --pitch1-primary-channel:   #A6E22E;
        --pitch1-secondary-note:    #4A90E2;
        --pitch1-primary-note:      #A6E22E;
        --pitch2-secondary-channel: #F92672;
        --pitch2-primary-channel:   #FF8C00;
        --pitch2-secondary-note:    #F92672;
        --pitch2-primary-note:      #FF8C00;
        --pitch3-secondary-channel: #F8F8F2;
        --pitch3-primary-channel:   #66D9EF;
        --pitch3-secondary-note:    #4A90E2;
        --pitch3-primary-note:      #66D9EF;
        --pitch4-secondary-channel: #A6E22E;
        --pitch4-primary-channel:   #F8F8F2;
        --pitch4-secondary-note:    #8ABF26;
        --pitch4-primary-note:      #A6E22E;
        --pitch5-secondary-channel: #F92672;
        --pitch5-primary-channel:   #F8F8F2;
        --pitch5-secondary-note:    #B82500;
        --pitch5-primary-note:      #F92672;
        --pitch6-secondary-channel: #75715E;
        --pitch6-primary-channel:   #A6E22E;
        --pitch6-secondary-note:    #7F7F7F;
        --pitch6-primary-note:      #A6E22E;
        --pitch7-secondary-channel: #F8F8F2;
        --pitch7-primary-channel:   #66D9EF;
        --pitch7-secondary-note:    #7F7F7F;
        --pitch7-primary-note:      #66D9EF;
        --pitch8-secondary-channel: #FF8C00;
        --pitch8-primary-channel:   #A6E22E;
        --pitch8-secondary-note:    #F92672;
        --pitch8-primary-note:      #FF8C00;
        --pitch9-secondary-channel: #A6E22E;
        --pitch9-primary-channel:   #66D9EF;
        --pitch9-secondary-note:    #66D9EF;
        --pitch9-primary-note:      #A6E22E;
        --pitch10-secondary-channel: #F92672;
        --pitch10-primary-channel:  #FF8C00;
        --pitch10-secondary-note:   #B82500;
        --pitch10-primary-note:     #F8F8F2;
        --noise1-secondary-channel: #BEBEBE;
        --noise1-primary-channel:   #C4C4C4;
        --noise1-secondary-note:    #D0D0D0;
        --noise1-primary-note:      #C8C8C8;
        --noise2-secondary-channel: #75715E;
        --noise2-primary-channel:   #F8F8F2;
        --noise2-secondary-note:    #7F7F7F;
        --noise2-primary-note:      #75715E;
        --noise3-secondary-channel: #A6E22E;
        --noise3-primary-channel:   #66D9EF;
        --noise3-secondary-note:    #A6E22E;
        --noise3-primary-note:      #66D9EF;
        --noise4-secondary-channel: #D0D0D0;
        --noise4-primary-channel:   #75715E;
        --noise4-secondary-note:    #C8C8C8;
        --noise4-primary-note:      #A6E22E;
        --noise5-secondary-channel: #A6E22E;
        --noise5-primary-channel:   #F8F8F2;
        --noise5-secondary-note:    #F8F8F2;
        --noise5-primary-note:      #A6E22E;
        --mod1-secondary-channel:   #66D9EF;
        --mod1-primary-channel:     #FF8C00;
        --mod1-secondary-note:      #66D9EF;
        --mod1-primary-note:        #FF8C00;
        --mod2-secondary-channel:   #F92672;
        --mod2-primary-channel:     #FF8C00;
        --mod2-secondary-note:      #F92672;
        --mod2-primary-note:        #FF8C00;
        --mod3-secondary-channel:   #A6E22E;
        --mod3-primary-channel:     #66D9EF;
        --mod3-secondary-note:      #A6E22E;
        --mod3-primary-note:        #66D9EF;
        --mod4-secondary-channel:   #75715E;
        --mod4-primary-channel:     #A6E22E;
        --mod4-secondary-note:      #75715E;
        --mod4-primary-note:        #66D9EF;
        --mod-label-primary:        #F8F8F2;
        --mod-label-secondary-text: #75715E;
        --mod-label-primary-text:   #A6E22E;
        --disabled-note-primary:    #75715E;
        --disabled-note-secondary:  #BEBEBE;
    }
`,
"dark-dracula": `
    :root {
        --page-margin: #282A36;
        --editor-background: #282A36;
        --hover-preview: #F8F8F2;
        --playhead: #F8F8F2;
        --primary-text: #F8F8F2;
        --secondary-text: #6272A4;
        --inverted-text: #282A36;
        --text-selection: rgba(139,233,253,0.8);
        --box-selection-fill: rgba(255,255,255,0.1);
        --loop-accent: #FF79C6;
        --link-accent: #8BE9FD;
        --ui-widget-background: #44475A;
        --ui-widget-focus: #6272A4;
        --pitch-background: #44475A;
        --tonic: #50FA7B;
        --fifth-note: #FFB86C;
        --white-piano-key: #F8F8F2;
        --black-piano-key: #6272A4;
        --use-color-formula: false;
        --track-editor-bg-pitch: #44475A;
        --track-editor-bg-pitch-dim: #282A36;
        --track-editor-bg-noise: #44475A;
        --track-editor-bg-noise-dim: #282A36;
        --track-editor-bg-mod: #FF79C6;
        --track-editor-bg-mod-dim: #8BE9FD;
        --multiplicative-mod-slider: #8BE9FD;
        --overwriting-mod-slider: #FF79C6;
        --indicator-primary: #FF79C6;
        --indicator-secondary: #282A36;
        --select2-opt-group: #585858;
        --input-box-outline: #6272A4;
        --mute-button-normal: #FF5555;
        --mute-button-mod: #BD93F9;
        --pitch1-secondary-channel: #8BE9FD;
        --pitch1-primary-channel:   #50FA7B;
        --pitch1-secondary-note:    #8BE9FD;
        --pitch1-primary-note:      #50FA7B;
        --pitch2-secondary-channel: #FF79C6;
        --pitch2-primary-channel:   #FFB86C;
        --pitch2-secondary-note:    #FF79C6;
        --pitch2-primary-note:      #FFB86C;
        --pitch3-secondary-channel: #F8F8F2;
        --pitch3-primary-channel:   #8BE9FD;
        --pitch3-secondary-note:    #50FA7B;
        --pitch3-primary-note:      #8BE9FD;
        --pitch4-secondary-channel: #50FA7B;
        --pitch4-primary-channel:   #FF79C6;
        --pitch4-secondary-note:    #8BE9FD;
        --pitch4-primary-note:      #50FA7B;
        --pitch5-secondary-channel: #FFB86C;
        --pitch5-primary-channel:   #BD93F9;
        --pitch5-secondary-note:    #FF79C6;
        --pitch5-primary-note:      #BD93F9;
        --pitch6-secondary-channel: #6272A4;
        --pitch6-primary-channel:   #50FA7B;
        --pitch6-secondary-note:    #F8F8F2;
        --pitch6-primary-note:      #6272A4;
        --pitch7-secondary-channel: #FF79C6;
        --pitch7-primary-channel:   #50FA7B;
        --pitch7-secondary-note:    #BD93F9;
        --pitch7-primary-note:      #FF79C6;
        --pitch8-secondary-channel: #8BE9FD;
        --pitch8-primary-channel:   #FFB86C;
        --pitch8-secondary-note:    #FF79C6;
        --pitch8-primary-note:      #FFB86C;
        --pitch9-secondary-channel: #50FA7B;
        --pitch9-primary-channel:   #FF5555;
        --pitch9-secondary-note:    #8BE9FD;
        --pitch9-primary-note:      #FF5555;
        --pitch10-secondary-channel: #FF79C6;
        --pitch10-primary-channel:  #FFB86C;
        --pitch10-secondary-note:   #FF79C6;
        --pitch10-primary-note:     #F8F8F2;
        --noise1-secondary-channel: #6272A4;
        --noise1-primary-channel:   #8BE9FD;
        --noise1-secondary-note:    #50FA7B;
        --noise1-primary-note:      #8BE9FD;
        --noise2-secondary-channel: #FF79C6;
        --noise2-primary-channel:   #FFB86C;
        --noise2-secondary-note:    #F8F8F2;
        --noise2-primary-note:      #FF79C6;
        --noise3-secondary-channel: #FF5555;
        --noise3-primary-channel:   #BD93F9;
        --noise3-secondary-note:    #FF5555;
        --noise3-primary-note:      #BD93F9;
        --noise4-secondary-channel: #F8F8F2;
        --noise4-primary-channel:   #6272A4;
        --noise4-secondary-note:    #6272A4;
        --noise4-primary-note:      #50FA7B;
        --noise5-secondary-channel: #8BE9FD;
        --noise5-primary-channel:   #FF79C6;
        --noise5-secondary-note:    #6272A4;
        --noise5-primary-note:      #F8F8F2;
        --mod1-secondary-channel:   #6272A4;
        --mod1-primary-channel:     #FF5555;
        --mod1-secondary-note:      #8BE9FD;
        --mod1-primary-note:        #FF5555;
        --mod2-secondary-channel:   #FF79C6;
        --mod2-primary-channel:     #BD93F9;
        --mod2-secondary-note:      #FF79C6;
        --mod2-primary-note:        #BD93F9;
        --mod3-secondary-channel:   #50FA7B;
        --mod3-primary-channel:     #F8F8F2;
        --mod3-secondary-note:      #50FA7B;
        --mod3-primary-note:        #8BE9FD;
        --mod4-secondary-channel:   #FF5555;
        --mod4-primary-channel:     #8BE9FD;
        --mod4-secondary-note:      #FF5555;
        --mod4-primary-note:        #6272A4;
        --mod-label-primary:        #F8F8F2;
        --mod-label-secondary-text: #6272A4;
        --mod-label-primary-text:   #F8F8F2;
        --disabled-note-primary:    #6272A4;
        --disabled-note-secondary:  #44475A;
    }
`,
		"funkylight": `
:root {
  --page-margin: #fff8e7;
  --editor-background: #fffef9;
  --hover-preview: #222;
  --playhead: #ff00cc;
  --primary-text: #333;
  --secondary-text: #777;
  --inverted-text: #ffffff;
  --text-selection: #ffb347;
  --box-selection-fill: rgba(255, 0, 204, 0.3);
  --loop-accent: #ff00cc;
  --link-accent: #00cfff;
  --ui-widget-background: #fff0e5;
  --ui-widget-focus: #ffe0cc;
  --pitch-background: #fffaf2;
  --tonic: #ffcc00;
  --fifth-note: #ff9966;
  --white-piano-key: #ffffff;
  --black-piano-key: #333;
  --use-color-formula: false;
  --track-editor-bg-pitch: #fdf5e6;
  --track-editor-bg-pitch-dim: #f4e8d4;
  --track-editor-bg-noise: #ffeedd;
  --track-editor-bg-noise-dim: #f7ddcc;
  --track-editor-bg-mod: #fce0ff;
  --track-editor-bg-mod-dim: #eed0f5;
  --multiplicative-mod-slider: #ff66cc;
  --overwriting-mod-slider: #00bfff;
  --indicator-primary: #ff1493;
  --indicator-secondary: #ff69b4;
  --select2-opt-group: #ffe4f0;
  --input-box-outline: #ffb6c1;
  --mute-button-normal: #ffaa00;
  --mute-button-mod: #d400ff;
  --pitch1-secondary-channel: #ffa07a;
  --pitch1-primary-channel: #ff4500;
  --pitch1-secondary-note: #ff8c69;
  --pitch1-primary-note: #ff6347;
  --pitch2-secondary-channel: #adff2f;
  --pitch2-primary-channel: #7fff00;
  --pitch2-secondary-note: #9acd32;
  --pitch2-primary-note: #32cd32;
  --pitch3-secondary-channel: #87cefa;
  --pitch3-primary-channel: #1e90ff;
  --pitch3-secondary-note: #00bfff;
  --pitch3-primary-note: #4682b4;
  --pitch4-secondary-channel: #dda0dd;
  --pitch4-primary-channel: #ba55d3;
  --pitch4-secondary-note: #ee82ee;
  --pitch4-primary-note: #da70d6;
  --pitch5-secondary-channel: #ffdb58;
  --pitch5-primary-channel: #ffd700;
  --pitch5-secondary-note: #ffc107;
  --pitch5-primary-note: #ffb300;
  --pitch6-secondary-channel: #ff6f69;
  --pitch6-primary-channel: #ff3e3e;
  --pitch6-secondary-note: #ff7f7f;
  --pitch6-primary-note: #ff1c1c;
  --pitch7-secondary-channel: #00ffff;
  --pitch7-primary-channel: #00ced1;
  --pitch7-secondary-note: #40e0d0;
  --pitch7-primary-note: #20b2aa;
  --pitch8-secondary-channel: #ffc0cb;
  --pitch8-primary-channel: #ff69b4;
  --pitch8-secondary-note: #ff85b2;
  --pitch8-primary-note: #ff1493;
  --pitch9-secondary-channel: #7fffd4;
  --pitch9-primary-channel: #40e0d0;
  --pitch9-secondary-note: #66cdaa;
  --pitch9-primary-note: #20b2aa;
  --pitch10-secondary-channel: #ffe4b5;
  --pitch10-primary-channel: #ffdab9;
  --pitch10-secondary-note: #ffdead;
  --pitch10-primary-note: #f4a460;
  --noise1-secondary-channel: #e0ffff;
  --noise1-primary-channel: #afeeee;
  --noise1-secondary-note: #b0e0e6;
  --noise1-primary-note: #add8e6;
  --noise2-secondary-channel: #f0e68c;
  --noise2-primary-channel: #fffacd;
  --noise2-secondary-note: #fafad2;
  --noise2-primary-note: #ffffe0;
  --noise3-secondary-channel: #f5deb3;
  --noise3-primary-channel: #ffe4c4;
  --noise3-secondary-note: #ffd700;
  --noise3-primary-note: #ffebcd;
  --noise4-secondary-channel: #e6e6fa;
  --noise4-primary-channel: #d8bfd8;
  --noise4-secondary-note: #dda0dd;
  --noise4-primary-note: #eee8aa;
  --noise5-secondary-channel: #f08080;
  --noise5-primary-channel: #fa8072;
  --noise5-secondary-note: #e9967a;
  --noise5-primary-note: #cd5c5c;
  --mod1-secondary-channel: #ff00ff;
  --mod1-primary-channel: #da70d6;
  --mod1-secondary-note: #ff66ff;
  --mod1-primary-note: #d87093;
  --mod2-secondary-channel: #00ffcc;
  --mod2-primary-channel: #20b2aa;
  --mod2-secondary-note: #00ced1;
  --mod2-primary-note: #5f9ea0;
  --mod3-secondary-channel: #ffcc00;
  --mod3-primary-channel: #ffb300;
  --mod3-secondary-note: #ff9900;
  --mod3-primary-note: #ffae42;
  --mod4-secondary-channel: #00ff00;
  --mod4-primary-channel: #7cfc00;
  --mod4-secondary-note: #32cd32;
  --mod4-primary-note: #9acd32;
  --mod-label-primary: #333;
  --mod-label-secondary-text: #777;
  --mod-label-primary-text: #ff00cc;
  --disabled-note-primary: #d3d3d3;
  --disabled-note-secondary: #b0b0b0;
}
`,
"funky": `
:root {
  --page-margin: #0a0a0a;
  --editor-background: #131313;
  --hover-preview: #ff00ff;
  --playhead: #00ffff;
  --primary-text: #e0e0e0;
  --secondary-text: #888888;
  --inverted-text: #000000;
  --text-selection: #ff69b4;
  --box-selection-fill: rgba(255, 105, 180, 0.45);
  --loop-accent: #00ff00;
  --link-accent: #ffa500;
  --ui-widget-background: #1a1a1a;
  --ui-widget-focus: #333333;
  --pitch-background: #181818;
  --tonic: #2b0057;
  --fifth-note: #0037ff;
  --white-piano-key: #dddddd;
  --black-piano-key: #222222;
  --use-color-formula: false;
  --track-editor-bg-pitch: #2d0036;
  --track-editor-bg-pitch-dim: #1a001f;
  --track-editor-bg-noise: #00302b;
  --track-editor-bg-noise-dim: #001a16;
  --track-editor-bg-mod: #361300;
  --track-editor-bg-mod-dim: #1f0a00;
  --multiplicative-mod-slider: #ff33cc;
  --overwriting-mod-slider: #33ccff;
  --indicator-primary: #ffeb3b;
  --indicator-secondary: #ff4081;
  --select2-opt-group: #0d0014;
  --input-box-outline: #2e002a;
  --mute-button-normal: #ff0055;
  --mute-button-mod: #5500ff;
  --pitch1-secondary-channel: #00ffcc;
  --pitch1-primary-channel: #00ffcc;
  --pitch1-secondary-note: #00ffcc;
  --pitch1-primary-note: #00ffcc;
  --pitch2-secondary-channel: #ff00aa;
  --pitch2-primary-channel: #ff00aa;
  --pitch2-secondary-note: #ff00aa;
  --pitch2-primary-note: #ff00aa;
  --pitch3-secondary-channel: #00aa00;
  --pitch3-primary-channel: #00ff00;
  --pitch3-secondary-note: #00aa00;
  --pitch3-primary-note: #00ff00;
  --pitch4-secondary-channel: #aa00aa;
  --pitch4-primary-channel: #ff00ff;
  --pitch4-secondary-note: #aa00aa;
  --pitch4-primary-note: #ff00ff;
  --pitch5-secondary-channel: #ffaa00;
  --pitch5-primary-channel: #ffff00;
  --pitch5-secondary-note: #ffaa00;
  --pitch5-primary-note: #ffff00;
  --pitch6-secondary-channel: #00aaff;
  --pitch6-primary-channel: #00ffff;
  --pitch6-secondary-note: #00aaff;
  --pitch6-primary-note: #00ffff;
  --pitch7-secondary-channel: #ff0055;
  --pitch7-primary-channel: #ff3399;
  --pitch7-secondary-note: #ff0055;
  --pitch7-primary-note: #ff3399;
  --pitch8-secondary-channel: #55ff00;
  --pitch8-primary-channel: #aaff00;
  --pitch8-secondary-note: #55ff00;
  --pitch8-primary-note: #aaff00;
  --pitch9-secondary-channel: #aa0055;
  --pitch9-primary-channel: #ff55aa;
  --pitch9-secondary-note: #aa0055;
  --pitch9-primary-note: #ff55aa;
  --pitch10-secondary-channel: #0055aa;
  --pitch10-primary-channel: #55aaff;
  --pitch10-secondary-note: #0055aa;
  --pitch10-primary-note: #55aaff;
  --noise1-secondary-channel: #ffdd00;
  --noise1-primary-channel: #ffff66;
  --noise1-secondary-note: #ffdd00;
  --noise1-primary-note: #ffff66;
  --noise2-secondary-channel: #dd00ff;
  --noise2-primary-channel: #ff66ff;
  --noise2-secondary-note: #dd00ff;
  --noise2-primary-note: #ff66ff;
  --noise3-secondary-channel: #00ddff;
  --noise3-primary-channel: #66ffff;
  --noise3-secondary-note: #00ddff;
  --noise3-primary-note: #66ffff;
  --noise4-secondary-channel: #ff6600;
  --noise4-primary-channel: #ff9966;
  --noise4-secondary-note: #ff6600;
  --noise4-primary-note: #ff9966;
  --noise5-secondary-channel: #66ff00;
  --noise5-primary-channel: #ccff66;
  --noise5-secondary-note: #66ff00;
  --noise5-primary-note: #ccff66;
  --mod1-secondary-channel: #ff0066;
  --mod1-primary-channel: #ff3399;
  --mod1-secondary-note: #ff0066;
  --mod1-primary-note: #ff3399;
  --mod2-secondary-channel: #6600ff;
  --mod2-primary-channel: #9933ff;
  --mod2-secondary-note: #6600ff;
  --mod2-primary-note: #9933ff;
  --mod3-secondary-channel: #00ff66;
  --mod3-primary-channel: #66ff99;
  --mod3-secondary-note: #00ff66;
  --mod3-primary-note: #66ff99;
  --mod4-secondary-channel: #ff6600;
  --mod4-primary-channel: #ff9933;
  --mod4-secondary-note: #ff6600;
  --mod4-primary-note: #ff9933;
  --mod-label-primary: #ffffff;
  --mod-label-secondary-text: #bbbbbb;
  --mod-label-primary-text: #000000;
  --disabled-note-primary: #555555;
  --disabled-note-secondary: #222222;
}
`,

"mirage": `
:root {
  --page-margin: #1f1c2c;
  --editor-background: #2a2340;
  --hover-preview: #ffc387;
  --playhead: #a58eff;
  --primary-text: #e8e6f1;
  --secondary-text: #b0aeb8;
  --inverted-text: #0f0d12;
  --text-selection: #d3a4ff;
  --box-selection-fill: rgba(211, 164, 255, 0.4);
  --loop-accent: #ff9e80;
  --link-accent: #88d8b0;
  --ui-widget-background: #312b3f;
  --ui-widget-focus: #4a415b;
  --pitch-background: #2e294e;
  --tonic: #3b2f63;
  --fifth-note: #473f77;
  --white-piano-key: #cdc9d9;
  --black-piano-key: #403754;
  --use-color-formula: false;
  --track-editor-bg-pitch: #3a3450;
  --track-editor-bg-pitch-dim: #25203a;
  --track-editor-bg-noise: #504760;
  --track-editor-bg-noise-dim: #3a3547;
  --track-editor-bg-mod: #423a59;
  --track-editor-bg-mod-dim: #2e2840;
  --multiplicative-mod-slider: #c17eff;
  --overwriting-mod-slider: #8fd4ff;
  --indicator-primary: #ffd280;
  --indicator-secondary: #aa84ff;
  --select2-opt-group: #1d1826;
  --input-box-outline: #2f2544;
  --mute-button-normal: #ff6f61;
  --mute-button-mod: #9753d1;
  --pitch1-secondary-channel: #a47aff;
  --pitch1-primary-channel: #d1b3ff;
  --pitch1-secondary-note: #8f66cc;
  --pitch1-primary-note: #d1b3ff;
  --pitch2-secondary-channel: #ffb87a;
  --pitch2-primary-channel: #ffe1b3;
  --pitch2-secondary-note: #cc9a66;
  --pitch2-primary-note: #ffe1b3;
  --pitch3-secondary-channel: #7ad1ff;
  --pitch3-primary-channel: #b3edff;
  --pitch3-secondary-note: #66bad9;
  --pitch3-primary-note: #b3edff;
  --pitch4-secondary-channel: #ff7ab3;
  --pitch4-primary-channel: #ffb3d9;
  --pitch4-secondary-note: #cc6699;
  --pitch4-primary-note: #ffb3d9;
  --pitch5-secondary-channel: #d4ff7a;
  --pitch5-primary-channel: #efffb3;
  --pitch5-secondary-note: #b9cc66;
  --pitch5-primary-note: #efffb3;
  --pitch6-secondary-channel: #7aff94;
  --pitch6-primary-channel: #b3ffd6;
  --pitch6-secondary-note: #66cc7a;
  --pitch6-primary-note: #b3ffd6;
  --pitch7-secondary-channel: #ff7a7a;
  --pitch7-primary-channel: #ffb3b3;
  --pitch7-secondary-note: #cc6666;
  --pitch7-primary-note: #ffb3b3;
  --pitch8-secondary-channel: #7a94ff;
  --pitch8-primary-channel: #b3d6ff;
  --pitch8-secondary-note: #667acc;
  --pitch8-primary-note: #b3d6ff;
  --pitch9-secondary-channel: #d17aff;
  --pitch9-primary-channel: #ebb3ff;
  --pitch9-secondary-note: #aa66cc;
  --pitch9-primary-note: #ebb3ff;
  --pitch10-secondary-channel: #ffda7a;
  --pitch10-primary-channel: #fff4b3;
  --pitch10-secondary-note: #ccba66;
  --pitch10-primary-note: #fff4b3;
  --noise1-secondary-channel: #bbaf7a;
  --noise1-primary-channel: #e6e0b3;
  --noise1-secondary-note: #9c9466;
  --noise1-primary-note: #e6e0b3;
  --noise2-secondary-channel: #af7abb;
  --noise2-primary-channel: #e0b3e6;
  --noise2-secondary-note: #946699;
  --noise2-primary-note: #e0b3e6;
  --noise3-secondary-channel: #7abbaf;
  --noise3-primary-channel: #b3e6e0;
  --noise3-secondary-note: #669994;
  --noise3-primary-note: #b3e6e0;
  --noise4-secondary-channel: #bb7aaf;
  --noise4-primary-channel: #e6b3e0;
  --noise4-secondary-note: #994d99;
  --noise4-primary-note: #e6b3e0;
  --noise5-secondary-channel: #afbb7a;
  --noise5-primary-channel: #e0e6b3;
  --noise5-secondary-note: #999966;
  --noise5-primary-note: #e0e6b3;
  --mod1-secondary-channel: #ff7aff;
  --mod1-primary-channel: #ffb3ff;
  --mod1-secondary-note: #cc66cc;
  --mod1-primary-note: #ffb3ff;
  --mod2-secondary-channel: #7aff7a;
  --mod2-primary-channel: #b3ffb3;
  --mod2-secondary-note: #66cc66;
  --mod2-primary-note: #b3ffb3;
  --mod3-secondary-channel: #7a7aff;
  --mod3-primary-channel: #b3b3ff;
  --mod3-secondary-note: #6666cc;
  --mod3-primary-note: #b3b3ff;
  --mod4-secondary-channel: #ff7a94;
  --mod4-primary-channel: #ffb3c9;
  --mod4-secondary-note: #cc6680;
  --mod4-primary-note: #ffb3c9;
  --mod-label-primary: #e8e6f1;
  --mod-label-secondary-text: #a8a6b0;
  --mod-label-primary-text: #1f1c2c;
  --disabled-note-primary: #6e6b7f;
  --disabled-note-secondary: #3b3944;
}
`
,
"githubdark": `
.fbox{
    color: #58a6ff;
}
:root {
  --page-margin: #0d1117;
  --editor-background: #0d1117;
  --hover-preview: #c9d1d9;
  --playhead: #58a6ff;
  --primary-text: #c9d1d9;
  --secondary-text: #8b949e;
  --inverted-text: #010409;
  --text-selection: #1f6feb;
  --box-selection-fill: rgba(56, 139, 253, 0.35);
  --loop-accent: #238636;
  --link-accent: #58a6ff;
  --ui-widget-background: #161b22;
  --ui-widget-focus: #21262d;
  --pitch-background: #161b22;
  --tonic: #0d1117;
  --fifth-note: #1f6feb;
  --white-piano-key: #c9d1d9;
  --black-piano-key: #010409;
  --use-color-formula: false;
  --track-editor-bg-pitch: #161b22;
  --track-editor-bg-pitch-dim: #0d1117;
  --track-editor-bg-noise: #21262d;
  --track-editor-bg-noise-dim: #161b22;
  --track-editor-bg-mod: #22272e;
  --track-editor-bg-mod-dim: #1b1f24;
  --multiplicative-mod-slider: #79c0ff;
  --overwriting-mod-slider: #38a169;
  --indicator-primary: #39d353;
  --indicator-secondary: #1f6feb;
  --select2-opt-group: #0c131a;
  --input-box-outline: #21262d;
  --mute-button-normal: #d29922;
  --mute-button-mod: #ad8b00;
  --pitch1-secondary-channel: #58a6ff;
  --pitch1-primary-channel: #79c0ff;
  --pitch1-secondary-note: #388bfd;
  --pitch1-primary-note: #a5d6ff;
  --pitch2-secondary-channel: #238636;
  --pitch2-primary-channel: #39d353;
  --pitch2-secondary-note: #1f6feb;
  --pitch2-primary-note: #56d364;
  --pitch3-secondary-channel: #bf4dff;
  --pitch3-primary-channel: #d2a8ff;
  --pitch3-secondary-note: #a463f2;
  --pitch3-primary-note: #e7c6ff;
  --pitch4-secondary-channel: #f85149;
  --pitch4-primary-channel: #ff8182;
  --pitch4-secondary-note: #d73a49;
  --pitch4-primary-note: #ffa39e;
  --pitch5-secondary-channel: #ffa657;
  --pitch5-primary-channel: #ffc657;
  --pitch5-secondary-note: #dd9c46;
  --pitch5-primary-note: #ffeaa7;
  --pitch6-secondary-channel: #96d0ff;
  --pitch6-primary-channel: #b1d4ff;
  --pitch6-secondary-note: #75baff;
  --pitch6-primary-note: #d0eaff;
  --pitch7-secondary-channel: #8b949e;
  --pitch7-primary-channel: #c9d1d9;
  --pitch7-secondary-note: #6e7781;
  --pitch7-primary-note: #e1e4e8;
  --pitch8-secondary-channel: #f97583;
  --pitch8-primary-channel: #ffacb7;
  --pitch8-secondary-note: #d34d6b;
  --pitch8-primary-note: #ffc1ce;
  --pitch9-secondary-channel: #ff7b72;
  --pitch9-primary-channel: #ffb3ac;
  --pitch9-secondary-note: #d64f4f;
  --pitch9-primary-note: #ffdcd7;
  --pitch10-secondary-channel: #a371f7;
  --pitch10-primary-channel: #caa9ff;
  --pitch10-secondary-note: #8a53f2;
  --pitch10-primary-note: #e7d4ff;
  --noise1-secondary-channel: #57606a;
  --noise1-primary-channel: #8b949e;
  --noise1-secondary-note: #484f58;
  --noise1-primary-note: #c9d1d9;
  --noise2-secondary-channel: #2f81f7;
  --noise2-primary-channel: #58a6ff;
  --noise2-secondary-note: #1f6feb;
  --noise2-primary-note: #79c0ff;
  --noise3-secondary-channel: #0ca678;
  --noise3-primary-channel: #39d353;
  --noise3-secondary-note: #238636;
  --noise3-primary-note: #56d364;
  --noise4-secondary-channel: #f0883e;
  --noise4-primary-channel: #ffa657;
  --noise4-secondary-note: #dd9c46;
  --noise4-primary-note: #ffeaa7;
  --noise5-secondary-channel: #bb8bfe;
  --noise5-primary-channel: #d2a8ff;
  --noise5-secondary-note: #9c6ade;
  --noise5-primary-note: #e7c6ff;
  --mod1-secondary-channel: #a371f7;
  --mod1-primary-channel: #caa9ff;
  --mod1-secondary-note: #8a53f2;
  --mod1-primary-note: #e7d4ff;
  --mod2-secondary-channel: #64d4ff;
  --mod2-primary-channel: #97dfff;
  --mod2-secondary-note: #38bdf8;
  --mod2-primary-note: #b4e1ff;
  --mod3-secondary-channel: #ff95c8;
  --mod3-primary-channel: #ffcce0;
  --mod3-secondary-note: #e76ba8;
  --mod3-primary-note: #ffdced;
  --mod4-secondary-channel: #ff7b72;
  --mod4-primary-channel: #ffb3ac;
  --mod4-secondary-note: #d64f4f;
  --mod4-primary-note: #ffdcd7;
  --mod-label-primary: #c9d1d9;
  --mod-label-secondary-text: #8b949e;
  --mod-label-primary-text: #0d1117;
  --disabled-note-primary: #484f58;
  --disabled-note-secondary: #21262d;
}
`,
		"toxic": `
.fbox {
    color: #BCDE2C;
}
		:root {
			--page-margin: #010003;
			--editor-background: #010003;
			--hover-preview: white;
			--playhead: white;
			--primary-text: white;
			--secondary-text: #999;
			--inverted-text: black;
			--text-selection: rgb(147 195 0);
			--box-selection-fill: rgb(145 174 73 / 49%);
			--loop-accent: #BCDE2C;
			--link-accent: #edff9f;
			--ui-widget-background: #261e2e;
			--ui-widget-focus: #322042;
			--pitch-background: #141c15;
			--tonic: #282c21;
			--fifth-note: #18221a;
			--white-piano-key: #e3e3e3;
			--black-piano-key: #2d2d2d;
			--use-color-formula: false;
			--track-editor-bg-pitch: #38293e;
			--track-editor-bg-pitch-dim: #251c29;
			--track-editor-bg-noise: #2c304c;
			--track-editor-bg-noise-dim: #191b2b;
			--track-editor-bg-mod: #311b32;
			--track-editor-bg-mod-dim: #1d101e;
			--multiplicative-mod-slider: #977da9;
			--overwriting-mod-slider: #798FA7;
			--indicator-primary: #aae9ff;
			--indicator-secondary: #253e46;
			--select2-opt-group: #110d15;
			--input-box-outline: #110d15;
			--mute-button-normal: #8f5ad1;
			--mute-button-mod: #482574;
			--pitch1-secondary-channel: #6b7f19;
			--pitch1-primary-channel: #BCDE2C;
			--pitch1-secondary-note: #6b7f19;
			--pitch1-primary-note: #BCDE2C;
			--pitch2-secondary-channel: #497a31;
			--pitch2-primary-channel: #7BD152;
			--pitch2-secondary-note: #497a31;
			--pitch2-primary-note: #7BD152;
			--pitch3-secondary-channel: #286b40;
			--pitch3-primary-channel: #45BE71;
			--pitch3-secondary-note: #286b40;
			--pitch3-primary-note: #45BE71;
			--pitch4-secondary-channel: #125140;
			--pitch4-primary-channel: #25A884;
			--pitch4-secondary-note: #125140;
			--pitch4-primary-note: #25A884;
			--pitch5-secondary-channel: #114c49;
			--pitch5-primary-channel: #21908C;
			--pitch5-secondary-note: #114c49;
			--pitch5-primary-note: #21908C;
			--pitch6-secondary-channel: #143843;
			--pitch6-primary-channel: #2B788E;
			--pitch6-secondary-note: #143843;
			--pitch6-primary-note: #2B788E;
			--pitch7-secondary-channel: #1d354e;
			--pitch7-primary-channel: #355F8D;
			--pitch7-secondary-note: #1a2f46;
			--pitch7-primary-note: #355F8D;
			--pitch8-secondary-channel: #2c2e5a;
			--pitch8-primary-channel: #414486;
			--pitch8-secondary-note: #1e1f3d;
			--pitch8-primary-note: #414486;
			--pitch9-secondary-channel: #3c1f5e;
			--pitch9-primary-channel: #5e3b89;
			--pitch9-secondary-note: #25133b;
			--pitch9-primary-note: #5e3b89;
			--pitch10-secondary-channel: #510264;
			--pitch10-primary-channel: #720d8a;
			--pitch10-secondary-note: #440154;
			--pitch10-primary-note: #720d8a;
			--noise1-secondary-channel: #BCDE2C;
			--noise1-primary-channel: #edff9f;
			--noise1-secondary-note: #BCDE2C;
			--noise1-primary-note: #edff9f;
			--noise2-secondary-channel: #45BE71;
			--noise2-primary-channel: #89ffb4;
			--noise2-secondary-note: #45BE71;
			--noise2-primary-note: #89ffb4;
			--noise3-secondary-channel: #21908C;
			--noise3-primary-channel: #72fffa;
			--noise3-secondary-note: #21908C;
			--noise3-primary-note: #72fffa;
			--noise4-secondary-channel: #355F8D;
			--noise4-primary-channel: #7cb6f5;
			--noise4-secondary-note: #355F8D;
			--noise4-primary-note: #7cb6f5;
			--noise5-secondary-channel: #482574;
			--noise5-primary-channel: #8f5ad1;
			--noise5-secondary-note: #48257A;
			--noise5-primary-note: #8f5ad1;
			--mod1-secondary-channel: #815a16;
			--mod1-primary-channel: #F5AB29;
			--mod1-secondary-note: #815a16;
			--mod1-primary-note: #F5AB29;
			--mod2-secondary-channel: #4d341a;
			--mod2-primary-channel: #C98540;
			--mod2-secondary-note: #4d341a;
			--mod2-primary-note: #C98540;
			--mod3-secondary-channel: #643734;
			--mod3-primary-channel: #A75D58;
			--mod3-secondary-note: #643734;
			--mod3-primary-note: #A75D58;
			--mod4-secondary-channel: #461430;
			--mod4-primary-channel: #812359;
			--mod4-secondary-note: #3f112b;
			--mod4-primary-note: #812359;
			--mod-label-primary: #282828;
			--mod-label-secondary-text: #707070;
			--mod-label-primary-text: white;
			--disabled-note-primary: #5d5d5d;
			--disabled-note-secondary: #292929;
		}`,
 
		"violet verdant": `
		:root {
			--page-margin: #0e031a;
			--editor-background: #0e031a;
			--hover-preview: #e5ffea;
			--playhead: rgba(255, 255, 255, 0.9);
			--primary-text: #f0e0ff;
			--secondary-text: #706087;
			--inverted-text: black;
			--text-selection: rgba(119,68,255,0.99);
			--box-selection-fill: #225835;
			--loop-accent: #8f00fb;
			--link-accent: #82dd5d;
			--ui-widget-background: #303c66;
			--ui-widget-focus: #62559b;
			--pitch-background: #293b52;
			--tonic: #5b46ad;
			--fifth-note: #42604d;
			--white-piano-key: #f6e8ff;
			--black-piano-key: #5a4972;
			--use-color-formula: true;
			--track-editor-bg-pitch: #392a46;
			--track-editor-bg-pitch-dim: #1c1d28;
			--track-editor-bg-noise: #403150;
			--track-editor-bg-noise-dim: #161313;
			--track-editor-bg-mod: #253c25;
			--track-editor-bg-mod-dim: #0c1811;
			--multiplicative-mod-slider: #606c9f;
			--overwriting-mod-slider: #6850b5;
			--indicator-primary: #9c64f7;
			--indicator-secondary: #393e4f;
			--select2-opt-group: #5d576f;
			--input-box-outline: #403150;
			--mute-button-normal: #82dd5d;
			--mute-button-mod: #945de5;
			--mod-label-primary: #312840;
			--mod-label-secondary-text: rgb(88 70 104);
			--mod-label-primary-text: #82dd5d;
			--pitch-secondary-channel-hue: 64;
			--pitch-secondary-channel-hue-scale: 6.1;
			--pitch-secondary-channel-sat: 63.3;
			--pitch-secondary-channel-sat-scale: 0.1;
			--pitch-secondary-channel-lum: 40;
			--pitch-secondary-channel-lum-scale: 0.05;
			--pitch-primary-channel-hue: 64;
			--pitch-primary-channel-hue-scale: 6.1;
			--pitch-primary-channel-sat: 90;
			--pitch-primary-channel-sat-scale: 0.1;
			--pitch-primary-channel-lum: 67.5;
			--pitch-primary-channel-lum-scale: 0.05;
			--pitch-secondary-note-hue: 32;
			--pitch-secondary-note-hue-scale: 6.1;
			--pitch-secondary-note-sat: 87.9;
			--pitch-secondary-note-sat-scale: 0.1;
			--pitch-secondary-note-lum: 25;
			--pitch-secondary-note-lum-scale: 0.05;
			--pitch-primary-note-hue: 64;
			--pitch-primary-note-hue-scale: 6.1;
			--pitch-primary-note-sat: 90;
			--pitch-primary-note-sat-scale: 0.05;
			--pitch-primary-note-lum: 85.6;
			--pitch-primary-note-lum-scale: 0.025;
			--noise-secondary-channel-hue: 192;
			--noise-secondary-channel-hue-scale: 2;
			--noise-secondary-channel-sat: 45;
			--noise-secondary-channel-sat-scale: 0;
			--noise-secondary-channel-lum: 32;
			--noise-secondary-channel-lum-scale: 0;
			--noise-primary-channel-hue: 192;
			--noise-primary-channel-hue-scale: 2;
			--noise-primary-channel-sat: 33;
			--noise-primary-channel-sat-scale: 0;
			--noise-primary-channel-lum: 43.5;
			--noise-primary-channel-lum-scale: 0;
			--noise-secondary-note-hue: 160;
			--noise-secondary-note-hue-scale: 2;
			--noise-secondary-note-sat: 33.5;
			--noise-secondary-note-sat-scale: 0;
			--noise-secondary-note-lum: 45;
			--noise-secondary-note-lum-scale: 0;
			--noise-primary-note-hue: 192;
			--noise-primary-note-hue-scale: 2;
			--noise-primary-note-sat: 46.5;
			--noise-primary-note-sat-scale: 0;
			--noise-primary-note-lum: 74;
			--noise-primary-note-lum-scale: 0;
			--mod-secondary-channel-hue: 132;
			--mod-secondary-channel-hue-scale: 1.5;
			--mod-secondary-channel-sat: 88;
			--mod-secondary-channel-sat-scale: 0;
			--mod-secondary-channel-lum: 50;
			--mod-secondary-channel-lum-scale: 0;
			--mod-primary-channel-hue: 132;
			--mod-primary-channel-hue-scale: 1.5;
			--mod-primary-channel-sat: 96;
			--mod-primary-channel-sat-scale: 0;
			--mod-primary-channel-lum: 80;
			--mod-primary-channel-lum-scale: 0;
			--mod-secondary-note-hue: 100;
			--mod-secondary-note-hue-scale: 1.5;
			--mod-secondary-note-sat: 92;
			--mod-secondary-note-sat-scale: 0;
			--mod-secondary-note-lum: 45;
			--mod-secondary-note-lum-scale: 0;
			--mod-primary-note-hue: 132;
			--mod-primary-note-hue-scale: 1.5;
			--mod-primary-note-sat: 96;
			--mod-primary-note-sat-scale: 0;
			--mod-primary-note-lum: 85;
			--mod-primary-note-lum-scale: 0;
			--disabled-note-primary: #91879f;
			--disabled-note-secondary: #6a677a;
		}`,

		"portal": `
		:root {
			--page-margin: #04081a;
			--editor-background: #04081a;
			--hover-preview: white;
			--playhead: white;
			--primary-text: white;
			--secondary-text: #999;
			--inverted-text: black;
			--text-selection: rgba(119,68,255,0.99);
			--box-selection-fill: rgb(0 72 181);
			--loop-accent: #44d4ff;
			--link-accent: #ffa500;
			--ui-widget-background: #212c4a;
			--ui-widget-focus: #121f42;
			--pitch-background: #1b263e;
			--tonic: #995d00;
			--fifth-note: #0898a1;
			--white-piano-key: #ffffff;
			--black-piano-key: #516d7a;
			--use-color-formula: false;
			--track-editor-bg-pitch: #213352;
			--track-editor-bg-pitch-dim: #152032;
			--track-editor-bg-noise: #403524;
			--track-editor-bg-noise-dim: #2a1f0e;
			--track-editor-bg-mod: #234;
			--track-editor-bg-mod-dim: #123;
			--multiplicative-mod-slider: #456;
			--overwriting-mod-slider: #654;
			--indicator-primary: #5490ff;
			--indicator-secondary: #444;
			--select2-opt-group: #585858;
			--input-box-outline: #333;
			--mute-button-normal: #3372ff;
			--mute-button-mod: #dd872f;
			--pitch1-secondary-channel: #0099A1;
			--pitch1-primary-channel: #77f7ff;
			--pitch1-secondary-note: #00BDC7;
			--pitch1-primary-note: #92F9FF;
			--pitch2-secondary-channel: #0083a1;
			--pitch2-primary-channel: #35d9ff;
			--pitch2-secondary-note: #0083a1;
			--pitch2-primary-note: #a4eeff;
			--pitch3-secondary-channel: #0074c7;
			--pitch3-primary-channel: #3caeff;
			--pitch3-secondary-note: #00477a;
			--pitch3-primary-note: #aadcff;
			--pitch4-secondary-channel: #0039a1;
			--pitch4-primary-channel: #2673ff;
			--pitch4-secondary-note: #001f56;
			--pitch4-primary-note: #9bbeff;
			--pitch5-secondary-channel: #31148b;
			--pitch5-primary-channel: #7042ff;
			--pitch5-secondary-note: #190656;
			--pitch5-primary-note: #b79fff;
			--pitch6-secondary-channel: #979934;
			--pitch6-primary-channel: #fbff2f;
			--pitch6-secondary-note: #5d5e0a;
			--pitch6-primary-note: #fdff9a;
			--pitch7-secondary-channel: #b78f00;
			--pitch7-primary-channel: #ffd747;
			--pitch7-secondary-note: #5e3d00;
			--pitch7-primary-note: #ffe381;
			--pitch8-secondary-channel: #9d6500;
			--pitch8-primary-channel: #ffa400;
			--pitch8-secondary-note: #583900;
			--pitch8-primary-note: #ffd07c;
			--pitch9-secondary-channel: #744203;
			--pitch9-primary-channel: #ff8e00;
			--pitch9-secondary-note: #502d00;
			--pitch9-primary-note: #ffcb89;
			--pitch10-secondary-channel: #a32d00;
			--pitch10-primary-channel: #ff885b;
			--pitch10-secondary-note: #521700;
			--pitch10-primary-note: #ffb397;
			--noise1-secondary-channel: #6e2210;
			--noise1-primary-channel: #ff4600;
			--noise1-secondary-note: #4c1a08;
			--noise1-primary-note: #ffc9b4;
			--noise2-secondary-channel: #6a3110;
			--noise2-primary-channel: #ff782a;
			--noise2-secondary-note: #4c1f05;
			--noise2-primary-note: #ffb488;
			--noise3-secondary-channel: #72460e;
			--noise3-primary-channel: #d9871f;
			--noise3-secondary-note: #442905;
			--noise3-primary-note: #ffdcae;
			--noise4-secondary-channel: #837a0f;
			--noise4-primary-channel: #f7ea55;
			--noise4-secondary-note: #605906;
			--noise4-primary-note: #fff9ab;
			--noise5-secondary-channel: #8c8f00;
			--noise5-primary-channel: #fdff90;
			--noise5-secondary-note: #606200;
			--noise5-primary-note: #feffbc;
			--mod1-secondary-channel: #561b97;
			--mod1-primary-channel: #aa66f5;
			--mod1-secondary-note: #30075c;
			--mod1-primary-note: #cd9fff;
			--mod2-secondary-channel: #5116df;
			--mod2-primary-channel: #6b2dff;
			--mod2-secondary-note: #36138b;
			--mod2-primary-note: #bea3ff;
			--mod3-secondary-channel: #2535a1;
			--mod3-primary-channel: #3f57ff;
			--mod3-secondary-note: #0e185c;
			--mod3-primary-note: #8494ff;
			--mod4-secondary-channel: #1b5883;
			--mod4-primary-channel: #5eb7f5;
			--mod4-secondary-note: #072f4a;
			--mod4-primary-note: #63beff;
			--mod-label-primary: #24293a;
			--mod-label-secondary-text: #454d4e;
			--mod-label-primary-text: #7bd4ff;
			--disabled-note-primary: #072f4a;
			--disabled-note-secondary: #6585a7;
		}`,

		"fusion":
		`:root {
			--page-margin: #0c0306;
			--editor-background: #0c0306;
			--hover-preview: white;
			--playhead: white;
			--primary-text: #26d9cd;
			--secondary-text: #ff6666;
			--inverted-text: white;
			--text-selection: #ffffff;
			--box-selection-fill: #ff00004d;
			--loop-accent: #ff6666;
			--link-accent: white;
			--ui-widget-background: #232323;
			--ui-widget-focus: #303030;
			--pitch-background: hsl(61deg 100% 70% / 25%);
			--tonic: #66a3ff40;
			--fifth-note: #ff666640;
			--white-piano-key: #cdcdcd;
			--black-piano-key: #232323;
			--use-color-formula: false;
			--track-editor-bg-pitch: #404040bf;
			--track-editor-bg-pitch-dim: #151515;
			--track-editor-bg-noise: #404040bf;
			--track-editor-bg-noise-dim: #151515;
			--track-editor-bg-mod: #404040bf;
			--track-editor-bg-mod-dim: #151515;
			--multiplicative-mod-slider: #ef7692;
			--overwriting-mod-slider: #f43e69;
			--indicator-primary: #26d9cd;
			--indicator-secondary: hsl(176deg 70% 25%);
			--select2-opt-group: #232323;
			--input-box-outline: #141e34;
			--mute-button-normal: #26d9cd;
			--mute-button-mod: hsl(346deg 70% 50%);
			--pitch1-secondary-channel: #bf4040;
			--pitch1-primary-channel: #ff6666;
			--pitch1-secondary-note: #bf4040;
			--pitch1-primary-note: #ff6666;
			--pitch2-secondary-channel: #bf5b40;
			--pitch2-primary-channel: #ff8766;
			--pitch2-secondary-note: #bf5b40;
			--pitch2-primary-note: #ff8766;
			--pitch3-secondary-channel: #bf7940;
			--pitch3-primary-channel: #ffab66;
			--pitch3-secondary-note: #bf7940;
			--pitch3-primary-note: #ffab66;
			--pitch4-secondary-channel: #bf9b40;
			--pitch4-primary-channel: #ffd466;
			--pitch4-secondary-note: #bf9b40;
			--pitch4-primary-note: #ffd466;
			--pitch5-secondary-channel: #bdbf40;
			--pitch5-primary-channel: #fcff66;
			--pitch5-secondary-note: #bdbf40;
			--pitch5-primary-note: #fcff66;
			--pitch6-secondary-channel: #9dbf40;
			--pitch6-primary-channel: #d6ff66;
			--pitch6-secondary-note: #9dbf40;
			--pitch6-primary-note: #d6ff66;
			--pitch7-secondary-channel: #9dbf40;
			--pitch7-primary-channel: #fcff66;
			--pitch7-secondary-note: #9dbf40;
			--pitch7-primary-note: #fcff66;
			--pitch8-secondary-channel: #bf9b40;
			--pitch8-primary-channel: #ffd466;
			--pitch8-secondary-note: #bf9b40;
			--pitch8-primary-note: #ffd466;
			--pitch9-secondary-channel: #bf5b40;
			--pitch9-primary-channel: #ffab66;
			--pitch9-secondary-note: #bf5b40;
			--pitch9-primary-note: #ffab66;
			--pitch10-secondary-channel: #d15a1f;
			--pitch10-primary-channel: #ff8766;
			--pitch10-secondary-note: #d15a1f;
			--pitch10-primary-note: #ff8766;
			--noise1-secondary-channel: #4073bf;
			--noise1-primary-channel: #66a3ff;
			--noise1-secondary-note: #4073bf;
			--noise1-primary-note: #66a3ff;
			--noise2-secondary-channel: #405dbf;
			--noise2-primary-channel: #668aff;
			--noise2-secondary-note: #405dbf;
			--noise2-primary-note: #668aff;
			--noise3-secondary-channel: #4f40bf;
			--noise3-primary-channel: #7866ff;
			--noise3-secondary-note: #4f40bf;
			--noise3-primary-note: #7866ff;
			--noise4-secondary-channel: #8840bf;
			--noise4-primary-channel: #bd66ff;
			--noise4-secondary-note: #8840bf;
			--noise4-primary-note: #bd66ff;
			--noise5-secondary-channel: #bf40b5;
			--noise5-primary-channel: #ff66f2;
			--noise5-secondary-note: #bf40b5;
			--noise5-primary-note: #ff66f2;
			--mod1-secondary-channel: #cc6666;
			--mod1-primary-channel: #ff9999;
			--mod1-secondary-note: #cc6666;
			--mod1-primary-note: #ff9999;
			--mod2-secondary-channel: #cc7766;
			--mod2-primary-channel: #ffaa99;
			--mod2-secondary-note: #bf5540;
			--mod2-primary-note: #ffaa99;
			--mod3-secondary-channel: #cc8866;
			--mod3-primary-channel: #ffbb99;
			--mod3-secondary-note: #cc8866;
			--mod3-primary-note: #ffbb99;
			--mod4-secondary-channel: #cc9966;
			--mod4-primary-channel: #ffcc99;
			--mod4-secondary-note: #cc9966;
			--mod4-primary-note: #ffcc99;
			--mod-label-primary: #999;
			--mod-label-secondary-text: #333;
			--mod-label-primary-text: black;
			--disabled-note-primary: #696969;
			--disabled-note-secondary: #232323;
		}`,

		"inverse":
			`:root {
			--page-margin: #c4c8e3;
			--editor-background: #c4c8e3;
			--hover-preview: #000000;
			--playhead: #243953;
			--primary-text: black;
			--secondary-text: #855b95;
			--inverted-text: black;
			--text-selection: rgb(132 125 255);
			--box-selection-fill: rgb(174 109 73 / 65%);
			--loop-accent: #EC897D;
			--link-accent: #4e00c8;
			--ui-widget-background: #e7e7ff;
			--ui-widget-focus: #d0d3e9;
			--pitch-background: #ffffff;
			--tonic: #bbbbbb;
			--fifth-note: #dcdcdc;
			--white-piano-key: #ffffff;
			--black-piano-key: #615f66;
			--use-color-formula: false;
			--track-editor-bg-pitch: #e9ebff;
			--track-editor-bg-pitch-dim: #e9ebff;
			--track-editor-bg-noise: #fdf2fe;
			--track-editor-bg-noise-dim: #fdf2fe;
			--track-editor-bg-mod: #dbdefe;
			--track-editor-bg-mod-dim: #dbdefe;
			--multiplicative-mod-slider: #6900b3;
			--overwriting-mod-slider: #004b9d;
			--indicator-primary: #ff633d;
			--indicator-secondary: #933822;
			--select2-opt-group: #e7e7ff;
			--input-box-outline: #e7e7ff;
			--mute-button-normal: #0072ef;
			--mute-button-mod: #002e67;
			--pitch1-secondary-channel: #b77d6e;
			--pitch1-primary-channel: #ff9d85;
			--pitch1-secondary-note: #b77d6e;
			--pitch1-primary-note: #ff9d85;
			--pitch2-secondary-channel: #be8821;
			--pitch2-primary-channel: #FFAF12;
			--pitch2-secondary-note: #be8821;
			--pitch2-primary-note: #FFAF12;
			--pitch3-secondary-channel: #3a62a4;
			--pitch3-primary-channel: #528ae6;
			--pitch3-secondary-note: #3a62a4;
			--pitch3-primary-note: #528ae6;
			--pitch4-secondary-channel: #3e8d78;
			--pitch4-primary-channel: #4EC5A7;
			--pitch4-secondary-note: #3e8d78;
			--pitch4-primary-note: #4EC5A7;
			--pitch5-secondary-channel: #84906d;
			--pitch5-primary-channel: #aabf84;
			--pitch5-secondary-note: #84906d;
			--pitch5-primary-note: #aabf84;
			--pitch6-secondary-channel: #bd6345;
			--pitch6-primary-channel: #e59a81;
			--pitch6-secondary-note: #bd6345;
			--pitch6-primary-note: #e59a81;
			--pitch7-secondary-channel: #aa592f;
			--pitch7-primary-channel: #FE813E;
			--pitch7-secondary-note: #aa592f;
			--pitch7-primary-note: #FE813E;
			--pitch8-secondary-channel: #b2a171;
			--pitch8-primary-channel: #ffd76d;
			--pitch8-secondary-note: #b2a171;
			--pitch8-primary-note: #ffd76d;
			--pitch9-secondary-channel: #4f6177;
			--pitch9-primary-channel: #798FA7;
			--pitch9-secondary-note: #4f6177;
			--pitch9-primary-note: #798FA7;
			--pitch10-secondary-channel: #165162;
			--pitch10-primary-channel: #107895;
			--pitch10-secondary-note: #165162;
			--pitch10-primary-note: #107895;
			--noise1-secondary-channel: #71617C;
			--noise1-primary-channel: #977da9;
			--noise1-secondary-note: #71617C;
			--noise1-primary-note: #977da9;
			--noise2-secondary-channel: #4a4c5b;
			--noise2-primary-channel: #707591;
			--noise2-secondary-note: #4a4c5b;
			--noise2-primary-note: #707591;
			--noise3-secondary-channel: #817c7b;
			--noise3-primary-channel: #A19D9C;
			--noise3-secondary-note: #817c7b;
			--noise3-primary-note: #A19D9C;
			--noise4-secondary-channel: #ab847b;
			--noise4-primary-channel: #EAAC9D;
			--noise4-secondary-note: #ab847b;
			--noise4-primary-note: #EAAC9D;
			--noise5-secondary-channel: #B49D74;
			--noise5-primary-channel: #dec69b;
			--noise5-secondary-note: #B49D74;
			--noise5-primary-note: #dec69b;
			--mod1-secondary-channel: #722124;
			--mod1-primary-channel: #D13A41;
			--mod1-secondary-note: #722124;
			--mod1-primary-note: #D13A41;
			--mod2-secondary-channel: #213657;
			--mod2-primary-channel: #34558B;
			--mod2-secondary-note: #213657;
			--mod2-primary-note: #34558B;
			--mod3-secondary-channel: #555D46;
			--mod3-primary-channel: #848f6d;
			--mod3-secondary-note: #555D46;
			--mod3-primary-note: #848f6d;
			--mod4-secondary-channel: #71617C;
			--mod4-primary-channel: #a68ab9;
			--mod4-secondary-note: #71617C;
			--mod4-primary-note: #a68ab9;
			--mod-label-primary: #e9e9e9;
			--mod-label-secondary-text: #707070;
			--mod-label-primary-text: black;
			--disabled-note-primary: #959595;
			--disabled-note-secondary: #6e6e6e;
			}`,

		"nebula": `
		:root {
			--page-margin: #040410;
			--editor-background: #150e1f;
			--hover-preview: white;
			--playhead: rgba(255, 255, 255, 0.9);
			--primary-text: white;
			--secondary-text: #8C849A;
			--inverted-text: black;
			--text-selection: rgba(141,79,201,0.99);
			--box-selection-fill: #311E44;
			--loop-accent: #CC688C;
			--link-accent: #817DC9;
			--ui-widget-background: #44394F;
			--ui-widget-focus: #7A6386;
			--pitch-background: #393e4f40;
			--tonic: #7D5C9EC0;
			--fifth-note: #ab77bd50;
			--white-piano-key: #EEEEEE;
			--black-piano-key: #5F5566;
			--use-color-formula: true;
			--track-editor-bg-pitch: #46374C;
			--track-editor-bg-pitch-dim: #1F1C2850;
			--track-editor-bg-noise: #3D353B;
			--track-editor-bg-noise-dim: #16131550;
			--track-editor-bg-mod: #623F4C;
			--track-editor-bg-mod-dim: #361A2450;
			--multiplicative-mod-slider: #9F6E6A;
			--overwriting-mod-slider: #A664B5;
			--indicator-primary: #CC6B8E;
			--indicator-secondary: #44394F;
			--select2-opt-group: #6A576F;
			--input-box-outline: #222;
			--mute-button-normal: #BF91DC;
			--mute-button-mod: #DC8C9A;
			--mod-label-primary: #3A2840;
			--mod-label-secondary-text: #62485E;
			--mod-label-primary-text: white;
			--pitch-secondary-channel-hue: -96;
			--pitch-secondary-channel-hue-scale: 4.2;
			--pitch-secondary-channel-sat: 50.3;
			--pitch-secondary-channel-sat-scale: 0.1;
			--pitch-secondary-channel-lum: 40;
			--pitch-secondary-channel-lum-scale: 0.05;
			--pitch-primary-channel-hue: -96;
			--pitch-primary-channel-hue-scale: 4.2;
			--pitch-primary-channel-sat: 70;
			--pitch-primary-channel-sat-scale: 0.1;
			--pitch-primary-channel-lum: 67.5;
			--pitch-primary-channel-lum-scale: 0.05;
			--pitch-secondary-note-hue: -96;
			--pitch-secondary-note-hue-scale: 4.2;
			--pitch-secondary-note-sat: 70.9;
			--pitch-secondary-note-sat-scale: 0.1;
			--pitch-secondary-note-lum: 25;
			--pitch-secondary-note-lum-scale: 0.05;
			--pitch-primary-note-hue: -96;
			--pitch-primary-note-hue-scale: 4.2;
			--pitch-primary-note-sat: 90;
			--pitch-primary-note-sat-scale: 0.05;
			--pitch-primary-note-lum: 85.6;
			--pitch-primary-note-lum-scale: 0.025;
			--noise-secondary-channel-hue: 16;
			--noise-secondary-channel-hue-scale: -1.33;
			--noise-secondary-channel-sat: 25;
			--noise-secondary-channel-sat-scale: 0;
			--noise-secondary-channel-lum: 42;
			--noise-secondary-channel-lum-scale: 0;
			--noise-primary-channel-hue: 16;
			--noise-primary-channel-hue-scale: -1.33;
			--noise-primary-channel-sat: 33;
			--noise-primary-channel-sat-scale: 0;
			--noise-primary-channel-lum: 63.5;
			--noise-primary-channel-lum-scale: 0;
			--noise-secondary-note-hue: 12;
			--noise-secondary-note-hue-scale: -1.33;
			--noise-secondary-note-sat: 33.5;
			--noise-secondary-note-sat-scale: 0;
			--noise-secondary-note-lum: 55;
			--noise-secondary-note-lum-scale: 0;
			--noise-primary-note-hue: 12;
			--noise-primary-note-hue-scale: -1.33;
			--noise-primary-note-sat: 46.5;
			--noise-primary-note-sat-scale: 0;
			--noise-primary-note-lum: 74;
			--noise-primary-note-lum-scale: 0;
			--mod-secondary-channel-hue: 12;
			--mod-secondary-channel-hue-scale: -.75;
			--mod-secondary-channel-sat: 50;
			--mod-secondary-channel-sat-scale: 0;
			--mod-secondary-channel-lum: 50;
			--mod-secondary-channel-lum-scale: 0;
			--mod-primary-channel-hue: 12;
			--mod-primary-channel-hue-scale: -.75;
			--mod-primary-channel-sat: 70;
			--mod-primary-channel-sat-scale: 0;
			--mod-primary-channel-lum: 80;
			--mod-primary-channel-lum-scale: 0;
			--mod-secondary-note-hue: 12;
			--mod-secondary-note-hue-scale: -.75;
			--mod-secondary-note-sat: 75;
			--mod-secondary-note-sat-scale: 0;
			--mod-secondary-note-lum: 45;
			--mod-secondary-note-lum-scale: 0;
			--mod-primary-note-hue: 12;
			--mod-primary-note-hue-scale: -.75;
			--mod-primary-note-sat: 85;
			--mod-primary-note-sat-scale: 0;
			--mod-primary-note-lum: 85;
			--mod-primary-note-lum-scale: 0;
			--disabled-note-primary: #aaa;
			--disabled-note-secondary: #666;
		}`,

		"roe light": `
		:root {
			--page-margin: #fff5f5;
			--editor-background: #fff5f5;
			--hover-preview: #0e8bf1;
			--playhead: 000;
			--primary-text: #0e8bf1;
			--secondary-text: #f10e0e;
			--inverted-text: white;
			--text-selection: #ff4444fc;
			--box-selection-fill: #ff00004d;
			--loop-accent: #9a75ff;
			--link-accent: #ff7070;
			--ui-widget-background: #bdc9e5;
			--ui-widget-focus: #a3b7e5;
			--pitch-background: #d0c7db;
			--tonic: #bed3e4;
			--fifth-note: #e7c6c6;
			--white-piano-key: #cdcdcd;
			--black-piano-key: #232323;
			--use-color-formula: false;
			--track-editor-bg-pitch: #e5e1ea;
			--track-editor-bg-pitch-dim: #cbc4d4;
			--track-editor-bg-noise: #e0ddee;
			--track-editor-bg-noise-dim: #c1bade;
			--track-editor-bg-mod: #d8e6f3;
			--track-editor-bg-mod-dim: #b1cce7;
			--multiplicative-mod-slider: #8097cb;
			--overwriting-mod-slider: #8097cb;
			--indicator-primary: #FF2A2A;
			--indicator-secondary: #92a6d3;
			--select2-opt-group: #b6c4e2;
			--input-box-outline: #bdc9e5;
			--mute-button-normal: #66baff;
			--mute-button-mod: #1a98ff;
			--pitch1-secondary-channel: #273c90;
			--pitch1-primary-channel: #476BFF;
			--pitch1-secondary-note: #273c90;
			--pitch1-primary-note: #476BFF;
			--pitch2-secondary-channel: #3a3898;
			--pitch2-primary-channel: #625FFB;
			--pitch2-secondary-note: #3a3898;
			--pitch2-primary-note: #625FFB;
			--pitch3-secondary-channel: #542780;
			--pitch3-primary-channel: #9C49EC;
			--pitch3-secondary-note: #542780;
			--pitch3-primary-note: #9C49EC;
			--pitch4-secondary-channel: #84225d;
			--pitch4-primary-channel: #fd3fb1;
			--pitch4-secondary-note: #84225d;
			--pitch4-primary-note: #fd3fb1;
			--pitch5-secondary-channel: #8d2323;
			--pitch5-primary-channel: #ff3f3f;
			--pitch5-secondary-note: #8d2323;
			--pitch5-primary-note: #ff3f3f;
			--pitch6-secondary-channel: #84225d;
			--pitch6-primary-channel: #fd3fb1;
			--pitch6-secondary-note: #84225d;
			--pitch6-primary-note: #fd3fb1;
			--pitch7-secondary-channel: #542780;
			--pitch7-primary-channel: #9C49EC;
			--pitch7-secondary-note: #542780;
			--pitch7-primary-note: #9C49EC;
			--pitch8-secondary-channel: #3a3898;
			--pitch8-primary-channel: #625FFB;
			--pitch8-secondary-note: #3a3898;
			--pitch8-primary-note: #625FFB;
			--pitch9-secondary-channel: #273c90;
			--pitch9-primary-channel: #476BFF;
			--pitch9-secondary-note: #273c90;
			--pitch9-primary-note: #476BFF;
			--pitch10-secondary-channel: #165a93;
			--pitch10-primary-channel: #299EFF;
			--pitch10-secondary-note: #165a93;
			--pitch10-primary-note: #299EFF;
			--noise1-secondary-channel: #336bdb;
			--noise1-primary-channel: #4281FF;
			--noise1-secondary-note: #336bdb;
			--noise1-primary-note: #4281FF;
			--noise2-secondary-channel: #5e38dc;
			--noise2-primary-channel: #7347FF;
			--noise2-secondary-note: #5e38dc;
			--noise2-primary-note: #7347FF;
			--noise3-secondary-channel: #7d3097;
			--noise3-primary-channel: #9F3CBF;
			--noise3-secondary-note: #7d3097;
			--noise3-primary-note: #9F3CBF;
			--noise4-secondary-channel: #ad2559;
			--noise4-primary-channel: #D3326F;
			--noise4-secondary-note: #ad2559;
			--noise4-primary-note: #D3326F;
			--noise5-secondary-channel: #d02525;
			--noise5-primary-channel: #FF2A2A;
			--noise5-secondary-note: #d02525;
			--noise5-primary-note: #FF2A2A;
			--mod1-secondary-channel: #35415a;
			--mod1-primary-channel: #47587a;
			--mod1-secondary-note: #35415a;
			--mod1-primary-note: #47587a;
			--mod2-secondary-channel: #5a5374;
			--mod2-primary-channel: #716791;
			--mod2-secondary-note: #5a5374;
			--mod2-primary-note: #716791;
			--mod3-secondary-channel: #53385c;
			--mod3-primary-channel: #6f4c7b;
			--mod3-secondary-note: #53385c;
			--mod3-primary-note: #6f4c7b;
			--mod4-secondary-channel: #7e4e60;
			--mod4-primary-channel: #9e6279;
			--mod4-secondary-note: #7e4e60;
			--mod4-primary-note: #9e6279;
			--mod-label-primary: #d0c7db;
			--mod-label-secondary-text: #cb3434;
			--mod-label-primary-text: black;
			--disabled-note-primary: #616161;
			--disabled-note-secondary: #474747;
		}`,
        "rainbow": `
			:root {
				--page-margin: black;
				--editor-background: black;
				--hover-preview: white;
				--playhead: white;
				--primary-text: white;
				--secondary-text: #999;
				--inverted-text: black;
				--text-selection: rgba(119,68,255,0.99);
				--box-selection-fill: rgba(255,255,255,0.2);
				--loop-accent: #74f;
				--link-accent: #98f;
				--ui-widget-background: #444;
				--ui-widget-focus: #777;
				--pitch-background: #444;
				--tonic: #864;
				--fifth-note: #468;
				--white-piano-key: #bbb;
				--black-piano-key: #444;
					--use-color-formula: false;
					--track-editor-bg-pitch: #444;
					--track-editor-bg-pitch-dim: #333;
					--track-editor-bg-noise: #444;
					--track-editor-bg-noise-dim: #333;
					--track-editor-bg-mod: #234;
					--track-editor-bg-mod-dim: #123;
					--multiplicative-mod-slider: #456;
					--overwriting-mod-slider: #654;
					--indicator-primary: #74f;
					--indicator-secondary: #444;
					--select2-opt-group: #585858;
					--input-box-outline: #333;
					--mute-button-normal: #ffa033;
					--mute-button-mod: #9a6bff;
				--pitch1-secondary-channel: #0099A1;
				--pitch1-primary-channel:   #25F3FF;
				--pitch1-secondary-note:    #00BDC7;
				--pitch1-primary-note:      #92F9FF;
				--pitch2-secondary-channel: #A1A100;
				--pitch2-primary-channel:   #FFFF25;
				--pitch2-secondary-note:    #C7C700;
				--pitch2-primary-note:      #FFFF92;
				--pitch3-secondary-channel: #C75000;
				--pitch3-primary-channel:   #FF9752;
				--pitch3-secondary-note:    #FF771C;
				--pitch3-primary-note:      #FFCDAB;
				--pitch4-secondary-channel: #00A100;
				--pitch4-primary-channel:   #50FF50;
				--pitch4-secondary-note:    #00C700;
				--pitch4-primary-note:      #A0FFA0;
				--pitch5-secondary-channel: #D020D0;
				--pitch5-primary-channel:   #FF90FF;
				--pitch5-secondary-note:    #E040E0;
				--pitch5-primary-note:      #FFC0FF;
				--pitch6-secondary-channel: #7777B0;
				--pitch6-primary-channel:   #A0A0FF;
				--pitch6-secondary-note:    #8888D0;
				--pitch6-primary-note:      #D0D0FF;
				--pitch7-secondary-channel: #8AA100;
				--pitch7-primary-channel:   #DEFF25;
				--pitch7-secondary-note:    #AAC700;
				--pitch7-primary-note:      #E6FF92;
				--pitch8-secondary-channel: #DF0019;
				--pitch8-primary-channel:   #FF98A4;
				--pitch8-secondary-note:    #FF4E63;
				--pitch8-primary-note:      #FFB2BB;
				--pitch9-secondary-channel: #00A170;
				--pitch9-primary-channel:   #50FFC9;
				--pitch9-secondary-note:    #00C78A;
				--pitch9-primary-note:      #83FFD9;
				--pitch10-secondary-channel:#A11FFF;
				--pitch10-primary-channel:  #CE8BFF;
				--pitch10-secondary-note:   #B757FF;
				--pitch10-primary-note:     #DFACFF;
				--noise1-secondary-channel: #6F6F6F;
				--noise1-primary-channel:   #AAAAAA;
				--noise1-secondary-note:    #A7A7A7;
				--noise1-primary-note:      #E0E0E0;
				--noise2-secondary-channel: #996633;
				--noise2-primary-channel:   #DDAA77;
				--noise2-secondary-note:    #CC9966;
				--noise2-primary-note:      #F0D0BB;
				--noise3-secondary-channel: #4A6D8F;
				--noise3-primary-channel:   #77AADD;
				--noise3-secondary-note:    #6F9FCF;
				--noise3-primary-note:      #BBD7FF;
				--noise4-secondary-channel: #7A4F9A;
				--noise4-primary-channel:   #AF82D2;
				--noise4-secondary-note:    #9E71C1;
				--noise4-primary-note:      #D4C1EA;
				--noise5-secondary-channel: #607837;
				--noise5-primary-channel:   #A2BB77;
				--noise5-secondary-note:    #91AA66;
				--noise5-primary-note:      #C5E2B2;
          --mod1-secondary-channel:   #339955;
					--mod1-primary-channel:     #77fc55;
					--mod1-secondary-note:      #77ff8a;
					--mod1-primary-note:        #cdffee;
					--mod2-secondary-channel:   #993355;
					--mod2-primary-channel:     #f04960;
					--mod2-secondary-note:      #f057a0;
					--mod2-primary-note:        #ffb8de;
					--mod3-secondary-channel:   #553399;
					--mod3-primary-channel:     #8855fc;
					--mod3-secondary-note:      #aa64ff;
					--mod3-primary-note:	    #f8ddff;
					--mod4-secondary-channel:   #a86436;
					--mod4-primary-channel:     #c8a825;
					--mod4-secondary-note:      #e8ba46;
					--mod4-primary-note:        #fff6d3;
					--mod-label-primary:        #999;
					--mod-label-secondary-text: #333;
					--mod-label-primary-text:   black;
					--disabled-note-primary:    #999;
					--disabled-note-secondary:  #666;
					animation: rainbow 1s ease infinite;
				}
:root {
  --dark-power: 0.1;
}

@keyframes rainbow {
  0%   { --editor-background: hsla(210, 40%, 6%, var(--dark-power)); }
  8%   { --editor-background: hsla(0, 100%, 8%, var(--dark-power)); }
  16%  { --editor-background: hsla(60, 100%, 10%, var(--dark-power)); }
  25%  { --editor-background: hsla(120, 80%, 8%, var(--dark-power)); }
  33%  { --editor-background: hsla(180, 100%, 6%, var(--dark-power)); }
  41%  { --editor-background: hsla(240, 80%, 10%, var(--dark-power)); }
  50%  { --editor-background: hsla(270, 60%, 8%, var(--dark-power)); }
  58%  { --editor-background: hsla(300, 80%, 10%, var(--dark-power)); }
  66%  { --editor-background: hsla(330, 70%, 8%, var(--dark-power)); }
  75%  { --editor-background: hsla(30, 100%, 10%, var(--dark-power)); }
  83%  { --editor-background: hsla(90, 60%, 8%, var(--dark-power)); }
  91%  { --editor-background: hsla(150, 100%, 10%, var(--dark-power)); }
  100% { --editor-background: hsla(210, 50%, 8%, var(--dark-power)); }
}

				
			`, 
			
			
			
			
			







"slushie": `
	:root {
	--use-color-formula: false;
		--page-margin: #040814;
		--editor-background: #040814;
		--hover-preview: #c6f7ff;
		--primary-text: #d3f3ff;
		--secondary-text: #6f72b5;
		--inverted-text: black;
		--box-selection-fill: rgb(43 70 171 / 62%);
		--loop-accent: #573ebb;
		--ui-widget-background: #2e2f44;
		--ui-widget-focus: #2b2c46;
		--pitch-background: #353654;
		--tonic: #716fe3;
		--fifth-note: #76469b;
		--white-piano-key: #abbce3;
		--black-piano-key: #2f235e;
		--track-editor-bg-pitch: #3a3b5c;
		--track-editor-bg-pitch-dim: #1f2036;
		--track-editor-bg-noise: #3c3554;
		--track-editor-bg-noise-dim: #1e1834;
		--track-editor-bg-mod: #30335e;
		--track-editor-bg-mod-dim: #161938;
		--multiplicative-mod-slider: #e29cff;
		--overwriting-mod-slider: #495789;
		--indicator-primary: #e1a6ff;
		--indicator-secondary: #415187;
		--select2-opt-group: #22223a;
		--input-box-outline: #2d2648;
		--mute-button-normal: #7aceff;
		--pitch1-secondary-channel: #5f3ea5;
		--pitch1-primary-channel: #c1a4ff;
		--pitch1-secondary-note: #794fd3;
		--pitch1-primary-note: #d8c6ff;
		--pitch2-secondary-channel: #4f44bf;
		--pitch2-primary-channel: #9287ff;
		--pitch2-secondary-note: #5e51d9;
		--pitch2-primary-note: #b6afff;
		--pitch3-secondary-channel: #374eb9;
		--pitch3-primary-channel: #8097ff;
		--pitch3-secondary-note: #445cc9;
		--pitch3-primary-note: #a0b2ff;
		--pitch4-secondary-channel: #2867cf;
		--pitch4-primary-channel: #6fa5ff;
		--pitch4-secondary-note: #2e6ed7;
		--pitch4-primary-note: #a6c7ff;
		--pitch5-secondary-channel: #3175a7;
		--pitch5-primary-channel: #7ec9ff;
		--pitch5-secondary-note: #367eb3;
		--pitch5-primary-note: #9fd7ff;
		--pitch6-secondary-channel: #3993a9;
		--pitch6-primary-channel: #8ce9ff;
		--pitch6-secondary-note: #386da3;
		--pitch6-primary-note: #9eecff;
		--pitch7-secondary-channel: #369d8a;
		--pitch7-primary-channel: #8bfce7;
		--pitch7-secondary-note: #1c93a7;
		--pitch7-primary-note: #abffef;
		--pitch8-secondary-channel: #00A170;
		--pitch8-primary-channel: #50FFC9;
		--pitch8-secondary-note: #00C78A;
		--pitch8-primary-note: #83FFD9;
		--pitch9-secondary-channel: #49b374;
		--pitch9-primary-channel: #8affa9;
		--pitch9-secondary-note: #26815f;
		--pitch9-primary-note: #c8ffde;
		--pitch10-secondary-channel: #58a747;
		--pitch10-primary-channel: #bbffaa;
		--pitch10-secondary-note: #1d7c48;
		--pitch10-primary-note: #c7ffbc;
		--noise1-secondary-channel: #42829b;
		--noise1-primary-channel: #97d3fc;
		--noise1-secondary-note: #3f53b3;
		--noise1-primary-note: #97d3fc;
		--noise2-secondary-channel: #6354bb;
		--noise2-primary-channel: #9a89ff;
		--noise2-secondary-note: #5f4dcd;
		--noise2-primary-note: #c6bcff;
		--noise3-secondary-channel: #704a95;
		--noise3-primary-channel: #c285ff;
		--noise3-secondary-note: #ad5aff;
		--noise3-primary-note: #d3a6ff;
		--noise4-secondary-channel: #a53c65;
		--noise4-primary-channel: #f794bb;
		--noise4-secondary-note: #cb5080;
		--noise4-primary-note: #f794bb;
		--noise5-secondary-channel: #9b2d2d;
		--noise5-primary-channel: #ff7676;
		--noise5-secondary-note: #cb4444;
		--noise5-primary-note: #ff9999;
		--mod1-secondary-channel: #b7613c;
		--mod1-primary-channel: #ff9f76;
		--mod1-secondary-note: #e77e52;
		--mod1-primary-note: #ffb99b;
		--mod2-secondary-channel: #916d34;
		--mod2-primary-channel: #fece80;
		--mod2-secondary-note: #c58b35;
		--mod2-primary-note: #ffdda5;
		--mod3-secondary-channel: #83761a;
		--mod3-primary-channel: #fdf68c;
		--mod3-secondary-note: #c18e00;
		--mod3-primary-note: #fdf68c;
		--mod4-secondary-channel: #a86436;
		--mod4-primary-channel: #c8a825;
		--mod4-secondary-note: #e8ba46;
		--mod4-primary-note: #c8a825;
		--mod-label-primary: #37325e;
		--mod-label-secondary-text: #6e8aa7;
		--mod-label-primary-text: #c1ffff;
}`,
 
			
			
			
"Dirty":`
:root {
  -webkit-text-stroke-width: 0.4px;
  --page-margin: #5A3A2E;
  --editor-background: #1E1916;
  --hover-preview: #D89C7F;
  --playhead: #B26440;
  --primary-text: #F1E4D2;
  --secondary-text: #E6C9AE;
  --inverted-text: #2C1C14;
  --text-selection: #B98B6A;
  --box-selection-fill: #CFA77F;
  --loop-accent: #A6603A;
  --link-accent: #D49A6A;
  --ui-widget-background: #3A2B24;
  --ui-widget-focus: #C47C4E;
  --pitch-background: #2C221D;
  --tonic: #A66B48;
  --fifth-note: #B7795A;
  --white-piano-key-color: #0F0D0B;
  --black-piano-key-color: #f0e5dc;
  --white-piano-key: #A28D7A;
  --black-piano-key: #1A1612;
  --use-color-formula: false;
  --track-editor-bg-pitch: #3F2C26;
  --track-editor-bg-pitch-dim: #2E221D;
  --track-editor-bg-noise: #44342F;
  --track-editor-bg-noise-dim: #3B2D28;
  --track-editor-bg-mod: #4C3A30;
  --track-editor-bg-mod-dim: #5A463C;
  --multiplicative-mod-slider: #C1A78B;
  --overwriting-mod-slider: #B0967F;
  --indicator-primary: #CE8352;
  --indicator-secondary: #9B6544;
  --select2-opt-group: #A76B4D;
  --input-box-outline: #A56942;
  --mute-button-normal: #F1E8DE;
  --mute-button-mod: #F5F0E7;

  /* pitch */
  --pitch1-primary-channel: #9E4B4B;
  --pitch1-secondary-channel: #7F2E2E;
  --pitch1-primary-note: #C98585;
  --pitch1-secondary-note: #5F1A1A;

  --pitch2-primary-channel: #A6793F;
  --pitch2-secondary-channel: #8F5E1E;
  --pitch2-primary-note: #D3B185;
  --pitch2-secondary-note: #664114;

  --pitch3-primary-channel: #7C8E3A;
  --pitch3-secondary-channel: #5A6B24;
  --pitch3-primary-note: #B2C27F;
  --pitch3-secondary-note: #3D4D18;

  --pitch4-primary-channel: #3D775C;
  --pitch4-secondary-channel: #296049;
  --pitch4-primary-note: #74B89E;
  --pitch4-secondary-note: #1F4533;

  --pitch5-primary-channel: #4B6A79;
  --pitch5-secondary-channel: #2C4D5C;
  --pitch5-primary-note: #89A5B6;
  --pitch5-secondary-note: #1F3642;

  --pitch6-primary-channel: #5C4D7A;
  --pitch6-secondary-channel: #3F3060;
  --pitch6-primary-note: #A895C4;
  --pitch6-secondary-note: #2A2044;

  --pitch7-primary-channel: #854D78;
  --pitch7-secondary-channel: #6A2F5C;
  --pitch7-primary-note: #C48FBA;
  --pitch7-secondary-note: #481B3E;

  --pitch8-primary-channel: #9C4D5A;
  --pitch8-secondary-channel: #802E40;
  --pitch8-primary-note: #D47C99;
  --pitch8-secondary-note: #5C1A2C;

  --pitch9-primary-channel: #B3704D;
  --pitch9-secondary-channel: #99512E;
  --pitch9-primary-note: #E0AD91;
  --pitch9-secondary-note: #71391E;

  --pitch10-primary-channel: #C9A14D;
  --pitch10-secondary-channel: #A5822E;
  --pitch10-primary-note: #F1D98F;
  --pitch10-secondary-note: #715F1E;

  /* noise */
  --noise1-primary-channel: #A25F4D;
  --noise1-secondary-channel: #833D2E;
  --noise1-primary-note: #D9A88F;
  --noise1-secondary-note: #5A261B;

  --noise2-primary-channel: #BA8B4D;
  --noise2-secondary-channel: #9A6B2E;
  --noise2-primary-note: #F0C790;
  --noise2-secondary-note: #70501E;

  --noise3-primary-channel: #B0A64D;
  --noise3-secondary-channel: #918A2E;
  --noise3-primary-note: #E8E090;
  --noise3-secondary-note: #6A641E;

  --noise4-primary-channel: #6A964D;
  --noise4-secondary-channel: #48712E;
  --noise4-primary-note: #A2D190;
  --noise4-secondary-note: #34501E;

  --noise5-primary-channel: #4D948D;
  --noise5-secondary-channel: #2E716B;
  --noise5-primary-note: #8AD9D2;
  --noise5-secondary-note: #1E4F4A;

  /* mod */
  --mod1-primary-channel: #4D887C;
  --mod1-secondary-channel: #2E6A5E;
  --mod1-primary-note: #8BCDC0;
  --mod1-secondary-note: #1E4E45;

  --mod2-primary-channel: #4D6788;
  --mod2-secondary-channel: #2E4C6A;
  --mod2-primary-note: #8BB0CD;
  --mod2-secondary-note: #1E354E;

  --mod3-primary-channel: #4D7C88;
  --mod3-secondary-channel: #2E5E6A;
  --mod3-primary-note: #8BC3CD;
  --mod3-secondary-note: #1E454E;

  --mod4-primary-channel: #4D5C88;
  --mod4-secondary-channel: #2E416A;
  --mod4-primary-note: #8BA6CD;
  --mod4-secondary-note: #1E2F4E;

  --mod-label-primary: #F0E8D8;
  --mod-label-secondary-text: #241C16;
  --mod-label-primary-text: #3B2A1F;

  --disabled-note-primary: #211B17;
  --disabled-note-secondary: #100D0B;
}
`,
"Moai":`
:root {
  --page-margin: #2B2B2B;
  --editor-background: #121212;
  --hover-preview: #4A4A4A;
  --playhead: #5C5C5C;
  --primary-text: #E0E0E0;
  --secondary-text: #AAAAAA;
  --inverted-text: #1A1A1A;
  --text-selection: #2F4F4F;
  --box-selection-fill: #3B3B3B;
  --loop-accent: #555;
  --link-accent: #8AB6C2;
  --ui-widget-background: #1C1C1C;
  --ui-widget-focus: #3A3A3A;
  --pitch-background: #1A1A1A;
  --tonic: #3D5A6C;
  --fifth-note: #4D6C7F;
  --white-piano-key: #777;
  --black-piano-key: #111;
  --white-piano-key-color: #000;
  --black-piano-key-color: #fff;
  --track-editor-bg-pitch: #2C2C2C;
  --track-editor-bg-noise: #333;
  --track-editor-bg-mod: #3A3A3A;
  --multiplicative-mod-slider: #4D5E6C;
  --overwriting-mod-slider: #6C7F8D;
  --indicator-primary: #9DAEBB;
  --indicator-secondary: #5C6C7A;
  --input-box-outline: #555;
  --mute-button-normal: #DDD;
  --mute-button-mod: #CCC;
}
@media (min-aspect-ratio: 1/1) {
body::after {
  content: "🗿";
  position: fixed;
  top: 50%;
  left: 50%;
  font-size: 50vh;
  transform: translate(-50%, -50%);
  opacity: 0.2;
  pointer-events: none;
  z-index: 9999;
  user-select: none;
}
}
@media (max-aspect-ratio: 1/1) {
body::after {
	content: "🗿";
	position: fixed;
	top: 50% ;
	left: 50% ;
	font-size: 50vh;
	transform: translate(-50% , -50% );
	opacity: 0.2;
	pointer-events: none;
	z-index: 9999;
	user-select: none;
}
}
`,
"Steel":`
:root {
  --page-margin: #2E2E33;
  --editor-background: #1A1A1D;
  --hover-preview: #95A3B3;
  --playhead: #AFC5D7;
  --primary-text: #F0F0F0;
  --secondary-text: #C4C4C4;
  --inverted-text: #121212;
  --text-selection: #778899;
  --box-selection-fill: #A0B0C0;
  --loop-accent: #5C7A8C;
  --link-accent: #9DB7C5;
  --ui-widget-background: #232428;
  --ui-widget-focus: #4A5A6A;
  --pitch-background: #1C1F23;
  --tonic: #6F8A9C;
  --fifth-note: #7C99AB;
  --white-piano-key: #BFC6CC;
  --black-piano-key: #2B2D30;
  --white-piano-key-color: #000;
  --black-piano-key-color: #fff;
  --track-editor-bg-pitch: #2D3137;
  --track-editor-bg-noise: #383E44;
  --track-editor-bg-mod: #454C52;
  --multiplicative-mod-slider: #9AAFC1;
  --overwriting-mod-slider: #7A8C9F;
  --indicator-primary: #C1D4E3;
  --indicator-secondary: #6E7F8F;
  --input-box-outline: #607080;
  --mute-button-normal: #D8DEE4;
  --mute-button-mod: #E0E7EC;

  /* pitch colors (tonal greys with slight blue/cyan tint) */
  --pitch1-primary-channel: #B0C5CF;
  --pitch1-secondary-channel: #90A3AD;
  --pitch1-primary-note: #D5E0E6;
  --pitch1-secondary-note: #657985;

  --pitch2-primary-channel: #C3D1D9;
  --pitch2-secondary-channel: #A4B6C0;
  --pitch2-primary-note: #E4EDF2;
  --pitch2-secondary-note: #73858E;

  --pitch3-primary-channel: #A8BCC4;
  --pitch3-secondary-channel: #879AA1;
  --pitch3-primary-note: #D0DDE3;
  --pitch3-secondary-note: #60717A;

  --pitch4-primary-channel: #8DA6AD;
  --pitch4-secondary-channel: #6C838B;
  --pitch4-primary-note: #B9C8CF;
  --pitch4-secondary-note: #4D5E66;

  --pitch5-primary-channel: #738E95;
  --pitch5-secondary-channel: #586E75;
  --pitch5-primary-note: #A3B5BB;
  --pitch5-secondary-note: #3B4A51;

  --pitch6-primary-channel: #AABDC3;
  --pitch6-secondary-channel: #889EA5;
  --pitch6-primary-note: #D4E2E7;
  --pitch6-secondary-note: #5F7278;

  --pitch7-primary-channel: #93A7AF;
  --pitch7-secondary-channel: #738891;
  --pitch7-primary-note: #BECED3;
  --pitch7-secondary-note: #495C65;

  --pitch8-primary-channel: #BDC9D0;
  --pitch8-secondary-channel: #9CAEB4;
  --pitch8-primary-note: #DFEAF0;
  --pitch8-secondary-note: #6A7C83;

  --pitch9-primary-channel: #8C9FA7;
  --pitch9-secondary-channel: #6E7F86;
  --pitch9-primary-note: #B5C5CC;
  --pitch9-secondary-note: #4E5F66;

  --pitch10-primary-channel: #B1BDC4;
  --pitch10-secondary-channel: #92A1A8;
  --pitch10-primary-note: #D7E3E9;
  --pitch10-secondary-note: #5A6A72;

  /* neutral noise */
  --noise1-primary-channel: #8D999F;
  --noise1-secondary-channel: #6C767C;
  --noise1-primary-note: #B6C1C7;
  --noise1-secondary-note: #4C5459;

  --noise2-primary-channel: #7F8B91;
  --noise2-secondary-channel: #5F6A6F;
  --noise2-primary-note: #A9B3B9;
  --noise2-secondary-note: #3F464B;

  --noise3-primary-channel: #6F7A80;
  --noise3-secondary-channel: #4F595E;
  --noise3-primary-note: #98A2A7;
  --noise3-secondary-note: #353A3F;

  --noise4-primary-channel: #9DAAB1;
  --noise4-secondary-channel: #7E8D94;
  --noise4-primary-note: #C4D1D7;
  --noise4-secondary-note: #5B6A70;

  --noise5-primary-channel: #C5D2D8;
  --noise5-secondary-channel: #A6B5BB;
  --noise5-primary-note: #E3EFF4;
  --noise5-secondary-note: #78878D;

  /* mods */
  --mod1-primary-channel: #A9B6C0;
  --mod1-secondary-channel: #8C98A1;
  --mod1-primary-note: #CEDBE3;
  --mod1-secondary-note: #6C7982;

  --mod2-primary-channel: #7B8A93;
  --mod2-secondary-channel: #5F6E76;
  --mod2-primary-note: #A4B3BC;
  --mod2-secondary-note: #455159;

  --mod3-primary-channel: #9DB1BC;
  --mod3-secondary-channel: #7F949F;
  --mod3-primary-note: #C8DDE8;
  --mod3-secondary-note: #5C6F7A;

  --mod4-primary-channel: #BACCD7;
  --mod4-secondary-channel: #9FAFB9;
  --mod4-primary-note: #E4F2FB;
  --mod4-secondary-note: #7A8A95;

  --mod-label-primary: #F3F7FA;
  --mod-label-secondary-text: #1A1C1E;
  --mod-label-primary-text: #2F3A45;

  --disabled-note-primary: #1A1A1A;
  --disabled-note-secondary: #0F0F0F;
}
 
body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 5;
  background: linear-gradient(120deg, #1A1A1D, #4A5D61, #1A1A1D);
  background-size: 400% 400%;
  animation: steelShift 10s ease-in-out infinite;
  opacity: 0.35;
  pointer-events: none;
}
@keyframes steelShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

`,
"Texture":`
:root {
  --page-margin: #111111;
  --editor-background: #0A0A0C;
  --hover-preview: #B0B0B0;
  --playhead: #888888;
  --primary-text: #F5F5F5;
  --secondary-text: #BFBFBF;
  --inverted-text: #0F0F0F;
  --text-selection: #444;
  --box-selection-fill: #666;
  --loop-accent: #999;
  --link-accent: #DDD;
  --ui-widget-background: #1A1A1A;
  --ui-widget-focus: #2A2A2A;
  --pitch-background: #111;
  --tonic: #777;
  --fifth-note: #666;
  --white-piano-key: #999;
  --black-piano-key: #222;
  --white-piano-key-color: #000;
  --black-piano-key-color: #FFF;
  --track-editor-bg-pitch: #181818;
  --track-editor-bg-noise: #202020;
  --track-editor-bg-mod: #282828;
  --multiplicative-mod-slider: #AAA;
  --overwriting-mod-slider: #888;
  --indicator-primary: #DDD;
  --indicator-secondary: #999;
  --input-box-outline: #666;
  --mute-button-normal: #EEE;
  --mute-button-mod: #CCC;

  /* pitch (minimal, muted grays with subtle variation) */
  --pitch1-primary-channel: #AAAAAA;
  --pitch1-secondary-channel: #888888;
  --pitch1-primary-note: #CCCCCC;
  --pitch1-secondary-note: #666666;

  --pitch2-primary-channel: #BBBBBB;
  --pitch2-secondary-channel: #999999;
  --pitch2-primary-note: #DDDDDD;
  --pitch2-secondary-note: #777777;

  --pitch3-primary-channel: #A0A0A0;
  --pitch3-secondary-channel: #7F7F7F;
  --pitch3-primary-note: #C0C0C0;
  --pitch3-secondary-note: #5F5F5F;

  --pitch4-primary-channel: #8C8C8C;
  --pitch4-secondary-channel: #6A6A6A;
  --pitch4-primary-note: #B0B0B0;
  --pitch4-secondary-note: #505050;

  --pitch5-primary-channel: #7A7A7A;
  --pitch5-secondary-channel: #585858;
  --pitch5-primary-note: #9F9F9F;
  --pitch5-secondary-note: #404040;

  --pitch6-primary-channel: #C0C0C0;
  --pitch6-secondary-channel: #9F9F9F;
  --pitch6-primary-note: #E0E0E0;
  --pitch6-secondary-note: #6F6F6F;

  --pitch7-primary-channel: #B3B3B3;
  --pitch7-secondary-channel: #939393;
  --pitch7-primary-note: #D0D0D0;
  --pitch7-secondary-note: #5C5C5C;

  --pitch8-primary-channel: #D0D0D0;
  --pitch8-secondary-channel: #B0B0B0;
  --pitch8-primary-note: #F0F0F0;
  --pitch8-secondary-note: #707070;

  --pitch9-primary-channel: #A9A9A9;
  --pitch9-secondary-channel: #898989;
  --pitch9-primary-note: #C9C9C9;
  --pitch9-secondary-note: #5E5E5E;

  --pitch10-primary-channel: #BCBCBC;
  --pitch10-secondary-channel: #9C9C9C;
  --pitch10-primary-note: #E0E0E0;
  --pitch10-secondary-note: #6A6A6A;

  /* noise (low color contrast) */
  --noise1-primary-channel: #B0B0B0;
  --noise1-secondary-channel: #909090;
  --noise1-primary-note: #D0D0D0;
  --noise1-secondary-note: #707070;

  --noise2-primary-channel: #C0C0C0;
  --noise2-secondary-channel: #A0A0A0;
  --noise2-primary-note: #E0E0E0;
  --noise2-secondary-note: #808080;

  --noise3-primary-channel: #999999;
  --noise3-secondary-channel: #777777;
  --noise3-primary-note: #BBBBBB;
  --noise3-secondary-note: #555555;

  --noise4-primary-channel: #878787;
  --noise4-secondary-channel: #676767;
  --noise4-primary-note: #AFAFAF;
  --noise4-secondary-note: #484848;

  --noise5-primary-channel: #D8D8D8;
  --noise5-secondary-channel: #B8B8B8;
  --noise5-primary-note: #F0F0F0;
  --noise5-secondary-note: #909090;

  /* mod (same vibe as pitch) */
  --mod1-primary-channel: #AAAAAA;
  --mod1-secondary-channel: #888888;
  --mod1-primary-note: #CCCCCC;
  --mod1-secondary-note: #666666;

  --mod2-primary-channel: #999999;
  --mod2-secondary-channel: #777777;
  --mod2-primary-note: #BBBBBB;
  --mod2-secondary-note: #555555;

  --mod3-primary-channel: #B0B0B0;
  --mod3-secondary-channel: #8E8E8E;
  --mod3-primary-note: #D0D0D0;
  --mod3-secondary-note: #6E6E6E;

  --mod4-primary-channel: #C4C4C4;
  --mod4-secondary-channel: #A4A4A4;
  --mod4-primary-note: #E4E4E4;
  --mod4-secondary-note: #848484;

  --mod-label-primary: #F2F2F2;
  --mod-label-secondary-text: #0F0F0F;
  --mod-label-primary-text: #2A2A2A;

  --disabled-note-primary: #1A1A1A;
  --disabled-note-secondary: #0F0F0F;
}
body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 5;
  pointer-events: none;
  background: radial-gradient(
    circle at center,
    rgba(0, 0, 0, 0) 60%,
    rgba(255, 255, 255, 0.04) 80%,
    rgba(255, 255, 255, 0.06) 90%,
    rgba(255, 255, 255, 0.08) 100%
  );
  animation: starsFade 10s ease-in-out infinite;
  backdrop-filter: blur(6px);
}
body::after {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 4;
  background-image: 
    radial-gradient(white 1px, transparent 0),
    radial-gradient(white 1px, transparent 0),
    radial-gradient(white 1px, transparent 0);
  background-size: 4px 4px, 6px 6px, 8px 8px;
  background-position: 0 0, 25% 25%, 50% 50%;
  opacity: 0.08;
  pointer-events: none;
}
@keyframes starsFade {
  0%   { opacity: 0.04; }
  50%  { opacity: 0.3; }
  100% { opacity: 0.04; }
}
 

`,
			"CyberPunk": `
:root {
  --page-margin: #0A0011;
  --editor-background: #08000C;
  --hover-preview: #FF90FF;
  --playhead: #FF00AA;
  --primary-text: #F0F0F0;
  --secondary-text: #FFCCFF;
  --inverted-text: #000000;
  --text-selection: #440044;
  --box-selection-fill: #990099;
  --loop-accent: #FF44CC;
  --link-accent: #FFDDFF;
  --ui-widget-background: #1A001A;
  --ui-widget-focus: #2A002A;
  --pitch-background: #110011;
  --tonic: #FF77FF;
  --fifth-note: #FF33CC;
  --white-piano-key: #FF99FF;
  --black-piano-key: #330033;
  --white-piano-key-color: #000;
  --black-piano-key-color: #FFF;
  --track-editor-bg-pitch: #1C001C;
  --track-editor-bg-noise: #240024;
  --track-editor-bg-mod: #2C002C;
  --multiplicative-mod-slider: #FFBBFF;
  --overwriting-mod-slider: #FF88FF;
  --indicator-primary: #FFDDFF;
  --indicator-secondary: #FF99DD;
  --input-box-outline: #CC00CC;
  --mute-button-normal: #FFEEFF;
  --mute-button-mod: #FFBBFF;
  --pitch1-primary-channel: #FF33CC;
  --pitch1-secondary-channel: #FF66CC;
  --pitch1-primary-note: #FF99FF;
  --pitch1-secondary-note: #CC33AA;

  --pitch2-primary-channel: #FF66FF;
  --pitch2-secondary-channel: #FF99FF;
  --pitch2-primary-note: #FFCCFF;
  --pitch2-secondary-note: #AA33AA;

  --pitch3-primary-channel: #FF44DD;
  --pitch3-secondary-channel: #DD22BB;
  --pitch3-primary-note: #FFAAFF;
  --pitch3-secondary-note: #992299;

  --pitch4-primary-channel: #FF66EE;
  --pitch4-secondary-channel: #DD44CC;
  --pitch4-primary-note: #FFBBFF;
  --pitch4-secondary-note: #882288;

  --pitch5-primary-channel: #FF77FF;
  --pitch5-secondary-channel: #CC33CC;
  --pitch5-primary-note: #FFCCFF;
  --pitch5-secondary-note: #772277;

  --pitch6-primary-channel: #FF99FF;
  --pitch6-secondary-channel: #DD66DD;
  --pitch6-primary-note: #FFEEFF;
  --pitch6-secondary-note: #992299;

  --pitch7-primary-channel: #FFAAFF;
  --pitch7-secondary-channel: #BB55BB;
  --pitch7-primary-note: #FFE0FF;
  --pitch7-secondary-note: #882288;

  --pitch8-primary-channel: #FFD0FF;
  --pitch8-secondary-channel: #CC88CC;
  --pitch8-primary-note: #FFFFFF;
  --pitch8-secondary-note: #993399;

  --pitch9-primary-channel: #FFB3FF;
  --pitch9-secondary-channel: #AA66AA;
  --pitch9-primary-note: #FFDFFF;
  --pitch9-secondary-note: #772277;

  --pitch10-primary-channel: #FFC8FF;
  --pitch10-secondary-channel: #BB77BB;
  --pitch10-primary-note: #FFEEFF;
  --pitch10-secondary-note: #884488;

  --noise1-primary-channel: #FFAAFF;
  --noise1-secondary-channel: #CC88CC;
  --noise1-primary-note: #FFD5FF;
  --noise1-secondary-note: #993399;

  --noise2-primary-channel: #FFCCFF;
  --noise2-secondary-channel: #AA55AA;
  --noise2-primary-note: #FFFFFF;
  --noise2-secondary-note: #882288;

  --noise3-primary-channel: #DD88DD;
  --noise3-secondary-channel: #BB66BB;
  --noise3-primary-note: #FFCCFF;
  --noise3-secondary-note: #772277;

  --noise4-primary-channel: #CC66CC;
  --noise4-secondary-channel: #AA44AA;
  --noise4-primary-note: #EEBBEE;
  --noise4-secondary-note: #661166;

  --noise5-primary-channel: #FFD0FF;
  --noise5-secondary-channel: #B080B0;
  --noise5-primary-note: #FFFFFF;
  --noise5-secondary-note: #994499;

 
  --mod1-primary-channel: #FF99FF;
  --mod1-secondary-channel: #DD66DD;
  --mod1-primary-note: #FFCCFF;
  --mod1-secondary-note: #AA33AA;

  --mod2-primary-channel: #FF88FF;
  --mod2-secondary-channel: #CC55CC;
  --mod2-primary-note: #FFBBFF;
  --mod2-secondary-note: #992299;

  --mod3-primary-channel: #FFB0FF;
  --mod3-secondary-channel: #DD88DD;
  --mod3-primary-note: #FFE0FF;
  --mod3-secondary-note: #AA55AA;

  --mod4-primary-channel: #FFC8FF;
  --mod4-secondary-channel: #CC88CC;
  --mod4-primary-note: #FFF0FF;
  --mod4-secondary-note: #BB66BB;

  --mod-label-primary: #FFE6FF;
  --mod-label-secondary-text: #1A001A;
  --mod-label-primary-text: #FF99FF;

  --disabled-note-primary: #2A002A;
  --disabled-note-secondary: #110011;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 5;
  pointer-events: none;
  background:
    radial-gradient(circle at 20% 30%, rgba(255, 0, 204, 0.2), transparent 40%),
    radial-gradient(circle at 80% 70%, rgba(0, 255, 255, 0.2), transparent 50%);
  backdrop-filter: blur(12px);
  opacity: 0.4;
  animation: Blur 8s ease-in-out infinite;
}
body::after {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 4;
  pointer-events: none;
  background-image:
    linear-gradient(45deg, rgba(255, 0, 255, 0.1) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(0, 255, 255, 0.1) 25%, transparent 25%),
    linear-gradient(45deg, rgba(255, 255, 255, 0.08) 75%, transparent 75%),
    linear-gradient(-45deg, rgba(255, 255, 255, 0.05) 75%, transparent 75%);
  background-size: 40px 40px;
  background-position: 0 0, 20px 20px, 0 0, 20px 20px;
  animation: gridWave 6s linear infinite;
  opacity: 0.15;
}
@keyframes gridWave {
  0% {
    background-position: 0 0, 20px 20px, 0 0, 20px 20px;
  }
  100% {
    background-position: 40px 40px, 60px 60px, 40px 40px, 60px 60px;
  }
}
@keyframes Blur {
  0%   { opacity: 0.3; transform: scale(1); }
  50%  { opacity: 0.5; transform: scale(1.03); }
  100% { opacity: 0.3; transform: scale(1); }
}

 
`,
"ToxicGlow": `
:root {
  --page-margin: #001100;
  --editor-background: #030C03;
  --hover-preview: #90FF90;
  --playhead: #00FF66;
  --primary-text: #E0FFE0;
  --secondary-text: #AAFFAA;
  --inverted-text: #000000;
  --text-selection: #004400;
  --box-selection-fill: #009900;
  --loop-accent: #33FF99;
  --link-accent: #DDFFDD;
  --ui-widget-background: #0A1A0A;
  --ui-widget-focus: #113311;
  --pitch-background: #001100;
  --tonic: #77FF77;
  --fifth-note: #33CC33;
  --white-piano-key: #99FF99;
  --black-piano-key: #003300;
  --white-piano-key-color: #000;
  --black-piano-key-color: #FFF;
  --track-editor-bg-pitch: #102010;
  --track-editor-bg-noise: #183018;
  --track-editor-bg-mod: #204020;
  --multiplicative-mod-slider: #BBFFBB;
  --overwriting-mod-slider: #88FF88;
  --indicator-primary: #DDFFDD;
  --indicator-secondary: #99DD99;
  --input-box-outline: #00CC00;
  --mute-button-normal: #EEFFEE;
  --mute-button-mod: #BBFFBB;

  /* pitch ToxicGlow green */
  --pitch1-primary-channel: #33CC66;
  --pitch1-secondary-channel: #66CC66;
  --pitch1-primary-note: #99FF99;
  --pitch1-secondary-note: #339933;

  --pitch2-primary-channel: #66FF66;
  --pitch2-secondary-channel: #99FF99;
  --pitch2-primary-note: #CCFFCC;
  --pitch2-secondary-note: #228822;

  --pitch3-primary-channel: #44DD44;
  --pitch3-secondary-channel: #22BB22;
  --pitch3-primary-note: #AAFFAA;
  --pitch3-secondary-note: #229922;

  --pitch4-primary-channel: #66EE66;
  --pitch4-secondary-channel: #44CC44;
  --pitch4-primary-note: #BBFFBB;
  --pitch4-secondary-note: #228822;

  --pitch5-primary-channel: #77FF77;
  --pitch5-secondary-channel: #33CC33;
  --pitch5-primary-note: #CCFFCC;
  --pitch5-secondary-note: #227722;

  --pitch6-primary-channel: #99FF99;
  --pitch6-secondary-channel: #66DD66;
  --pitch6-primary-note: #EEFFEE;
  --pitch6-secondary-note: #229922;

  --pitch7-primary-channel: #AAFFAA;
  --pitch7-secondary-channel: #55BB55;
  --pitch7-primary-note: #E0FFE0;
  --pitch7-secondary-note: #228822;

  --pitch8-primary-channel: #D0FFD0;
  --pitch8-secondary-channel: #88CC88;
  --pitch8-primary-note: #FFFFFF;
  --pitch8-secondary-note: #339933;

  --pitch9-primary-channel: #B3FFB3;
  --pitch9-secondary-channel: #66AA66;
  --pitch9-primary-note: #DFFFDF;
  --pitch9-secondary-note: #227722;

  --pitch10-primary-channel: #C8FFC8;
  --pitch10-secondary-channel: #77BB77;
  --pitch10-primary-note: #EEFFEE;
  --pitch10-secondary-note: #338833;

  /* noise ToxicGlow style */
  --noise1-primary-channel: #AAFFAA;
  --noise1-secondary-channel: #88CC88;
  --noise1-primary-note: #D5FFD5;
  --noise1-secondary-note: #339933;

  --noise2-primary-channel: #CCFFCC;
  --noise2-secondary-channel: #55AA55;
  --noise2-primary-note: #FFFFFF;
  --noise2-secondary-note: #228822;

  --noise3-primary-channel: #88DD88;
  --noise3-secondary-channel: #66BB66;
  --noise3-primary-note: #CCFFCC;
  --noise3-secondary-note: #227722;

  --noise4-primary-channel: #66CC66;
  --noise4-secondary-channel: #44AA44;
  --noise4-primary-note: #BBEEBB;
  --noise4-secondary-note: #116611;

  --noise5-primary-channel: #D0FFD0;
  --noise5-secondary-channel: #80B080;
  --noise5-primary-note: #FFFFFF;
  --noise5-secondary-note: #449944;

  /* mod ToxicGlow green */
  --mod1-primary-channel: #99FF99;
  --mod1-secondary-channel: #66DD66;
  --mod1-primary-note: #CCFFCC;
  --mod1-secondary-note: #33AA33;

  --mod2-primary-channel: #88FF88;
  --mod2-secondary-channel: #55CC55;
  --mod2-primary-note: #BBFFBB;
  --mod2-secondary-note: #229922;

  --mod3-primary-channel: #B0FFB0;
  --mod3-secondary-channel: #88DD88;
  --mod3-primary-note: #E0FFE0;
  --mod3-secondary-note: #55AA55;

  --mod4-primary-channel: #C8FFC8;
  --mod4-secondary-channel: #88CC88;
  --mod4-primary-note: #F0FFF0;
  --mod4-secondary-note: #66BB66;

  --mod-label-primary: #E6FFE6;
  --mod-label-secondary-text: #0A1A0A;
  --mod-label-primary-text: #99FF99;

  --disabled-note-primary: #002A00;
  --disabled-note-secondary: #001100;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 5;
  pointer-events: none;
  background:
    radial-gradient(circle at 20% 30%, rgba(0, 255, 240, 0.15), transparent 40%),
    radial-gradient(circle at 80% 70%, rgba(200, 200, 0, 0.2), transparent 50%);
  backdrop-filter: blur(12px);
  opacity: 0.4;
  animation: Blur 8s ease-in-out infinite;
}

body::after {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 4;
  pointer-events: none;
  background-image: 
    conic-gradient(from 0deg at 50% 50%, 
      rgba(0,255,100,0.05) 0deg 60deg, 
      transparent 60deg 120deg, 
      rgba(0,255,100,0.05) 120deg 180deg, 
      transparent 180deg 240deg, 
      rgba(0,255,100,0.05) 240deg 300deg, 
      transparent 300deg 360deg),
    repeating-linear-gradient(60deg, rgba(0,255,0,0.03) 0 1px, transparent 1px 20px),
    repeating-linear-gradient(-60deg, rgba(0,255,0,0.03) 0 1px, transparent 1px 20px),
    repeating-linear-gradient(0deg, rgba(0,255,0,0.02) 0 1px, transparent 1px 20px);
  background-size: 120px 120px;
  background-position: center;
  animation: Hexagon 15s linear infinite;
  opacity: 0.25;
}

@keyframes Hexagon {
  0% {
    background-position: center;
    transform: scale(1);
  }
  50% {
    background-position: center;
    transform: scale(1.6) rotate(20deg);
  }
  100% {
    background-position: center;
    transform: scale(1);
  }
}


 

@keyframes Blur {
  0%   { opacity: 0.3; transform: scale(1); }
  50%  { opacity: 0.5; transform: scale(1.03); }
  100% { opacity: 0.3; transform: scale(1); }
}
`,
"TheOrange":`

:root {
  --page-margin: #1a0a00;
  --editor-background: #1a0a00;
  --hover-preview: #ffb380;
  --playhead: #ff704d;
  --primary-text: #ffe5d9;
  --secondary-text: #ffccbc; 
  --inverted-text: #1a0a00;
  --text-selection: #802000;
  --box-selection-fill: #cc3300;
  --loop-accent: #ff704d;
  --link-accent: #ff9966;
  --ui-widget-background: #330d00;
  --ui-widget-focus: #661a00;
  --pitch-background: #1a0a00;
  --tonic: #ff6633;
  --fifth-note: #cc2900;
  --white-piano-key: #ff9966;
  --black-piano-key: #4d0f00;
  --white-piano-key-color: #1a0a00;
  --black-piano-key-color: #fff;
  --track-editor-bg-pitch: #260f00;
  --track-editor-bg-noise: #331300;
  --track-editor-bg-mod: #401700;
  --multiplicative-mod-slider: #ffb380;
  --overwriting-mod-slider: #ff704d;
  --indicator-primary: #ffccb3;
  --indicator-secondary: #ff9966;
  --input-box-outline: #cc3300;
  --mute-button-normal: #ffead9;
  --mute-button-mod: #ffccbc;

  --pitch1-primary-channel: #ff9966;
  --pitch1-secondary-channel: #cc6633;
  --pitch1-primary-note: #ffb380;
  --pitch1-secondary-note: #b34700;

  --pitch2-primary-channel: #ffaa80;
  --pitch2-secondary-channel: #cc704d;
  --pitch2-primary-note: #ffcc99;
  --pitch2-secondary-note: #994d00;

  --pitch3-primary-channel: #ff8c66;
  --pitch3-secondary-channel: #cc5c33;
  --pitch3-primary-note: #ffad80;
  --pitch3-secondary-note: #803300;

  --pitch4-primary-channel: #e6734d;
  --pitch4-secondary-channel: #b35933;
  --pitch4-primary-note: #ff9966;
  --pitch4-secondary-note: #732600;

  --pitch5-primary-channel: #cc5c33;
  --pitch5-secondary-channel: #994d26;
  --pitch5-primary-note: #ff7f50;
  --pitch5-secondary-note: #661a00;

  --pitch6-primary-channel: #ffc299;
  --pitch6-secondary-channel: #ff9966;
  --pitch6-primary-note: #ffe5d9;
  --pitch6-secondary-note: #cc704d;

  --pitch7-primary-channel: #ffb380;
  --pitch7-secondary-channel: #e6734d;
  --pitch7-primary-note: #ffd9c2;
  --pitch7-secondary-note: #b34700;

  --pitch8-primary-channel: #ffd9c2;
  --pitch8-secondary-channel: #ffb380;
  --pitch8-primary-note: #fff0e5;
  --pitch8-secondary-note: #994d26;

  --pitch9-primary-channel: #ffad80;
  --pitch9-secondary-channel: #cc704d;
  --pitch9-primary-note: #ffc2a1;
  --pitch9-secondary-note: #802000;

  --pitch10-primary-channel: #ffc2a1;
  --pitch10-secondary-channel: #e6734d;
  --pitch10-primary-note: #ffe5d9;
  --pitch10-secondary-note: #994d26;

  --noise1-primary-channel: #ffb380;
  --noise1-secondary-channel: #e6734d;
  --noise1-primary-note: #ffd9c2;
  --noise1-secondary-note: #b34700;

  --noise2-primary-channel: #ffc2a1;
  --noise2-secondary-channel: #ff9966;
  --noise2-primary-note: #ffe5d9;
  --noise2-secondary-note: #cc704d;

  --noise3-primary-channel: #e6734d;
  --noise3-secondary-channel: #cc5c33;
  --noise3-primary-note: #ff9966;
  --noise3-secondary-note: #994d26;

  --noise4-primary-channel: #cc704d;
  --noise4-secondary-channel: #b34700;
  --noise4-primary-note: #ffb380;
  --noise4-secondary-note: #802000;

  --noise5-primary-channel: #ffe5d9;
  --noise5-secondary-channel: #ffc2a1;
  --noise5-primary-note: #fff0e5;
  --noise5-secondary-note: #cc704d;

  --mod1-primary-channel: #ff9966;
  --mod1-secondary-channel: #cc6633;
  --mod1-primary-note: #ffb380;
  --mod1-secondary-note: #b34700;

  --mod2-primary-channel: #e6734d;
  --mod2-secondary-channel: #cc5c33;
  --mod2-primary-note: #ff9966;
  --mod2-secondary-note: #994d26;

  --mod3-primary-channel: #ffb380;
  --mod3-secondary-channel: #cc704d;
  --mod3-primary-note: #ffd9c2;
  --mod3-secondary-note: #a34700;

  --mod4-primary-channel: #ffd9c2;
  --mod4-secondary-channel: #ffad80;
  --mod4-primary-note: #fff0e5;
  --mod4-secondary-note: #cc704d;

  --mod-label-primary: #ffe5d9;
  --mod-label-secondary-text: #1a0a00;
  --mod-label-primary-text: #401700;

  --disabled-note-primary: #330d00;
  --disabled-note-secondary: #1a0a00;
}
html::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 3;
  pointer-events: none;
  background: linear-gradient(120deg, #000, orange, #000);
  background-size: 400% 400%;
  animation: steelShift 10s ease-in-out infinite;
  opacity: 0.10;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 4;
  pointer-events: none;
  background: radial-gradient(
    circle at center,
    rgba(0, 0, 0, 0) 60%,
    rgba(255, 255, 255, 0.04) 80%,
    rgba(255, 255, 255, 0.06) 90%,
    rgba(255, 255, 255, 0.08) 100%
  );
  animation: BlurFad 10s ease-in-out infinite;
  backdrop-filter: blur(6px);
}

body::after {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 5;
  background-image: 
    radial-gradient(orange 2px, transparent 0),
    radial-gradient(orange 1px, transparent 0),
    radial-gradient(orange 1px, transparent 0);
  background-size: 10px 10px, 4px 4px, 16px 16px;
  background-position: 0 0, 25% 25%, 100% 100%;
  opacity: 0.08;
  width: 200%;
  height: 200%;
  top: -50%;
  left: -50%;
  pointer-events: none;
  animation: Anim2 55s linear infinite;
  transform-origin: center center;
}

@keyframes BlurFad {
  0%   { opacity: 0.04; }
  50%  { opacity: 0.3; }
  100% { opacity: 0.04; }
}

@keyframes Anim2 {
  0% { transform: scale(1.2) rotate(0deg); }
  50% { transform: scale(1.8) rotate(180deg); }
  100% { transform: scale(1.2) rotate(360deg); }
}

@keyframes steelShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}


`,

    };
    
    
 
    
    
    ColorConfig.pageMargin = "var(--page-margin, black)";
ColorConfig.editorBackground = "var(--editor-background, black)";
ColorConfig.patternBackground = "var(--pattern-background, black)";
ColorConfig.hoverPreview = "var(--hover-preview, white)";
ColorConfig.playhead = "var(--playhead, white)";
ColorConfig.primaryText = "var(--primary-text, white)";
ColorConfig.secondaryText = "var(--secondary-text, #999)";
ColorConfig.invertedText = "var(--inverted-text, black)";
ColorConfig.textSelection = "var(--text-selection, rgba(119,68,255,0.99))";
ColorConfig.boxSelectionFill = "var(--box-selection-fill, rgba(255,255,255,0.2))";
ColorConfig.loopAccent = "var(--loop-accent, #74f)";
ColorConfig.linkAccent = "var(--link-accent, #98f)";
ColorConfig.uiWidgetBackground = "var(--ui-widget-background, #444)";
ColorConfig.uiWidgetFocus = "var(--ui-widget-focus, #777)";
ColorConfig.pitchBackground = "var(--pitch-background, #444)";
ColorConfig.tonic = "var(--tonic, #864)";
ColorConfig.fifthNote = "var(--fifth-note, #468)";
ColorConfig.whitePianoKey = "var(--white-piano-key, #bbb)";
ColorConfig.blackPianoKey = "var(--black-piano-key, #444)";
ColorConfig.whitePianoKeyText = "var(--white-piano-key-text, #131200)";
ColorConfig.blackPianoKeyText = "var(--black-piano-key-text, #fff)";
ColorConfig.useColorFormula = "var(--use-color-formula, false)";
ColorConfig.pitchSecondaryChannelHue = "var(--pitch-secondary-channel-hue)";
ColorConfig.pitchSecondaryChannelHueScale = "var(--pitch-secondary-channel-hue-scale)";
ColorConfig.pitchSecondaryChannelSat = "var(--pitch-secondary-channel-sat)";
ColorConfig.pitchSecondaryChannelSatScale = "var(--pitch-secondary-channel-sat-scale)";
ColorConfig.pitchSecondaryChannelLum = "var(--pitch-secondary-channel-lum)";
ColorConfig.pitchSecondaryChannelLumScale = "var(--pitch-secondary-channel-lum-scale)";
ColorConfig.pitchPrimaryChannelHue = "var(--pitch-primary-channel-hue)";
ColorConfig.pitchPrimaryChannelHueScale = "var(--pitch-primary-channel-hue-scale)";
ColorConfig.pitchPrimaryChannelSat = "var(--pitch-primary-channel-sat)";
ColorConfig.pitchPrimaryChannelSatScale = "var(--pitch-primary-channel-sat-scale)";
ColorConfig.pitchPrimaryChannelLum = "var(--pitch-primary-channel-lum)";
ColorConfig.pitchPrimaryChannelLumScale = "var(--pitch-primary-channel-lum-scale)";
ColorConfig.pitchSecondaryNoteHue = "var(--pitch-secondary-note-hue)";
ColorConfig.pitchSecondaryNoteHueScale = "var(--pitch-secondary-note-hue-scale)";
ColorConfig.pitchSecondaryNoteSat = "var(--pitch-secondary-note-sat)";
ColorConfig.pitchSecondaryNoteSatScale = "var(--pitch-secondary-note-sat-scale)";
ColorConfig.pitchSecondaryNoteLum = "var(--pitch-secondary-note-lum)";
ColorConfig.pitchSecondaryNoteLumScale = "var(--pitch-secondary-note-lum-scale)";
ColorConfig.pitchPrimaryNoteHue = "var(--pitch-primary-note-hue)";
ColorConfig.pitchPrimaryNoteHueScale = "var(--pitch-primary-note-hue-scale)";
ColorConfig.pitchPrimaryNoteSat = "var(--pitch-primary-note-sat)";
ColorConfig.pitchPrimaryNoteSatScale = "var(--pitch-primary-note-sat-scale)";
ColorConfig.pitchPrimaryNoteLum = "var(--pitch-primary-note-lum)";
ColorConfig.pitchPrimaryNoteLumScale = "var(--pitch-primary-note-lum-scale)";
ColorConfig.modSecondaryChannelHue = "var(--mod-secondary-channel-hue)";
ColorConfig.modSecondaryChannelHueScale = "var(--mod-secondary-channel-hue-scale)";
ColorConfig.modSecondaryChannelSat = "var(--mod-secondary-channel-sat)";
ColorConfig.modSecondaryChannelSatScale = "var(--mod-secondary-channel-sat-scale)";
ColorConfig.modSecondaryChannelLum = "var(--mod-secondary-channel-lum)";
ColorConfig.modSecondaryChannelLumScale = "var(--mod-secondary-channel-lum-scale)";
ColorConfig.modPrimaryChannelHue = "var(--mod-primary-channel-hue)";
ColorConfig.modPrimaryChannelHueScale = "var(--mod-primary-channel-hue-scale)";
ColorConfig.modPrimaryChannelSat = "var(--mod-primary-channel-sat)";
ColorConfig.modPrimaryChannelSatScale = "var(--mod-primary-channel-sat-scale)";
ColorConfig.modPrimaryChannelLum = "var(--mod-primary-channel-lum)";
ColorConfig.modPrimaryChannelLumScale = "var(--mod-primary-channel-lum-scale)";
ColorConfig.modSecondaryNoteHue = "var(--mod-secondary-note-hue)";
ColorConfig.modSecondaryNoteHueScale = "var(--mod-secondary-note-hue-scale)";
ColorConfig.modSecondaryNoteSat = "var(--mod-secondary-note-sat)";
ColorConfig.modSecondaryNoteSatScale = "var(--mod-secondary-note-sat-scale)";
ColorConfig.modSecondaryNoteLum = "var(--mod-secondary-note-lum)";
ColorConfig.modSecondaryNoteLumScale = "var(--mod-secondary-note-lum-scale)";
ColorConfig.modPrimaryNoteHue = "var(--mod-primary-note-hue)";
ColorConfig.modPrimaryNoteHueScale = "var(--mod-primary-note-hue-scale)";
ColorConfig.modPrimaryNoteSat = "var(--mod-primary-note-sat)";
ColorConfig.modPrimaryNoteSatScale = "var(--mod-primary-note-sat-scale)";
ColorConfig.modPrimaryNoteLum = "var(--mod-primary-note-lum)";
ColorConfig.modPrimaryNoteLumScale = "var(--mod-primary-note-lum-scale)";
ColorConfig.noiseSecondaryChannelHue = "var(--noise-secondary-channel-hue)";
ColorConfig.noiseSecondaryChannelHueScale = "var(--noise-secondary-channel-hue-scale)";
ColorConfig.noiseSecondaryChannelSat = "var(--noise-secondary-channel-sat)";
ColorConfig.noiseSecondaryChannelSatScale = "var(--noise-secondary-channel-sat-scale)";
ColorConfig.noiseSecondaryChannelLum = "var(--noise-secondary-channel-lum)";
ColorConfig.noiseSecondaryChannelLumScale = "var(--noise-secondary-channel-lum-scale)";
ColorConfig.noisePrimaryChannelHue = "var(--noise-primary-channel-hue)";
ColorConfig.noisePrimaryChannelHueScale = "var(--noise-primary-channel-hue-scale)";
ColorConfig.noisePrimaryChannelSat = "var(--noise-primary-channel-sat)";
ColorConfig.noisePrimaryChannelSatScale = "var(--noise-primary-channel-sat-scale)";
ColorConfig.noisePrimaryChannelLum = "var(--noise-primary-channel-lum)";
ColorConfig.noisePrimaryChannelLumScale = "var(--noise-primary-channel-lum-scale)";
ColorConfig.noiseSecondaryNoteHue = "var(--noise-secondary-note-hue)";
ColorConfig.noiseSecondaryNoteHueScale = "var(--noise-secondary-note-hue-scale)";
ColorConfig.noiseSecondaryNoteSat = "var(--noise-secondary-note-sat)";
ColorConfig.noiseSecondaryNoteSatScale = "var(--noise-secondary-note-sat-scale)";
ColorConfig.noiseSecondaryNoteLum = "var(--noise-secondary-note-lum)";
ColorConfig.noiseSecondaryNoteLumScale = "var(--noise-secondary-note-lum-scale)";
ColorConfig.noisePrimaryNoteHue = "var(--noise-primary-note-hue)";
ColorConfig.noisePrimaryNoteHueScale = "var(--noise-primary-note-hue-scale)";
ColorConfig.noisePrimaryNoteSat = "var(--noise-primary-note-sat)";
ColorConfig.noisePrimaryNoteSatScale = "var(--noise-primary-note-sat-scale)";
ColorConfig.noisePrimaryNoteLum = "var(--noise-primary-note-lum)";
ColorConfig.noisePrimaryNoteLumScale = "var(--noise-primary-note-lum-scale)";
ColorConfig.trackEditorBgPitch = "var(--track-editor-bg-pitch, #444)";
ColorConfig.trackEditorBgPitchDim = "var(--track-editor-bg-pitch-dim, #333)";
ColorConfig.trackEditorBgNoise = "var(--track-editor-bg-noise, #444)";
ColorConfig.trackEditorBgNoiseDim = "var(--track-editor-bg-noise-dim, #333)";
ColorConfig.trackEditorBgMod = "var(--track-editor-bg-mod, #234)";
ColorConfig.trackEditorBgModDim = "var(--track-editor-bg-mod-dim, #123)";
ColorConfig.multiplicativeModSlider = "var(--multiplicative-mod-slider, #456;)";
ColorConfig.overwritingModSlider = "var(--overwriting-mod-slider, #654)";
ColorConfig.indicatorPrimary = "var(--indicator-primary, #74f)";
ColorConfig.indicatorSecondary = "var(--indicator-secondary, #444)";
ColorConfig.select2OptGroup = "var(--select2-opt-group, #585858)";
ColorConfig.inputBoxOutline = "var(--input-box-outline, #333)";
ColorConfig.muteButtonNormal = "var(--mute-button-normal, #ffa033)";
ColorConfig.muteButtonMod = "var(--mute-button-mod, #9a6bff)";
ColorConfig.modLabelPrimary = "var(--mod-label-primary, #999)";
ColorConfig.modLabelSecondaryText = "var(--mod-label-secondary-text, #333)";
ColorConfig.modLabelPrimaryText = "var(--mod-label-primary-text, black)";
ColorConfig.disabledNotePrimary = "var(--disabled-note-primary, #999)";
ColorConfig.disabledNoteSecondary = "var(--disabled-note-secondary, #666)";
ColorConfig.c_pitchSecondaryChannelHue = 0;
ColorConfig.c_pitchSecondaryChannelHueScale = 0;
ColorConfig.c_pitchSecondaryChannelSat = 0;
ColorConfig.c_pitchSecondaryChannelSatScale = 0;
ColorConfig.c_pitchSecondaryChannelLum = 0;
ColorConfig.c_pitchSecondaryChannelLumScale = 0;
ColorConfig.c_pitchPrimaryChannelHue = 0;
ColorConfig.c_pitchPrimaryChannelHueScale = 0;
ColorConfig.c_pitchPrimaryChannelSat = 0;
ColorConfig.c_pitchPrimaryChannelSatScale = 0;
ColorConfig.c_pitchPrimaryChannelLum = 0;
ColorConfig.c_pitchPrimaryChannelLumScale = 0;
ColorConfig.c_pitchSecondaryNoteHue = 0;
ColorConfig.c_pitchSecondaryNoteHueScale = 0;
ColorConfig.c_pitchSecondaryNoteSat = 0;
ColorConfig.c_pitchSecondaryNoteSatScale = 0;
ColorConfig.c_pitchSecondaryNoteLum = 0;
ColorConfig.c_pitchSecondaryNoteLumScale = 0;
ColorConfig.c_pitchPrimaryNoteHue = 0;
ColorConfig.c_pitchPrimaryNoteHueScale = 0;
ColorConfig.c_pitchPrimaryNoteSat = 0;
ColorConfig.c_pitchPrimaryNoteSatScale = 0;
ColorConfig.c_pitchPrimaryNoteLum = 0;
ColorConfig.c_pitchPrimaryNoteLumScale = 0;
ColorConfig.c_modSecondaryChannelHue = 0;
ColorConfig.c_modSecondaryChannelHueScale = 0;
ColorConfig.c_modSecondaryChannelSat = 0;
ColorConfig.c_modSecondaryChannelSatScale = 0;
ColorConfig.c_modSecondaryChannelLum = 0;
ColorConfig.c_modSecondaryChannelLumScale = 0;
ColorConfig.c_modPrimaryChannelHue = 0;
ColorConfig.c_modPrimaryChannelHueScale = 0;
ColorConfig.c_modPrimaryChannelSat = 0;
ColorConfig.c_modPrimaryChannelSatScale = 0;
ColorConfig.c_modPrimaryChannelLum = 0;
ColorConfig.c_modPrimaryChannelLumScale = 0;
ColorConfig.c_modSecondaryNoteHue = 0;
ColorConfig.c_modSecondaryNoteHueScale = 0;
ColorConfig.c_modSecondaryNoteSat = 0;
ColorConfig.c_modSecondaryNoteSatScale = 0;
ColorConfig.c_modSecondaryNoteLum = 0;
ColorConfig.c_modSecondaryNoteLumScale = 0;
ColorConfig.c_modPrimaryNoteHue = 0;
ColorConfig.c_modPrimaryNoteHueScale = 0;
ColorConfig.c_modPrimaryNoteSat = 0;
ColorConfig.c_modPrimaryNoteSatScale = 0;
ColorConfig.c_modPrimaryNoteLum = 0;
ColorConfig.c_modPrimaryNoteLumScale = 0;
ColorConfig.c_noiseSecondaryChannelHue = 0;
ColorConfig.c_noiseSecondaryChannelHueScale = 0;
ColorConfig.c_noiseSecondaryChannelSat = 0;
ColorConfig.c_noiseSecondaryChannelSatScale = 0;
ColorConfig.c_noiseSecondaryChannelLum = 0;
ColorConfig.c_noiseSecondaryChannelLumScale = 0;
ColorConfig.c_noisePrimaryChannelHue = 0;
ColorConfig.c_noisePrimaryChannelHueScale = 0;
ColorConfig.c_noisePrimaryChannelSat = 0;
ColorConfig.c_noisePrimaryChannelSatScale = 0;
ColorConfig.c_noisePrimaryChannelLum = 0;
ColorConfig.c_noisePrimaryChannelLumScale = 0;
ColorConfig.c_noiseSecondaryNoteHue = 0;
ColorConfig.c_noiseSecondaryNoteHueScale = 0;
ColorConfig.c_noiseSecondaryNoteSat = 0;
ColorConfig.c_noiseSecondaryNoteSatScale = 0;
ColorConfig.c_noiseSecondaryNoteLum = 0;
ColorConfig.c_noiseSecondaryNoteLumScale = 0;
ColorConfig.c_noisePrimaryNoteHue = 0;
ColorConfig.c_noisePrimaryNoteHueScale = 0;
ColorConfig.c_noisePrimaryNoteSat = 0;
ColorConfig.c_noisePrimaryNoteSatScale = 0;
ColorConfig.c_noisePrimaryNoteLum = 0;
ColorConfig.c_noisePrimaryNoteLumScale = 0;
ColorConfig.c_pitchChannelCountOverride = 40;
ColorConfig.c_noiseChannelCountOverride = 16;
ColorConfig.c_modChannelCountOverride = 12;
ColorConfig.c_pitchLimit = 1;
ColorConfig.c_noiseLimit = 1;
ColorConfig.c_modLimit = 1;
ColorConfig.c_colorFormulaPitchLimit = 1;
ColorConfig.c_colorFormulaNoiseLimit = 1;
ColorConfig.c_colorFormulaModLimit = 1;
ColorConfig.c_invertedText = "";
ColorConfig.c_trackEditorBgNoiseDim = "";
ColorConfig.c_trackEditorBgNoise = "";
ColorConfig.c_trackEditorBgModDim = "";
ColorConfig.c_trackEditorBgMod = "";
ColorConfig.c_trackEditorBgPitchDim = "";
ColorConfig.c_trackEditorBgPitch = "";
ColorConfig.pitchChannels = toNameMap([
    {
        name: "pitch1",
        secondaryChannel: "var(--pitch1-secondary-channel, #0099A1)",
        primaryChannel: "var(--pitch1-primary-channel, #25F3FF)",
        secondaryNote: "var(--pitch1-secondary-note, #00BDC7)",
        primaryNote: "var(--pitch1-primary-note, #92F9FF)",
    }, {
        name: "pitch2",
        secondaryChannel: "var(--pitch2-secondary-channel, #A1A100)",
        primaryChannel: "var(--pitch2-primary-channel, #FFFF25)",
        secondaryNote: "var(--pitch2-secondary-note, #C7C700)",
        primaryNote: "var(--pitch2-primary-note, #FFFF92)",
    }, {
        name: "pitch3",
        secondaryChannel: "var(--pitch3-secondary-channel, #C75000)",
        primaryChannel: "var(--pitch3-primary-channel, #FF9752)",
        secondaryNote: "var(--pitch3-secondary-note, #FF771C)",
        primaryNote: "var(--pitch3-primary-note, #FFCDAB)",
    }, {
        name: "pitch4",
        secondaryChannel: "var(--pitch4-secondary-channel, #00A100)",
        primaryChannel: "var(--pitch4-primary-channel, #50FF50)",
        secondaryNote: "var(--pitch4-secondary-note, #00C700)",
        primaryNote: "var(--pitch4-primary-note, #A0FFA0)",
    }, {
        name: "pitch5",
        secondaryChannel: "var(--pitch5-secondary-channel, #D020D0)",
        primaryChannel: "var(--pitch5-primary-channel, #FF90FF)",
        secondaryNote: "var(--pitch5-secondary-note, #E040E0)",
        primaryNote: "var(--pitch5-primary-note, #FFC0FF)",
    }, {
        name: "pitch6",
        secondaryChannel: "var(--pitch6-secondary-channel, #7777B0)",
        primaryChannel: "var(--pitch6-primary-channel, #A0A0FF)",
        secondaryNote: "var(--pitch6-secondary-note, #8888D0)",
        primaryNote: "var(--pitch6-primary-note, #D0D0FF)",
    }, {
        name: "pitch7",
        secondaryChannel: "var(--pitch7-secondary-channel, #8AA100)",
        primaryChannel: "var(--pitch7-primary-channel, #DEFF25)",
        secondaryNote: "var(--pitch7-secondary-note, #AAC700)",
        primaryNote: "var(--pitch7-primary-note, #E6FF92)",
    }, {
        name: "pitch8",
        secondaryChannel: "var(--pitch8-secondary-channel, #DF0019)",
        primaryChannel: "var(--pitch8-primary-channel, #FF98A4)",
        secondaryNote: "var(--pitch8-secondary-note, #FF4E63)",
        primaryNote: "var(--pitch8-primary-note, #FFB2BB)",
    }, {
        name: "pitch9",
        secondaryChannel: "var(--pitch9-secondary-channel, #00A170)",
        primaryChannel: "var(--pitch9-primary-channel, #50FFC9)",
        secondaryNote: "var(--pitch9-secondary-note, #00C78A)",
        primaryNote: "var(--pitch9-primary-note, #83FFD9)",
    }, {
        name: "pitch10",
        secondaryChannel: "var(--pitch10-secondary-channel, #A11FFF)",
        primaryChannel: "var(--pitch10-primary-channel, #CE8BFF)",
        secondaryNote: "var(--pitch10-secondary-note, #B757FF)",
        primaryNote: "var(--pitch10-primary-note, #DFACFF)",
    },
]);
ColorConfig.noiseChannels = toNameMap([
    {
        name: "noise1",
        secondaryChannel: "var(--noise1-secondary-channel, #6F6F6F)",
        primaryChannel: "var(--noise1-primary-channel, #AAAAAA)",
        secondaryNote: "var(--noise1-secondary-note, #A7A7A7)",
        primaryNote: "var(--noise1-primary-note, #E0E0E0)",
    }, {
        name: "noise2",
        secondaryChannel: "var(--noise2-secondary-channel, #996633)",
        primaryChannel: "var(--noise2-primary-channel, #DDAA77)",
        secondaryNote: "var(--noise2-secondary-note, #CC9966)",
        primaryNote: "var(--noise2-primary-note, #F0D0BB)",
    }, {
        name: "noise3",
        secondaryChannel: "var(--noise3-secondary-channel, #4A6D8F)",
        primaryChannel: "var(--noise3-primary-channel, #77AADD)",
        secondaryNote: "var(--noise3-secondary-note, #6F9FCF)",
        primaryNote: "var(--noise3-primary-note, #BBD7FF)",
    }, {
        name: "noise4",
        secondaryChannel: "var(--noise4-secondary-channel, #7A4F9A)",
        primaryChannel: "var(--noise4-primary-channel, #AF82D2)",
        secondaryNote: "var(--noise4-secondary-note, #9E71C1)",
        primaryNote: "var(--noise4-primary-note, #D4C1EA)",
    }, {
        name: "noise5",
        secondaryChannel: "var(--noise5-secondary-channel, #607837)",
        primaryChannel: "var(--noise5-primary-channel, #A2BB77)",
        secondaryNote: "var(--noise5-secondary-note, #91AA66)",
        primaryNote: "var(--noise5-primary-note, #C5E2B2)",
    },
]);
ColorConfig.modChannels = toNameMap([
    {
        name: "mod1",
        secondaryChannel: "var(--mod1-secondary-channel, #339955)",
        primaryChannel: "var(--mod1-primary-channel, #77fc55)",
        secondaryNote: "var(--mod1-secondary-note, #77ff8a)",
        primaryNote: "var(--mod1-primary-note, #cdffee)",
    }, {
        name: "mod2",
        secondaryChannel: "var(--mod2-secondary-channel, #993355)",
        primaryChannel: "var(--mod2-primary-channel, #f04960)",
        secondaryNote: "var(--mod2-secondary-note, #f057a0)",
        primaryNote: "var(--mod2-primary-note, #ffb8de)",
    }, {
        name: "mod3",
        secondaryChannel: "var(--mod3-secondary-channel, #553399)",
        primaryChannel: "var(--mod3-primary-channel, #8855fc)",
        secondaryNote: "var(--mod3-secondary-note, #aa64ff)",
        primaryNote: "var(--mod3-primary-note, #f8ddff)",
    }, {
        name: "mod4",
        secondaryChannel: "var(--mod4-secondary-channel, #a86436)",
        primaryChannel: "var(--mod4-primary-channel, #c8a825)",
        secondaryNote: "var(--mod4-secondary-note, #e8ba46)",
        primaryNote: "var(--mod4-primary-note, #fff6d3)",
    },
]);
    ColorConfig._styleElement = document.head.appendChild(HTML.style({ type: "text/css" }));

    const scrollBarTest = document.body.appendChild(HTML.div({ style: "width:30px; height:30px; overflow: auto;" }, HTML.div({ style: "width:100%;height:40px" })));
    if (scrollBarTest.firstChild.clientWidth < 30) {
        document.documentElement.classList.add("obtrusive-scrollbars");
    }
    document.body.removeChild(scrollBarTest);
    document.head.appendChild(HTML.style({ type: "text/css" }, `

/* Note: "#" symbols need to be encoded as "%23" in SVG data urls, otherwise they are interpreted as fragment identifiers! */
:root {
	--button-size: 26px;
	--settings-area-width: 192px;
	--record-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><circle cx="0" cy="0" r="6" fill="gray"/></svg>');
	--stop-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="-6" y="-6" width="12" height="12" fill="gray"/></svg>'); 
	--play-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M -4 -8 L -4 8 L 9 0 z" fill="gray"/></svg>');
	--pause-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="-4" y="-8" width="4" height="16" fill="gray"/><rect x="5" y="-8" width="4" height="16" fill="gray"/></svg>');
	--prev-bar-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="-6" y="-6" width="2" height="12" fill="gray"/><path d="M 6 -6 L 6 6 L -3 0 z" fill="gray"/></svg>');
	--next-bar-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="4" y="-6" width="2" height="12" fill="gray"/><path d="M -6 -6 L -6 6 L 3 0 z" fill="gray"/></svg>');
	--volume-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"><path d="M 4 16 L 4 10 L 8 10 L 13 5 L 13 21 L 8 16 z M 15 11 L 16 10 A 7.2 7.2 0 0 1 16 16 L 15 15 A 5.8 5.8 0 0 0 15 12 z M 18 8 L 19 7 A 11.5 11.5 0 0 1 19 19 L 18 18 A 10.1 10.1 0 0 0 18 8 z" fill="gray"/></svg>');
	--unmuted-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="3 3 20 20"><path d="M 4 16 L 4 10 L 8 10 L 13 5 L 13 21 L 8 16 z M 15 11 L 16 10 A 7.2 7.2 0 0 1 16 16 L 15 15 A 5.8 5.8 0 0 0 15 12 z M 18 8 L 19 7 A 11.5 11.5 0 0 1 19 19 L 18 18 A 10.1 10.1 0 0 0 18 8 z" fill="gray"/></svg>');
	--muted-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="3 3 20 20"><path d="M 4 16 L 4 10 L 8 10 L 13 5 L 13 21 L 8 16 z" fill="gray"/></svg>');
	--menu-down-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M -4 -2 L 4 -2 L 0 3 z" fill="gray"/></svg>');
	--select-arrows-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M -4 -3 L 4 -3 L 0 -8 z M -4 3 L 4 3 L 0 8 z" fill="gray"/></svg>');
	--file-page-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-5 -21 26 26"><path d="M 2 0 L 2 -16 L 10 -16 L 14 -12 L 14 0 z M 3 -1 L 13 -1 L 13 -11 L 9 -11 L 9 -15 L 3 -15 z" fill="gray"/></svg>');
	--edit-pencil-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-5 -21 26 26"><path d="M 0 0 L 1 -4 L 4 -1 z M 2 -5 L 10 -13 L 13 -10 L 5 -2 zM 11 -14 L 13 -16 L 14 -16 L 16 -14 L 16 -13 L 14 -11 z" fill="gray"/></svg>');
	--preferences-gear-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M 5.78 -1.6 L 7.93 -0.94 L 7.93 0.94 L 5.78 1.6 L 4.85 3.53 L 5.68 5.61 L 4.21 6.78 L 2.36 5.52 L 0.27 5.99 L -0.85 7.94 L -2.68 7.52 L -2.84 5.28 L -4.52 3.95 L -6.73 4.28 L -7.55 2.59 L -5.9 1.07 L -5.9 -1.07 L -7.55 -2.59 L -6.73 -4.28 L -4.52 -3.95 L -2.84 -5.28 L -2.68 -7.52 L -0.85 -7.94 L 0.27 -5.99 L 2.36 -5.52 L 4.21 -6.78 L 5.68 -5.61 L 4.85 -3.53 M 2.92 0.67 L 2.92 -0.67 L 2.35 -1.87 L 1.3 -2.7 L 0 -3 L -1.3 -2.7 L -2.35 -1.87 L -2.92 -0.67 L -2.92 0.67 L -2.35 1.87 L -1.3 2.7 L -0 3 L 1.3 2.7 L 2.35 1.87 z" fill="gray"/></svg>');
	--customize-dial-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"> \
			<g transform="translate(0,1)" fill="gray"> \
				<circle cx="0" cy="0" r="6.5" stroke="gray" stroke-width="1" fill="none"/> \
				<rect x="-1" y="-5" width="2" height="4" transform="rotate(30)"/> \
				<circle cx="-7.79" cy="4.5" r="0.75"/> \
				<circle cx="-9" cy="0" r="0.75"/> \
				<circle cx="-7.79" cy="-4.5" r="0.75"/> \
				<circle cx="-4.5" cy="-7.79" r="0.75"/> \
				<circle cx="0" cy="-9" r="0.75"/> \
				<circle cx="4.5" cy="-7.79" r="0.75"/> \
				<circle cx="7.79" cy="-4.5" r="0.75"/> \
				<circle cx="9" cy="0" r="0.75"/> \
				<circle cx="7.79" cy="4.5" r="0.75"/> \
			</g> \
		</svg>');
	--instrument-copy-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-5 -21 26 26"><path d="M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z" fill="currentColor"></path></svg>');
	--instrument-paste-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"><path d="M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z" stroke="currentColor" fill="none"></path><path d="M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z" fill="currentColor"></path></svg>');
	--export-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -8 3 L -8 8 L 8 8 L 8 3 L 6 3 L 6 6 L -6 6 L -6 3 z M 0 2 L -4 -2 L -1 -2 L -1 -8 L 1 -8 L 1 -2 L 4 -2 z"/></svg>');
	--close-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -7.07 -5.66 L -5.66 -7.07 L 0 -1.4 L 5.66 -7.07 L 7.07 -5.66 L 1.4 0 L 7.07 5.66 L 5.66 7.07 L 0 1.4 L -5.66 7.07 L -7.07 5.66 L -1.4 0 z"/></svg>');
	--add-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -8 -1 L -1 -1 L -1 -8  L 1 -8 L 1 -1 L 8 -1 L 8 1 L 1 1 L 1 8 L -1 8 L -1 1 L -8 1 z"/></svg>');
	--zoom-in-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="-10 -10 20 20"><circle cx="-1" cy="-1" r="6" stroke-width="2" stroke="gray" fill="none"></circle><path stroke="gray" stroke-width="2" d="M 3 3 L 7 7 M -1 -4 L -1 2 M -4 -1 L 2 -1" fill="none"></path></svg>');
	--zoom-out-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="-10 -10 20 20"><circle cx="-1" cy="-1" r="6" stroke-width="2" stroke="gray" fill="none"></circle><path stroke="gray" stroke-width="2" d="M 3 3 L 7 7 M -4 -1 L 2 -1" fill="none"></path></svg>');
	--checkmark-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -9 -2 L -8 -3 L -3 2 L 9 -8 L 10 -7 L -3 8 z"/></svg>');
	--drum-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="40" viewBox="0 0 32 40"> \
			<defs> \
				<linearGradient id="gold1" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="%237e3302"/> \
					<stop offset="40%" stop-color="%23ffec6b"/> \
					<stop offset="100%" stop-color="%237e3302"/> \
				</linearGradient> \
				<linearGradient id="gold2" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="%23faaf7d"/> \
					<stop offset="15%" stop-color="%23fffba9"/> \
					<stop offset="40%" stop-color="%23ffffe3"/> \
					<stop offset="65%" stop-color="%23fffba9"/> \
					<stop offset="100%" stop-color="%23faaf7d"/> \
				</linearGradient> \
				<radialGradient id="gold3" cx="0%" cy="0%" r="100%"> \
					<stop offset="0%" stop-color="%23ffffe3"/> \
					<stop offset="50%" stop-color="%23ffec6b"/> \
					<stop offset="100%" stop-color="%237e3302"/> \
				</radialGradient> \
				<linearGradient id="red" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="%23641919"/> \
					<stop offset="40%" stop-color="%23cd2c2c"/> \
					<stop offset="100%" stop-color="%23641919"/> \
				</linearGradient> \
				<radialGradient id="membrane"> \
					<stop offset="10%" stop-color="%23cccccc" /> \
					<stop offset="90%" stop-color="%23f6f6f7" /> \
					<stop offset="100%" stop-color="%23999" /> \
				</radialGradient> \
			</defs> \
			<ellipse cx="16" cy="26" rx="16" ry="14" fill="rgba(0,0,0,0.5)"/> \
			<ellipse cx="16" cy="25" rx="16" ry="14" fill="url(%23gold1)"/> \
			<rect x="0" y="23" width="32" height="2" fill="url(%23gold1)"/> \
			<ellipse cx="16" cy="23" rx="16" ry="14" fill="url(%23gold2)"/> \
			<ellipse cx="16" cy="23" rx="15" ry="13" fill="url(%23red)"/> \
			<rect x="1" y="17" width="30" height="6" fill="url(%23red)"/> \
			<rect x="5" y="27" width="1" height="5" rx="0.5" fill="rgba(0,0,0,0.5)"/> \
			<rect x="15" y="31" width="2" height="5" rx="1" fill="rgba(0,0,0,0.5)"/> \
			<rect x="26" y="27" width="1" height="5" rx="0.5" fill="rgba(0,0,0,0.5)"/> \
			<rect x="5" y="26" width="1" height="5" rx="0.5" fill="url(%23gold3)"/> \
			<rect x="15" y="30" width="2" height="5" rx="1" fill="url(%23gold3)"/> \
			<rect x="26" y="26" width="1" height="5" rx="0.5" fill="url(%23gold3)"/> \
			<ellipse cx="16" cy="18" rx="15" ry="13" fill="rgba(0,0,0,0.5)"/> \
			<ellipse cx="16" cy="16" rx="16" ry="14" fill="url(%23gold1)"/> \
			<rect x="0" y="14" width="32" height="2" fill="url(%23gold1)"/> \
			<ellipse cx="16" cy="14" rx="16" ry="14" fill="url(%23gold2)"/> \
			<ellipse cx="16" cy="14" rx="15" ry="13" fill="url(%23membrane)"/> \
		</svg>');
	--piano-key-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="15" preserveAspectRatio="none" viewBox="0 -1 32 15"> \
			<defs> \
				<linearGradient id="shadow" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="rgba(0,0,0,0.5)"/> \
					<stop offset="100%" stop-color="transparent"/> \
				</linearGradient> \
			</defs> \
			<rect x="-1" y="1" width="31" height="1" rx="0.6" fill="rgba(255,255,255,0.4)"/> \
			<path d="M -1 11 L 30 11 L 30 2 L 33 -1 L 33 14 L -1 14 z" fill="rgba(0,0,0,0.7)"/> \
			<rect x="-1" y="-1" width="19" height="15" fill="url(%23shadow)"/> \
		</svg>');
  --mod-key-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="80" preserveAspectRatio="none" viewBox="0 -1 32 80"> \
			<defs> \
				<linearGradient id="shadow" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="rgba(0,0,0,0.4)"/> \
					<stop offset="100%" stop-color="transparent"/> \
				</linearGradient> \
			</defs> \
			<rect x="-1" y="1" width="31" height="1" rx="0.6" fill="rgba(255,255,255,0.2)"/> \
			<path d="M -1 76 L 30 76 L 30 1 L 33 -1 L 33 80 L -1 80 z" fill="rgba(0,0,0,0.7)"/> \
			<rect x="-1" y="-1" width="19" height="80" fill="url(%23shadow)"/> \
		</svg>');
}


.obtrusive-scrollbars, .obtrusive-scrollbars * {
	scrollbar-width: thin;
	scrollbar-color: ${ColorConfig.uiWidgetBackground} ${ColorConfig.editorBackground};
}
.obtrusive-scrollbars::-webkit-scrollbar, .obtrusive-scrollbars *::-webkit-scrollbar {
	width: 12px;
}
.obtrusive-scrollbars::-webkit-scrollbar-track, .obtrusive-scrollbars *::-webkit-scrollbar-track {
	background: ${ColorConfig.editorBackground};
}
.obtrusive-scrollbars::-webkit-scrollbar-thumb, .obtrusive-scrollbars *::-webkit-scrollbar-thumb {
	background-color: ${ColorConfig.uiWidgetBackground};
	border: 3px solid ${ColorConfig.editorBackground};
}

@-moz-document url-prefix() {
	.muteButtonText {
		transform: translate(3px, 1px) !important;
	}
}

.beepboxEditor {
	display: grid;
    grid-template-columns: minmax(0, 1fr) max-content;
    grid-template-rows: max-content 1fr; /* max-content minmax(0, 1fr); Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */
    grid-template-areas: "pattern-area settings-area" "track-area settings-area";
	grid-column-gap: 6px;
	grid-row-gap: 6px;
	position: relative;
	touch-action: manipulation;
	cursor: default;
	font-size: 13px;
	overflow: hidden;
	color: ${ColorConfig.primaryText};
	background: ${ ColorConfig.editorBackground  };
    opacity: 0;
    -webkit-transition: opacity 0.2s ease-in;
    -moz-transition: opacity 0.2s ease-in;
    -o-transition: opacity 0.2s ease-in;
    -ms-transition: opacity 0.2s ease-in;
    transition: opacity 0.2s ease-in;
    transition-delay: 0s;
}

.beepboxEditor .operatorRow {
	margin: 2px 0;
	height: 2em;
	display: flex;
	flex-direction: row;
	align-items: center;
}

.beepboxEditor .operatorRow > * {
	flex-grow: 1;
	flex-shrink: 1;
}

.pattern-area {
     opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0s;
}

.settings-area {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.15s;
}

.editor-song-settings {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.35s;
}

.instrument-settings-area {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.45s;
}

.trackAndMuteContainer {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.4s;
}

.barScrollBar {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.5s;
}



.load {
    opacity: 1;
}

.beepboxEditor .noSelection {
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}

.beepboxEditor div {
	margin: 0;
	padding: 0;
}

.beepboxEditor .pattern-area {
	grid-area: pattern-area;
	height: 481px;
	display: flex;
	flex-direction: row;
	position: relative;
}

.beepboxEditor .track-area {
	grid-area: track-area;
}

.beepboxEditor .loopEditor {
	height: 20px;
	position: sticky;
	bottom: 0;
	padding: 5px 0;
	background-color: ${ ColorConfig.editorBackground};
}

.beepboxEditor .settings-area {
	grid-area: settings-area;
	display: grid;
    grid-template-columns: auto;
    grid-template-rows: min-content min-content min-content min-content min-content;
    grid-template-areas: "version-area" "play-pause-area" "menu-area" "song-settings-area" "instrument-settings-area";
	grid-column-gap: 6px;
}

.beepboxEditor .version-area{ grid-area: version-area; }
.beepboxEditor .play-pause-area{ grid-area: play-pause-area; }
.beepboxEditor .menu-area{ grid-area: menu-area; }
.beepboxEditor .song-settings-area{ grid-area: song-settings-area; }
.beepboxEditor .instrument-settings-area{ grid-area: instrument-settings-area; }

.beepboxEditor .tip {
	cursor: help;
	color: ${ColorConfig.secondaryText};
	text-decoration: none;
}

.beepboxEditor .tip:hover {
	color: ${ColorConfig.linkAccent};
	text-decoration: underline;
}
.beepboxEditor .tip:active {
	color: ${ColorConfig.primaryText};
}

.beepboxEditor .volume-speaker {
	flex-shrink: 0;
	width: var(--button-size);
	height: var(--button-size);
	background: ${ColorConfig.secondaryText};
	-webkit-mask-image: var(--volume-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--volume-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .drum-button {
	flex: 1;
	background-color: transparent;
	background-image: var(--drum-symbol);
	background-repeat: no-repeat;
	background-position: center;
}

.beepboxEditor .modulator-button {
	flex: 1;
	position: relative;
	display: flex;
	align-items: center;
}
.beepboxEditor .modulator-button::before {
	content: "";
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-image: var(--mod-key-symbol);
	background-repeat: no-repeat;
	background-position: center;
	background-size: 100% 102%;
}

.beepboxEditor .piano-button {
	flex: 1;
	position: relative;
	display: flex;
	align-items: center;
}
.beepboxEditor .piano-button::before {
	content: "";
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-image: var(--piano-key-symbol);
	background-repeat: no-repeat;
	background-position: center;
	background-size: 100% 115.38%;
}
.beepboxEditor .piano-button.disabled::after {
	content: "";
	position: absolute;
	right: 0;
	top: 0;
	width: 70%;
	height: 100%;
	pointer-events: none;
	background: ${ColorConfig.editorBackground};
	-webkit-mask-image: linear-gradient(90deg, transparent 0%, gray 70%, gray 100%);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: linear-gradient(90deg, transparent 0%, gray 70%, gray 100%);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .customize-instrument {
	margin: 2px 0;
}
.beepboxEditor .customize-instrument::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--customize-dial-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--customize-dial-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .instrumentCopyPasteRow {
	gap: 2px;
}

.beepboxEditor .copy-instrument {
	margin: 2px 0;
	flex-grow: 1;
}
.beepboxEditor .copy-instrument::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--instrument-copy-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--instrument-copy-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .paste-instrument {
	margin: 2px 0;
	flex-grow: 1;
}
.beepboxEditor .paste-instrument::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--instrument-paste-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--instrument-paste-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .envelopeEditor {
	display: flex;
	flex-direction: column;
}

.beepboxEditor .envelope-row {
	display: flex;
	margin: 2px 0;
	gap: 2px;
}

.beepboxEditor .add-envelope {
	width: var(--button-size);
}
.beepboxEditor .add-envelope::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--add-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--add-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .add-envelope:disabled {
	visibility: hidden;
}

.beepboxEditor .effects-menu {
	width: var(--button-size);
	position: relative;
}
.beepboxEditor .effects-menu::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--menu-down-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--menu-down-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .zoomInButton, .beepboxEditor .zoomOutButton {
	width: var(--button-size);
	position: absolute;
	right: 10px;
}
.beepboxEditor .zoomInButton {
	top: 10px;
}
.beepboxEditor .zoomOutButton {
	top: 50px;
}
.beepboxEditor .zoomInButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--zoom-in-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--zoom-in-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .zoomOutButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--zoom-out-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--zoom-out-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .delete-envelope {
	width: var(--button-size);
	flex-shrink: 0;
	flex-grow: 0;
}
.beepboxEditor .delete-envelope::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .delete-envelope:disabled {
	visibility: hidden;
}

.beepboxEditor .menu.file::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--file-page-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--file-page-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .menu.edit::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--edit-pencil-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--edit-pencil-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .menu.preferences::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--preferences-gear-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--preferences-gear-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .mute-button {
	background: transparent;
	border: none;
  padding-right: 0px;
  padding-left: 0px;
  box-shadow: none;
}

.beepboxEditor .mute-button:focus {
  background: transparent;
	border: none;
}

.beepboxEditor .mute-button::before {
	content: "";
	pointer-events: none;
	width: 100%;
	height: 100%;
	display: inline-block;
  background: var(--mute-button-normal);
	-webkit-mask-image: var(--unmuted-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	-webkit-mask-size: cover;
  mask-repeat: no-repeat;
	mask-position: center;
	mask-size: cover;
  mask-image: var(--unmuted-symbol);
}

.beepboxEditor .mute-button.muted::before {
  background: var(--ui-widget-background);
	-webkit-mask-image: var(--muted-symbol);
  mask-image: var(--muted-symbol);
}

.beepboxEditor .mute-button.modMute.muted::before {
  background: var(--ui-widget-background);
	-webkit-mask-image: var(--muted-symbol);
  mask-image: var(--muted-symbol);
}

.beepboxEditor .mute-button.modMute::before {
  background: var(--mute-button-mod);
}


.beepboxEditor .promptContainer {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: 100;
}

.beepboxEditor .promptContainer::before {
	content: "";
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: ${ColorConfig.editorBackground};
	opacity: 0.5;
	display: flex;
}

.beepboxEditor .prompt {
	margin: auto;
	text-align: center;
	background: ${ColorConfig.editorBackground};
	border-radius: 15px;
	border: 4px solid ${ColorConfig.uiWidgetBackground};
	color: ${ColorConfig.primaryText};
	padding: 20px;
	display: flex;
	flex-direction: column;
	max-height:80vh; overflow: hidden scroll;
	max-width:90vw;
	position: fixed;
	right: 12px;
	top: 50vh;
	left: 50vw;
	minHeight: 40vh;
	transform: translate(-50%,-50%);
	zIndex: 5;
	
	
	box-shadow: 5px 5px 20px 10px rgba(0,0,0,0.5);
}

.beepboxEditor .prompt > *:not(:first-child):not(.cancelButton) {
	margin-top: 1.5em;
}

.beepboxEditor .prompt h2 {
	font-size: 2em;
	margin: 0 16px;
	font-weight: normal;
}

.beepboxEditor .prompt p {
	text-align: left;
	margin: 1em 0;
}

.beepboxEditor .layout-option {
	display: flex;
	flex-direction: column;
	flex: 1;
	cursor: pointer;
	color: ${ColorConfig.secondaryText};
}

.beepboxEditor .layout-option input {
	display: none;
}

.beepboxEditor .layout-option input:checked ~ * {
	color: ${ColorConfig.primaryText};
}
.beepboxEditor select.invalidSetting {
	border: solid 1px red;
}
.beepboxEditor .selectContainer {
	position: relative;
}
.beepboxEditor .selectContainer:not(.menu)::after {
	content: "";
	flex-shrink: 0;
	position: absolute;
	right: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: 14px;
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--select-arrows-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--select-arrows-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor .selectContainer.menu::after {
	content: "";
	flex-shrink: 0;
	position: absolute;
	right: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--menu-down-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--menu-down-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor select {
	margin: 0;
	padding: 0 4px;
	display: block;
	height: var(--button-size);
	border: none;
	border-radius: 5px;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit;
	font-size: inherit;
	cursor: pointer;
	font-family: inherit;
	font-weight: inherit;

	-webkit-appearance:none;
	-moz-appearance: none;
	appearance: none;
}

.select2-container .select2-selection--single {
  height: auto;
}

.select2-container {
  width: -moz-available !important;
  width: -webkit-fill-available !important;
}

.select2-container--default .select2-selection--single{
  border-radius: 0px;
  border: 0px;
  background-color: transparent;
  outline: none;
}

.select2-selection__rendered:not(.menu)::before {
	content: "";
	position: absolute;
	right: 0.3em;
	top: 0.4em;
	border-bottom: 0.4em solid currentColor;
	border-left: 0.3em solid transparent;
	border-right: 0.3em solid transparent;
	pointer-events: none;
}
.select2-selection__rendered:not(.menu)::after {
	content: "";
	position: absolute;
	right: 0.3em;
	bottom: 0.4em;
	border-top: 0.4em solid currentColor;
	border-left: 0.3em solid transparent;
	border-right: 0.3em solid transparent;
	pointer-events: none;
}
.select2-selection__rendered {
	margin: 0;
	padding: 0 0.3em;
	display: block;
	height: 2em;
	border: none;
	border-radius: 0.4em;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit !important;
	font-size: inherit;
	cursor: pointer;
	font-family: inherit;
	-webkit-appearance:none;
	-moz-appearance: none;
	appearance: none;
}
.select2-selection__arrow b{
    display:none !important;
}

.select2-selection__rendered--focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}
.select2-search__field {
    background: ${ColorConfig.uiWidgetBackground};
    color: inherit !important;
    font-size: small;
    font-family: inherit;
    border: 0px !important;
    padding: 1px !important;
}
.select2-dropdown {
    box-sizing: border-box;
    display: inline-block;
    margin: 0;
    font-size: small;
    position: relative;
    vertical-align: middle;
    background-color: ${ColorConfig.uiWidgetFocus};
}

.select2-container--default .select2-results>.select2-results__options {
    max-height: 430px;
    overflow-x: hidden;
}
.select2-container--default .select2-results__group {
    cursor: default;
    display: block;
    padding: 1px;
    background: ${ColorConfig.select2OptGroup};
}
.select2-results__option {
    padding: 2px;
    user-select: none;
    -webkit-user-select: none;
}
.select2-container--default .select2-results__option .select2-results__option {
    padding-left: 0.1em;
}
.select2-container--default .select2-results__option[aria-selected=true] {
  background-color: transparent !important;
}

.beepboxEditor .menu select {
	padding: 0 var(--button-size);
}
.beepboxEditor select:focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}
.beepboxEditor .menu select {
	text-align: center;
	text-align-last: center;
}
.beepboxEditor .settings-area select {
       width: 100%;
}

/* This makes it look better in firefox on my computer... What about others?
@-moz-document url-prefix() {
	.beepboxEditor select { padding: 0 2px; }
}
*/
.beepboxEditor button {
	margin: 0;
	position: relative;
	height: var(--button-size);
	border: none;
	border-radius: 5px;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit;
	font-size: inherit;
	font-family: inherit;
	font-weight: inherit;
	cursor: pointer;
}
.beepboxEditor button:focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}

.beepboxEditor button.cancelButton {
	float: right;
	width: var(--button-size);
	position: absolute;
	top: 8px;
	right: 8px;
}

.beepboxEditor   button.stopButton, .beepboxEditor button.okayButton, .beepboxEditor button.exportButton {
	padding-left: var(--button-size);
}
.beepboxEditor button.playButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--play-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--play-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor button.recordButton::before {
content: "";
flex-shrink: 0;
position: absolute;
left: 0;
top: 50%;
transform: translateY(-50%);
pointer-events: none;
width: var(--button-size);
height: var(--button-size);
background: currentColor;
-webkit-mask-image: var(--record-symbol);
-webkit-mask-repeat: no-repeat;
-webkit-mask-position: center;
mask-image: var(--record-symbol);
mask-repeat: no-repeat;
mask-position: center;
}
.beepboxEditor button.pauseButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--pause-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--pause-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor button.stopButton::before {
content: "";
flex-shrink: 0;
position: absolute;
left: 0;
top: 50%;
transform: translateY(-50%);
pointer-events: none;
width: var(--button-size);
height: var(--button-size);
background: currentColor;
-webkit-mask-image: var(--stop-symbol);
-webkit-mask-repeat: no-repeat;
-webkit-mask-position: center;
mask-image: var(--stop-symbol);
mask-repeat: no-repeat;
mask-position: center;
}
.beepboxEditor button.prevBarButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--prev-bar-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--prev-bar-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.nextBarButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--next-bar-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--next-bar-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.cancelButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor button.okayButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	-webkit-mask-image: var(--checkmark-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--checkmark-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.exportButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--export-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--export-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .instrument-bar {
	display: flex;
	gap: 2px;
}

.beepboxEditor .instrument-bar button {
	flex-grow: 1;
	min-width: 0;
	padding: 0;
	flex-basis: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	color: var(--text-color-lit);
}

.beepboxEditor .instrument-bar .remove-instrument, .beepboxEditor .instrument-bar .add-instrument {
	max-width: var(--button-size);
}

.beepboxEditor .instrument-bar > :not(:first-child) {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}

.beepboxEditor .instrument-bar > :not(.last-button) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}

.beepboxEditor .instrument-bar .selected-instrument {
	background: var(--background-color-lit);
	color: ${ColorConfig.invertedText};
}

.beepboxEditor .instrument-bar .deactivated {
	background: ${ColorConfig.editorBackground};
	color: var(--text-color-dim);
}

.beepboxEditor .instrument-bar .deactivated.selected-instrument {
	background: var(--background-color-dim);
	color: ${ColorConfig.invertedText};
}

.beepboxEditor .instrument-bar .remove-instrument::before {
	content: "";
	position: absolute;
	width: 100%;
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .instrument-bar .add-instrument::before {
	content: "";
	position: absolute;
	width: 100%;
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--add-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--add-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor canvas {
	overflow: hidden;
	position: absolute;
	display: block;
  cursor: crosshair;
}

@keyframes dash-animation {
  to {
    stroke-dashoffset: -100;
  }
}

.beepboxEditor .dash-move {
  animation: dash-animation 20s infinite linear;
}

.beepboxEditor .trackContainer {
	flex-grow: 1;
}

.beepboxEditor .trackAndMuteContainer {
	display: flex;
	align-items: flex-start;
	width: 100%;
	min-height: 0;
	flex: 1;
	overflow-x: hidden;
	position: relative;
}

.beepboxEditor .muteEditor {
	width: 32px;
	flex-shrink: 0;
	display: flex;
	flex-direction: column;
	align-items: stretch;
	position: sticky;
	left: 0;
	z-index: 1;
	background: ${ColorConfig.editorBackground};
}

.beepboxEditor .selectRow, .beepboxEditor .instrumentCopyPasteRow {
	margin: 2px 0;
	height: var(--button-size);
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: space-between;
}

.beepboxEditor .selectRow > :last-child {
	width: 62.5%;
	flex-shrink: 0;
}

.beepboxEditor .menu-area {
	display: flex;
	flex-direction: column;
}
.beepboxEditor .menu-area > * {
	margin: 2px 0;
}
.beepboxEditor .menu-area > button {
	padding: 0 var(--button-size);
	white-space: nowrap;
}

.beepboxEditor .song-settings-area {
	display: flex;
	flex-direction: column;
}

.beepboxEditor .editor-controls {
	flex-shrink: 0;
	display: flex;
	flex-direction: column;
}

.beepboxEditor .instrument-settings-area {
	display: flex;
	flex-direction: column;
}

.beepboxEditor .editor-right-side-top > *, .beepboxEditor .editor-right-side-bottom > * {
	flex-shrink: 0;
}

.beepboxEditor .pitchShiftMarkerContainer {
	box-sizing: border-box;
	display: flex;
	height: 100%;
	left: 3px;
	right: 3px;
	position: absolute;
	align-items: center;
	pointer-events: none;
}

.beepboxEditor .pitchShiftMarker {
	width: 0;
	height: 0;
	position: absolute;
}

.beepboxEditor .pitchShiftMarker::before {
	content: "";
	width: 2px;
	height: 20px;
	transform: translate(-50%, -50%);
	position: absolute;
	background: currentColor;
	border-radius: 3px;
}

.beepboxEditor input[type=text], .beepboxEditor input[type=number] {
	font-size: inherit;
	font-weight: inherit;
	font-family: inherit;
	background: transparent;
	text-align: center;
	border: 1px solid ${ColorConfig.inputBoxOutline};
	color: ${ColorConfig.primaryText};
}

.beepboxEditor input[type=text]::selection, .beepboxEditor input[type=number]::selection {
	background-color: ${ColorConfig.textSelection};
	color: ${ColorConfig.primaryText};
}

.beepboxEditor input[type=checkbox] {
  transform: scale(1.5);
}

.beepboxEditor input[type=range] {
	-webkit-appearance: none;
	color: inherit;
	width: 100%;
	height: var(--button-size);
	font-size: inherit;
	margin: 0;
	cursor: pointer;
	background: none;
	touch-action: pan-y;
  position: relative;
}
.beepboxEditor input[type=range]:focus {
	outline: none;
}
.beepboxEditor input[type=range]::-webkit-slider-runnable-track {
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
}

.modTarget:hover {
	fill: ${ColorConfig.hoverPreview} !important;
}

.beepboxEditor span.midTick:after {
    content: "";
    display:inline-block;
    position: absolute;
    background: currentColor;
    width: 2%;
    left: 49%;
    height: 0.5em;
    top: 32%;
    z-index: 1;
		pointer-events: none;
}
.beepboxEditor span.modSlider {
	--mod-position: 20%;
	--mod-color: ${ColorConfig.overwritingModSlider};
  --mod-border-radius: 0%;
}
.beepboxEditor span.modSlider:before {
	content: "";
    display:inline-block;
    position: absolute;
    background: var(--mod-color);
    width: 4%;
    left: var(--mod-position);
    height: 0.8em;
    top: 28%;
    z-index: 2;
		transform: translate(-50%, 0%);
		pointer-events: none;
		border: 40%;
		border-radius: var(--mod-border-radius);
}
.beepboxEditor input[type=range]::-webkit-slider-thumb {
	height: var(--button-size);
	width: 6px;
	border-radius: 3px;
	background: currentColor;
	cursor: pointer;
	-webkit-appearance: none;
	margin-top: -10px;
}
.beepboxEditor input[type=range]:focus::-webkit-slider-runnable-track {
	background: ${ColorConfig.uiWidgetFocus};
}
.beepboxEditor input[type=range]::-moz-range-track {
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
}
.beepboxEditor input[type=range]:focus::-moz-range-track {
	background: ${ColorConfig.uiWidgetFocus};
}
.beepboxEditor input[type=range]::-moz-range-thumb {
	height: var(--button-size);
	width: 6px;
	border-radius: 3px;
	border: none;
	background: currentColor;
	cursor: pointer;
}
.beepboxEditor input[type=range]::-ms-track {
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
	border-color: transparent;
}
.beepboxEditor input[type=range]:focus::-ms-track {
	background: ${ColorConfig.uiWidgetFocus};
}
.beepboxEditor input[type=range]::-ms-thumb {
	height: var(--button-size);
	width: 6px;
	border-radius: 3px;
	background: currentColor;
	cursor: pointer;
}

li.select2-results__option[role=group] > strong:hover {
  background-color: #516fbb;
}

/* wide screen */
@media (min-width: 711px) {
	#beepboxEditorContainer {
		display: table;
	}
	.beepboxEditor {
		flex-direction: row;
	}
	.beepboxEditor:focus-within {
		outline: 3px solid ${ColorConfig.uiWidgetBackground};
	}
	.beepboxEditor .trackAndMuteContainer {
		width: 512px;
	}
	.beepboxEditor .trackSelectBox {
		display: none;
	}
    .beepboxEditor .muteButtonSelectBox {
		display: none;
	}
	.beepboxEditor .play-pause-area {
		display: flex;
		flex-direction: column;
	}
	.beepboxEditor .playback-bar-controls {
		display: flex;
		flex-direction: row;
		margin: 2px 0;
	}
	.beepboxEditor .playback-volume-controls {
		display: flex;
		flex-direction: row;
		margin: 2px 0;
		align-items: center;
	}
	.beepboxEditor .pauseButton, .beepboxEditor .playButton,
    .beepboxEditor .copyButton, .beepboxEditor .pasteButton
    {
		flex-grow: 1;
	}
	.beepboxEditor .nextBarButton, .beepboxEditor .prevBarButton {
		flex-grow: 1;
		margin-left: 10px;
	}
	.beepboxEditor .settings-area {
		width: var(--settings-area-width);
	}
}

/* narrow screen */
@media (max-width: 710px) {
	.beepboxEditor {
		grid-template-columns: minmax(0, 1fr);
		grid-template-rows: min-content 6px min-content min-content;
		grid-template-areas: "pattern-area" "." "track-area" "settings-area";
		grid-row-gap: 0;
	}
	.beepboxEditor .settings-area {
		grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
		grid-template-rows: min-content min-content 1fr min-content;
		grid-template-areas:
			"play-pause-area play-pause-area"
			"menu-area instrument-settings-area"
			"song-settings-area instrument-settings-area"
			"version-area version-area";
		grid-column-gap: 8px;
		margin: 0 4px;
	}
	.beepboxEditor:focus-within {
		outline: none;
	}
	.beepboxEditor .pattern-area {
		max-height: 75vh;
	}
	.beepboxEditor .trackAndMuteContainer {
		overflow-x: auto;
	}
	.beepboxEditor .barScrollBar {
		display: none;
	}
	.beepboxEditor .play-pause-area {
		display: flex;
		flex-direction: row;
		margin: 2px 0;
	}
	.beepboxEditor .playback-bar-controls {
		display: flex;
		flex-direction: row;
		flex-grow: 1;
	}
	.beepboxEditor .playback-volume-controls {
		display: flex;
		flex-direction: row;
		align-items: center;
		flex-grow: 1;
		margin: 0 2px;
	}
	.beepboxEditor .pauseButton, .beepboxEditor .playButton,
	.beepboxEditor .nextBarButton, .beepboxEditor .prevBarButton,
    .beepboxEditor .copyButton, .beepboxEditor .pasteButton
    {
		flex-grow: 1;
		margin: 0 2px;
	}
	
	.beepboxEditor .soundIcon {
	  background: ${ColorConfig.editorBackground};
	  display: inline-block;
	  height: 10px;
	  margin-left: 0px;
	  margin-top: 8px;
		position: relative;
		width: 10px;
	}
	.beepboxEditor .soundIcon:before {
	  border-bottom: 6px solid transparent;
	  border-top: 6px solid transparent;
	  border-right: 10px solid ${ColorConfig.editorBackground};
	  content: "";
	  height: 10px;
	  left: 6px;
	  position: absolute;
	  top: -6px;
	  width: 0;
	}
}

`));

    class BarScrollBar {
        constructor(_doc, _trackContainer) {
            this._doc = _doc;
            this._trackContainer = _trackContainer;
            this._editorWidth = 512;
            this._editorHeight = 20;
            this._playhead = SVG.rect("rect", { fill: ColorConfig.playhead, x: 0, y: 0, width: 2, height: this._editorHeight });
            this._notches = SVG.svg({ "pointer-events": "none" });
            this._handle = SVG.rect({ fill: ColorConfig.uiWidgetBackground, x: 0, y: 2, width: 10, height: this._editorHeight - 4 });
            this._handleHighlight = SVG.rect({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": 2, "pointer-events": "none", x: 0, y: 1, width: 10, height: this._editorHeight - 2 });
            this._leftHighlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._rightHighlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._renderedPlayhead = -1;
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: pan-y; position: absolute;`, width: this._editorWidth, height: this._editorHeight }, this._notches, this._handle, this._handleHighlight, this._leftHighlight, this._rightHighlight, this._playhead);
            this.container = HTML.div({ class: "barScrollBar", style: "width: 512px; height: 20px; overflow: hidden; position: relative;" }, this._svg);
            this._mouseX = 0;
            this._mouseDown = false;
            this._mouseOver = false;
            this._dragging = false;
            this._renderedNotchCount = -1;
            this._renderedBarPos = -1;
            this.animatePlayhead = () => {
                const playhead = Math.min(512, Math.max(0, (this._notchSpace * this._doc.synth.playhead - 2)));
                if (this._renderedPlayhead != playhead) {
                    this._renderedPlayhead = playhead;
                    this._playhead.setAttribute("x", "" + playhead);
                }
            };
            this._onScroll = (event) => {
                this._doc.barScrollPos = (this._trackContainer.scrollLeft / this._doc.getBarWidth());
            };
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._updatePreview();
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
                this._updatePreview();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
                this._updatePreview();
                if (this._mouseX >= this._doc.barScrollPos * this._notchSpace && this._mouseX <= (this._doc.barScrollPos + this._doc.trackVisibleBars) * this._notchSpace) {
                    this._dragging = true;
                    this._dragStart = this._mouseX;
                }
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = event.touches[0].clientX - boundingRect.left;
                this._updatePreview();
                if (this._mouseX >= this._doc.barScrollPos * this._notchSpace && this._mouseX <= (this._doc.barScrollPos + this._doc.trackVisibleBars) * this._notchSpace) {
                    this._dragging = true;
                    this._dragStart = this._mouseX;
                }
            };
            this._whenMouseMoved = (event) => {
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = event.touches[0].clientX - boundingRect.left;
                
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (!this._dragging && this._mouseDown) {
                    if (this._mouseX < (this._doc.barScrollPos + 8) * this._notchSpace) {
                        if (this._doc.barScrollPos > 0)
                            this._doc.barScrollPos--;
                        this._doc.notifier.changed();
                    }
                    else {
                        if (this._doc.barScrollPos < this._doc.song.barCount - this._doc.trackVisibleBars)
                            this._doc.barScrollPos++;
                        this._doc.notifier.changed();
                    }
                }
                this._mouseDown = false;
                this._dragging = false;
                this._updatePreview();
            };
            const center = this._editorHeight * 0.5;
            const base = 20;
            const tip = 9;
            const arrowHeight = 6;
            this._leftHighlight.setAttribute("d", `M ${tip} ${center} L ${base} ${center + arrowHeight} L ${base} ${center - arrowHeight} z`);
            this._rightHighlight.setAttribute("d", `M ${this._editorWidth - tip} ${center} L ${this._editorWidth - base} ${center + arrowHeight} L ${this._editorWidth - base} ${center - arrowHeight} z`);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
            this._trackContainer.addEventListener("scroll", this._onScroll, { capture: false, passive: true });
        }
        _whenCursorMoved() {
            if (this._dragging) {
            	 
                while (this._mouseX - this._dragStart < -this._notchSpace * 0.5) {
                    if (this._doc.barScrollPos > 0) {
                        this._doc.barScrollPos--;
                        this._dragStart -= this._notchSpace;
                        this._doc.notifier.changed();
                    }
                    else {
                        break;
                    }
                }
                while (this._mouseX - this._dragStart > this._notchSpace * 0.5) {
                    if (this._doc.barScrollPos < this._doc.song.barCount - this._doc.trackVisibleBars) {
                        this._doc.barScrollPos++;
                        this._dragStart += this._notchSpace;
                        this._doc.notifier.changed();
                    }
                    else {
                        break;
                    }
                }
            }
            if (this._mouseOver)
                this._updatePreview();
        }
        changePos(offset) {
            while (Math.abs(offset) >= 1) {
                if (offset < 0) {
                    if (this._doc.barScrollPos > 0) {
                        this._doc.barScrollPos--;
                        this._dragStart += this._notchSpace;
                        this._doc.notifier.changed();
                    }
                }
                else {
                    if (this._doc.barScrollPos < this._doc.song.barCount - this._doc.trackVisibleBars) {
                        this._doc.barScrollPos++;
                        this._dragStart += this._notchSpace;
                        this._doc.notifier.changed();
                    }
                }
                offset += (offset > 0) ? -1 : 1;
            }
        }
        _updatePreview() {
            const showHighlight = this._mouseOver && !this._mouseDown;
            let showleftHighlight = false;
            let showRightHighlight = false;
            let showHandleHighlight = false;
            if (showHighlight) {
                if (this._mouseX < this._doc.barScrollPos * this._notchSpace) {
                    showleftHighlight = true;
                }
                else if (this._mouseX > (this._doc.barScrollPos + this._doc.trackVisibleBars) * this._notchSpace) {
                    showRightHighlight = true;
                }
                else {
                    showHandleHighlight = true;
                }
            }
            this._leftHighlight.style.visibility = showleftHighlight ? "visible" : "hidden";
            this._rightHighlight.style.visibility = showRightHighlight ? "visible" : "hidden";
            this._handleHighlight.style.visibility = showHandleHighlight ? "visible" : "hidden";
        }
        render() {
            this._notchSpace = (this._editorWidth - 1) / Math.max(this._doc.trackVisibleBars, this._doc.song.barCount);
            const resized = this._renderedNotchCount != this._doc.song.barCount;
            if (resized) {
                this._renderedNotchCount = this._doc.song.barCount;
                while (this._notches.firstChild)
                    this._notches.removeChild(this._notches.firstChild);
                for (let i = 0; i <= this._doc.song.barCount; i++) {
                    const lineHeight = (i % 16 == 0) ? 0 : ((i % 4 == 0) ? this._editorHeight / 8 : this._editorHeight / 3);
                    this._notches.appendChild(SVG.rect({ fill: ColorConfig.uiWidgetBackground, x: i * this._notchSpace - 1, y: lineHeight, width: 2, height: this._editorHeight - lineHeight * 2 }));
                }
            }
            if (resized || this._renderedBarPos != this._doc.barScrollPos) {
                this._renderedBarPos = this._doc.barScrollPos;
                this._handle.setAttribute("x", String(this._notchSpace * this._doc.barScrollPos));
                this._handle.setAttribute("width", String(this._notchSpace * this._doc.trackVisibleBars));
                this._handleHighlight.setAttribute("x", String(this._notchSpace * this._doc.barScrollPos));
                this._handleHighlight.setAttribute("width", String(this._notchSpace * this._doc.trackVisibleBars));
            }
            this._updatePreview();
            this._trackContainer.scrollLeft = this._doc.barScrollPos * this._doc.getBarWidth();
            this._trackContainer.scrollTop = this._doc.channelScrollPos * this._doc.getChannelHeight();
        }
    }

    function scaleElementsByFactor(array, factor) {
        for (let i = 0; i < array.length; i++) {
            array[i] *= factor;
        }
    }
    function isPowerOf2(n) {
        return !!n && !(n & (n - 1));
    }
    function countBits(n) {
        if (!isPowerOf2(n))
            throw new Error("FFT array length must be a power of 2.");
        return Math.round(Math.log(n) / Math.log(2));
    }
    function reverseIndexBits(array, fullArrayLength) {
        const bitCount = countBits(fullArrayLength);
        if (bitCount > 16)
            throw new Error("FFT array length must not be greater than 2^16.");
        const finalShift = 16 - bitCount;
        for (let i = 0; i < fullArrayLength; i++) {
            let j;
            j = ((i & 0xaaaa) >> 1) | ((i & 0x5555) << 1);
            j = ((j & 0xcccc) >> 2) | ((j & 0x3333) << 2);
            j = ((j & 0xf0f0) >> 4) | ((j & 0x0f0f) << 4);
            j = ((j >> 8) | ((j & 0xff) << 8)) >> finalShift;
            if (j > i) {
                let temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
    function inverseRealFourierTransform(array, fullArrayLength) {
        const totalPasses = countBits(fullArrayLength);
        if (fullArrayLength < 4)
            throw new Error("FFT array length must be at least 4.");
        for (let pass = totalPasses - 1; pass >= 2; pass--) {
            const subStride = 1 << pass;
            const midSubStride = subStride >> 1;
            const stride = subStride << 1;
            const radiansIncrement = Math.PI * 2.0 / stride;
            const cosIncrement = Math.cos(radiansIncrement);
            const sinIncrement = Math.sin(radiansIncrement);
            const oscillatorMultiplier = 2.0 * cosIncrement;
            for (let startIndex = 0; startIndex < fullArrayLength; startIndex += stride) {
                const startIndexA = startIndex;
                const midIndexA = startIndexA + midSubStride;
                const startIndexB = startIndexA + subStride;
                const midIndexB = startIndexB + midSubStride;
                const stopIndex = startIndexB + subStride;
                const realStartA = array[startIndexA];
                const imagStartB = array[startIndexB];
                array[startIndexA] = realStartA + imagStartB;
                array[midIndexA] *= 2;
                array[startIndexB] = realStartA - imagStartB;
                array[midIndexB] *= 2;
                let c = cosIncrement;
                let s = -sinIncrement;
                let cPrev = 1.0;
                let sPrev = 0.0;
                for (let index = 1; index < midSubStride; index++) {
                    const indexA0 = startIndexA + index;
                    const indexA1 = startIndexB - index;
                    const indexB0 = startIndexB + index;
                    const indexB1 = stopIndex - index;
                    const real0 = array[indexA0];
                    const real1 = array[indexA1];
                    const imag0 = array[indexB0];
                    const imag1 = array[indexB1];
                    const tempA = real0 - real1;
                    const tempB = imag0 + imag1;
                    array[indexA0] = real0 + real1;
                    array[indexA1] = imag1 - imag0;
                    array[indexB0] = tempA * c - tempB * s;
                    array[indexB1] = tempB * c + tempA * s;
                    const cTemp = oscillatorMultiplier * c - cPrev;
                    const sTemp = oscillatorMultiplier * s - sPrev;
                    cPrev = c;
                    sPrev = s;
                    c = cTemp;
                    s = sTemp;
                }
            }
        }
        for (let index = 0; index < fullArrayLength; index += 4) {
            const index1 = index + 1;
            const index2 = index + 2;
            const index3 = index + 3;
            const real0 = array[index];
            const real1 = array[index1] * 2;
            const imag2 = array[index2];
            const imag3 = array[index3] * 2;
            const tempA = real0 + imag2;
            const tempB = real0 - imag2;
            array[index] = tempA + real1;
            array[index1] = tempA - real1;
            array[index2] = tempB + imag3;
            array[index3] = tempB - imag3;
        }
        reverseIndexBits(array, fullArrayLength);
    }

    class Deque {
        constructor() {
            this._capacity = 1;
            this._buffer = [undefined];
            this._mask = 0;
            this._offset = 0;
            this._count = 0;
        }
        pushFront(element) {
            if (this._count >= this._capacity)
                this._expandCapacity();
            this._offset = (this._offset - 1) & this._mask;
            this._buffer[this._offset] = element;
            this._count++;
        }
        pushBack(element) {
            if (this._count >= this._capacity)
                this._expandCapacity();
            this._buffer[(this._offset + this._count) & this._mask] = element;
            this._count++;
        }
        popFront() {
            if (this._count <= 0)
                throw new Error("No elements left to pop.");
            const element = this._buffer[this._offset];
            this._buffer[this._offset] = undefined;
            this._offset = (this._offset + 1) & this._mask;
            this._count--;
            return element;
        }
        popBack() {
            if (this._count <= 0)
                throw new Error("No elements left to pop.");
            this._count--;
            const index = (this._offset + this._count) & this._mask;
            const element = this._buffer[index];
            this._buffer[index] = undefined;
            return element;
        }
        peakFront() {
            if (this._count <= 0)
                throw new Error("No elements left to pop.");
            return this._buffer[this._offset];
        }
        peakBack() {
            if (this._count <= 0)
                throw new Error("No elements left to pop.");
            return this._buffer[(this._offset + this._count - 1) & this._mask];
        }
        count() {
            return this._count;
        }
        set(index, element) {
            if (index < 0 || index >= this._count)
                throw new Error("Invalid index");
            this._buffer[(this._offset + index) & this._mask] = element;
        }
        get(index) {
            if (index < 0 || index >= this._count)
                throw new Error("Invalid index");
            return this._buffer[(this._offset + index) & this._mask];
        }
        remove(index) {
            if (index < 0 || index >= this._count)
                throw new Error("Invalid index");
            if (index <= (this._count >> 1)) {
                while (index > 0) {
                    this.set(index, this.get(index - 1));
                    index--;
                }
                this.popFront();
            }
            else {
                index++;
                while (index < this._count) {
                    this.set(index - 1, this.get(index));
                    index++;
                }
                this.popBack();
            }
        }
        _expandCapacity() {
            if (this._capacity >= 0x40000000)
                throw new Error("Capacity too big.");
            this._capacity = this._capacity << 1;
            const oldBuffer = this._buffer;
            const newBuffer = new Array(this._capacity);
            const size = this._count | 0;
            const offset = this._offset | 0;
            for (let i = 0; i < size; i++) {
                newBuffer[i] = oldBuffer[(offset + i) & this._mask];
            }
            for (let i = size; i < this._capacity; i++) {
                newBuffer[i] = undefined;
            }
            this._offset = 0;
            this._buffer = newBuffer;
            this._mask = this._capacity - 1;
        }
    }

    class FilterCoefficients {
        constructor() {
            this.a = [1.0];
            this.b = [1.0];
            this.order = 0;
        }
        linearGain0thOrder(linearGain) {
            this.b[0] = linearGain;
            this.order = 0;
        }
        lowPass1stOrderButterworth(cornerRadiansPerSample) {
            const g = 1.0 / Math.tan(cornerRadiansPerSample * 0.5);
            const a0 = 1.0 + g;
            this.a[1] = (1.0 - g) / a0;
            this.b[1] = this.b[0] = 1 / a0;
            this.order = 1;
        }
        lowPass1stOrderSimplified(cornerRadiansPerSample) {
            const g = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);
            this.a[1] = g - 1.0;
            this.b[0] = g;
            this.b[1] = 0.0;
            this.order = 1;
        }
        highPass1stOrderButterworth(cornerRadiansPerSample) {
            const g = 1.0 / Math.tan(cornerRadiansPerSample * 0.5);
            const a0 = 1.0 + g;
            this.a[1] = (1.0 - g) / a0;
            this.b[0] = g / a0;
            this.b[1] = -g / a0;
            this.order = 1;
        }
        highShelf1stOrder(cornerRadiansPerSample, shelfLinearGain) {
            const tan = Math.tan(cornerRadiansPerSample * 0.5);
            const sqrtGain = Math.sqrt(shelfLinearGain);
            const g = (tan * sqrtGain - 1) / (tan * sqrtGain + 1.0);
            const a0 = 1.0;
            this.a[1] = g / a0;
            this.b[0] = (1.0 + g + shelfLinearGain * (1.0 - g)) / (2.0 * a0);
            this.b[1] = (1.0 + g - shelfLinearGain * (1.0 - g)) / (2.0 * a0);
            this.order = 1;
        }
        allPass1stOrderInvertPhaseAbove(cornerRadiansPerSample) {
            const g = (Math.sin(cornerRadiansPerSample) - 1.0) / Math.cos(cornerRadiansPerSample);
            this.a[1] = g;
            this.b[0] = g;
            this.b[1] = 1.0;
            this.order = 1;
        }
        allPass1stOrderFractionalDelay(delay) {
            const g = (1.0 - delay) / (1.0 + delay);
            this.a[1] = g;
            this.b[0] = g;
            this.b[1] = 1.0;
            this.order = 1;
        }
        lowPass2ndOrderButterworth(cornerRadiansPerSample, peakLinearGain) {
            const alpha = Math.sin(cornerRadiansPerSample) / (2.0 * peakLinearGain);
            const cos = Math.cos(cornerRadiansPerSample);
            const a0 = 1.0 + alpha;
            this.a[1] = -2.0 * cos / a0;
            this.a[2] = (1 - alpha) / a0;
            this.b[2] = this.b[0] = (1 - cos) / (2.0 * a0);
            this.b[1] = (1 - cos) / a0;
            this.order = 2;
        }
        lowPass2ndOrderSimplified(cornerRadiansPerSample, peakLinearGain) {
            const g = 2.0 * Math.sin(cornerRadiansPerSample / 2.0);
            const filterResonance = 1.0 - 1.0 / (2.0 * peakLinearGain);
            const feedback = filterResonance + filterResonance / (1.0 - g);
            this.a[1] = 2.0 * g + (g - 1.0) * g * feedback - 2.0;
            this.a[2] = (g - 1.0) * (g - g * feedback - 1.0);
            this.b[0] = g * g;
            this.b[1] = 0;
            this.b[2] = 0;
            this.order = 2;
        }
        highPass2ndOrderButterworth(cornerRadiansPerSample, peakLinearGain) {
            const alpha = Math.sin(cornerRadiansPerSample) / (2 * peakLinearGain);
            const cos = Math.cos(cornerRadiansPerSample);
            const a0 = 1.0 + alpha;
            this.a[1] = -2.0 * cos / a0;
            this.a[2] = (1.0 - alpha) / a0;
            this.b[2] = this.b[0] = (1.0 + cos) / (2.0 * a0);
            this.b[1] = -(1.0 + cos) / a0;
            this.order = 2;
        }
        peak2ndOrder(cornerRadiansPerSample, peakLinearGain, bandWidthScale) {
            const sqrtGain = Math.sqrt(peakLinearGain);
            const bandWidth = bandWidthScale * cornerRadiansPerSample / (sqrtGain >= 1 ? sqrtGain : 1 / sqrtGain);
            const alpha = Math.tan(bandWidth * 0.5);
            const a0 = 1.0 + alpha / sqrtGain;
            this.b[0] = (1.0 + alpha * sqrtGain) / a0;
            this.b[1] = this.a[1] = -2.0 * Math.cos(cornerRadiansPerSample) / a0;
            this.b[2] = (1.0 - alpha * sqrtGain) / a0;
            this.a[2] = (1.0 - alpha / sqrtGain) / a0;
            this.order = 2;
        }
    }
    class FrequencyResponse {
        constructor() {
            this.real = 0.0;
            this.imag = 0.0;
            this.denom = 1.0;
        }
        analyze(filter, radiansPerSample) {
            this.analyzeComplex(filter, Math.cos(radiansPerSample), Math.sin(radiansPerSample));
        }
        analyzeComplex(filter, real, imag) {
            const a = filter.a;
            const b = filter.b;
            const realZ1 = real;
            const imagZ1 = -imag;
            let realNum = b[0] + b[1] * realZ1;
            let imagNum = b[1] * imagZ1;
            let realDenom = 1.0 + a[1] * realZ1;
            let imagDenom = a[1] * imagZ1;
            let realZ = realZ1;
            let imagZ = imagZ1;
            for (let i = 2; i <= filter.order; i++) {
                const realTemp = realZ * realZ1 - imagZ * imagZ1;
                const imagTemp = realZ * imagZ1 + imagZ * realZ1;
                realZ = realTemp;
                imagZ = imagTemp;
                realNum += b[i] * realZ;
                imagNum += b[i] * imagZ;
                realDenom += a[i] * realZ;
                imagDenom += a[i] * imagZ;
            }
            this.denom = realDenom * realDenom + imagDenom * imagDenom;
            this.real = realNum * realDenom + imagNum * imagDenom;
            this.imag = imagNum * realDenom - realNum * imagDenom;
        }
        magnitude() {
            return Math.sqrt(this.real * this.real + this.imag * this.imag) / this.denom;
        }
        angle() {
            return Math.atan2(this.imag, this.real);
        }
    }
    class DynamicBiquadFilter {
        constructor() {
            this.a1 = 0.0;
            this.a2 = 0.0;
            this.b0 = 1.0;
            this.b1 = 0.0;
            this.b2 = 0.0;
            this.a1Delta = 0.0;
            this.a2Delta = 0.0;
            this.b0Delta = 0.0;
            this.b1Delta = 0.0;
            this.b2Delta = 0.0;
            this.output1 = 0.0;
            this.output2 = 0.0;
            this.useMultiplicativeInputCoefficients = false;
        }
        resetOutput() {
            this.output1 = 0.0;
            this.output2 = 0.0;
        }
        loadCoefficientsWithGradient(start, end, deltaRate, useMultiplicativeInputCoefficients) {
            if (start.order != 2 || end.order != 2)
                throw new Error();
            this.a1 = start.a[1];
            this.a2 = start.a[2];
            this.b0 = start.b[0];
            this.b1 = start.b[1];
            this.b2 = start.b[2];
            this.a1Delta = (end.a[1] - start.a[1]) * deltaRate;
            this.a2Delta = (end.a[2] - start.a[2]) * deltaRate;
            if (useMultiplicativeInputCoefficients) {
                this.b0Delta = Math.pow(end.b[0] / start.b[0], deltaRate);
                this.b1Delta = Math.pow(end.b[1] / start.b[1], deltaRate);
                this.b2Delta = Math.pow(end.b[2] / start.b[2], deltaRate);
            }
            else {
                this.b0Delta = (end.b[0] - start.b[0]) * deltaRate;
                this.b1Delta = (end.b[1] - start.b[1]) * deltaRate;
                this.b2Delta = (end.b[2] - start.b[2]) * deltaRate;
            }
            this.useMultiplicativeInputCoefficients = useMultiplicativeInputCoefficients;
        }
    }

    const epsilon = (1.0e-24);
    const base64IntToCharCode = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 95];
    const base64CharCodeToInt = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 63, 0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0, 0, 0, 0, 0];
    class BitFieldReader {
        constructor(source, startIndex, stopIndex) {
            this._bits = [];
            this._readIndex = 0;
            for (let i = startIndex; i < stopIndex; i++) {
                const value = base64CharCodeToInt[source.charCodeAt(i)];
                this._bits.push((value >> 5) & 0x1);
                this._bits.push((value >> 4) & 0x1);
                this._bits.push((value >> 3) & 0x1);
                this._bits.push((value >> 2) & 0x1);
                this._bits.push((value >> 1) & 0x1);
                this._bits.push(value & 0x1);
            }
        }
        read(bitCount) {
            let result = 0;
            while (bitCount > 0) {
                result = result << 1;
                result += this._bits[this._readIndex++];
                bitCount--;
            }
            return result;
        }
        readLongTail(minValue, minBits) {
            let result = minValue;
            let numBits = minBits;
            while (this._bits[this._readIndex++]) {
                result += 1 << numBits;
                numBits++;
            }
            while (numBits > 0) {
                numBits--;
                if (this._bits[this._readIndex++]) {
                    result += 1 << numBits;
                }
            }
            return result;
        }
        readPartDuration() {
            return this.readLongTail(1, 3);
        }
        readLegacyPartDuration() {
            return this.readLongTail(1, 2);
        }
        readPinCount() {
            return this.readLongTail(1, 0);
        }
        readPitchInterval() {
            if (this.read(1)) {
                return -this.readLongTail(1, 3);
            }
            else {
                return this.readLongTail(1, 3);
            }
        }
    }
    class BitFieldWriter {
        constructor() {
            this._index = 0;
            this._bits = [];
        }
        clear() {
            this._index = 0;
        }
        write(bitCount, value) {
            bitCount--;
            while (bitCount >= 0) {
                this._bits[this._index++] = (value >>> bitCount) & 1;
                bitCount--;
            }
        }
        writeLongTail(minValue, minBits, value) {
            if (value < minValue)
                throw new Error("value out of bounds");
            value -= minValue;
            let numBits = minBits;
            while (value >= (1 << numBits)) {
                this._bits[this._index++] = 1;
                value -= 1 << numBits;
                numBits++;
            }
            this._bits[this._index++] = 0;
            while (numBits > 0) {
                numBits--;
                this._bits[this._index++] = (value >>> numBits) & 1;
            }
        }
        writePartDuration(value) {
            this.writeLongTail(1, 3, value);
        }
        writePinCount(value) {
            this.writeLongTail(1, 0, value);
        }
        writePitchInterval(value) {
            if (value < 0) {
                this.write(1, 1);
                this.writeLongTail(1, 3, -value);
            }
            else {
                this.write(1, 0);
                this.writeLongTail(1, 3, value);
            }
        }
        concat(other) {
            for (let i = 0; i < other._index; i++) {
                this._bits[this._index++] = other._bits[i];
            }
        }
        encodeBase64(buffer) {
            for (let i = 0; i < this._index; i += 6) {
                const value = (this._bits[i] << 5) | (this._bits[i + 1] << 4) | (this._bits[i + 2] << 3) | (this._bits[i + 3] << 2) | (this._bits[i + 4] << 1) | this._bits[i + 5];
                buffer.push(base64IntToCharCode[value]);
            }
            return buffer;
        }
        lengthBase64() {
            return Math.ceil(this._index / 6);
        }
    }
    function makeNotePin(interval, time, size) {
        return { interval: interval, time: time, size: size };
    }
    function clamp(min, max, val) {
        max = max - 1;
        if (val <= max) {
            if (val >= min)
                return val;
            else
                return min;
        }
        else {
            return max;
        }
    }
 function encode32BitNumber(buffer, x) {
	buffer.push(base64IntToCharCode[(x >>> (6 * 5)) & 0x3]);
	buffer.push(base64IntToCharCode[(x >>> (6 * 4)) & 0x3f]);
	buffer.push(base64IntToCharCode[(x >>> (6 * 3)) & 0x3f]);
	buffer.push(base64IntToCharCode[(x >>> (6 * 2)) & 0x3f]);
	buffer.push(base64IntToCharCode[(x >>> (6 * 1)) & 0x3f]);
	buffer.push(base64IntToCharCode[(x >>> (6 * 0)) & 0x3f]);
}
function decode32BitNumber(compressed, charIndex) {
	let x = 0;
	x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 5);
	x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 4);
	x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 3);
	x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 2);
	x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 1);
	x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 0);
	return x;
}
    function encodeUnisonSettings(buffer, v, s, o, e, i) {
	buffer.push(base64IntToCharCode[v]);
	buffer.push(base64IntToCharCode[Number((s > 0))]);
	let cleanS = Math.round(Math.abs(s) * 1000);
	let cleanSDivided = Math.floor(cleanS / 63);
	buffer.push(base64IntToCharCode[cleanS % 63], base64IntToCharCode[cleanSDivided % 63], base64IntToCharCode[Math.floor(cleanSDivided / 63)]);
	buffer.push(base64IntToCharCode[Number((o > 0))]);
	let cleanO = Math.round(Math.abs(o) * 1000);
	let cleanODivided = Math.floor(cleanO / 63);
	buffer.push(base64IntToCharCode[cleanO % 63], base64IntToCharCode[cleanODivided % 63], base64IntToCharCode[Math.floor(cleanODivided / 63)]);
	buffer.push(base64IntToCharCode[Number((e > 0))]);
	let cleanE = Math.round(Math.abs(e) * 1000);
	buffer.push(base64IntToCharCode[cleanE % 63], base64IntToCharCode[Math.floor(cleanE / 63)]);
	buffer.push(base64IntToCharCode[Number((i > 0))]);
	let cleanI = Math.round(Math.abs(i) * 1000);
	buffer.push(base64IntToCharCode[cleanI % 63], base64IntToCharCode[Math.floor(cleanI / 63)]);
}
    function validateRange(min, max, val) {
        if (min <= val && val <= max)
            return val;
        throw new Error(`Value ${val} not in range [${min}, ${max}]`);
    }
    class Note {
        constructor(pitch, start, end, size, fadeout = false) {
            this.pitches = [pitch];
            this.pins = [makeNotePin(0, 0, size), makeNotePin(0, end - start, fadeout ? 0 : size)];
            this.start = start;
            this.end = end;
            this.continuesLastPattern = false;
        }
        pickMainInterval() {
            let longestFlatIntervalDuration = 0;
            let mainInterval = 0;
            for (let pinIndex = 1; pinIndex < this.pins.length; pinIndex++) {
                const pinA = this.pins[pinIndex - 1];
                const pinB = this.pins[pinIndex];
                if (pinA.interval == pinB.interval) {
                    const duration = pinB.time - pinA.time;
                    if (longestFlatIntervalDuration < duration) {
                        longestFlatIntervalDuration = duration;
                        mainInterval = pinA.interval;
                    }
                }
            }
            if (longestFlatIntervalDuration == 0) {
                let loudestSize = 0;
                for (let pinIndex = 0; pinIndex < this.pins.length; pinIndex++) {
                    const pin = this.pins[pinIndex];
                    if (loudestSize < pin.size) {
                        loudestSize = pin.size;
                        mainInterval = pin.interval;
                    }
                }
            }
            return mainInterval;
        }
        clone() {
            const newNote = new Note(-1, this.start, this.end, 3);
            newNote.pitches = this.pitches.concat();
            newNote.pins = [];
            for (const pin of this.pins) {
                newNote.pins.push(makeNotePin(pin.interval, pin.time, pin.size));
            }
            newNote.continuesLastPattern = this.continuesLastPattern;
            return newNote;
        }
        getEndPinIndex(part) {
            let endPinIndex;
            for (endPinIndex = 1; endPinIndex < this.pins.length - 1; endPinIndex++) {
                if (this.pins[endPinIndex].time + this.start > part)
                    break;
            }
            return endPinIndex;
        }
    }
    class Pattern {
        constructor() {
            this.notes = [];
            this.instruments = [0];
        }
        cloneNotes() {
            const result = [];
            for (const note of this.notes) {
                result.push(note.clone());
            }
            return result;
        }
        reset() {
            this.notes.length = 0;
            this.instruments[0] = 0;
            this.instruments.length = 1;
        }
    }
    class Operator {
        constructor(index) {
            this.frequency = 0;
            this.amplitude = 0;
            this.waveform = 0;
            this.pulseWidth = 0.5;
            this.reset(index);
        }
        reset(index) {
            this.frequency = 0;
            this.amplitude = (index <= 1) ? Config.operatorAmplitudeMax : 0;
            this.waveform = 0;
            this.pulseWidth = 5;
        }
        copy(other) {
            this.frequency = other.frequency;
            this.amplitude = other.amplitude;
            this.waveform = other.waveform;
            this.pulseWidth = other.pulseWidth;
        }
    }
    class SpectrumWave {
        constructor(isNoiseChannel) {
            this.spectrum = [];
            this._wave = null;
            this._waveIsReady = false;
            this.reset(isNoiseChannel);
        }
        reset(isNoiseChannel) {
            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                if (isNoiseChannel) {
                    this.spectrum[i] = Math.round(Config.spectrumMax * (1 / Math.sqrt(1 + i / 3)));
                }
                else {
                    const isHarmonic = i == 0 || i == 7 || i == 11 || i == 14 || i == 16 || i == 18 || i == 21 || i == 23 || i >= 25;
                    this.spectrum[i] = isHarmonic ? Math.max(0, Math.round(Config.spectrumMax * (1 - i / 30))) : 0;
                }
            }
            this._waveIsReady = false;
        }
        markCustomWaveDirty() {
            this._waveIsReady = false;
        }
        getCustomWave(lowestOctave) {
            if (this._waveIsReady)
                return this._wave;
            const waveLength = Config.spectrumNoiseLength;
            if (this._wave == null || this._wave.length != waveLength + 1) {
                this._wave = new Float32Array(waveLength + 1);
            }
            const wave = this._wave;
            for (let i = 0; i < waveLength; i++) {
                wave[i] = 0;
            }
            const highestOctave = 14;
            const falloffRatio = 0.25;
            const pitchTweak = [0, 1 / 7, Math.log2(5 / 4), 3 / 7, Math.log2(3 / 2), 5 / 7, 6 / 7];
            function controlPointToOctave(point) {
                return lowestOctave + Math.floor(point / Config.spectrumControlPointsPerOctave) + pitchTweak[(point + Config.spectrumControlPointsPerOctave) % Config.spectrumControlPointsPerOctave];
            }
            let combinedAmplitude = 1;
            for (let i = 0; i < Config.spectrumControlPoints + 1; i++) {
                const value1 = (i <= 0) ? 0 : this.spectrum[i - 1];
                const value2 = (i >= Config.spectrumControlPoints) ? this.spectrum[Config.spectrumControlPoints - 1] : this.spectrum[i];
                const octave1 = controlPointToOctave(i - 1);
                let octave2 = controlPointToOctave(i);
                if (i >= Config.spectrumControlPoints)
                    octave2 = highestOctave + (octave2 - highestOctave) * falloffRatio;
                if (value1 == 0 && value2 == 0)
                    continue;
                combinedAmplitude += 0.02 * drawNoiseSpectrum(wave, waveLength, octave1, octave2, value1 / Config.spectrumMax, value2 / Config.spectrumMax, -0.5);
            }
            if (this.spectrum[Config.spectrumControlPoints - 1] > 0) {
                combinedAmplitude += 0.02 * drawNoiseSpectrum(wave, waveLength, highestOctave + (controlPointToOctave(Config.spectrumControlPoints) - highestOctave) * falloffRatio, highestOctave, this.spectrum[Config.spectrumControlPoints - 1] / Config.spectrumMax, 0, -0.5);
            }
            inverseRealFourierTransform(wave, waveLength);
            scaleElementsByFactor(wave, 5.0 / (Math.sqrt(waveLength) * Math.pow(combinedAmplitude, 0.75)));
            wave[waveLength] = wave[0];
            this._waveIsReady = true;
            return wave;
        }
    }
    class HarmonicsWave {
        constructor() {
            this.harmonics = [];
            this._wave = null;
            this._waveIsReady = false;
            this.reset();
        }
        reset() {
            for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                this.harmonics[i] = 0;
            }
            this.harmonics[0] = Config.harmonicsMax;
            this.harmonics[3] = Config.harmonicsMax;
            this.harmonics[6] = Config.harmonicsMax;
            this._waveIsReady = false;
        }
        markCustomWaveDirty() {
            this._waveIsReady = false;
        }
        getCustomWave(instrumentType) {
            if (this._generatedForType != instrumentType) {
                this._generatedForType = instrumentType;
                this._waveIsReady = false;
            }
            const harmonicsRendered = (instrumentType == 7) ? Config.harmonicsRenderedForPickedString : Config.harmonicsRendered;
            if (this._waveIsReady)
                return this._wave;
            const waveLength = Config.harmonicsWavelength;
            const retroWave = getDrumWave(0, null, null);
            if (this._wave == null || this._wave.length != waveLength + 1) {
                this._wave = new Float32Array(waveLength + 1);
            }
            const wave = this._wave;
            for (let i = 0; i < waveLength; i++) {
                wave[i] = 0;
            }
            const overallSlope = -0.25;
            let combinedControlPointAmplitude = 1;
            for (let harmonicIndex = 0; harmonicIndex < harmonicsRendered; harmonicIndex++) {
                const harmonicFreq = harmonicIndex + 1;
                let controlValue = harmonicIndex < Config.harmonicsControlPoints ? this.harmonics[harmonicIndex] : this.harmonics[Config.harmonicsControlPoints - 1];
                if (harmonicIndex >= Config.harmonicsControlPoints) {
                    controlValue *= 1 - (harmonicIndex - Config.harmonicsControlPoints) / (harmonicsRendered - Config.harmonicsControlPoints);
                }
                const normalizedValue = controlValue / Config.harmonicsMax;
                let amplitude = Math.pow(2, controlValue - Config.harmonicsMax + 1) * Math.sqrt(normalizedValue);
                if (harmonicIndex < Config.harmonicsControlPoints) {
                    combinedControlPointAmplitude += amplitude;
                }
                amplitude *= Math.pow(harmonicFreq, overallSlope);
                amplitude *= retroWave[harmonicIndex + 589];
                wave[waveLength - harmonicFreq] = amplitude;
            }
            inverseRealFourierTransform(wave, waveLength);
            const mult = 1 / Math.pow(combinedControlPointAmplitude, 0.7);
            for (let i = 0; i < wave.length; i++)
                wave[i] *= mult;
            performIntegralOld(wave);
            wave[waveLength] = wave[0];
            this._waveIsReady = true;
            return wave;
        }
    }
    class FilterControlPoint {
        constructor() {
            this.freq = 0;
            this.gain = Config.filterGainCenter;
            this.type = 2;
        }
        set(freqSetting, gainSetting) {
            this.freq = freqSetting;
            this.gain = gainSetting;
        }
        getHz() {
            return FilterControlPoint.getHzFromSettingValue(this.freq);
        }
        static getHzFromSettingValue(value) {
            return Config.filterFreqReferenceHz * Math.pow(2.0, (value - Config.filterFreqReferenceSetting) * Config.filterFreqStep);
        }
        static getSettingValueFromHz(hz) {
            return Math.log2(hz / Config.filterFreqReferenceHz) / Config.filterFreqStep + Config.filterFreqReferenceSetting;
        }
        static getRoundedSettingValueFromHz(hz) {
            return Math.max(0, Math.min(Config.filterFreqRange - 1, Math.round(FilterControlPoint.getSettingValueFromHz(hz))));
        }
        getLinearGain(peakMult = 1.0) {
            const power = (this.gain - Config.filterGainCenter) * Config.filterGainStep;
            const neutral = (this.type == 2) ? 0.0 : -0.5;
            const interpolatedPower = neutral + (power - neutral) * peakMult;
            return Math.pow(2.0, interpolatedPower);
        }
        static getRoundedSettingValueFromLinearGain(linearGain) {
            return Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(Math.log2(linearGain) / Config.filterGainStep + Config.filterGainCenter)));
        }
        toCoefficients(filter, sampleRate, freqMult = 1.0, peakMult = 1.0) {
            const cornerRadiansPerSample = 2.0 * Math.PI * Math.max(Config.filterFreqMinHz, Math.min(Config.filterFreqMaxHz, freqMult * this.getHz())) / sampleRate;
            const linearGain = this.getLinearGain(peakMult);
            switch (this.type) {
                case 0:
                    filter.lowPass2ndOrderButterworth(cornerRadiansPerSample, linearGain);
                    break;
                case 1:
                    filter.highPass2ndOrderButterworth(cornerRadiansPerSample, linearGain);
                    break;
                case 2:
                    filter.peak2ndOrder(cornerRadiansPerSample, linearGain, 1.0);
                    break;
                default:
                    throw new Error();
            }
        }
        getVolumeCompensationMult() {
            const octave = (this.freq - Config.filterFreqReferenceSetting) * Config.filterFreqStep;
            const gainPow = (this.gain - Config.filterGainCenter) * Config.filterGainStep;
            switch (this.type) {
                case 0:
                    const freqRelativeTo8khz = Math.pow(2.0, octave) * Config.filterFreqReferenceHz / 8000.0;
                    const warpedFreq = (Math.sqrt(1.0 + 4.0 * freqRelativeTo8khz) - 1.0) / 2.0;
                    const warpedOctave = Math.log2(warpedFreq);
                    return Math.pow(0.5, 0.2 * Math.max(0.0, gainPow + 1.0) + Math.min(0.0, Math.max(-3.0, 0.595 * warpedOctave + 0.35 * Math.min(0.0, gainPow + 1.0))));
                case 1:
                    return Math.pow(0.5, 0.125 * Math.max(0.0, gainPow + 1.0) + Math.min(0.0, 0.3 * (-octave - Math.log2(Config.filterFreqReferenceHz / 125.0)) + 0.2 * Math.min(0.0, gainPow + 1.0)));
                case 2:
                    const distanceFromCenter = octave + Math.log2(Config.filterFreqReferenceHz / 2000.0);
                    const freqLoudness = Math.pow(1.0 / (1.0 + Math.pow(distanceFromCenter / 3.0, 2.0)), 2.0);
                    return Math.pow(0.5, 0.125 * Math.max(0.0, gainPow) + 0.1 * freqLoudness * Math.min(0.0, gainPow));
                default:
                    throw new Error();
            }
        }
    }
    class FilterSettings {
        constructor() {
            this.controlPoints = [];
            this.controlPointCount = 0;
            this.reset();
        }
        reset() {
            this.controlPointCount = 0;
        }
        addPoint(type, freqSetting, gainSetting) {
            let controlPoint;
            if (this.controlPoints.length <= this.controlPointCount) {
                controlPoint = new FilterControlPoint();
                this.controlPoints[this.controlPointCount] = controlPoint;
            }
            else {
                controlPoint = this.controlPoints[this.controlPointCount];
            }
            this.controlPointCount++;
            controlPoint.type = type;
            controlPoint.set(freqSetting, gainSetting);
        }
        toJsonObject() {
            const filterArray = [];
            for (let i = 0; i < this.controlPointCount; i++) {
                const point = this.controlPoints[i];
                filterArray.push({
                    "type": Config.filterTypeNames[point.type],
                    "cutoffHz": Math.round(point.getHz() * 100) / 100,
                    "linearGain": Math.round(point.getLinearGain() * 10000) / 10000,
                });
            }
            return filterArray;
        }
        fromJsonObject(filterObject) {
            this.controlPoints.length = 0;
            if (filterObject) {
                for (const pointObject of filterObject) {
                    const point = new FilterControlPoint();
                    point.type = Config.filterTypeNames.indexOf(pointObject["type"]);
                    if (point.type == -1)
                        point.type = 2;
                    if (pointObject["cutoffHz"] != undefined) {
                        point.freq = FilterControlPoint.getRoundedSettingValueFromHz(pointObject["cutoffHz"]);
                    }
                    else {
                        point.freq = 0;
                    }
                    if (pointObject["linearGain"] != undefined) {
                        point.gain = FilterControlPoint.getRoundedSettingValueFromLinearGain(pointObject["linearGain"]);
                    }
                    else {
                        point.gain = Config.filterGainCenter;
                    }
                    this.controlPoints.push(point);
                }
            }
            this.controlPointCount = this.controlPoints.length;
        }
        static filtersCanMorph(filterA, filterB) {
            if (filterA.controlPointCount != filterB.controlPointCount)
                return false;
            for (let i = 0; i < filterA.controlPointCount; i++) {
                if (filterA.controlPoints[i].type != filterB.controlPoints[i].type)
                    return false;
            }
            return true;
        }
        static lerpFilters(filterA, filterB, pos) {
            let lerpedFilter = new FilterSettings();
            if (filterA == null) {
                return filterA;
            }
            if (filterB == null) {
                return filterB;
            }
            pos = Math.max(0, Math.min(1, pos));
            if (this.filtersCanMorph(filterA, filterB)) {
                for (let i = 0; i < filterA.controlPointCount; i++) {
                    lerpedFilter.controlPoints[i] = new FilterControlPoint();
                    lerpedFilter.controlPoints[i].type = filterA.controlPoints[i].type;
                    lerpedFilter.controlPoints[i].freq = filterA.controlPoints[i].freq + (filterB.controlPoints[i].freq - filterA.controlPoints[i].freq) * pos;
                    lerpedFilter.controlPoints[i].gain = filterA.controlPoints[i].gain + (filterB.controlPoints[i].gain - filterA.controlPoints[i].gain) * pos;
                }
                lerpedFilter.controlPointCount = filterA.controlPointCount;
                return lerpedFilter;
            }
            else {
                return (pos >= 1) ? filterB : filterA;
            }
        }
        convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyEnv) {
            this.reset();
            const legacyFilterCutoffMaxHz = 8000;
            const legacyFilterMax = 0.95;
            const legacyFilterMaxRadians = Math.asin(legacyFilterMax / 2.0) * 2.0;
            const legacyFilterMaxResonance = 0.95;
            const legacyFilterCutoffRange = 11;
            const legacyFilterResonanceRange = 8;
            const resonant = (legacyResonanceSetting > 1);
            const firstOrder = (legacyResonanceSetting == 0);
            const cutoffAtMax = (legacyCutoffSetting == legacyFilterCutoffRange - 1);
            const envDecays = (legacyEnv.type == 3 || legacyEnv.type == 4 || legacyEnv.type == 8 || legacyEnv.type == 0);
            const standardSampleRate = 48000;
            const legacyHz = legacyFilterCutoffMaxHz * Math.pow(2.0, (legacyCutoffSetting - (legacyFilterCutoffRange - 1)) * 0.5);
            const legacyRadians = Math.min(legacyFilterMaxRadians, 2 * Math.PI * legacyHz / standardSampleRate);
            if (legacyEnv.type == 1 && !resonant && cutoffAtMax) ;
            else if (firstOrder) {
                const extraOctaves = 3.5;
                const targetRadians = legacyRadians * Math.pow(2.0, extraOctaves);
                const curvedRadians = targetRadians / (1.0 + targetRadians / Math.PI);
                const curvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI);
                const freqSetting = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);
                const finalHz = FilterControlPoint.getHzFromSettingValue(freqSetting);
                const finalRadians = 2.0 * Math.PI * finalHz / standardSampleRate;
                const legacyFilter = new FilterCoefficients();
                legacyFilter.lowPass1stOrderSimplified(legacyRadians);
                const response = new FrequencyResponse();
                response.analyze(legacyFilter, finalRadians);
                const legacyFilterGainAtNewRadians = response.magnitude();
                let logGain = Math.log2(legacyFilterGainAtNewRadians);
                logGain = -extraOctaves + (logGain + extraOctaves) * 0.82;
                if (envDecays)
                    logGain = Math.min(logGain, -1.0);
                const convertedGain = Math.pow(2.0, logGain);
                const gainSetting = FilterControlPoint.getRoundedSettingValueFromLinearGain(convertedGain);
                this.addPoint(0, freqSetting, gainSetting);
            }
            else {
                const intendedGain = 0.5 / (1.0 - legacyFilterMaxResonance * Math.sqrt(Math.max(0.0, legacyResonanceSetting - 1.0) / (legacyFilterResonanceRange - 2.0)));
                const invertedGain = 0.5 / intendedGain;
                const maxRadians = 2.0 * Math.PI * legacyFilterCutoffMaxHz / standardSampleRate;
                const freqRatio = legacyRadians / maxRadians;
                const targetRadians = legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1.0);
                const curvedRadians = legacyRadians + (targetRadians - legacyRadians) * invertedGain;
                let curvedHz;
                if (envDecays) {
                    curvedHz = standardSampleRate * Math.min(curvedRadians, legacyRadians * Math.pow(2, 0.25)) / (2.0 * Math.PI);
                }
                else {
                    curvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI);
                }
                const freqSetting = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);
                let legacyFilterGain;
                if (envDecays) {
                    legacyFilterGain = intendedGain;
                }
                else {
                    const legacyFilter = new FilterCoefficients();
                    legacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);
                    const response = new FrequencyResponse();
                    response.analyze(legacyFilter, curvedRadians);
                    legacyFilterGain = response.magnitude();
                }
                if (!resonant)
                    legacyFilterGain = Math.min(legacyFilterGain, Math.sqrt(0.5));
                const gainSetting = FilterControlPoint.getRoundedSettingValueFromLinearGain(legacyFilterGain);
                this.addPoint(0, freqSetting, gainSetting);
            }
            this.controlPoints.length = this.controlPointCount;
        }
        convertLegacySettingsForSynth(legacyCutoffSetting, legacyResonanceSetting, allowFirstOrder = false) {
            this.reset();
            const legacyFilterCutoffMaxHz = 8000;
            const legacyFilterMax = 0.95;
            const legacyFilterMaxRadians = Math.asin(legacyFilterMax / 2.0) * 2.0;
            const legacyFilterMaxResonance = 0.95;
            const legacyFilterCutoffRange = 11;
            const legacyFilterResonanceRange = 8;
            const firstOrder = (legacyResonanceSetting == 0 && allowFirstOrder);
            const standardSampleRate = 48000;
            const legacyHz = legacyFilterCutoffMaxHz * Math.pow(2.0, (legacyCutoffSetting - (legacyFilterCutoffRange - 1)) * 0.5);
            const legacyRadians = Math.min(legacyFilterMaxRadians, 2 * Math.PI * legacyHz / standardSampleRate);
            if (firstOrder) {
                const extraOctaves = 3.5;
                const targetRadians = legacyRadians * Math.pow(2.0, extraOctaves);
                const curvedRadians = targetRadians / (1.0 + targetRadians / Math.PI);
                const curvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI);
                const freqSetting = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);
                const finalHz = FilterControlPoint.getHzFromSettingValue(freqSetting);
                const finalRadians = 2.0 * Math.PI * finalHz / standardSampleRate;
                const legacyFilter = new FilterCoefficients();
                legacyFilter.lowPass1stOrderSimplified(legacyRadians);
                const response = new FrequencyResponse();
                response.analyze(legacyFilter, finalRadians);
                const legacyFilterGainAtNewRadians = response.magnitude();
                let logGain = Math.log2(legacyFilterGainAtNewRadians);
                logGain = -extraOctaves + (logGain + extraOctaves) * 0.82;
                const convertedGain = Math.pow(2.0, logGain);
                const gainSetting = FilterControlPoint.getRoundedSettingValueFromLinearGain(convertedGain);
                this.addPoint(0, freqSetting, gainSetting);
            }
            else {
                const intendedGain = 0.5 / (1.0 - legacyFilterMaxResonance * Math.sqrt(Math.max(0.0, legacyResonanceSetting - 1.0) / (legacyFilterResonanceRange - 2.0)));
                const invertedGain = 0.5 / intendedGain;
                const maxRadians = 2.0 * Math.PI * legacyFilterCutoffMaxHz / standardSampleRate;
                const freqRatio = legacyRadians / maxRadians;
                const targetRadians = legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1.0);
                const curvedRadians = legacyRadians + (targetRadians - legacyRadians) * invertedGain;
                let curvedHz;
                curvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI);
                const freqSetting = FilterControlPoint.getSettingValueFromHz(curvedHz);
                let legacyFilterGain;
                const legacyFilter = new FilterCoefficients();
                legacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);
                const response = new FrequencyResponse();
                response.analyze(legacyFilter, curvedRadians);
                legacyFilterGain = response.magnitude();
                const gainSetting = FilterControlPoint.getRoundedSettingValueFromLinearGain(legacyFilterGain);
                this.addPoint(0, freqSetting, gainSetting);
            }
        }
    }
    class EnvelopeSettings {
        constructor() {
            this.target = 0;
            this.index = 0;
            this.envelope = 0;
            this.reset();
        }
        reset() {
            this.target = 0;
            this.index = 0;
            this.envelope = 0;
        }
        toJsonObject() {
            const envelopeObject = {
                "target": Config.instrumentAutomationTargets[this.target].name,
                "envelope": Config.envelopes[this.envelope].name,
            };
            if (Config.instrumentAutomationTargets[this.target].maxCount > 1) {
                envelopeObject["index"] = this.index;
            }
            return envelopeObject;
        }
        fromJsonObject(envelopeObject) {
            this.reset();
            
            let target = Config.instrumentAutomationTargets.dictionary[envelopeObject["target"]];
            if (target == null)
                target = Config.instrumentAutomationTargets.dictionary["noteVolume"];
            this.target = target.index;
            let envelope = Config.envelopes.dictionary[envelopeObject["envelope"]];
             
            if (envelope == null)
                envelope = Config.envelopes.dictionary["none"];
            this.envelope = envelope.index;
            if (envelopeObject["index"] != undefined) {
                this.index = clamp(0, Config.instrumentAutomationTargets[this.target].maxCount, envelopeObject["index"] | 0);
            }
            else {
                this.index = 0;
            }
        }
    }
    class Instrument {
        constructor(isNoiseChannel, isModChannel) {
            this.type = 0;
            this.preset = 0;
            this.chipWave = 2;
            this.chipwaveselected=2;
            this.computed=true;
            this.isUsingAdvancedLoopControls = false;
            this.volumeScale = 1;
this.chipWaveLoopStart = 0;
this.chipWaveLoopEnd = Config.rawRawChipWaves[this.chipWave].samples.length - 1;
this.chipWaveLoopMode = 0;
this.chipWavePlayBackwards = false;
this.chipWaveStartOffset = 0;
            this.chipNoise = 1;
            this.eqFilter = new FilterSettings();
            this.eqFilterType = false;
            this.eqFilterSimpleCut = Config.filterSimpleCutRange - 1;
            this.eqFilterSimplePeak = 0;
            this.noteFilter = new FilterSettings();
            this.envelopeComputer = new EnvelopeComputer();
            this.noteFilterType = false;
            this.noteFilterSimpleCut = Config.filterSimpleCutRange - 1;
            this.noteFilterSimplePeak = 0;
            this.eqSubFilters = [];
            this.noteSubFilters = [];
            this.envelopessave=[];
            this.envelopes = [];
            this.fadeIn = 0;
            this.fadeOut = Config.fadeOutNeutral;
            this.envelopeCount = 0;
            this.transition = Config.transitions.dictionary["normal"].index;
            this.pitchShift = 16;
        
    this.pitchShiftSemitones= 16;
    
            this.detune = 0;
            this.vibrato = 0;
            this.interval = 0;
            this.vibratoDepth = 0;
            this.vibratoSpeed = 10;
            this.vibratoDelay = 0;
            this.vibratoType = 0;
            this.unison = 0;
            
            
this.detectForUnison = 0;

this.unisonVoices =1
this.unisonSign =1
this.unisonExpression =2.0
this.unisonOffset =1
this.unisonSpread =1

this.last_unisonVoices = 1
this.last_unisonSign = 1
this.last_unisonExpression = 2.0
this.last_unisonOffset = 1
this.last_unisonSpread = 1

this.ringModMix = 0;
this.ringModMixDelta = 0;
this.ringModPhase = 0;
this.ringModPhaseDelta = 0;
this.ringModPhaseDeltaScale = 1.0;
this.ringModWaveformIndex = 0.0;
this.ringModPulseWidth = Config.pwmOperatorWaves.length >> 1;
this.ringModHzOffset = 0.0;
this.ringModMixFade = 1.0;
this.ringModMixFadeDelta = 0;
            
 
this.ringModulation = Config.ringModRange >> 1;
this.ringModulationHz = Config.ringModHzRange >> 1;
 

this.ringModWaveformIndex = 0;
this.ringModHzOffset = 200;

            this.effects = 0;
            this.chord = 1;
            this.volume = 0;
            this.pan = Config.panCenter;
            this.panDelay = 10;
            this.arpeggioSpeed = 12;
            this.fastTwoNoteArp = false;
            this.legacyTieOver = false;
            this.clicklessTransition = false;
            this.aliases = false;
            this.pulseWidth = Config.pulseWidthRange;
            this.stringSustain = 10;
            this.distortion = 0;
            this.bitcrusherFreq = 0;
            this.bitcrusherQuantization = 0;
            this.chorus = 0;
            this.reverb = 0;
            this.echoSustain = 0;
            this.echoDelay = 0;
            this.algorithm = 0;
            this.feedbackType = 0;
            this.feedbackAmplitude = 0;
            this.LFOtime = 0;
            this.nextLFOtime = 0;
            this.arpTime = 0;
            this.customChipWave = new Float64Array(64);
            this.customChipWaveIntegral = new Float64Array(65);
            this.operators = [];
            this.harmonicsWave = new HarmonicsWave();
            this.drumsetEnvelopes = [];
            this.drumsetSpectrumWaves = [];
            this.modChannels = [];
            this.modInstruments = [];
            this.modulators = [];
            this.modFilterTypes = [];
            this.invalidModulators = [];
            if (isModChannel) {
                for (let mod = 0; mod < Config.modCount; mod++) {
                    this.modChannels.push(0);
                    this.modInstruments.push(0);
                    this.modulators.push(Config.modulators.dictionary["none"].index);
                }
            }
            this.spectrumWave = new SpectrumWave(isNoiseChannel);
            for (let i = 0; i < Config.operatorCount; i++) {
                this.operators[i] = new Operator(i);
            }
            for (let i = 0; i < Config.drumCount; i++) {
                this.drumsetEnvelopes[i] = Config.envelopes.dictionary["twang 2"].index;
                this.drumsetSpectrumWaves[i] = new SpectrumWave(true);
            }
            for (let i = 0; i < 64; i++) {
                this.customChipWave[i] = 24 - Math.floor(i * (48 / 64));
            }
            let sum = 0.0;
            for (let i = 0; i < this.customChipWave.length; i++) {
                sum += this.customChipWave[i];
            }
            const average = sum / this.customChipWave.length;
            let cumulative = 0;
            let wavePrev = 0;
            for (let i = 0; i < this.customChipWave.length; i++) {
                cumulative += wavePrev;
                wavePrev = this.customChipWave[i] - average;
                this.customChipWaveIntegral[i] = cumulative;
            }
            this.customChipWaveIntegral[64] = 0.0;
        }
        setTypeAndReset(type, isNoiseChannel, isModChannel) {
            if (isModChannel) 
                type = 9;
            this.type = type;
            this.preset = type;
            this.volume = 0;
            this.effects = (1 << 2);
            this.chorus = Config.chorusRange - 1;
            this.reverb = 0;
            this.echoSustain = Math.floor((Config.echoSustainRange - 1) * 0.5);
            this.echoDelay = Math.floor((Config.echoDelayRange - 1) * 0.5);
            this.eqFilter.reset();
            this.eqFilterType = false;
            this.eqFilterSimpleCut = Config.filterSimpleCutRange - 1;
            this.eqFilterSimplePeak = 0;
            for (let i = 0; i < Config.filterMorphCount; i++) {
                this.eqSubFilters[i] = null;
                this.noteSubFilters[i] = null;
            }
            this.noteFilter.reset();
            this.noteFilterType = false;
            this.noteFilterSimpleCut = Config.filterSimpleCutRange - 1;
            this.noteFilterSimplePeak = 0;
            this.distortion = Math.floor((Config.distortionRange - 1) * 0.75);
            this.bitcrusherFreq = Math.floor((Config.bitcrusherFreqRange - 1) * 0.5);
            this.bitcrusherQuantization = Math.floor((Config.bitcrusherQuantizationRange - 1) * 0.5);
            this.pan = Config.panCenter;
            this.panDelay = 10;
            this.pitchShift = Config.pitchShiftCenter||16;
            this.pitchShiftSemitones = Config.pitchShiftCenter||16;
            this.detune = Config.detuneCenter;
            this.vibrato = 0;
            this.unison = 0;
            this.stringSustain = 10;
            this.clicklessTransition = false;
            this.arpeggioSpeed = 12;
             
this.ringModulation = Config.ringModRange >> 1;
this.ringModulationHz = Config.ringModHzRange >> 1;
this.ringModPulseWidth = Config.pwmOperatorWaves.length >> 1;
            this.legacyTieOver = false;
            this.aliases = false;
            this.fadeIn = 0;
            this.fadeOut = Config.fadeOutNeutral;
            this.transition = Config.transitions.dictionary["normal"].index;
            this.envelopeCount = 0;
            switch (type) {
                case 0:
                    this.chipWave = 2;
                    //this.chipwaveselected=this.chipWave
                    this.chord = Config.chords.dictionary["arpeggio"].index;
                    break;
                case 8:
                    this.chipWave = 2;
                     
                    this.chord = Config.chords.dictionary["arpeggio"].index;
                    for (let i = 0; i < 64; i++) {
                        this.customChipWave[i] = 24 - (Math.floor(i * (48 / 64)));
                    }
                    let sum = 0.0;
                    for (let i = 0; i < this.customChipWave.length; i++) {
                        sum += this.customChipWave[i];
                    }
                    const average = sum / this.customChipWave.length;
                    let cumulative = 0;
                    let wavePrev = 0;
                    for (let i = 0; i < this.customChipWave.length; i++) {
                        cumulative += wavePrev;
                        wavePrev = this.customChipWave[i] - average;
                        this.customChipWaveIntegral[i] = cumulative;
                    }
                    this.customChipWaveIntegral[64] = 0.0;
                    break;
                case 1:
                    this.chord = Config.chords.dictionary["custom interval"].index;
                    this.algorithm = 0;
                    this.feedbackType = 0;
                    this.feedbackAmplitude = 0;
                    for (let i = 0; i < this.operators.length; i++) {
                        this.operators[i].reset(i);
                    }
                    break;
                case 2:
                    this.chipNoise = 1;
                    this.chord = Config.chords.dictionary["arpeggio"].index;
                    break;
                case 3:
                    this.chord = Config.chords.dictionary["simultaneous"].index;
                    this.spectrumWave.reset(isNoiseChannel);
                    break;
                case 4:
                    this.chord = Config.chords.dictionary["simultaneous"].index;
                    for (let i = 0; i < Config.drumCount; i++) {
                        this.drumsetEnvelopes[i] = Config.envelopes.dictionary["twang 2"].index;
                        if (this.drumsetSpectrumWaves[i] == undefined) {
                            this.drumsetSpectrumWaves[i] = new SpectrumWave(true);
                        }
                        this.drumsetSpectrumWaves[i].reset(isNoiseChannel);
                    }
                    break;
                case 5:
                    this.chord = Config.chords.dictionary["simultaneous"].index;
                    this.harmonicsWave.reset();
                    break;
                case 6:
                    this.chord = Config.chords.dictionary["arpeggio"].index;
                    this.pulseWidth = Config.pulseWidthRange;
                    break;
                case 7:
                    this.chord = Config.chords.dictionary["strum"].index;
                    this.harmonicsWave.reset();
                    break;
                case 9:
                    this.transition = 0;
                    this.vibrato = 0;
                    this.interval = 0;
                    this.effects = 0;
                    this.chord = 0;
                    this.modChannels = [];
                    this.modInstruments = [];
                    this.modulators = [];
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        this.modChannels.push(-2);
                        this.modInstruments.push(0);
                        this.modulators.push(Config.modulators.dictionary["none"].index);
                        this.invalidModulators[mod] = false;
                        this.modFilterTypes[mod] = 0;
                    }
                    break;
                default:
                    throw new Error("Unrecognized instrument type: " + type);
            }
            if (this.chord != Config.chords.dictionary["simultaneous"].index) {
                this.effects = (this.effects & ((1 << 15) - 1));
            }
        }
        convertLegacySettings(legacySettings, forceSimpleFilter) {
            let legacyCutoffSetting = legacySettings.filterCutoff;
            let legacyResonanceSetting = legacySettings.filterResonance;
            let legacyFilterEnv = legacySettings.filterEnvelope;
            let legacyPulseEnv = legacySettings.pulseEnvelope;
            let legacyOperatorEnvelopes = legacySettings.operatorEnvelopes;
            let legacyFeedbackEnv = legacySettings.feedbackEnvelope;
            
            
            if (legacyCutoffSetting == undefined)
                legacyCutoffSetting = (this.type == 0) ? 6 : 10;
            if (legacyResonanceSetting == undefined)
                legacyResonanceSetting = 0;
            if (legacyFilterEnv == undefined)
                legacyFilterEnv = Config.envelopes.dictionary["none"];
            if (legacyPulseEnv == undefined)
                legacyPulseEnv = Config.envelopes.dictionary[(this.type == 6) ? "twang 2" : "none"];
            if (legacyOperatorEnvelopes == undefined)
                legacyOperatorEnvelopes = [Config.envelopes.dictionary[(this.type == 1) ? "note size" : "none"], Config.envelopes.dictionary["none"], Config.envelopes.dictionary["none"], Config.envelopes.dictionary["none"]];
            if (legacyFeedbackEnv == undefined)
                legacyFeedbackEnv = Config.envelopes.dictionary["none"];
                
            const carrierCount = Config.algorithms[this.algorithm].carrierCount;
            let noCarriersControlledByNoteSize = true;
            let allCarriersControlledByNoteSize = true;
            let noteSizeControlsSomethingElse = (legacyFilterEnv.type == 0) || (legacyPulseEnv.type == 0);
            if (this.type == 1) {
                noteSizeControlsSomethingElse = noteSizeControlsSomethingElse || (legacyFeedbackEnv.type == 0);
                for (let i = 0; i < legacyOperatorEnvelopes.length; i++) {
                    if (i < carrierCount) {
                        if (legacyOperatorEnvelopes[i].type != 0) {
                            allCarriersControlledByNoteSize = false;
                        }
                        else {
                            noCarriersControlledByNoteSize = false;
                        }
                    }
                    else {
                        noteSizeControlsSomethingElse = noteSizeControlsSomethingElse || (legacyOperatorEnvelopes[i].type == 0);
                    }
                }
            }
            this.envelopeCount = 0;
            if (this.type == 1) {
                if (allCarriersControlledByNoteSize && noteSizeControlsSomethingElse) {
                    this.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteVolume"].index, 0, Config.envelopes.dictionary["note size"].index);
                }
                else if (noCarriersControlledByNoteSize && !noteSizeControlsSomethingElse) {
                    this.addEnvelope(Config.instrumentAutomationTargets.dictionary["none"].index, 0, Config.envelopes.dictionary["note size"].index);
                }
            }
            if (legacyFilterEnv.type == 1) {
                this.noteFilter.reset();
                this.noteFilterType = false;
                this.eqFilter.convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyFilterEnv);
                this.effects &= ~(1 << 5);
                if (forceSimpleFilter || this.eqFilterType) {
                    this.eqFilterType = true;
                    this.eqFilterSimpleCut = legacyCutoffSetting;
                    this.eqFilterSimplePeak = legacyResonanceSetting;
                }
            }
            else {
                this.eqFilter.reset();
                this.eqFilterType = false;
                this.noteFilterType = false;
                this.noteFilter.convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyFilterEnv);
                this.effects |= 1 << 5;
                this.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteFilterAllFreqs"].index, 0, legacyFilterEnv.index);
                if (forceSimpleFilter || this.noteFilterType) {
                    this.noteFilterType = true;
                    this.noteFilterSimpleCut = legacyCutoffSetting;
                    this.noteFilterSimplePeak = legacyResonanceSetting;
                }
            }
            if (legacyPulseEnv.type != 1) {
                this.addEnvelope(Config.instrumentAutomationTargets.dictionary["pulseWidth"].index, 0, legacyPulseEnv.index);
            }
            for (let i = 0; i < legacyOperatorEnvelopes.length; i++) {
                if (i < carrierCount && allCarriersControlledByNoteSize)
                    continue;
                if (legacyOperatorEnvelopes[i].type != 1) {
                    this.addEnvelope(Config.instrumentAutomationTargets.dictionary["operatorAmplitude"].index, i, legacyOperatorEnvelopes[i].index);
                }
            }
            if (legacyFeedbackEnv.type != 1) {
                this.addEnvelope(Config.instrumentAutomationTargets.dictionary["feedbackAmplitude"].index, 0, legacyFeedbackEnv.index);
            }
        }
        toJsonObject() { 
            const instrumentObject = {
                "type": Config.instrumentTypeNames[this.type],
                "volume": this.volume,
                "eqFilter": this.eqFilter.toJsonObject(),
                "eqFilterType": this.eqFilterType,
                "eqSimpleCut": this.eqFilterSimpleCut,
                "eqSimplePeak": this.eqFilterSimplePeak
            };
            if (this.preset != this.type) {
                instrumentObject["preset"] = this.preset;
            }
            for (let i = 0; i < Config.filterMorphCount; i++) {
                if (this.eqSubFilters[i] != null)
                    instrumentObject["eqSubFilters" + i] = this.eqSubFilters[i].toJsonObject();
            }
            const effects = [];
            for (const effect of Config.effectOrder) {
                if (this.effects & (1 << effect)) {
                    effects.push(Config.effectNames[effect]);
                }
            }
            instrumentObject["effects"] = effects;
            if (effectsIncludeTransition(this.effects)) {
                instrumentObject["transition"] = Config.transitions[this.transition].name;
                instrumentObject["clicklessTransition"] = this.clicklessTransition;
            }
            if (effectsIncludeChord(this.effects)) {
                instrumentObject["chord"] = this.getChord().name;
                instrumentObject["fastTwoNoteArp"] = this.fastTwoNoteArp;
                instrumentObject["arpeggioSpeed"] = this.arpeggioSpeed;
            }
  
            if (effectsIncludePitchShift(this.effects)) {
                instrumentObject["pitchShiftSemitones"] = this.pitchShift;
            }
            if (effectsIncludeDetune(this.effects)) {
                instrumentObject["detuneCents"] = Synth.detuneToCents(this.detune);
            }
            if (effectsIncludeVibrato(this.effects)) {
                if (this.vibrato == -1) {
                    this.vibrato = 5;
                }
                if (this.vibrato != 5) {
                    instrumentObject["vibrato"] = Config.vibratos[this.vibrato].name;
                }
                else {
                    instrumentObject["vibrato"] = "custom";
                }
                instrumentObject["vibratoDepth"] = this.vibratoDepth;
                instrumentObject["vibratoDelay"] = this.vibratoDelay;
                instrumentObject["vibratoSpeed"] = this.vibratoSpeed;
                instrumentObject["vibratoType"] = this.vibratoType;
            }
            if (effectsIncludeNoteFilter(this.effects)) {
                instrumentObject["noteFilterType"] = this.noteFilterType;
                instrumentObject["noteSimpleCut"] = this.noteFilterSimpleCut;
                instrumentObject["noteSimplePeak"] = this.noteFilterSimplePeak;
                instrumentObject["noteFilter"] = this.noteFilter.toJsonObject();
                for (let i = 0; i < Config.filterMorphCount; i++) {
                    if (this.noteSubFilters[i] != null)
                        instrumentObject["noteSubFilters" + i] = this.noteSubFilters[i].toJsonObject();
                }
            }
            if (effectsIncludeRingModulation(this.effects)) {
 instrumentObject["ringMod"] = Math.round(100 * this.ringModulation / (Config.ringModRange - 1));
 instrumentObject["ringModHz"] = Math.round(100 * this.ringModulationHz / (Config.ringModHzRange - 1));
 instrumentObject["ringModWaveformIndex"] = this.ringModWaveformIndex;
 instrumentObject["ringModPulseWidth"] = Math.round(100 * this.ringModPulseWidth / (Config.pulseWidthRange - 1));
 instrumentObject["ringModHzOffset"] = Math.round(100 * this.ringModHzOffset / (Config.rmHzOffsetMax));
}
            if (effectsIncludeDistortion(this.effects)) {
                instrumentObject["distortion"] = Math.round(100 * this.distortion / (Config.distortionRange - 1));
                instrumentObject["aliases"] = this.aliases;
            }
            if (effectsIncludeBitcrusher(this.effects)) {
                instrumentObject["bitcrusherOctave"] = (Config.bitcrusherFreqRange - 1 - this.bitcrusherFreq) * Config.bitcrusherOctaveStep;
                instrumentObject["bitcrusherQuantization"] = Math.round(100 * this.bitcrusherQuantization / (Config.bitcrusherQuantizationRange - 1));
            }
            if (effectsIncludePanning(this.effects)) {
                instrumentObject["pan"] = Math.round(100 * (this.pan - Config.panCenter) / Config.panCenter);
                instrumentObject["panDelay"] = this.panDelay;
            }
            if (effectsIncludeChorus(this.effects)) {
                instrumentObject["chorus"] = Math.round(100 * this.chorus / (Config.chorusRange - 1));
            }
            if (effectsIncludeEcho(this.effects)) {
                instrumentObject["echoSustain"] = Math.round(100 * this.echoSustain / (Config.echoSustainRange - 1));
                instrumentObject["echoDelayBeats"] = Math.round(1000 * (this.echoDelay + 1) * Config.echoDelayStepTicks / (Config.ticksPerPart * Config.partsPerBeat)) / 1000;
            }
            if (effectsIncludeReverb(this.effects)) {
                instrumentObject["reverb"] = Math.round(100 * this.reverb / (Config.reverbRange - 1));
            }
            if (this.type != 4) {
                instrumentObject["fadeInSeconds"] = Math.round(10000 * Synth.fadeInSettingToSeconds(this.fadeIn)) / 10000;
                instrumentObject["fadeOutTicks"] = Synth.fadeOutSettingToTicks(this.fadeOut);
            }
            if (this.type == 5 || this.type == 7) {
                instrumentObject["harmonics"] = [];
                for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                    instrumentObject["harmonics"][i] = Math.round(100 * this.harmonicsWave.harmonics[i] / Config.harmonicsMax);
                }
            } 
            
            if (this.type == 2) {
 instrumentObject["wave"] = Config.chipNoises[this.chipNoise].name;
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
}
else if (this.type == 3) {
 instrumentObject["spectrum"] = [];
 for (let i = 0; i < Config.spectrumControlPoints; i++) {
  instrumentObject["spectrum"][i] = Math.round(100 * this.spectrumWave.spectrum[i] / Config.spectrumMax);
 }
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
}
else if (this.type == 4) {
 instrumentObject["drums"] = [];
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
 for (let j = 0; j < Config.drumCount; j++) {
  const spectrum = [];
  for (let i = 0; i < Config.spectrumControlPoints; i++) {
   spectrum[i] = Math.round(100 * this.drumsetSpectrumWaves[j].spectrum[i] / Config.spectrumMax);
  }
  instrumentObject["drums"][j] = {
   "filterEnvelope": this.getDrumsetEnvelope(j).name,
   "spectrum": spectrum,
  };
 }
}
else if (this.type == 0) {
 instrumentObject["wave"] = Config.chipWaves[this.chipWave].name;
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
 instrumentObject["isUsingAdvancedLoopControls"] = this.isUsingAdvancedLoopControls;
 instrumentObject["chipWaveLoopStart"] = this.chipWaveLoopStart;
 instrumentObject["chipWaveLoopEnd"] = this.chipWaveLoopEnd;
 instrumentObject["chipWaveLoopMode"] = this.chipWaveLoopMode;
 instrumentObject["chipWavePlayBackwards"] = this.chipWavePlayBackwards;
 instrumentObject["chipWaveStartOffset"] = this.chipWaveStartOffset;
}
else if (this.type == 6) { 
 instrumentObject["pulseWidth"] = this.pulseWidth;
 instrumentObject["decimalOffset"] = this.decimalOffset;
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
}
else if (this.type == 7) {
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
 instrumentObject["stringSustain"] = Math.round(100 * this.stringSustain / (Config.stringSustainRange - 1));
 if (Config.enableAcousticSustain) {
  instrumentObject["stringSustainType"] = Config.sustainTypeNames[this.stringSustainType];
 }
}
else if (this.type == 5) {
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
}
else if (this.type == 1 || this.type == 11) { 
 const operatorArray = [];
 for (const operator of this.operators) {
  operatorArray.push({
   "frequency": Config.operatorFrequencies[operator.frequency].name,
   "amplitude": operator.amplitude,
   "waveform": Config.operatorWaves[operator.waveform].name,
   "pulseWidth": operator.pulseWidth,
  });
 }
 if (this.type == 1) {
  instrumentObject["algorithm"] = Config.algorithms[this.algorithm].name;
  instrumentObject["feedbackType"] = Config.feedbacks[this.feedbackType].name;
  instrumentObject["feedbackAmplitude"] = this.feedbackAmplitude;
  instrumentObject["operators"] = operatorArray;
 }
 else {
  instrumentObject["algorithm"] = Config.algorithms6Op[this.algorithm6Op].name;
  instrumentObject["feedbackType"] = Config.feedbacks6Op[this.feedbackType6Op].name;
  instrumentObject["feedbackAmplitude"] = this.feedbackAmplitude;
  if (this.algorithm6Op == 0) {
   const customAlgorithm = {};
   customAlgorithm["mods"] = this.customAlgorithm.modulatedBy;
   customAlgorithm["carrierCount"] = this.customAlgorithm.carrierCount;
   instrumentObject["customAlgorithm"] = customAlgorithm;
  }
  if (this.feedbackType6Op == 0) {
   const customFeedback = {};
   customFeedback["mods"] = this.customFeedbackType.indices;
   instrumentObject["customFeedback"] = customFeedback;
  }
  instrumentObject["operators"] = operatorArray;
 }
}
else if (this.type == 8) {
 instrumentObject["wave"] = Config.chipWaves[this.chipWave].name;
 instrumentObject["unison"] = this.unison == Config.unisons.length ? "custom" : Config.unisons[this.unison].name;
 if (this.unison == Config.unisons.length) {
  instrumentObject["unisonVoices"] = this.unisonVoices;
  instrumentObject["unisonSpread"] = this.unisonSpread;
  instrumentObject["unisonOffset"] = this.unisonOffset;
  instrumentObject["unisonExpression"] = this.unisonExpression;
  instrumentObject["unisonSign"] = this.unisonSign;
 }
 instrumentObject["customChipWave"] = new Float64Array(64);
 instrumentObject["customChipWaveIntegral"] = new Float64Array(65);
 for (let i = 0; i < this.customChipWave.length; i++) {
  instrumentObject["customChipWave"][i] = this.customChipWave[i];
 }
}
else if (this.type == 9) {
	instrumentObject["modChannels"] = [];
	instrumentObject["modInstruments"] = [];
	instrumentObject["modSettings"] = [];
	instrumentObject["modFilterTypes"] = [];
	instrumentObject["modStatuses"] = [];
	for (let mod = 0; mod < Config.modCount; mod++) {
		instrumentObject["modChannels"][mod] = this.modChannels[mod];
		instrumentObject["modInstruments"][mod] = this.modInstruments[mod];
		instrumentObject["modSettings"][mod] = this.modulators[mod];
		instrumentObject["modFilterTypes"][mod] = this.modFilterTypes[mod];
	}
}
else {
 throw new Error("Unrecognized instrument type");
}
            const envelopes = [];
            for (let i = 0; i < this.envelopeCount; i++) {
                envelopes.push(this.envelopes[i].toJsonObject());
            }
            
if (this.unison && this.unison !== 0 && this.unison == Config.unisons.length) {
	instrumentObject["unisonVoices"] = this.unisonVoices;
	instrumentObject["unisonSpread"] = this.unisonSpread;
	instrumentObject["unisonOffset"] = this.unisonOffset;
	instrumentObject["unisonExpression"] = this.unisonExpression;
	instrumentObject["unisonSign"] = this.unisonSign;
}
            instrumentObject["envelopes"] = envelopes;
            return instrumentObject;
        }
        fromJsonObject(instrumentObject, isNoiseChannel, isModChannel, useSlowerRhythm, useFastTwoNoteArp, legacyGlobalReverb = 0) {
            if (instrumentObject == undefined)
                instrumentObject = {};
            let type = Config.instrumentTypeNames.indexOf(instrumentObject["type"]);
            if (type == -1)
                type = isModChannel ? 9 : (isNoiseChannel ? 2 : 0);
            this.setTypeAndReset(type, isNoiseChannel, isModChannel);
            if (instrumentObject["preset"] != undefined) {
                this.preset = instrumentObject["preset"] >>> 0;
            }
            if (instrumentObject["volume"] != undefined) {
                this.volume = clamp(-Config.volumeRange / 2, (Config.volumeRange / 2) + 1, instrumentObject["volume"] | 0);
            }
            else {
                this.volume = 0;
            } 
            if (Array.isArray(instrumentObject["effects"])) {
                let effects = 0;
                for (let i = 0; i < instrumentObject["effects"].length; i++) {
                    effects = effects | (1 << Config.effectNames.indexOf(instrumentObject["effects"][i]));
                }
                this.effects = (effects & ((1 << 15) - 1));
            }
            else {
                const legacyEffectsNames = ["none", "reverb", "chorus", "chorus & reverb"];
                this.effects = legacyEffectsNames.indexOf(instrumentObject["effects"]);
                if (this.effects == -1)
                    this.effects = (this.type == 2) ? 0 : 1;
            }
            this.transition = Config.transitions.dictionary["normal"].index;
            const transitionProperty = instrumentObject["transition"] || instrumentObject["envelope"];
            if (transitionProperty != undefined) {
                let transition = Config.transitions.dictionary[transitionProperty];
                if (instrumentObject["fadeInSeconds"] == undefined || instrumentObject["fadeOutTicks"] == undefined) {
                    const legacySettings = {
                        "binary": { transition: "interrupt", fadeInSeconds: 0.0, fadeOutTicks: -1 },
                        "seamless": { transition: "interrupt", fadeInSeconds: 0.0, fadeOutTicks: -1 },
                        "sudden": { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: -3 },
                        "hard": { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: -3 },
                        "smooth": { transition: "normal", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                        "soft": { transition: "normal", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                        "slide": { transition: "slide in pattern", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                        "cross fade": { transition: "normal", fadeInSeconds: 0.04, fadeOutTicks: 6 },
                        "hard fade": { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: 48 },
                        "medium fade": { transition: "normal", fadeInSeconds: 0.0125, fadeOutTicks: 72 },
                        "soft fade": { transition: "normal", fadeInSeconds: 0.06, fadeOutTicks: 96 },
                    }[transitionProperty];
                    if (legacySettings != undefined) {
                        transition = Config.transitions.dictionary[legacySettings.transition];
                        this.fadeIn = Synth.secondsToFadeInSetting(legacySettings.fadeInSeconds);
                        this.fadeOut = Synth.ticksToFadeOutSetting(legacySettings.fadeOutTicks);
                    }
                }
                if (transition != undefined)
                    this.transition = transition.index;
                if (this.transition != Config.transitions.dictionary["normal"].index) {
                    this.effects = (this.effects & ((1 << 15) - 1));
                }
            }
            if (instrumentObject["fadeInSeconds"] != undefined) {
                this.fadeIn = Synth.secondsToFadeInSetting(+instrumentObject["fadeInSeconds"]);
            }
            if (instrumentObject["fadeOutTicks"] != undefined) {
                this.fadeOut = Synth.ticksToFadeOutSetting(+instrumentObject["fadeOutTicks"]);
            }
            {
                const chordProperty = instrumentObject["chord"];
                const legacyChordNames = { "harmony": "simultaneous" };
                const chord = Config.chords.dictionary[legacyChordNames[chordProperty]] || Config.chords.dictionary[chordProperty];
                if (chord != undefined) {
                    this.chord = chord.index;
                }
                else {
                    if (this.type == 2) {
                        this.chord = Config.chords.dictionary["arpeggio"].index;
                    }
                    else if (this.type == 7) {
                        this.chord = Config.chords.dictionary["strum"].index;
                    }
                    else if (this.type == 0) {
                        this.chord = Config.chords.dictionary["arpeggio"].index;
                    }
                    else if (this.type == 1) {
                        this.chord = Config.chords.dictionary["custom interval"].index;
                    }
                    else {
                        this.chord = Config.chords.dictionary["simultaneous"].index;
                    }
                }
            }
this.unison = Config.unisons.dictionary["none"].index;
const unisonProperty = instrumentObject["unison"] || instrumentObject["interval"] || instrumentObject["chorus"];
if (unisonProperty != undefined) {
 const legacyChorusNames = { "union": "none", "fifths": "fifth", "octaves": "octave", "error": "voiced" };
 const unison = Config.unisons.dictionary[legacyChorusNames[unisonProperty]] || Config.unisons.dictionary[unisonProperty];
 if (unison != undefined)
  this.unison = unison.index;
 if (unisonProperty == "custom")
  this.unison = Config.unisons.length;
}
this.unisonVoices = (instrumentObject["unisonVoices"] == undefined) ? Config.unisons[this.unison].voices : instrumentObject["unisonVoices"];
this.unisonSpread = (instrumentObject["unisonSpread"] == undefined) ? Config.unisons[this.unison].spread : instrumentObject["unisonSpread"];
this.unisonOffset = (instrumentObject["unisonOffset"] == undefined) ? Config.unisons[this.unison].offset : instrumentObject["unisonOffset"];
this.unisonExpression = (instrumentObject["unisonExpression"] == undefined) ? Config.unisons[this.unison].expression : instrumentObject["unisonExpression"];
this.unisonSign = (instrumentObject["unisonSign"] == undefined) ? Config.unisons[this.unison].sign : instrumentObject["unisonSign"];
 
            if (instrumentObject["chorus"] == "custom harmony") {
                this.unison = Config.unisons.dictionary["hum"].index;
                this.chord = Config.chords.dictionary["custom interval"].index;
            }
            if (this.chord != Config.chords.dictionary["simultaneous"].index && !Array.isArray(instrumentObject["effects"])) {
                this.effects = (this.effects & ((1 << 15) - 1));
            }

// id 


            if (instrumentObject["pitchShiftSemitones"] != undefined) {
                this.pitchShift = clamp(0, Config.pitchShiftRange, Math.round(+instrumentObject["pitchShiftSemitones"]));
                 
            }
            if (instrumentObject["detuneCents"] != undefined) {
                this.detune = clamp(Config.detuneMin, Config.detuneMax + 1, Math.round(Synth.centsToDetune(+instrumentObject["detuneCents"])));
            }
            this.vibrato = Config.vibratos.dictionary["none"].index;
            const vibratoProperty = instrumentObject["vibrato"] || instrumentObject["effect"];
            if (vibratoProperty != undefined) {
                const legacyVibratoNames = { "vibrato light": "light", "vibrato delayed": "delayed", "vibrato heavy": "heavy" };
                const vibrato = Config.vibratos.dictionary[legacyVibratoNames[unisonProperty]] || Config.vibratos.dictionary[vibratoProperty];
                if (vibrato != undefined)
                    this.vibrato = vibrato.index;
                else if (vibratoProperty == "custom")
                    this.vibrato = Config.vibratos.length;
                if (this.vibrato == Config.vibratos.length) {
                    this.vibratoDepth = instrumentObject["vibratoDepth"];
                    this.vibratoSpeed = instrumentObject["vibratoSpeed"];
                    this.vibratoDelay = instrumentObject["vibratoDelay"];
                    this.vibratoType = instrumentObject["vibratoType"];
                }
                else {
                    this.vibratoDepth = Config.vibratos[this.vibrato].amplitude;
                    this.vibratoDelay = Config.vibratos[this.vibrato].delayTicks / 2;
                    this.vibratoSpeed = 10;
                    this.vibratoType = Config.vibratos[this.vibrato].type;
                }
                if (vibrato != Config.vibratos.dictionary["none"]) {
                    this.effects = (this.effects & ((1 << 15) - 1));
                }
            }
            if (instrumentObject["pan"] != undefined) {
                this.pan = clamp(0, Config.panMax + 1, Math.round(Config.panCenter + (instrumentObject["pan"] | 0) * Config.panCenter / 100));
                if (this.pan != Config.panCenter) {
                    this.effects = (this.effects & ((1 << 15) - 1));
                }
            }
            else {
                this.pan = Config.panCenter;
            }
            if (instrumentObject["panDelay"] != undefined) {
                this.panDelay = (instrumentObject["panDelay"] | 0);
            }
            else {
                this.panDelay = 10;
            }
            if (instrumentObject["detune"] != undefined) {
                this.detune = clamp(Config.detuneMin, Config.detuneMax + 1, (instrumentObject["detune"] | 0));
            }
            else if (instrumentObject["detuneCents"] == undefined) {
                this.detune = Config.detuneCenter;
            }
            if (instrumentObject["ringMod"] != undefined) {
             this.ringModulation = clamp(0, Config.ringModRange, Math.round((Config.ringModRange - 1) * (instrumentObject["ringMod"] | 0) / 100));
            }
            if (instrumentObject["ringModHz"] != undefined) {
 this.ringModulationHz = clamp(0, Config.ringModHzRange, Math.round((Config.ringModHzRange - 1) * (instrumentObject["ringModHz"] | 0) / 100));
}
if (instrumentObject["ringModWaveformIndex"] != undefined) {
 this.ringModWaveformIndex = clamp(0, Config.operatorWaves.length, instrumentObject["ringModWaveformIndex"]);
}
if (instrumentObject["ringModPulseWidth"] != undefined) {
	this.ringModPulseWidth = clamp(0, Config.pulseWidthRange, Math.round((Config.pulseWidthRange - 1) * (instrumentObject["ringModPulseWidth"] | 0) / 100));
}
if (instrumentObject["ringModHzOffset"] != undefined) {
 this.ringModHzOffset = clamp(0, Config.rmHzOffsetMax, Math.round((Config.rmHzOffsetMax - 1) * (instrumentObject["ringModHzOffset"] | 0) / 100));
}
            if (instrumentObject["distortion"] != undefined) {
                this.distortion = clamp(0, Config.distortionRange, Math.round((Config.distortionRange - 1) * (instrumentObject["distortion"] | 0) / 100));
            }
            if (instrumentObject["bitcrusherOctave"] != undefined) {
                this.bitcrusherFreq = Config.bitcrusherFreqRange - 1 - (+instrumentObject["bitcrusherOctave"]) / Config.bitcrusherOctaveStep;
            }
            if (instrumentObject["bitcrusherQuantization"] != undefined) {
                this.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, Math.round((Config.bitcrusherQuantizationRange - 1) * (instrumentObject["bitcrusherQuantization"] | 0) / 100));
            }
            if (instrumentObject["echoSustain"] != undefined) {
                this.echoSustain = clamp(0, Config.echoSustainRange, Math.round((Config.echoSustainRange - 1) * (instrumentObject["echoSustain"] | 0) / 100));
            }
            if (instrumentObject["echoDelayBeats"] != undefined) {
                this.echoDelay = clamp(0, Config.echoDelayRange, Math.round((+instrumentObject["echoDelayBeats"]) * (Config.ticksPerPart * Config.partsPerBeat) / Config.echoDelayStepTicks - 1.0));
            }
            if (!isNaN(instrumentObject["chorus"])) {
                this.chorus = clamp(0, Config.chorusRange, Math.round((Config.chorusRange - 1) * (instrumentObject["chorus"] | 0) / 100));
            }
            if (instrumentObject["reverb"] != undefined) {
                this.reverb = clamp(0, Config.reverbRange, Math.round((Config.reverbRange - 1) * (instrumentObject["reverb"] | 0) / 100));
            }
            else {
                this.reverb = legacyGlobalReverb;
            }
            if (instrumentObject["pulseWidth"] != undefined) {
                this.pulseWidth = clamp(1, Config.pulseWidthRange + 1, Math.round(instrumentObject["pulseWidth"]));
            }
            else {
                this.pulseWidth = Config.pulseWidthRange;
            }
            if (instrumentObject["harmonics"] != undefined) {
                for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                    this.harmonicsWave.harmonics[i] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(Config.harmonicsMax * (+instrumentObject["harmonics"][i]) / 100)));
                }
            }
            else {
                this.harmonicsWave.reset();
            }
            if (instrumentObject["spectrum"] != undefined) {
                for (let i = 0; i < Config.spectrumControlPoints; i++) {
                    this.spectrumWave.spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(Config.spectrumMax * (+instrumentObject["spectrum"][i]) / 100)));
                }
            }
            else {
                this.spectrumWave.reset(isNoiseChannel);
            }
            if (instrumentObject["stringSustain"] != undefined) {
                this.stringSustain = clamp(0, Config.stringSustainRange, Math.round((Config.stringSustainRange - 1) * (instrumentObject["stringSustain"] | 0) / 100));
            }
            else {
                this.stringSustain = 10;
            }
            if (this.type == 2) {
                this.chipNoise = Config.chipNoises.findIndex(wave => wave.name == instrumentObject["wave"]);
                if (this.chipNoise == -1)
                    this.chipNoise = 1;
            }
            const legacyEnvelopeNames = { "custom": "note size", "steady": "none", "pluck 1": "twang 1", "pluck 2": "twang 2", "pluck 3": "twang 3" };
            const getEnvelope = (name) => (legacyEnvelopeNames[name] != undefined) ? Config.envelopes.dictionary[legacyEnvelopeNames[name]] : Config.envelopes.dictionary[name];
            if (this.type == 4) {
                if (instrumentObject["drums"] != undefined) {
                    for (let j = 0; j < Config.drumCount; j++) {
                        const drum = instrumentObject["drums"][j];
                        if (drum == undefined)
                            continue;
                        this.drumsetEnvelopes[j] = Config.envelopes.dictionary["twang 2"].index;
                        if (drum["filterEnvelope"] != undefined) {
                            const envelope = getEnvelope(drum["filterEnvelope"]);
                            if (envelope != undefined)
                                this.drumsetEnvelopes[j] = envelope.index;
                        }
                        if (drum["spectrum"] != undefined) {
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                this.drumsetSpectrumWaves[j].spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(Config.spectrumMax * (+drum["spectrum"][i]) / 100)));
                            }
                        }
                    }
                }
            }
            if (this.type == 0) {
                const legacyWaveNames = { "triangle": 1, "square": 2, "pulse wide": 3, "pulse narrow": 4, "sawtooth": 5, "double saw": 6, "double pulse": 7, "spiky": 8, "plateau": 0 };
                this.chipWave = legacyWaveNames[instrumentObject["wave"]] != undefined ? legacyWaveNames[instrumentObject["wave"]] : Config.chipWaves.findIndex(wave => wave.name == instrumentObject["wave"]);
                 
                if (this.chipWave == -1)
                    this.chipWave = 1;
                    
                   // this.chipwaveselected=this.chipWave
            }
            if (this.type == 1) {
                this.algorithm = Config.algorithms.findIndex(algorithm => algorithm.name == instrumentObject["algorithm"]);
                if (this.algorithm == -1)
                    this.algorithm = 0;
                this.feedbackType = Config.feedbacks.findIndex(feedback => feedback.name == instrumentObject["feedbackType"]);
                if (this.feedbackType == -1)
                    this.feedbackType = 0;
                if (instrumentObject["feedbackAmplitude"] != undefined) {
                    this.feedbackAmplitude = clamp(0, Config.operatorAmplitudeMax + 1, instrumentObject["feedbackAmplitude"] | 0);
                }
                else {
                    this.feedbackAmplitude = 0;
                }
                for (let j = 0; j < Config.operatorCount; j++) {
                    const operator = this.operators[j];
                    let operatorObject = undefined;
                    if (instrumentObject["operators"] != undefined)
                        operatorObject = instrumentObject["operators"][j];
                    if (operatorObject == undefined)
                        operatorObject = {};
                    operator.frequency = Config.operatorFrequencies.findIndex(freq => freq.name == operatorObject["frequency"]);
                    if (operator.frequency == -1)
                        operator.frequency = 0;
                    if (operatorObject["amplitude"] != undefined) {
                        operator.amplitude = clamp(0, Config.operatorAmplitudeMax + 1, operatorObject["amplitude"] | 0);
                    }
                    else {
                        operator.amplitude = 0;
                    }
                    if (operatorObject["waveform"] != undefined) {
                        operator.waveform = Config.operatorWaves.findIndex(wave => wave.name == operatorObject["waveform"]);
                        if (operator.waveform == -1) {
                            if (operatorObject["waveform"] == "square") {
                                operator.waveform = Config.operatorWaves.dictionary["pulse width"].index;
                                operator.pulseWidth = 5;
                            }
                            else {
                                operator.waveform = 0;
                            }
                        }
                    }
                    else {
                        operator.waveform = 0;
                    }
                    if (operatorObject["pulseWidth"] != undefined) {
                        operator.pulseWidth = operatorObject["pulseWidth"] | 0;
                    }
                    else {
                        operator.pulseWidth = 5;
                    }
                }
            }
            else if (this.type == 8) {
                if (instrumentObject["customChipWave"]) {
                    for (let i = 0; i < 64; i++) {
                        this.customChipWave[i] = instrumentObject["customChipWave"][i];
                    }
                    let sum = 0.0;
                    for (let i = 0; i < this.customChipWave.length; i++) {
                        sum += this.customChipWave[i];
                    }
                    const average = sum / this.customChipWave.length;
                    let cumulative = 0;
                    let wavePrev = 0;
                    for (let i = 0; i < this.customChipWave.length; i++) {
                        cumulative += wavePrev;
                        wavePrev = this.customChipWave[i] - average;
                        this.customChipWaveIntegral[i] = cumulative;
                    }
                    this.customChipWaveIntegral[64] = 0.0;
                }
            }
            else if (this.type == 9) {
                if (instrumentObject["modChannels"] != undefined) {
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        this.modChannels[mod] = instrumentObject["modChannels"][mod];
                        this.modInstruments[mod] = instrumentObject["modInstruments"][mod];
                        this.modulators[mod] = instrumentObject["modSettings"][mod];
 
if(  instrumentObject.modFilterTypes ){ this.modFilterTypes[mod]=instrumentObject["modFilterTypes"][mod]}
                    }
                }
            }
            if (this.type != 9) {
                if (this.chord == Config.chords.dictionary["arpeggio"].index && instrumentObject["arpeggioSpeed"] != undefined) {
                    this.arpeggioSpeed = instrumentObject["arpeggioSpeed"];
                }
                else {
                    this.arpeggioSpeed = (useSlowerRhythm) ? 9 : 12;
                }
                if (instrumentObject["fastTwoNoteArp"] != undefined) {
                    this.fastTwoNoteArp = instrumentObject["fastTwoNoteArp"];
                }
                else {
                    this.fastTwoNoteArp = useFastTwoNoteArp;
                }
                if (instrumentObject["clicklessTransition"] != undefined) {
                    this.clicklessTransition = instrumentObject["clicklessTransition"];
                }
                else {
                    this.clicklessTransition = false;
                }
                if (instrumentObject["aliases"] != undefined) {
                    this.aliases = instrumentObject["aliases"];
                }
                else {
                    this.aliases = false;
                }
                if (instrumentObject["noteFilterType"] != undefined) {
                    this.noteFilterType = instrumentObject["noteFilterType"];
                }
                if (instrumentObject["noteSimpleCut"] != undefined) {
                    this.noteFilterSimpleCut = instrumentObject["noteSimpleCut"];
                }
                if (instrumentObject["noteSimplePeak"] != undefined) {
                    this.noteFilterSimplePeak = instrumentObject["noteSimplePeak"];
                }
                if (instrumentObject["noteFilter"] != undefined) {
                    this.noteFilter.fromJsonObject(instrumentObject["noteFilter"]);
                }
                else {
                    this.noteFilter.reset();
                }
                for (let i = 0; i < Config.filterMorphCount; i++) {
                    if (Array.isArray(instrumentObject["noteSubFilters" + i])) {
                        this.noteSubFilters[i] = new FilterSettings();
                        this.noteSubFilters[i].fromJsonObject(instrumentObject["noteSubFilters" + i]);
                    }
                }
                if (instrumentObject["eqFilterType"] != undefined) {
                    this.eqFilterType = instrumentObject["eqFilterType"];
                }
                if (instrumentObject["eqSimpleCut"] != undefined) {
                    this.eqFilterSimpleCut = instrumentObject["eqSimpleCut"];
                }
                if (instrumentObject["eqSimplePeak"] != undefined) {
                    this.eqFilterSimplePeak = instrumentObject["eqSimplePeak"];
                }
                if (Array.isArray(instrumentObject["eqFilter"])) {
                    this.eqFilter.fromJsonObject(instrumentObject["eqFilter"]);
                }
                else {
                    this.eqFilter.reset();
                    const legacySettings = {};
                    const filterCutoffMaxHz = 8000;
                    const filterCutoffRange = 11;
                    const filterResonanceRange = 8;
                    if (instrumentObject["filterCutoffHz"] != undefined) {
                        legacySettings.filterCutoff = clamp(0, filterCutoffRange, Math.round((filterCutoffRange - 1) + 2.0 * Math.log((instrumentObject["filterCutoffHz"] | 0) / filterCutoffMaxHz) / Math.LN2));
                    }
                    else {
                        legacySettings.filterCutoff = (this.type == 0) ? 6 : 10;
                    }
                    if (instrumentObject["filterResonance"] != undefined) {
                        legacySettings.filterResonance = clamp(0, filterResonanceRange, Math.round((filterResonanceRange - 1) * (instrumentObject["filterResonance"] | 0) / 100));
                    }
                    else {
                        legacySettings.filterResonance = 0;
                    }
                    legacySettings.filterEnvelope = getEnvelope(instrumentObject["filterEnvelope"]);
                    legacySettings.pulseEnvelope = getEnvelope(instrumentObject["pulseEnvelope"]);
                    legacySettings.feedbackEnvelope = getEnvelope(instrumentObject["feedbackEnvelope"]);
                    if (Array.isArray(instrumentObject["operators"])) {
                        legacySettings.operatorEnvelopes = [];
                        for (let j = 0; j < Config.operatorCount; j++) {
                            let envelope;
                            if (instrumentObject["operators"][j] != undefined) {
                                envelope = getEnvelope(instrumentObject["operators"][j]["envelope"]);
                            }
                            legacySettings.operatorEnvelopes[j] = (envelope != undefined) ? envelope : Config.envelopes.dictionary["none"];
                        }
                    }
                    if (instrumentObject["filter"] != undefined) {
                        const legacyToCutoff = [10, 6, 3, 0, 8, 5, 2];
                        const legacyToEnvelope = ["none", "none", "none", "none", "decay 1", "decay 2", "decay 3"];
                        const filterNames = ["none", "bright", "medium", "soft", "decay bright", "decay medium", "decay soft"];
                        const oldFilterNames = { "sustain sharp": 1, "sustain medium": 2, "sustain soft": 3, "decay sharp": 4 };
                        let legacyFilter = oldFilterNames[instrumentObject["filter"]] != undefined ? oldFilterNames[instrumentObject["filter"]] : filterNames.indexOf(instrumentObject["filter"]);
                        if (legacyFilter == -1)
                            legacyFilter = 0;
                        legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                        legacySettings.filterEnvelope = getEnvelope(legacyToEnvelope[legacyFilter]);
                        legacySettings.filterResonance = 0;
                    }
                    this.convertLegacySettings(legacySettings, true);
                }
                for (let i = 0; i < Config.filterMorphCount; i++) {
                    if (Array.isArray(instrumentObject["eqSubFilters" + i])) {
                        this.eqSubFilters[i] = new FilterSettings();
                        this.eqSubFilters[i].fromJsonObject(instrumentObject["eqSubFilters" + i]);
                    }
                }
                if (Array.isArray(instrumentObject["envelopes"])) {
                    const envelopeArray = instrumentObject["envelopes"];
                    for (let i = 0; i < envelopeArray.length; i++) {
                        if (this.envelopeCount >= Config.maxEnvelopeCount)
                            break;
                        const tempEnvelope = new EnvelopeSettings();
                        tempEnvelope.fromJsonObject(envelopeArray[i]);
                        this.addEnvelope(tempEnvelope.target, tempEnvelope.index, tempEnvelope.envelope);
                    }
                }
            }
            if (type === 0) {
 if (instrumentObject["isUsingAdvancedLoopControls"] != undefined) {
  this.isUsingAdvancedLoopControls = instrumentObject["isUsingAdvancedLoopControls"];
  this.chipWaveLoopStart = instrumentObject["chipWaveLoopStart"];
  this.chipWaveLoopEnd = instrumentObject["chipWaveLoopEnd"];
  this.chipWaveLoopMode = instrumentObject["chipWaveLoopMode"];
  this.chipWavePlayBackwards = instrumentObject["chipWavePlayBackwards"];
  this.chipWaveStartOffset = instrumentObject["chipWaveStartOffset"];
 }
 else {
  this.isUsingAdvancedLoopControls = false;
  this.chipWaveLoopStart = 0;
  this.chipWaveLoopEnd = Config.chipWaves[this.chipWave].samples.length - 1;
  this.chipWaveLoopMode = 0;
  this.chipWavePlayBackwards = false;
  this.chipWaveStartOffset = 0;
 }
}
        }
        static frequencyFromPitch(pitch) {
            return 440.0 * Math.pow(2.0, (pitch - 69.0) / 12.0);
        }
        static drumsetIndexReferenceDelta(index) {
            return Instrument.frequencyFromPitch(Config.spectrumBasePitch + index * 6) / 44100;
        }
        static _drumsetIndexToSpectrumOctave(index) {
            return 15 + Math.log2(Instrument.drumsetIndexReferenceDelta(index));
        }
        addEnvelope(target, index, envelope) {
            let makeEmpty = false;
            if (!this.supportsEnvelopeTarget(target, index))
                makeEmpty = true;
            if (this.envelopeCount >= Config.maxEnvelopeCount)
                throw new Error();
            while (this.envelopes.length <= this.envelopeCount)
                this.envelopes[this.envelopes.length] = new EnvelopeSettings();
            const envelopeSettings = this.envelopes[this.envelopeCount];
            envelopeSettings.target = makeEmpty ? Config.instrumentAutomationTargets.dictionary["none"].index : target;
            envelopeSettings.index = makeEmpty ? 0 : index;
            envelopeSettings.envelope = envelope;
            this.envelopeCount++;
        }
        supportsEnvelopeTarget(target, index) {
            const automationTarget = Config.instrumentAutomationTargets[target];
            if (index >= automationTarget.maxCount) {
                return false;
            }
            if (automationTarget.compatibleInstruments != null && automationTarget.compatibleInstruments.indexOf(this.type) == -1) {
                return false;
            }
            if (automationTarget.effect != null && (this.effects & (1 << automationTarget.effect)) == 0) {
                return false;
            }
            if (automationTarget.isFilter) {
                let useControlPointCount = this.noteFilter.controlPointCount;
                if (this.noteFilterType)
                    useControlPointCount = 1;
                if (index >= useControlPointCount)
                    return false;
            }
            return true;
        }
        clearInvalidEnvelopeTargets() {
            for (let envelopeIndex = 0; envelopeIndex < this.envelopeCount; envelopeIndex++) {
                const target = this.envelopes[envelopeIndex].target;
                const index = this.envelopes[envelopeIndex].index;
                if (!this.supportsEnvelopeTarget(target, index)) {
                    this.envelopes[envelopeIndex].target = Config.instrumentAutomationTargets.dictionary["none"].index;
                    this.envelopes[envelopeIndex].index = 0;
                }
            }
        }
        warmUp(samplesPerSecond) {
            this.LFOtime = 0;
            this.nextLFOtime = 0;
            this.arpTime = 0;
            this.tmpEqFilterStart = this.eqFilter;
            this.tmpEqFilterEnd = null;
            this.tmpNoteFilterStart = this.noteFilter;
            this.tmpNoteFilterEnd = null;
            if (this.type == 2) {
                getDrumWave(this.chipNoise, inverseRealFourierTransform, scaleElementsByFactor);
            }
            else if (this.type == 5) {
                this.harmonicsWave.getCustomWave(this.type);
            }
            else if (this.type == 7) {
                this.harmonicsWave.getCustomWave(this.type);
            }
            else if (this.type == 3) {
                this.spectrumWave.getCustomWave(8);
            }
            else if (this.type == 4) {
                for (let i = 0; i < Config.drumCount; i++) {
                    this.drumsetSpectrumWaves[i].getCustomWave(Instrument._drumsetIndexToSpectrumOctave(i));
                }
            }
        }
        getDrumWave() {
            if (this.type == 2) {
                return getDrumWave(this.chipNoise, inverseRealFourierTransform, scaleElementsByFactor);
            }
            else if (this.type == 3) {
                return this.spectrumWave.getCustomWave(8);
            }
            else {
                throw new Error("Unhandled instrument type in getDrumWave");
            }
        }
        getDrumsetWave(pitch) {
            if (this.type == 4) {
                return this.drumsetSpectrumWaves[pitch].getCustomWave(Instrument._drumsetIndexToSpectrumOctave(pitch));
            }
            else {
                throw new Error("Unhandled instrument type in getDrumsetWave");
            }
        }
        getTransition() {
            return effectsIncludeTransition(this.effects) ? Config.transitions[this.transition] :
                (this.type == 9 ? Config.transitions.dictionary["interrupt"] : Config.transitions.dictionary["normal"]);
        }
        getFadeInSeconds() {
            return (this.type == 4) ? 0.0 : Synth.fadeInSettingToSeconds(this.fadeIn);
        }
        getFadeOutTicks() {
            return (this.type == 4) ? Config.drumsetFadeOutTicks : Synth.fadeOutSettingToTicks(this.fadeOut);
        }
        getChord() {
            return effectsIncludeChord(this.effects) ? Config.chords[this.chord] : Config.chords.dictionary["simultaneous"];
        }
        getDrumsetEnvelope(pitch) {
            if (this.type != 4)
                throw new Error("Can't getDrumsetEnvelope() for non-drumset.");
            return Config.envelopes[this.drumsetEnvelopes[pitch]];
        }
    }
    class Channel {
        constructor() {
            this.octave = 0;
            this.instruments = [];
            this.patterns = [];
            this.bars = [];
            this.muted = false;
            this.name = "";
        }
    }
    class Song {
        constructor(string) {
            this.channels = [];
            this.limitDecay = 4.0;
            this.limitRise = 4000.0;
            this.compressionThreshold = 1.0;
            this.limitThreshold = 1.0;
            this.compressionRatio = 1.0;
            this.limitRatio = 1.0;
            this.masterGain = 1.0;
            this.inVolumeCap = 0.0;
            this.outVolumeCap = 0.0;
            this.getNewNoteVolume = (isMod, modChannel, modInstrument, modCount) => {
                if (!isMod || modChannel == undefined || modInstrument == undefined || modCount == undefined)
                    return 6;
                else {
                    modCount = Config.modCount - modCount - 1;
                    let vol = Config.modulators[this.channels[modChannel].instruments[modInstrument].modulators[modCount]].newNoteVol;
                    let tempoIndex = Config.modulators.dictionary["tempo"].index;
                    if (this.channels[modChannel].instruments[modInstrument].modulators[modCount] == tempoIndex) {
                        vol = this.tempo - Config.modulators[tempoIndex].convertRealFactor;
                    }
                    if (vol != undefined)
                        return vol;
                    else
                        return 6;
                }
            };
            this.getVolumeCap = (isMod, modChannel, modInstrument, modCount) => {
                if (!isMod || modChannel == undefined || modInstrument == undefined || modCount == undefined   )
                    return 6;
                else {
                    modCount = Config.modCount - modCount - 1;
                    let instrument = this.channels[modChannel].instruments[modInstrument];
                    let modulator = Config.modulators[instrument.modulators[modCount]];
                    
                    let cap = modulator.maxRawVol;
                    if (cap != undefined) {
                        if (modulator.name == "eq filter" || modulator.name == "note filter") {
                            cap = Config.filterMorphCount - 1;
                            if (instrument.modFilterTypes[modCount] > 0 && instrument.modFilterTypes[modCount] % 2) {
                                cap = Config.filterFreqRange;
                            }
                            else if (instrument.modFilterTypes[modCount] > 0) {
                                cap = Config.filterGainRange;
                            }
                        }
                        return cap;
                    }
                    else
                        return 6;
                }
            };
            this.getVolumeCapForSetting = (isMod, modSetting, filterType) => {
                if (!isMod)
                    return Config.noteSizeMax;
                else {
                    
 
              //      if( ! Config.modulators[modSetting] ) return; 
                    
                    
                    let cap = Config.modulators[modSetting].maxRawVol;
                    if (cap != undefined) {
                        if (filterType != undefined && (Config.modulators[modSetting].name == "eq filter" || Config.modulators[modSetting].name == "note filter")) {
                            cap = Config.filterMorphCount - 1;
                            if (filterType > 0 && filterType % 2) {
                                cap = Config.filterFreqRange;
                            }
                            else if (filterType > 0) {
                                cap = Config.filterGainRange;
                            }
                        }
                        return cap;
                    }
                    else
                        return Config.noteSizeMax;
                }
            };
            if (string != undefined) {
                this.fromBase64String(string);
            }
            else {
                this.initToDefault(true);
            }
        }
        getChannelCount() {
            return this.pitchChannelCount + this.noiseChannelCount + this.modChannelCount;
        }
        getMaxInstrumentsPerChannel() {
            return Math.max(this.layeredInstruments ? Config.layeredInstrumentCountMax : Config.instrumentCountMin, this.patternInstruments ? Config.patternInstrumentCountMax : Config.instrumentCountMin);
        }
        getMaxInstrumentsPerPattern(channelIndex) {
            return this.getMaxInstrumentsPerPatternForChannel(this.channels[channelIndex]);
        }
        getMaxInstrumentsPerPatternForChannel(channel) {
            return this.layeredInstruments
                ? Math.min(Config.layeredInstrumentCountMax, channel.instruments.length)
                : 1;
        }
        getChannelIsNoise(channelIndex) {
            return (channelIndex >= this.pitchChannelCount && channelIndex < this.pitchChannelCount + this.noiseChannelCount);
        }
        getChannelIsMod(channelIndex) {
            return (channelIndex >= this.pitchChannelCount + this.noiseChannelCount);
        }
        initToDefault(andResetChannels = true) {
            this.scale = 0;
            this.key = 0;
            this.loopStart = 0;
            this.loopLength = 1;
            this.tempo = 120;
            this.reverb = 0;
            this.beatsPerBar = 8;
            this.barCount = 8;
            this.patternsPerChannel = 40;
            this.rhythm = 1;
            this.layeredInstruments = false;
            this.patternInstruments = false;
            
            
            
 
 

            
            this.title = "FruityBoxSong";
            document.title = EditorConfig.versionDisplayName;
            if (andResetChannels) {
                this.pitchChannelCount = 4;
                this.noiseChannelCount =1;
                this.modChannelCount = 1;
                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                    const isNoiseChannel = channelIndex >= this.pitchChannelCount && channelIndex < this.pitchChannelCount + this.noiseChannelCount;
                    const isModChannel = channelIndex >= this.pitchChannelCount + this.noiseChannelCount;
                    if (this.channels.length <= channelIndex) {
                        this.channels[channelIndex] = new Channel();
                        
                        
                    }
                    const channel = this.channels[channelIndex];
                    channel.octave = Math.max(3 - channelIndex, 0);
                    for (let pattern = 0; pattern < this.patternsPerChannel; pattern++) {
                        if (channel.patterns.length <= pattern) {
                            channel.patterns[pattern] = new Pattern();
                        }
                        else {
                            channel.patterns[pattern].reset();
                        }
                    }
                    channel.patterns.length = this.patternsPerChannel;
                    for (let instrument = 0; instrument < Config.instrumentCountMin; instrument++) {
                        if (channel.instruments.length <= instrument) {
                            channel.instruments[instrument] = new Instrument(isNoiseChannel, isModChannel);
                        }
                        channel.instruments[instrument].setTypeAndReset(isModChannel ? 9 : (isNoiseChannel ? 2 : 0), isNoiseChannel, isModChannel);
                    }
                    channel.instruments.length = Config.instrumentCountMin;
                    for (let bar = 0; bar < this.barCount; bar++) {
                        channel.bars[bar] = bar < 4 ? 0 : 0; // ? 1:0 for active group
                    }
                    channel.bars.length = this.barCount;
                }
                this.channels.length = this.getChannelCount();
            }
// avoiding base64 limitations maded by a creator of beepbox lmfao now Infinity amount of samples ♾️   v1. beta code  
for (let channel of this.channels) {
	for (let instrument of channel.instruments) {
		if (instrument.chipWave !== undefined && instrument.chipWave !== null) {
			instrument.chipwaveselected = instrument.chipWave 
		} else {
			instrument.chipwaveselected = 0;
		}
	}
}
for (let channel of this.channels) {
	for (let instrument of channel.instruments) {
		if (!instrument.envelopessave) {
			instrument.envelopessave = instrument.envelopes
		}
	}
}

        }
        toBase64String() {
            let bits;
            let buffer = [];
            buffer.push(Song._variant);
            buffer.push(base64IntToCharCode[Song._latestJummBoxVersion]);
            buffer.push(78);
            var encodedSongTitle = encodeURIComponent(this.title);
            buffer.push(base64IntToCharCode[encodedSongTitle.length >> 6], base64IntToCharCode[encodedSongTitle.length & 0x3f]);
            for (let i = 0; i < encodedSongTitle.length; i++) {
                buffer.push(encodedSongTitle.charCodeAt(i));
            }
            
buffer.push(110,
    base64IntToCharCode[(this.pitchChannelCount >> 6) & 63],
    base64IntToCharCode[this.pitchChannelCount & 63],
    base64IntToCharCode[(this.modChannelCount >> 6) & 63],
    base64IntToCharCode[this.modChannelCount & 63],
    base64IntToCharCode[(this.noiseChannelCount >> 6) & 63],
    base64IntToCharCode[this.noiseChannelCount & 63]
);
            buffer.push(115, base64IntToCharCode[this.scale]);
            buffer.push(107, base64IntToCharCode[this.key]);
            buffer.push(108, base64IntToCharCode[this.loopStart >> 6], base64IntToCharCode[this.loopStart & 0x3f]);
            buffer.push(101, base64IntToCharCode[(this.loopLength - 1) >> 6], base64IntToCharCode[(this.loopLength - 1) & 0x3f]);
            buffer.push(116, base64IntToCharCode[this.tempo >> 6], base64IntToCharCode[this.tempo & 0x3F]);
            buffer.push(97, base64IntToCharCode[this.beatsPerBar - 1]);
            buffer.push(103, base64IntToCharCode[(this.barCount - 1) >> 6], base64IntToCharCode[(this.barCount - 1) & 0x3f]);
            buffer.push(106, base64IntToCharCode[(this.patternsPerChannel - 1) >> 6], base64IntToCharCode[(this.patternsPerChannel - 1) & 0x3f]);
            buffer.push(114, base64IntToCharCode[this.rhythm]);
            buffer.push(79);
            if (this.compressionRatio != 1.0 || this.limitRatio != 1.0 || this.limitRise != 4000.0 || this.limitDecay != 4.0 || this.limitThreshold != 1.0 || this.compressionThreshold != 1.0 || this.masterGain != 1.0) {
                buffer.push(base64IntToCharCode[Math.round(this.compressionRatio < 1 ? this.compressionRatio * 10 : 10 + (this.compressionRatio - 1) * 60)]);
                buffer.push(base64IntToCharCode[Math.round(this.limitRatio < 1 ? this.limitRatio * 10 : 9 + this.limitRatio)]);
                buffer.push(base64IntToCharCode[this.limitDecay]);
                buffer.push(base64IntToCharCode[Math.round((this.limitRise - 2000.0) / 250.0)]);
                buffer.push(base64IntToCharCode[Math.round(this.compressionThreshold * 20)]);
                buffer.push(base64IntToCharCode[Math.round(this.limitThreshold * 20)]);
                buffer.push(base64IntToCharCode[Math.round(this.masterGain * 50) >> 6], base64IntToCharCode[Math.round(this.masterGain * 50) & 0x3f]);
            }
            else {
                buffer.push(base64IntToCharCode[0x3f]);
            }
            buffer.push(85);
            for (let channel = 0; channel < this.getChannelCount(); channel++) {
                var encodedChannelName = encodeURIComponent(this.channels[channel].name);
                buffer.push(base64IntToCharCode[encodedChannelName.length >> 6], base64IntToCharCode[encodedChannelName.length & 0x3f]);
                for (let i = 0; i < encodedChannelName.length; i++) {
                    buffer.push(encodedChannelName.charCodeAt(i));
                }
            }
            buffer.push(105, base64IntToCharCode[(this.layeredInstruments << 1) | this.patternInstruments]);
            if (this.layeredInstruments || this.patternInstruments) {
                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                    buffer.push(base64IntToCharCode[this.channels[channelIndex].instruments.length - Config.instrumentCountMin]);
                }
            }
            buffer.push(111);
            for (let channelIndex = 0; channelIndex < this.pitchChannelCount; channelIndex++) {
                buffer.push(base64IntToCharCode[this.channels[channelIndex].octave]);
            }
            for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                for (let i = 0; i < this.channels[channelIndex].instruments.length; i++) {
                    const instrument = this.channels[channelIndex].instruments[i];
                    buffer.push(84, base64IntToCharCode[instrument.type]);
                    buffer.push(118, base64IntToCharCode[(instrument.volume + Config.volumeRange / 2) >> 6], base64IntToCharCode[(instrument.volume + Config.volumeRange / 2) & 0x3f]);
                    
                    
                    
                    buffer.push(117, base64IntToCharCode[instrument.preset >> 6], base64IntToCharCode[instrument.preset & 63]);
                    buffer.push(102);
                    buffer.push(base64IntToCharCode[+instrument.eqFilterType]);
                    if (instrument.eqFilterType) {
                        buffer.push(base64IntToCharCode[instrument.eqFilterSimpleCut]);
                        buffer.push(base64IntToCharCode[instrument.eqFilterSimplePeak]);
                    }
                    else {
                        if (instrument.eqFilter == null) {
                            buffer.push(base64IntToCharCode[0]);
                            console.log("Null EQ filter settings detected in toBase64String for channelIndex " + channelIndex + ", instrumentIndex " + i);
POPUP(innerWidth/2-150, innerHeight/2-100 + window.scrollY
,"EqFilter Error",
"<text style='color:black'>"+
"Null EQ filter settings detected in toBase64String for channelIndex " + channelIndex + ", instrumentIndex " + i +"</text>",  "#00afdf"
);
                        }
                        else {
                            buffer.push(base64IntToCharCode[instrument.eqFilter.controlPointCount]);
                            for (let j = 0; j < instrument.eqFilter.controlPointCount; j++) {
                                const point = instrument.eqFilter.controlPoints[j];
                                buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);
                            }
                        }
                        let usingSubFilterBitfield = 0;
                        for (let j = 0; j < Config.filterMorphCount - 1; j++) {
                            usingSubFilterBitfield |= (+(instrument.eqSubFilters[j + 1] != null) << j);
                        }
                        buffer.push(base64IntToCharCode[usingSubFilterBitfield >> 6], base64IntToCharCode[usingSubFilterBitfield & 63]);
                        for (let j = 0; j < Config.filterMorphCount - 1; j++) {
                            if (usingSubFilterBitfield & (1 << j)) {
                                buffer.push(base64IntToCharCode[instrument.eqSubFilters[j + 1].controlPointCount]);
                                for (let k = 0; k < instrument.eqSubFilters[j + 1].controlPointCount; k++) {
                                    const point = instrument.eqSubFilters[j + 1].controlPoints[k];
                                    buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);
                                }
                            }
                        }
                    }
              buffer.push(113, base64IntToCharCode[(instrument.effects >> 12) & 63], base64IntToCharCode[(instrument.effects >> 6) & 63], base64IntToCharCode[instrument.effects & 63]);
              
                    if (effectsIncludeNoteFilter(instrument.effects)) {
                        buffer.push(base64IntToCharCode[+instrument.noteFilterType]);
                        if (instrument.noteFilterType) {
                            buffer.push(base64IntToCharCode[instrument.noteFilterSimpleCut]);
                            buffer.push(base64IntToCharCode[instrument.noteFilterSimplePeak]);
                        }
                        else {
                            if (instrument.noteFilter == null) {
                                buffer.push(base64IntToCharCode[0]);
                                console.log("Null note filter settings detected in toBase64String for channelIndex " + channelIndex + ", instrumentIndex " + i);
POPUP(innerWidth/2-150, innerHeight/2-100 + window.scrollY
,"EqFilter Error",
"<text style='color:black'>"+
"Null note filter settings detected in toBase64String for channelIndex " + channelIndex + ", instrumentIndex " + i +

"</text>",  "#00afdf"
);
                            }
                            else {
                                buffer.push(base64IntToCharCode[instrument.noteFilter.controlPointCount]);
                                for (let j = 0; j < instrument.noteFilter.controlPointCount; j++) {
                                    const point = instrument.noteFilter.controlPoints[j];
                                    buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);
                                }
                            }
                            let usingSubFilterBitfield = 0;
                            for (let j = 0; j < Config.filterMorphCount - 1; j++) {
                                usingSubFilterBitfield |= (+(instrument.noteSubFilters[j + 1] != null) << j);
                            }
                            buffer.push(base64IntToCharCode[usingSubFilterBitfield >> 6], base64IntToCharCode[usingSubFilterBitfield & 63]);
                            for (let j = 0; j < Config.filterMorphCount - 1; j++) {
                                if (usingSubFilterBitfield & (1 << j)) {
                                    buffer.push(base64IntToCharCode[instrument.noteSubFilters[j + 1].controlPointCount]);
                                    for (let k = 0; k < instrument.noteSubFilters[j + 1].controlPointCount; k++) {
                                        const point = instrument.noteSubFilters[j + 1].controlPoints[k];
                                        buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);
                                    }
                                }
                            }
                        }
                    }
                    if (effectsIncludeTransition(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.transition]);
                    }
                    if (effectsIncludeChord(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.chord]);
                        if (instrument.chord == Config.chords.dictionary["arpeggio"].index) {
                            buffer.push(base64IntToCharCode[instrument.arpeggioSpeed]);
                            buffer.push(base64IntToCharCode[+instrument.fastTwoNoteArp]);
                        }
                    }
                    if (effectsIncludePitchShift(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.pitchShift]);
                    }
                    if (effectsIncludeDetune(instrument.effects)) {
                        buffer.push(base64IntToCharCode[(instrument.detune - Config.detuneMin) >> 6], base64IntToCharCode[(instrument.detune - Config.detuneMin) & 0x3F]);
                    }
                    if (effectsIncludeVibrato(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.vibrato]);
                        if (instrument.vibrato == Config.vibratos.length) {
                            buffer.push(base64IntToCharCode[Math.round(instrument.vibratoDepth * 25)]);
                            buffer.push(base64IntToCharCode[instrument.vibratoSpeed]);
                            buffer.push(base64IntToCharCode[instrument.vibratoDelay]);
                            buffer.push(base64IntToCharCode[instrument.vibratoType]);
                        }
                    }
                    if (effectsIncludeDistortion(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.distortion]);
                        buffer.push(base64IntToCharCode[+instrument.aliases]);
                    }
                    if (effectsIncludeBitcrusher(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.bitcrusherFreq], base64IntToCharCode[instrument.bitcrusherQuantization]);
                    }
                    if (effectsIncludePanning(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.pan >> 6], base64IntToCharCode[instrument.pan & 0x3f]);
                        buffer.push(base64IntToCharCode[instrument.panDelay]);
                    }
                    if (effectsIncludeChorus(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.chorus]);
                    }
                    if (effectsIncludeEcho(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.echoSustain], base64IntToCharCode[instrument.echoDelay]);
                    }
                    if (effectsIncludeReverb(instrument.effects)) {
                        buffer.push(base64IntToCharCode[instrument.reverb]);
                    }
                    
if (effectsIncludeRingModulation(instrument.effects)) {
 buffer.push(base64IntToCharCode[instrument.ringModulation]);
 buffer.push(base64IntToCharCode[instrument.ringModulationHz]);
 buffer.push(base64IntToCharCode[instrument.ringModWaveformIndex]);
 buffer.push(base64IntToCharCode[(instrument.ringModPulseWidth)]);
 buffer.push(base64IntToCharCode[(instrument.ringModHzOffset - Config.rmHzOffsetMin) >> 6], base64IntToCharCode[(instrument.ringModHzOffset - Config.rmHzOffsetMin) & 0x3F]);
}
                    
                    if (instrument.type != 4) {
                        buffer.push(100, base64IntToCharCode[instrument.fadeIn], base64IntToCharCode[instrument.fadeOut]);
                        buffer.push(base64IntToCharCode[+instrument.clicklessTransition]);
                    }
                    if (instrument.type == 5 || instrument.type == 7) {
                        buffer.push(72);
                        const harmonicsBits = new BitFieldWriter();
                        for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                            harmonicsBits.write(Config.harmonicsControlPointBits, instrument.harmonicsWave.harmonics[i]);
                        }
                        harmonicsBits.encodeBase64(buffer);
                    }
                    if (instrument.type == 0) {
                    	
buffer.push(119);
 
var wave = instrument.chipWave >>> 0; 
buffer.push(
	base64IntToCharCode[(wave >> 30) & 63],
	base64IntToCharCode[(wave >> 24) & 63],
	base64IntToCharCode[(wave >> 18) & 63],
	base64IntToCharCode[(wave >> 12) & 63],
	base64IntToCharCode[(wave >> 6)  & 63],
	base64IntToCharCode[wave & 63]
);

                        
                        
buffer.push(104, base64IntToCharCode[instrument.unison]);
if (instrument.unison == Config.unisons.length){
	encodeUnisonSettings(buffer, instrument.unisonVoices, instrument.unisonSpread, instrument.unisonOffset, instrument.unisonExpression, instrument.unisonSign);}
	
buffer.push(121);
const encodedLoopMode = ((clamp(0, 31 + 1, instrument.chipWaveLoopMode) << 1) |
	(instrument.isUsingAdvancedLoopControls ? 1 : 0));
buffer.push(base64IntToCharCode[encodedLoopMode]);
//alert(base64IntToCharCode[encodedLoopMode])
const encodedReleaseMode = ((clamp(0, 31 + 1, 0) << 1) |
	(instrument.chipWavePlayBackwards ? 1 : 0));
buffer.push(base64IntToCharCode[encodedReleaseMode]);
encode32BitNumber(buffer, instrument.chipWaveLoopStart);
encode32BitNumber(buffer, instrument.chipWaveLoopEnd);
encode32BitNumber(buffer, instrument.chipWaveStartOffset);
	
                    } 
                    else if (instrument.type == 1) {
                      
                      
                      
                     //   buffer.push(65, base64IntToCharCode[instrument.algorithm]);
const algorithm1 = instrument.algorithm;
buffer.push(
  65,
  base64IntToCharCode[(algorithm1 >> 6) & 63], // large 6 
  base64IntToCharCode[algorithm1 & 63] // small 6  
);
                        
                        
                        buffer.push(70, base64IntToCharCode[instrument.feedbackType]);
                        buffer.push(66, base64IntToCharCode[instrument.feedbackAmplitude]);
                        buffer.push(81);
                        for (let o = 0; o < Config.operatorCount; o++) {
                            buffer.push(base64IntToCharCode[instrument.operators[o].frequency]);
                        }
                        buffer.push(80);
                        for (let o = 0; o < Config.operatorCount; o++) {
                            buffer.push(base64IntToCharCode[instrument.operators[o].amplitude]);
                        }
                        buffer.push(82);
                        for (let o = 0; o < Config.operatorCount; o++) {
                            buffer.push(base64IntToCharCode[instrument.operators[o].waveform]);
                            if (instrument.operators[o].waveform == 3) {
                                buffer.push(base64IntToCharCode[instrument.operators[o].pulseWidth]);
                            }
                        }
                    }
                    else if (instrument.type == 8) {
                      //  buffer.push(119, base64IntToCharCode[instrument.chipWave]);
buffer.push(104, base64IntToCharCode[instrument.unison]);
if (instrument.unison == Config.unisons.length)
	encodeUnisonSettings(buffer, instrument.unisonVoices, instrument.unisonSpread, instrument.unisonOffset, instrument.unisonExpression, instrument.unisonSign);
                        buffer.push(77);
                        
                        for (let j = 0; j < 64; j++) {
                            buffer.push(base64IntToCharCode[(instrument.customChipWave[j] + 24)]);
                        }
                        
                    }
                    else if (instrument.type == 2) {
                        buffer.push(119, base64IntToCharCode[instrument.chipNoise]);
                    }
                    else if (instrument.type == 3) {
                        buffer.push(83);
                        const spectrumBits = new BitFieldWriter();
                        for (let i = 0; i < Config.spectrumControlPoints; i++) {
                            spectrumBits.write(Config.spectrumControlPointBits, instrument.spectrumWave.spectrum[i]);
                        }
                        spectrumBits.encodeBase64(buffer);
                    }
                    else if (instrument.type == 4) {
                        buffer.push(122);
                        for (let j = 0; j < Config.drumCount; j++) {
                            buffer.push(base64IntToCharCode[instrument.drumsetEnvelopes[j]]);
                        }
                        buffer.push(83);
                        const spectrumBits = new BitFieldWriter();
                        for (let j = 0; j < Config.drumCount; j++) {
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                spectrumBits.write(Config.spectrumControlPointBits, instrument.drumsetSpectrumWaves[j].spectrum[i]);
                            }
                        }
                        spectrumBits.encodeBase64(buffer);
                    }
                    else if (instrument.type == 5) {
 buffer.push(104, base64IntToCharCode[instrument.unison]);
if (instrument.unison == Config.unisons.length)
	encodeUnisonSettings(buffer, instrument.unisonVoices, instrument.unisonSpread, instrument.unisonOffset, instrument.unisonExpression, instrument.unisonSign);
                    }
                    else if (instrument.type == 6) {
                        buffer.push(87, base64IntToCharCode[instrument.pulseWidth]);
                        
buffer.push(104, base64IntToCharCode[instrument.unison]);
if (instrument.unison == Config.unisons.length)
	encodeUnisonSettings(buffer, instrument.unisonVoices, instrument.unisonSpread, instrument.unisonOffset, instrument.unisonExpression, instrument.unisonSign);
                        
                    }
                    else if (instrument.type == 7) {
buffer.push(104, base64IntToCharCode[instrument.unison]);
if (instrument.unison == Config.unisons.length)
	encodeUnisonSettings(buffer, instrument.unisonVoices, instrument.unisonSpread, instrument.unisonOffset, instrument.unisonExpression, instrument.unisonSign);
	
                        buffer.push(73, base64IntToCharCode[instrument.stringSustain]);
                    }
                    else if (instrument.type == 9) ;
                    else {
                        throw new Error("Unknown instrument type.");
                    }
                    buffer.push(69, base64IntToCharCode[instrument.envelopeCount]);
                    for (let envelopeIndex = 0; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                        buffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].target]);
                        
                        if (Config.instrumentAutomationTargets[instrument.envelopes[envelopeIndex].target].maxCount > 1) {
                            buffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].index]);
                            
                        }
                        // base64 base64
const envelope = instrument.envelopes[envelopeIndex].envelope; // num 0–4095
buffer.push(
	base64IntToCharCode[(envelope >> 6) & 63],  // large 6 
	base64IntToCharCode[envelope & 63]          // small 6  
);

                   //     buffer.push( instrument.envelopes[envelopeIndex].envelope ); // deleted  base64IntToCharCode
                        
                    }
                }
            }
            buffer.push(98);
            bits = new BitFieldWriter();
            let neededBits = 0;
            while ((1 << neededBits) < this.patternsPerChannel + 1)
                neededBits++;
            for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++)
                for (let i = 0; i < this.barCount; i++) {
                    bits.write(neededBits, this.channels[channelIndex].bars[i]);
                }
            bits.encodeBase64(buffer);
            buffer.push(112); 
            bits = new BitFieldWriter();
            const shapeBits = new BitFieldWriter();
            const bitsPerNoteSize = Song.getNeededBits(Config.noteSizeMax);
            for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                const channel = this.channels[channelIndex];
                const maxInstrumentsPerPattern = this.getMaxInstrumentsPerPattern(channelIndex);
                const isNoiseChannel = this.getChannelIsNoise(channelIndex);
                const isModChannel = this.getChannelIsMod(channelIndex);
                const neededInstrumentCountBits = Song.getNeededBits(maxInstrumentsPerPattern - Config.instrumentCountMin);
                const neededInstrumentIndexBits = Song.getNeededBits(channel.instruments.length - 1);
                if (isModChannel) {
                    const neededModInstrumentIndexBits = Song.getNeededBits(this.getMaxInstrumentsPerChannel() + 2);
                    for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                        let instrument = this.channels[channelIndex].instruments[instrumentIndex];
                        for (let mod = 0; mod < Config.modCount; mod++) {
                            const modChannel = instrument.modChannels[mod];
                            const modInstrument = instrument.modInstruments[mod];
                            const modSetting = instrument.modulators[mod];
                            const modFilter = instrument.modFilterTypes[mod];
                            let status = Config.modulators[modSetting].forSong ? 2 : 0;
                            if (modSetting == Config.modulators.dictionary["none"].index)
                                status = 3;
                            bits.write(2, status);
                            if (status == 0 || status == 1) {
                                bits.write(8, modChannel);
                                bits.write(neededModInstrumentIndexBits, modInstrument);
                            }
                            if (status != 3) {
                                bits.write(6, modSetting);
                            }
                            if (Config.modulators[instrument.modulators[mod]].name == "eq filter" || Config.modulators[instrument.modulators[mod]].name == "note filter") {
                                bits.write(6, modFilter);
                            }
                        }
                    }
                }
                const octaveOffset = (isNoiseChannel || isModChannel) ? 0 : channel.octave * Config.pitchesPerOctave;
                let lastPitch = (isNoiseChannel ? 4 : octaveOffset);
                const recentPitches = isModChannel ? [0, 1, 2, 3, 4, 5] : (isNoiseChannel ? [4, 6, 7, 2, 3, 8, 0, 10] : [0, 7, 12, 19, 24, -5, -12]);
                const recentShapes = [];
                for (let i = 0; i < recentPitches.length; i++) {
                    recentPitches[i] += octaveOffset;
                }
                for (const pattern of channel.patterns) {
                    if (this.patternInstruments) {
                        const instrumentCount = validateRange(Config.instrumentCountMin, maxInstrumentsPerPattern, pattern.instruments.length);
                        bits.write(neededInstrumentCountBits, instrumentCount - Config.instrumentCountMin);
                        for (let i = 0; i < instrumentCount; i++) {
                            bits.write(neededInstrumentIndexBits, pattern.instruments[i]);
                        }
                    }
                    if (pattern.notes.length > 0) {
                        bits.write(1, 1);
                        let curPart = 0;
                        for (const note of pattern.notes) {
                            if (note.start < curPart && isModChannel) {
                                bits.write(2, 0);
                                bits.write(1, 1);
                                bits.writePartDuration(curPart - note.start);
                            }
                            if (note.start > curPart) {
                                bits.write(2, 0);
                                if (isModChannel)
                                    bits.write(1, 0);
                                bits.writePartDuration(note.start - curPart);
                                
                            }
                            shapeBits.clear();
                            if (note.pitches.length == 1) {
                                shapeBits.write(1, 0);
                            }
                            else {
                                shapeBits.write(1, 1);
                                shapeBits.write(3, note.pitches.length - 2);
                            }
                            shapeBits.writePinCount(note.pins.length - 1);
                            if (!isModChannel) {
                                shapeBits.write(bitsPerNoteSize, note.pins[0].size);
                            }
                            else {
                                shapeBits.write(18, note.pins[0].size);
                            }
                            let shapePart = 0;
                            let startPitch = note.pitches[0];
                            let currentPitch = startPitch;
                            const pitchBends = [];
                            for (let i = 1; i < note.pins.length; i++) {
                                const pin = note.pins[i];
                                const nextPitch = startPitch + pin.interval;
                                if (currentPitch != nextPitch) {
                                    shapeBits.write(1, 1);
                                    pitchBends.push(nextPitch);
                                    currentPitch = nextPitch;
                                }
                                else {
                                    shapeBits.write(1, 0);
                                }
                                shapeBits.writePartDuration(pin.time - shapePart);
                                shapePart = pin.time;
                                if (!isModChannel) {
                                    shapeBits.write(bitsPerNoteSize, pin.size);
                                }
                                else {
                                    shapeBits.write(18, pin.size);
                                }
                            }
                            const shapeString = String.fromCharCode.apply(null, shapeBits.encodeBase64([]));
                            const shapeIndex = recentShapes.indexOf(shapeString);
                            if (shapeIndex == -1) {
                                bits.write(2, 1);
                                bits.concat(shapeBits);
                            }
                            else {
                                bits.write(1, 1);
                                bits.writeLongTail(0, 0, shapeIndex);
                                recentShapes.splice(shapeIndex, 1);
                            }
                            recentShapes.unshift(shapeString);
                            if (recentShapes.length > 10)
                                recentShapes.pop();
                            const allPitches = note.pitches.concat(pitchBends);
                            for (let i = 0; i < allPitches.length; i++) {
                                const pitch = allPitches[i];
                                const pitchIndex = recentPitches.indexOf(pitch);
                                if (pitchIndex == -1) {
                                    let interval = 0;
                                    let pitchIter = lastPitch;
                                    if (pitchIter < pitch) {
                                        while (pitchIter != pitch) {
                                            pitchIter++;
                                            if (recentPitches.indexOf(pitchIter) == -1)
                                                interval++;
                                        }
                                    }
                                    else {
                                        while (pitchIter != pitch) {
                                            pitchIter--;
                                            if (recentPitches.indexOf(pitchIter) == -1)
                                                interval--;
                                        }
                                    }
                                    bits.write(1, 0);
                                    bits.writePitchInterval(interval);
                                }
                                else {
                                    bits.write(1, 1);
                                    bits.write(4, pitchIndex);
                                    recentPitches.splice(pitchIndex, 1);
                                }
                                recentPitches.unshift(pitch);
                                if (recentPitches.length > 16)
                                    recentPitches.pop();
                                if (i == note.pitches.length - 1) {
                                    lastPitch = note.pitches[0];
                                }
                                else {
                                    lastPitch = pitch;
                                }
                            }
                            if (note.start == 0) {
                                bits.write(1, note.continuesLastPattern ? 1 : 0);
                            }
                            curPart = note.end;
                        }
                        if (curPart < this.beatsPerBar * Config.partsPerBeat + (+isModChannel)) {
                            bits.write(2, 0);
                            if (isModChannel)
                                bits.write(1, 0);
                            bits.writePartDuration(this.beatsPerBar * Config.partsPerBeat + (+isModChannel) - curPart);
                        }
                    }
                    else {
                        bits.write(1, 0);
                    }
                }
            }
            let stringLength = bits.lengthBase64();
            let digits = [];
            while (stringLength > 0) {
                digits.unshift(base64IntToCharCode[stringLength & 0x3f]);
                stringLength = stringLength >> 6;
            }
            buffer.push(base64IntToCharCode[digits.length]);
            Array.prototype.push.apply(buffer, digits);
            bits.encodeBase64(buffer);
            const maxApplyArgs = 64000;
            if (buffer.length < maxApplyArgs) {
                return String.fromCharCode.apply(null, buffer);
            }
            else {
                let result = "";
                for (let i = 0; i < buffer.length; i += maxApplyArgs) {
                    result += String.fromCharCode.apply(null, buffer.slice(i, i + maxApplyArgs));
                }
                return result;
            }
        }
        static _envelopeFromLegacyIndex(legacyIndex) {
           
            if (legacyIndex == 0)
                legacyIndex = 1;
            else if (legacyIndex == 1)
                legacyIndex = 0;
                
            return Config.envelopes[clamp(0, Config.envelopes.length, legacyIndex)];
        }
        
        


        
        
        fromBase64String(compressed) {
            if (compressed == null || compressed == "") {
                this.initToDefault(true);
                
                
                return;
            }
            let charIndex = 0;
            while (compressed.charCodeAt(charIndex) <= 32)
                charIndex++;
            if (compressed.charCodeAt(charIndex) == 35)
                charIndex++;
            if (compressed.charCodeAt(charIndex) == 123) {
                this.fromJsonObject(JSON.parse(charIndex == 0 ? compressed : compressed.substring(charIndex)));
                return;
            }
            const variantTest = compressed.charCodeAt(charIndex);
            let fromBeepBox;
            let fromJummBox;
            if (variantTest == 0x6A) {
                fromBeepBox = false;
                fromJummBox = true;
                charIndex++;
            }
            else {
                fromBeepBox = true;
                fromJummBox = false;
            }
            const version = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
            if (fromBeepBox && (version == -1 || version > Song._latestBeepboxVersion || version < Song._oldestBeepboxVersion))
                return;
            if (fromJummBox && (version == -1 || version > Song._latestJummBoxVersion || version < Song._oldestJummBoxVersion))
                return;
            const beforeTwo = version < 2;
            const beforeThree = version < 3;
            const beforeFour = version < 4;
            const beforeFive = version < 5;
            const beforeSix = version < 6;
            const beforeSeven = version < 7;
            const beforeEight = version < 8;
            const beforeNine = version < 9;
            this.initToDefault((fromBeepBox && beforeNine) || (fromJummBox && beforeFive));
            const forceSimpleFilter = (fromBeepBox && beforeNine || fromJummBox && beforeFive);
            if (beforeThree && fromBeepBox) {
                for (const channel of this.channels) {
                    channel.instruments[0].transition = Config.transitions.dictionary["interrupt"].index;
                    channel.instruments[0].effects |= 1 << 10;
                }
                this.channels[3].instruments[0].chipNoise = 0;
            }
            let legacySettingsCache = null;
            if ((fromBeepBox && beforeNine) || (fromJummBox && beforeFive)) {
                legacySettingsCache = [];
                for (let i = legacySettingsCache.length; i < this.getChannelCount(); i++) {
                    legacySettingsCache[i] = [];
                    for (let j = 0; j < Config.instrumentCountMin; j++)
                        legacySettingsCache[i][j] = {};
                }
            }
            let legacyGlobalReverb = 0;
            let instrumentChannelIterator = 0;
            let instrumentIndexIterator = -1;
            let command;
            let useSlowerArpSpeed = false;
            let useFastTwoNoteArp = false;
           
  //    console.log((":" + (command) + " at index " + (charIndex) + " "+compressed.charCodeAt(charIndex)))
      

            while (charIndex < compressed.length)
               
                switch (command = compressed.charCodeAt(charIndex++)) {
                    
                    

                    case 78 :
                        {
                             
                            var songNameLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            this.title = decodeURIComponent(compressed.substring(charIndex, charIndex + songNameLength));
                            document.title = this.title + " - " + EditorConfig.versionDisplayName;
                            charIndex += songNameLength;
                        }
                        break;
case 110:
{
    this.pitchChannelCount = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) |
base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
    this.modChannelCount = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) |
base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
    this.noiseChannelCount = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) |
                              base64CharCodeToInt[compressed.charCodeAt(charIndex++)];

    if (fromBeepBox || beforeTwo) {
        this.modChannelCount = 0;
    }

    this.pitchChannelCount = validateRange(Config.pitchChannelCountMin, Config.pitchChannelCountMax, this.pitchChannelCount);
    this.noiseChannelCount = validateRange(Config.noiseChannelCountMin, Config.noiseChannelCountMax, this.noiseChannelCount);
    this.modChannelCount = validateRange(Config.modChannelCountMin, Config.modChannelCountMax, this.modChannelCount);

    for (let channelIndex = this.channels.length; channelIndex < this.getChannelCount(); channelIndex++) {
        this.channels[channelIndex] = new Channel();
    }
    this.channels.length = this.getChannelCount();

    if ((fromBeepBox && beforeNine) || (fromJummBox && beforeFive)) {
        for (let i = legacySettingsCache.length; i < this.getChannelCount(); i++) {
            legacySettingsCache[i] = [];
            for (let j = 0; j < Config.instrumentCountMin; j++)
                legacySettingsCache[i][j] = {};
        }
    }
}
break;

                    case 115:
                        {
                            this.scale = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            if (fromBeepBox)
                                this.scale = 0;
                        }
                        break;
                    case 107:
                        {
                            if (beforeSeven && fromBeepBox) {
                                this.key = clamp(0, Config.keys.length, 11 - base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                            else {
                                this.key = clamp(0, Config.keys.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                        }
                        break;
                    case 108:
                        {
                            if (beforeFive && fromBeepBox) {
                                this.loopStart = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            }
                            else {
                                this.loopStart = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            }
                        }
                        break;
                    case 101:
                        {
                            if (beforeFive && fromBeepBox) {
                                this.loopLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            }
                            else {
                                this.loopLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                            }
                        }
                        break;
                    case 116:
                        {
                            if (beforeFour && fromBeepBox) {
                                this.tempo = [95, 120, 151, 190][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
                            }
                            else if (beforeSeven && fromBeepBox) {
                                this.tempo = [88, 95, 103, 111, 120, 130, 140, 151, 163, 176, 190, 206, 222, 240, 259][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
                            }
                            else {
                                this.tempo = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                            this.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, this.tempo);
                        }
                        break;
                    case 109:
                        {
                            if (beforeNine && fromBeepBox) {
                                legacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 12;
                                legacyGlobalReverb = clamp(0, Config.reverbRange, legacyGlobalReverb);
                            }
                            else if (beforeFive && fromJummBox) {
                                legacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                legacyGlobalReverb = clamp(0, Config.reverbRange, legacyGlobalReverb);
                            }
                            else ;
                        }
                        break;
                    case 97:
                        {
                            if (beforeThree && fromBeepBox) {
                                this.beatsPerBar = [6, 7, 8, 9, 10][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
                            }
                            else {
                                this.beatsPerBar = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                            }
                            this.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, this.beatsPerBar));
                        }
                        break;
                    case 103:
                        {
                            const barCount = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                            this.barCount = validateRange(Config.barCountMin, Config.barCountMax, barCount);
                            for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                for (let bar = this.channels[channelIndex].bars.length; bar < this.barCount; bar++) {
                                    this.channels[channelIndex].bars[bar] = (bar < 4) ? 1 : 0;
                                }
                                this.channels[channelIndex].bars.length = this.barCount;
                            }
                        }
                        break;
                    case 106:
                        {
                            let patternsPerChannel;
                            if (beforeEight && fromBeepBox) {
                                patternsPerChannel = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                            }
                            else {
                                patternsPerChannel = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                            }
                            this.patternsPerChannel = validateRange(1, Config.barCountMax, patternsPerChannel);
                            const channelCount = this.getChannelCount();
                            for (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {
                                const patterns = this.channels[channelIndex].patterns;
                                for (let pattern = patterns.length; pattern < this.patternsPerChannel; pattern++) {
                                    patterns[pattern] = new Pattern();
                                }
                                patterns.length = this.patternsPerChannel;
                            }
                        }
                        break;
                    case 105:
                        {
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                const instrumentsPerChannel = validateRange(Config.instrumentCountMin, Config.patternInstrumentCountMax, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);
                                this.layeredInstruments = false;
                                this.patternInstruments = (instrumentsPerChannel > 1);
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    const isNoiseChannel = channelIndex >= this.pitchChannelCount && channelIndex < this.pitchChannelCount + this.noiseChannelCount;
                                    const isModChannel = channelIndex >= this.pitchChannelCount + this.noiseChannelCount;
                                    for (let instrumentIndex = this.channels[channelIndex].instruments.length; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {
                                        this.channels[channelIndex].instruments[instrumentIndex] = new Instrument(isNoiseChannel, isModChannel);
                                    }
                                    this.channels[channelIndex].instruments.length = instrumentsPerChannel;
                                    if (beforeSix && fromBeepBox) {
                                        for (let instrumentIndex = 0; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {
                                            this.channels[channelIndex].instruments[instrumentIndex].setTypeAndReset(isNoiseChannel ? 2 : 0, isNoiseChannel, isModChannel);
                                        }
                                    }
                                    for (let j = legacySettingsCache[channelIndex].length; j < instrumentsPerChannel; j++) {
                                        legacySettingsCache[channelIndex][j] = {};
                                    }
                                }
                            }
                            else {
                                const instrumentsFlagBits = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                this.layeredInstruments = (instrumentsFlagBits & (1 << 1)) != 0;
                                this.patternInstruments = (instrumentsFlagBits & (1 << 0)) != 0;
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    let instrumentCount = 1;
                                    if (this.layeredInstruments || this.patternInstruments) {
                                        instrumentCount = validateRange(Config.instrumentCountMin, this.getMaxInstrumentsPerChannel(), base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);
                                    }
                                    const channel = this.channels[channelIndex];
                                    const isNoiseChannel = this.getChannelIsNoise(channelIndex);
                                    const isModChannel = this.getChannelIsMod(channelIndex);
                                    for (let i = channel.instruments.length; i < instrumentCount; i++) {
                                        channel.instruments[i] = new Instrument(isNoiseChannel, isModChannel);
                                    }
                                    channel.instruments.length = instrumentCount;
                                }
                            }
                        }
                        break;
                    case 114:
                        {
                            this.rhythm = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            if (fromJummBox && beforeThree || fromBeepBox) {
                                if (this.rhythm == Config.rhythms.dictionary["÷3 (triplets)"].index || this.rhythm == Config.rhythms.dictionary["÷6"].index) {
                                    useSlowerArpSpeed = true;
                                }
                                if (this.rhythm >= Config.rhythms.dictionary["÷6"].index) {
                                    useFastTwoNoteArp = true;
                                }
                            }
                        }
                        break;
                    case 111:
                        {
                            if (beforeThree && fromBeepBox) {
                                const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);
                                if (channelIndex >= this.pitchChannelCount)
                                    this.channels[channelIndex].octave = 0;
                            }
                            else if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);
                                    if (channelIndex >= this.pitchChannelCount)
                                        this.channels[channelIndex].octave = 0;
                                }
                            }
                            else {
                                for (let channelIndex = 0; channelIndex < this.pitchChannelCount; channelIndex++) {
                                    this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                            }
                        }
                        break;
                    case 84:
                        {
                            instrumentIndexIterator++;
                            if (instrumentIndexIterator >= this.channels[instrumentChannelIterator].instruments.length) {
                                instrumentChannelIterator++;
                                instrumentIndexIterator = 0;
                            }
                            validateRange(0, this.channels.length - 1, instrumentChannelIterator);
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            let instrumentType = validateRange(0, 10 - 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            if (fromJummBox && beforeFive) {
                                if (instrumentType == 7) {
                                    instrumentType = 8;
                                }
                                else if (instrumentType == 8) {
                                    instrumentType = 9;
                                }
                            }
                            instrument.setTypeAndReset(instrumentType, instrumentChannelIterator >= this.pitchChannelCount && instrumentChannelIterator < this.pitchChannelCount + this.noiseChannelCount, instrumentChannelIterator >= this.pitchChannelCount + this.noiseChannelCount);
                            if (((beforeSeven && fromBeepBox) || (beforeTwo && fromJummBox)) && (instrumentType == 0 || instrumentType == 8 || instrumentType == 6)) {
                                instrument.aliases = true;
                            }
                            if (useSlowerArpSpeed) {
                                instrument.arpeggioSpeed = 9;
                            }
                            if (useFastTwoNoteArp) {
                                instrument.fastTwoNoteArp = true;
                            }
                            if (beforeSeven && fromBeepBox) {
                                instrument.effects = 0;
                                if (instrument.chord != Config.chords.dictionary["simultaneous"].index) {
                                    instrument.effects |= 1 << 11;
                                }
                            }
                        }
                        break;
                    case 117:
                        {
                            const presetValue = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = presetValue;
                            if (fromJummBox && beforeFive) {
                                if (this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset == 7) {
                                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = 8;
                                }
                            }
                        }
                        break;
                    case 119:
                        {
if (beforeThree && fromBeepBox) {
 const legacyWaves = [1, 2, 3, 4, 5, 6, 7, 8, 0];
 const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
 const instrument = this.channels[channelIndex].instruments[0];
var wave = 0;
for (var i = 0; i < 6; i++) {
	wave = (wave << 6) | legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
}
this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = wave;

                                instrument.convertLegacySettings(legacySettingsCache[channelIndex][0], forceSimpleFilter);
                            }
                            else if (beforeSix && fromBeepBox) {
                                const legacyWaves = [1, 2, 3, 4, 5, 6, 7, 8, 0];
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    for (const instrument of this.channels[channelIndex].instruments) {
                                        if (channelIndex >= this.pitchChannelCount) {
                                           instrument.chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                            
                                        }
                                        else {
var wave = 0;
for (var i = 0; i < 6; i++) {
	wave = (wave << 6) | legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
}
this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = wave;
                                        }
                                    }
                                }
                            }
                            else if (beforeSeven && fromBeepBox) {
                                const legacyWaves = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
                                if (instrumentChannelIterator >= this.pitchChannelCount) {
                                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipNoise =  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                                }
                                else {
var wave = 0;
for (var i = 0; i < 6; i++) {
	wave = (wave << 6) | legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
}
this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = wave;
                                }
                            }
                            else {
                                if (instrumentChannelIterator >= this.pitchChannelCount) {
                                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipNoise =  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                                }
                                else {
var wave = 0;
for (var i = 0; i < 6; i++) {
	wave = (wave << 6) | base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
}
this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = wave;


            }
                            }
 
                        }
                        break;
                    case 102:
                        {
                          
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                if (beforeSeven && fromBeepBox) {
                                    const legacyToCutoff = [10, 6, 3, 0, 8, 5, 2];
                                    const legacyToEnvelope = ["none", "none", "none", "none", "decay 1", "decay 2", "decay 3"];
                                    if (beforeThree && fromBeepBox) {
                                        const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                        const instrument = this.channels[channelIndex].instruments[0];
                                        const legacySettings = legacySettingsCache[channelIndex][0];
                                        const legacyFilter = [1, 3, 4, 5][clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                                        
                                        legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                                        legacySettings.filterResonance = 0;
                                        legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];
                                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                    }
                                    else if (beforeSix && fromBeepBox) {
                                        for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                            for (let i = 0; i < this.channels[channelIndex].instruments.length; i++) {
                                                const instrument = this.channels[channelIndex].instruments[i];
                                                const legacySettings = legacySettingsCache[channelIndex][i];
                                                const legacyFilter = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);
                                                if (channelIndex < this.pitchChannelCount) {
                                                    legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                                                    legacySettings.filterResonance = 0;
                                                    legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];
                                                }
                                                else {
                                                    legacySettings.filterCutoff = 10;
                                                    legacySettings.filterResonance = 0;
                                                    legacySettings.filterEnvelope = Config.envelopes.dictionary["none"];
                                                }
                                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                            }
                                        }
                                    }
                                    else {
                                        const legacyFilter = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                        const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                        legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                                        legacySettings.filterResonance = 0;
                                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                    }
                                }
                                else {
                                    const filterCutoffRange = 11;
                                    const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                    const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                    legacySettings.filterCutoff = clamp(0, filterCutoffRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                     
                                }
                            }
                            else {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                let typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                if (fromBeepBox || typeCheck == 0) {
                                    instrument.eqFilterType = false;
                                    if (fromJummBox)
                                        typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                    const originalControlPointCount = typeCheck;
                                    instrument.eqFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalControlPointCount);
                                    for (let i = instrument.eqFilter.controlPoints.length; i < instrument.eqFilter.controlPointCount; i++) {
                                        instrument.eqFilter.controlPoints[i] = new FilterControlPoint();
                                    }
                                    for (let i = 0; i < instrument.eqFilter.controlPointCount; i++) {
                                        const point = instrument.eqFilter.controlPoints[i];
                                        point.type = clamp(0, 3, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                    for (let i = instrument.eqFilter.controlPointCount; i < originalControlPointCount; i++) {
                                        charIndex += 3;
                                    }
                                    instrument.eqSubFilters[0] = instrument.eqFilter;
                                    if (fromJummBox && !beforeFive) {
                                        let usingSubFilterBitfield = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        for (let j = 0; j < Config.filterMorphCount - 1; j++) {
                                            if (usingSubFilterBitfield & (1 << j)) {
                                                const originalSubfilterControlPointCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                                if (instrument.eqSubFilters[j + 1] == null)
                                                    instrument.eqSubFilters[j + 1] = new FilterSettings();
                                                instrument.eqSubFilters[j + 1].controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);
                                                for (let i = instrument.eqSubFilters[j + 1].controlPoints.length; i < instrument.eqSubFilters[j + 1].controlPointCount; i++) {
                                                    instrument.eqSubFilters[j + 1].controlPoints[i] = new FilterControlPoint();
                                                }
                                                for (let i = 0; i < instrument.eqSubFilters[j + 1].controlPointCount; i++) {
                                                    const point = instrument.eqSubFilters[j + 1].controlPoints[i];
                                                    point.type = clamp(0, 3, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                    point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                    point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                }
                                                for (let i = instrument.eqSubFilters[j + 1].controlPointCount; i < originalSubfilterControlPointCount; i++) {
                                                    charIndex += 3;
                                                }
                                            }
                                        }
                                    }
                                }
                                else {
                                    instrument.eqFilterType = true;
                                    instrument.eqFilterSimpleCut = clamp(0, Config.filterSimpleCutRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    instrument.eqFilterSimplePeak = clamp(0, Config.filterSimplePeakRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                            }
                        }
                        break;
                    case 121:
                        {
const encodedLoopMode = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
const isUsingAdvancedLoopControls = Boolean(encodedLoopMode & 1);
const chipWaveLoopMode = encodedLoopMode >> 1;
const encodedReleaseMode = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
const chipWavePlayBackwards = Boolean(encodedReleaseMode & 1);
const chipWaveLoopStart = decode32BitNumber(compressed, charIndex);
charIndex += 6;
const chipWaveLoopEnd = decode32BitNumber(compressed, charIndex);
charIndex += 6;
const chipWaveStartOffset = decode32BitNumber(compressed, charIndex);
charIndex += 6;
const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
instrument.isUsingAdvancedLoopControls = isUsingAdvancedLoopControls;
instrument.chipWaveLoopStart = chipWaveLoopStart;
instrument.chipWaveLoopEnd = chipWaveLoopEnd;
instrument.chipWaveLoopMode = chipWaveLoopMode;
instrument.chipWavePlayBackwards = chipWavePlayBackwards;
instrument.chipWaveStartOffset = chipWaveStartOffset;
                        }
                        break;
                        
                    case 122:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                if (instrument.type == 4) {
                                    for (let i = 0; i < Config.drumCount; i++) {
                                        instrument.drumsetEnvelopes[i] = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]).index;
                                    }
                                }
                                else {
                                	 
                                    const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                    legacySettings.filterEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                }
                            }
                            else {
                                for (let i = 0; i < Config.drumCount; i++) {
                                    instrument.drumsetEnvelopes[i] = clamp(0, Config.envelopes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                            }
                        }
                        break;
                    case 87:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            instrument.pulseWidth = clamp(0, Config.pulseWidthRange + (+(fromJummBox)), base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            if (fromBeepBox) {
                                instrument.pulseWidth = Math.round(Math.pow(0.5, (7 - instrument.pulseWidth) * Config.pulseWidthStepPower) * Config.pulseWidthRange);
                            }
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                legacySettings.pulseEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                            }
                        }
                        break;
                    case 73:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            instrument.stringSustain = clamp(0, Config.stringSustainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                        break;
                    case 100:
                        {
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                const legacySettings = [
                                    { transition: "interrupt", fadeInSeconds: 0.0, fadeOutTicks: -1 },
                                    { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: -3 },
                                    { transition: "normal", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                                    { transition: "slide in pattern", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                                    { transition: "normal", fadeInSeconds: 0.04, fadeOutTicks: 6 },
                                    { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: 48 },
                                    { transition: "normal", fadeInSeconds: 0.0125, fadeOutTicks: 72 },
                                    { transition: "normal", fadeInSeconds: 0.06, fadeOutTicks: 96 },
                                ];
                                if (beforeThree && fromBeepBox) {
                                    const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                    const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                                    const instrument = this.channels[channelIndex].instruments[0];
                                    instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                                    instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                                    instrument.transition = Config.transitions.dictionary[settings.transition].index;
                                    if (instrument.transition != Config.transitions.dictionary["normal"].index) {
                                        instrument.effects |= 1 << 10;
                                    }
                                }
                                else if (beforeSix && fromBeepBox) {
                                    for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                        for (const instrument of this.channels[channelIndex].instruments) {
                                            const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                                            instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                                            instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                                            instrument.transition = Config.transitions.dictionary[settings.transition].index;
                                            if (instrument.transition != Config.transitions.dictionary["normal"].index) {
                                                instrument.effects |= 1 << 10;
                                            }
                                        }
                                    }
                                }
                                else if (beforeFour || fromBeepBox) {
                                    const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                                    const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                    instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                                    instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                                    instrument.transition = Config.transitions.dictionary[settings.transition].index;
                                    if (instrument.transition != Config.transitions.dictionary["normal"].index) {
                                        instrument.effects |= 1 << 10;
                                    }
                                }
                                else {
                                    const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                                    const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                    instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                                    instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                                    instrument.transition = Config.transitions.dictionary[settings.transition].index;
                                    if (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] > 0) {
                                        instrument.legacyTieOver = true;
                                    }
                                    instrument.clicklessTransition = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
                                    if (instrument.transition != Config.transitions.dictionary["normal"].index || instrument.clicklessTransition) {
                                        instrument.effects |= 1 << 10;
                                    }
                                }
                            }
                            else {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.fadeIn = clamp(0, Config.fadeInRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                instrument.fadeOut = clamp(0, Config.fadeOutTicks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                if (fromJummBox)
                                    instrument.clicklessTransition = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
                            }
                        }
                        break;
                    case 99:
                        {
                        	
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                if (beforeSeven && fromBeepBox) {
                                    if (beforeThree && fromBeepBox) {
                                        const legacyEffects = [0, 3, 2, 0];
                                        const legacyEnvelopes = ["none", "none", "none", "tremolo2"];
                                        const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                        const effect = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        const instrument = this.channels[channelIndex].instruments[0];
                                        const legacySettings = legacySettingsCache[channelIndex][0];
                                        instrument.vibrato = legacyEffects[effect];
                                        if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == 1) {
                                            legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];
                                            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                        }
                                        if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                            instrument.effects |= 1 << 9;
                                        }
                                    }
                                    else if (beforeSix && fromBeepBox) {
                                        const legacyEffects = [0, 1, 2, 3, 0, 0];
                                        const legacyEnvelopes = ["none", "none", "none", "none", "tremolo5", "tremolo2"];
                                        for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                            for (let i = 0; i < this.channels[channelIndex].instruments.length; i++) {
                                                const effect = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                const instrument = this.channels[channelIndex].instruments[i];
                                                const legacySettings = legacySettingsCache[channelIndex][i];
                                                instrument.vibrato = legacyEffects[effect];
                                                if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == 1) {
                                                    legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];
                                                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                                }
                                                if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                                    instrument.effects |= 1 << 9;
                                                }
                                                if ((legacyGlobalReverb != 0 || (fromJummBox && beforeFive)) && !this.getChannelIsNoise(channelIndex)) {
                                                    instrument.effects |= 1 << 0;
                                                    instrument.reverb = legacyGlobalReverb;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        const legacyEffects = [0, 1, 2, 3, 0, 0];
                                        const legacyEnvelopes = ["none", "none", "none", "none", "tremolo5", "tremolo2"];
                                        const effect = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                        const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                        instrument.vibrato = legacyEffects[effect];
                                        if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == 1) {
                                            legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];
                                            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                        }
                                        if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                            instrument.effects |= 1 << 9;
                                        }
                                        if (legacyGlobalReverb != 0 || (fromJummBox && beforeFive)) {
                                            instrument.effects |= 1 << 0;
                                            instrument.reverb = legacyGlobalReverb;
                                        }
                                    }
                                }
                                else {
                                    const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                    const vibrato = clamp(0, Config.vibratos.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    instrument.vibrato = vibrato;
                                    if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                        instrument.effects |= 1 << 9;
                                    }
                                    if (vibrato == Config.vibratos.length) {
                                        instrument.vibratoDepth = clamp(0, Config.modulators.dictionary["vibrato depth"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 25;
                                        instrument.vibratoSpeed = clamp(0, Config.modulators.dictionary["vibrato speed"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.vibratoDelay = clamp(0, Config.modulators.dictionary["vibrato delay"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.vibratoType = clamp(0, Config.vibratoTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.effects |= 1 << 9;
                                    }
                                    else {
                                        instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;
                                        instrument.vibratoSpeed = 10;
                                        instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;
                                        instrument.vibratoType = Config.vibratos[instrument.vibrato].type;
                                    }
                                }
                            }
                        }
                        break;
                    case 71:
                        {
                            if (fromJummBox && beforeFive) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.arpeggioSpeed = clamp(0, Config.modulators.dictionary["arp speed"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                instrument.fastTwoNoteArp = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
                            }
                        }
                        break;
                    case 104:
                        
                        if (beforeThree && fromBeepBox) {
                            const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            this.channels[channelIndex].instruments[0].unison = clamp(0, Config.unisons.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            const instrument = this.channels[channelIndex].instruments[0];
                            instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                            instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                            instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                            instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                            instrument.unisonSign = Config.unisons[instrument.unison].sign;
                        }
                        else if (beforeSix && fromBeepBox) {
                            for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                for (const instrument of this.channels[channelIndex].instruments) {
                                    const originalValue = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                    let unison = clamp(0, Config.unisons.length, originalValue);
                                    if (originalValue == 8) {
                                        unison = 2;
                                        instrument.chord = 3;
                                    }
                                    instrument.unison = unison;
                                    instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                                    instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                                    instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                                    instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                                    instrument.unisonSign = Config.unisons[instrument.unison].sign;
                                }
                            }
                        }
                        else if (beforeSeven && fromBeepBox) {
                            const originalValue = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            let unison = clamp(0, Config.unisons.length, originalValue);
                            if (originalValue == 8) {
                                unison = 2;
                                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chord = 3;
                            }
                            this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].unison = unison;
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                            instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                            instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                            instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                            instrument.unisonSign = Config.unisons[instrument.unison].sign;
                        }
                        else {
                            this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].unison = clamp(0, Config.unisons.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            if ((true && !beforeFive) && (instrument.unison == Config.unisons.length)) {
                                instrument.unisonVoices = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const unisonSpreadNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const unisonSpread = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63)) * 63);
                                const unisonOffsetNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const unisonOffset = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63)) * 63);
                                const unisonExpressionNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const unisonExpression = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63);
                                const unisonSignNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const unisonSign = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63);
                                instrument.unisonSpread = unisonSpread / 1000;
                                if (unisonSpreadNegative == 0)
                                    instrument.unisonSpread *= -1;
                                instrument.unisonOffset = unisonOffset / 1000;
                                if (unisonOffsetNegative == 0)
                                    instrument.unisonOffset *= -1;
                                instrument.unisonExpression = unisonExpression / 1000;
                                if (unisonExpressionNegative == 0)
                                    instrument.unisonExpression *= -1;
                                instrument.unisonSign = unisonSign / 1000;
                                if (unisonSignNegative == 0)
                                    instrument.unisonSign *= -1;
                            }
                            else {
                                instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                                instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                                instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                                instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                                instrument.unisonSign = Config.unisons[instrument.unison].sign;
                            }
                        }
                    
                        break;
                    case 67:
                        {
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                if (instrument.chord != Config.chords.dictionary["simultaneous"].index) {
                                    instrument.effects |= 1 << 11;
                                }
                            }
                        }
                        break;
                    case 113:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                instrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] & ((1 << 12) - 1));
                                if (legacyGlobalReverb == 0 && !(fromJummBox && beforeFive)) {
                                    instrument.effects &= ~(1 << 0);
                                }
                                else if (effectsIncludeReverb(instrument.effects)) {
                                    instrument.reverb = legacyGlobalReverb;
                                }
                                if (instrument.pan != Config.panCenter) {
                                    instrument.effects |= 1 << 2;
                                }
                                if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                    instrument.effects |= 1 << 9;
                                }
                                if (instrument.detune != Config.detuneCenter) {
                                    instrument.effects |= 1 << 8;
                                }
                                instrument.effects &= ~(1 << 3);
                                const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                            }
                            else {
                                instrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 12) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                
                                if (effectsIncludeNoteFilter(instrument.effects)) {
                                    let typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                    if (fromBeepBox || typeCheck == 0) {
                                        instrument.noteFilterType = false;
                                        if (fromJummBox)
                                            typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                        instrument.noteFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, typeCheck);
                                        for (let i = instrument.noteFilter.controlPoints.length; i < instrument.noteFilter.controlPointCount; i++) {
                                            instrument.noteFilter.controlPoints[i] = new FilterControlPoint();
                                        }
                                        for (let i = 0; i < instrument.noteFilter.controlPointCount; i++) {
                                            const point = instrument.noteFilter.controlPoints[i];
                                            point.type = clamp(0, 3, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                            point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                            point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        }
                                        for (let i = instrument.noteFilter.controlPointCount; i < typeCheck; i++) {
                                            charIndex += 3;
                                        }
                                        instrument.noteSubFilters[0] = instrument.noteFilter;
                                        if (fromJummBox && !beforeFive) {
                                            let usingSubFilterBitfield = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                            for (let j = 0; j < Config.filterMorphCount - 1; j++) {
                                                if (usingSubFilterBitfield & (1 << j)) {
                                                    const originalSubfilterControlPointCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                                    if (instrument.noteSubFilters[j + 1] == null)
                                                        instrument.noteSubFilters[j + 1] = new FilterSettings();
                                                    instrument.noteSubFilters[j + 1].controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);
                                                    for (let i = instrument.noteSubFilters[j + 1].controlPoints.length; i < instrument.noteSubFilters[j + 1].controlPointCount; i++) {
                                                        instrument.noteSubFilters[j + 1].controlPoints[i] = new FilterControlPoint();
                                                    }
                                                    for (let i = 0; i < instrument.noteSubFilters[j + 1].controlPointCount; i++) {
                                                        const point = instrument.noteSubFilters[j + 1].controlPoints[i];
                                                        point.type = clamp(0, 3, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                        point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                        point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                                    }
                                                    for (let i = instrument.noteSubFilters[j + 1].controlPointCount; i < originalSubfilterControlPointCount; i++) {
                                                        charIndex += 3;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        instrument.noteFilterType = true;
                                        instrument.noteFilter.reset();
                                        instrument.noteFilterSimpleCut = clamp(0, Config.filterSimpleCutRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.noteFilterSimplePeak = clamp(0, Config.filterSimplePeakRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                }
                                if (effectsIncludeTransition(instrument.effects)) {
                                    instrument.transition = clamp(0, Config.transitions.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                                if (effectsIncludeChord(instrument.effects)) {
                                    instrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    if (instrument.chord == Config.chords.dictionary["arpeggio"].index && fromJummBox) {
                                        instrument.arpeggioSpeed = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                        instrument.fastTwoNoteArp = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) ? true : false;
                                    }
                                }
                                if (effectsIncludePitchShift(instrument.effects)) {
                                    instrument.pitchShift = clamp(0, Config.pitchShiftRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                   // alert(base64CharCodeToInt.length)
                                }
                                if (effectsIncludeDetune(instrument.effects)) {
                                    if (fromBeepBox) {
                                        instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.detune = Math.round((instrument.detune - 9) * (Math.abs(instrument.detune - 9) + 1) / 2 + Config.detuneCenter);
                                    }
                                    else {
                                        instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                }
                                if (effectsIncludeVibrato(instrument.effects)) {
                                    instrument.vibrato = clamp(0, Config.vibratos.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    if (instrument.vibrato == Config.vibratos.length && fromJummBox) {
                                        instrument.vibratoDepth = clamp(0, Config.modulators.dictionary["vibrato depth"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 25;
                                        instrument.vibratoSpeed = clamp(0, Config.modulators.dictionary["vibrato speed"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.vibratoDelay = clamp(0, Config.modulators.dictionary["vibrato delay"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        instrument.vibratoType = clamp(0, Config.vibratoTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                    else {
                                        instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;
                                        instrument.vibratoSpeed = 10;
                                        instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;
                                        instrument.vibratoType = Config.vibratos[instrument.vibrato].type;
                                    }
                                }
                                if (effectsIncludeDistortion(instrument.effects)) {
                                    instrument.distortion = clamp(0, Config.distortionRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    if (fromJummBox && !beforeFive)
                                        instrument.aliases = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
                                }
                                if (effectsIncludeBitcrusher(instrument.effects)) {
                                    instrument.bitcrusherFreq = clamp(0, Config.bitcrusherFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    instrument.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                                if (effectsIncludePanning(instrument.effects)) {
                                    if (fromBeepBox) {
                                        instrument.pan = clamp(0, Config.panMax + 1, Math.round(base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * ((Config.panMax) / 8.0)));
                                    }
                                    else {
                                        instrument.pan = clamp(0, Config.panMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                    if (fromJummBox && !beforeTwo)
                                        instrument.panDelay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                }
                                if (effectsIncludeChorus(instrument.effects)) {
                                    if (fromBeepBox) {
                                        instrument.chorus = clamp(0, (Config.chorusRange / 2) + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) * 2;
                                    }
                                    else {
                                        instrument.chorus = clamp(0, Config.chorusRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                }
                                if (effectsIncludeEcho(instrument.effects)) {
                                    instrument.echoSustain = clamp(0, Config.echoSustainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    instrument.echoDelay = clamp(0, Config.echoDelayRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                                if (effectsIncludeReverb(instrument.effects)) {
                                    if (fromBeepBox) {
                                        instrument.reverb = clamp(0, Config.reverbRange, Math.round(base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * Config.reverbRange / 3.0));
                                    }
                                    else {
                                        instrument.reverb = clamp(0, Config.reverbRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    }
                                }
if (effectsIncludeRingModulation(instrument.effects)) {
 instrument.ringModulation = clamp(0, Config.ringModRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 instrument.ringModulationHz = clamp(0, Config.ringModHzRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 instrument.ringModWaveformIndex = clamp(0, Config.operatorWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 instrument.ringModPulseWidth = clamp(0, Config.pulseWidthRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 instrument.ringModHzOffset = clamp(Config.rmHzOffsetMin, Config.rmHzOffsetMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
}
                            }
                            instrument.effects &= (1 << 15) - 1;
                        }
                        break;
                    case 118:
                        {
                            if (beforeThree && fromBeepBox) {
                                const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const instrument = this.channels[channelIndex].instruments[0];
                                instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));
                                
                                
                                
                            }
                            else if (beforeSix && fromBeepBox) {
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    for (const instrument of this.channels[channelIndex].instruments) {
                                        instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));
                                    }
                                }
                            }
                            else if (beforeSeven && fromBeepBox) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));
                            }
                            else if (fromBeepBox) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 25.0 / 7.0));
                            }
                            else {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.volume = Math.round(clamp(-Config.volumeRange / 2, Config.volumeRange / 2 + 1, ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)])) - Config.volumeRange / 2));
                            }
                        }
                        break;
                    case 76:
                        {
                            if (beforeNine && fromBeepBox) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.pan = clamp(0, Config.panMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * ((Config.panMax) / 8.0));
                            }
                            else if (beforeFive && fromJummBox) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.pan = clamp(0, Config.panMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                if (fromJummBox && !beforeThree) {
                                    instrument.panDelay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                }
                            }
                            else ;
                        }
                        break;
                    case 68:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            if (fromJummBox && beforeFive) {
                                instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) * 4);
                                instrument.effects |= 1 << 8;
                            }
                        }
                        break;
                   case 77:
                        {
                            let instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            for (let j = 0; j < 64; j++) {
                                instrument.customChipWave[j]
                                    = clamp(-24, 25, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] - 24);
                            }
                            let sum = 0.0;
                            for (let i = 0; i < instrument.customChipWave.length; i++) {
                                sum += instrument.customChipWave[i];
                            }
                            const average = sum / instrument.customChipWave.length;
                            let cumulative = 0;
                            let wavePrev = 0;
                            for (let i = 0; i < instrument.customChipWave.length; i++) {
                                cumulative += wavePrev;
                                wavePrev = instrument.customChipWave[i] - average;
                                instrument.customChipWaveIntegral[i] = cumulative;
                            }
                            instrument.customChipWaveIntegral[64] = 0.0;
                        }
                        break;
                    case 79:
                        {
                            let nextValue = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            if (nextValue == 0x3f) {
                                this.restoreLimiterDefaults();
                            }
                            else {
                                this.compressionRatio = (nextValue < 10 ? nextValue / 10 : (1 + (nextValue - 10) / 60));
                                nextValue = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                this.limitRatio = (nextValue < 10 ? nextValue / 10 : (nextValue - 9));
                                this.limitDecay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                this.limitRise = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 250.0) + 2000.0;
                                this.compressionThreshold = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] / 20.0;
                                this.limitThreshold = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] / 20.0;
                                this.masterGain = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 50.0;
                            }
                        }
                        break;
                    case 85:
                        {
                            for (let channel = 0; channel < this.getChannelCount(); channel++) {
                                var channelNameLength;
                                if (beforeFour)
                                    channelNameLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                else
                                    channelNameLength = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                this.channels[channel].name = decodeURIComponent(compressed.substring(charIndex, charIndex + channelNameLength));
                                charIndex += channelNameLength;
                            }
                        }
                        break;
                    case 65:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            
                            
const upper = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
const lower = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
const algo = (upper << 6) | lower;
instrument.algorithm = clamp(0, Config.algorithms.length, algo );

                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                            }
                        }
                        break;
                    case 70:
                        {
                            this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].feedbackType = clamp(0, Config.feedbacks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                        break;
                    case 66:
                        {
                            this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].feedbackAmplitude = clamp(0, Config.operatorAmplitudeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                        break;
                    case 86:
                        {
                            if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
                                legacySettings.feedbackEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                            }
                        }
                        break;
                    case 81:
                        {
                            for (let o = 0; o < Config.operatorCount; o++) {
                                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].operators[o].frequency = clamp(0, Config.operatorFrequencies.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                        }
                        break;
                    case 80:
                        {
                            for (let o = 0; o < Config.operatorCount; o++) {
                                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].operators[o].amplitude = clamp(0, Config.operatorAmplitudeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                        }
                        break;
                    case 69:
{const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
const legacySettings = legacySettingsCache[instrumentChannelIterator][instrumentIndexIterator];
legacySettings.operatorEnvelopes = [];
 for (let o = 0; o < Config.operatorCount; o++) {
 legacySettings.operatorEnvelopes[o] = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 }
 instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
 }
 else {
 const envelopeCount = clamp(0, Config.maxEnvelopeCount + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 for (let i = 0; i < envelopeCount; i++) {
 const target = clamp(0, Config.instrumentAutomationTargets.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
 let index = 0;
 const maxCount = Config.instrumentAutomationTargets[target].maxCount;
 if (maxCount > 1) {
 index = clamp(0, maxCount, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
   
 }
const upper = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
const lower = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
const envelope = (upper << 6) | lower;

//const envelope = clamp(0, Config.envelopes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);

 

instrument.addEnvelope(target, index, envelope);
 }
}
 }
break;
                    case 82:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            for (let o = 0; o < Config.operatorCount; o++) {
                                instrument.operators[o].waveform = clamp(0, Config.operatorWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                if (instrument.operators[o].waveform == 3) {
                                    instrument.operators[o].pulseWidth = clamp(0, Config.pwmOperatorWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                }
                            }
                        }
                        break;
                    case 83:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            if (instrument.type == 3) {
                                const byteCount = Math.ceil(Config.spectrumControlPoints * Config.spectrumControlPointBits / 6);
                                const bits = new BitFieldReader(compressed, charIndex, charIndex + byteCount);
                                for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                    instrument.spectrumWave.spectrum[i] = bits.read(Config.spectrumControlPointBits);
                                }
                                instrument.spectrumWave.markCustomWaveDirty();
                                charIndex += byteCount;
                            }
                            else if (instrument.type == 4) {
                                const byteCount = Math.ceil(Config.drumCount * Config.spectrumControlPoints * Config.spectrumControlPointBits / 6);
                                const bits = new BitFieldReader(compressed, charIndex, charIndex + byteCount);
                                for (let j = 0; j < Config.drumCount; j++) {
                                    for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                        instrument.drumsetSpectrumWaves[j].spectrum[i] = bits.read(Config.spectrumControlPointBits);
                                    }
                                    instrument.drumsetSpectrumWaves[j].markCustomWaveDirty();
                                }
                                charIndex += byteCount;
                            }
                            else {
                                throw new Error("Unhandled instrument type for spectrum song tag code.");
                            }
                        }
                        break;
                    case 72:
                        {
                            const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            const byteCount = Math.ceil(Config.harmonicsControlPoints * Config.harmonicsControlPointBits / 6);
                            const bits = new BitFieldReader(compressed, charIndex, charIndex + byteCount);
                            for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                                instrument.harmonicsWave.harmonics[i] = bits.read(Config.harmonicsControlPointBits);
                            }
                            instrument.harmonicsWave.markCustomWaveDirty();
                            charIndex += byteCount;
                        }
                        break;
                    case 88:
                        {
                            if (fromJummBox && beforeFive) {
                                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                                instrument.aliases = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) ? true : false;
                                if (instrument.aliases) {
                                    instrument.distortion = 0;
                                    instrument.effects |= 1 << 3;
                                }
                            }
                        }
                        break;
                    case 98:
                        {
                            let subStringLength;
                            if (beforeThree && fromBeepBox) {
                                const channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                const barCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                subStringLength = Math.ceil(barCount * 0.5);
                                const bits = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);
                                for (let i = 0; i < barCount; i++) {
                                    this.channels[channelIndex].bars[i] = bits.read(3) + 1;
                                }
                            }
                            else if (beforeFive && fromBeepBox) {
                                let neededBits = 0;
                                while ((1 << neededBits) < this.patternsPerChannel)
                                    neededBits++;
                                subStringLength = Math.ceil(this.getChannelCount() * this.barCount * neededBits / 6);
                                const bits = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    for (let i = 0; i < this.barCount; i++) {
                                        this.channels[channelIndex].bars[i] = bits.read(neededBits) + 1;
                                    }
                                }
                            }
                            else {
                                let neededBits = 0;
                                while ((1 << neededBits) < this.patternsPerChannel + 1)
                                    neededBits++;
                                subStringLength = Math.ceil(this.getChannelCount() * this.barCount * neededBits / 6);
                                const bits = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);
                                for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                    for (let i = 0; i < this.barCount; i++) {
                                        this.channels[channelIndex].bars[i] = bits.read(neededBits);
                                    }
                                }
                            }
                            charIndex += subStringLength;
                        }
                        break;
                    case 112:
                        {
                            let bitStringLength = 0;
                            let channelIndex;
                            let largerChords = !((beforeFour && fromJummBox) || fromBeepBox);
                            let recentPitchBitLength = (largerChords ? 4 : 3);
                            let recentPitchLength = (largerChords ? 16 : 8);
                            if (beforeThree && fromBeepBox) {
                                channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                charIndex++;
                                bitStringLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                bitStringLength = bitStringLength << 6;
                                bitStringLength += base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            }
                            else {
                                channelIndex = 0;
                                let bitStringLengthLength = validateRange(1, 4, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                while (bitStringLengthLength > 0) {
                                    bitStringLength = bitStringLength << 6;
                                    bitStringLength += base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                    bitStringLengthLength--;
                                }
                            }
                            const bits = new BitFieldReader(compressed, charIndex, charIndex + bitStringLength);
                            charIndex += bitStringLength;
                            const bitsPerNoteSize = Song.getNeededBits(Config.noteSizeMax);
                            let songReverbChannel = -1;
                            let songReverbInstrument = -1;
                            let songReverbIndex = -1;
                            while (true) {
                                const channel = this.channels[channelIndex];
                                const isNoiseChannel = this.getChannelIsNoise(channelIndex);
                                const isModChannel = this.getChannelIsMod(channelIndex);
                                const maxInstrumentsPerPattern = this.getMaxInstrumentsPerPattern(channelIndex);
                                const neededInstrumentCountBits = Song.getNeededBits(maxInstrumentsPerPattern - Config.instrumentCountMin);
                                const neededInstrumentIndexBits = Song.getNeededBits(channel.instruments.length - 1);
                                if (isModChannel) {
                                    const neededModInstrumentIndexBits = (beforeFive) ? neededInstrumentIndexBits : Song.getNeededBits(this.getMaxInstrumentsPerChannel() + 2);
                                    for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                                        let instrument = channel.instruments[instrumentIndex];
                                        
                                        for (let mod = 0; mod < Config.modCount; mod++) {
                                            let status = bits.read(2);
                                            switch (status) {
                                                case 0:
                                                    instrument.modChannels[mod] = clamp(0, this.pitchChannelCount + this.noiseChannelCount + 1, bits.read(8));
                                                    instrument.modInstruments[mod] = clamp(0, this.channels[instrument.modChannels[mod]].instruments.length + 2, bits.read(neededModInstrumentIndexBits));

                                                    break;
                                                case 1:
                                                    instrument.modChannels[mod] = this.pitchChannelCount + clamp(0, this.noiseChannelCount + 1, bits.read(8));
                                                    instrument.modInstruments[mod] = clamp(0, this.channels[instrument.modChannels[mod]].instruments.length + 2, bits.read(neededInstrumentIndexBits));
                                                    break;
                                                case 2:
                                                    instrument.modChannels[mod] = -1;
                                                    break;
                                                case 3:
                                                    instrument.modChannels[mod] = -2;
                                                    break;
                                            }
                                            if (status != 3) {
                                                instrument.modulators[mod] = bits.read(6);
                                            }
                                            if (!beforeFive && (Config.modulators[instrument.modulators[mod]].name == "eq filter" || Config.modulators[instrument.modulators[mod]].name == "note filter")) {
                                                instrument.modFilterTypes[mod] = bits.read(6);
                                            }
                                            if (beforeFive && instrument.modChannels[mod] >= 0) {
                                                let forNoteFilter = effectsIncludeNoteFilter(this.channels[instrument.modChannels[mod]].instruments[instrument.modInstruments[mod]].effects);
                                                if (instrument.modulators[mod] == 7) {
                                                    if (forNoteFilter) {
                                                        instrument.modulators[mod] = Config.modulators.dictionary["note filt cut"].index;
                                                    }
                                                    else {
                                                        instrument.modulators[mod] = Config.modulators.dictionary["eq filt cut"].index;
                                                    }
                                                    instrument.modFilterTypes[mod] = 1;
                                                }
                                                else if (instrument.modulators[mod] == 8) {
                                                    if (forNoteFilter) {
                                                        instrument.modulators[mod] = Config.modulators.dictionary["note filt peak"].index;
                                                    }
                                                    else {
                                                        instrument.modulators[mod] = Config.modulators.dictionary["eq filt peak"].index;
                                                    }
                                                    instrument.modFilterTypes[mod] = 2;
                                                }
                                            }
                                            else if (beforeFive) {
                                                if (instrument.modulators[mod] == Config.modulators.dictionary["song reverb"].index) {
                                                    songReverbChannel = channelIndex;
                                                    songReverbInstrument = instrumentIndex;
                                                    songReverbIndex = mod;
                                                }
                                            }
                                            if (beforeFive && Config.modulators[instrument.modulators[mod]].associatedEffect != 12) {
                                                this.channels[instrument.modChannels[mod]].instruments[instrument.modInstruments[mod]].effects |= 1 << Config.modulators[instrument.modulators[mod]].associatedEffect;
                                            }
                                            
                                            
                                        }
                                    }
                                }
                                const detuneScaleNotes = [];
                                for (let j = 0; j < channel.instruments.length; j++) {
                                    detuneScaleNotes[j] = [];
                                    for (let i = 0; i < Config.modCount; i++) {
                                        detuneScaleNotes[j][Config.modCount - 1 - i] = 1 + 3 * +(beforeFive && fromJummBox && isModChannel && (channel.instruments[j].modulators[i] == Config.modulators.dictionary["detune"].index));
                                    }
                                }
                                const octaveOffset = (isNoiseChannel || isModChannel) ? 0 : channel.octave * 12;
                                let lastPitch = ((isNoiseChannel || isModChannel) ? 4 : octaveOffset);
                                const recentPitches = isModChannel ? [0, 1, 2, 3, 4, 5] : (isNoiseChannel ? [4, 6, 7, 2, 3, 8, 0, 10] : [0, 7, 12, 19, 24, -5, -12]);
                                const recentShapes = [];
                                for (let i = 0; i < recentPitches.length; i++) {
                                    recentPitches[i] += octaveOffset;
                                }
                                for (let i = 0; i < this.patternsPerChannel; i++) {
                                    const newPattern = channel.patterns[i];
                                    if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {
                                        newPattern.instruments[0] = validateRange(0, channel.instruments.length - 1, bits.read(neededInstrumentIndexBits));
                                        newPattern.instruments.length = 1;
                                    }
                                    else {
                                        if (this.patternInstruments) {
                                            const instrumentCount = validateRange(Config.instrumentCountMin, maxInstrumentsPerPattern, bits.read(neededInstrumentCountBits) + Config.instrumentCountMin);
                                            for (let j = 0; j < instrumentCount; j++) {
                                                newPattern.instruments[j] = validateRange(0, channel.instruments.length - 1 + +(isModChannel) * 2, bits.read(neededInstrumentIndexBits));
                                            }
                                            newPattern.instruments.length = instrumentCount;
                                        }
                                        else {
                                            newPattern.instruments[0] = 0;
                                            newPattern.instruments.length = Config.instrumentCountMin;
                                        }
                                    }
                                    if (!(fromBeepBox && beforeThree) && bits.read(1) == 0) {
                                        newPattern.notes.length = 0;
                                        continue;
                                    }
                                    let curPart = 0;
                                    const newNotes = newPattern.notes;
                                    let noteCount = 0;
                                    while (curPart < this.beatsPerBar * Config.partsPerBeat + (+isModChannel)) {
                                        const useOldShape = bits.read(1) == 1;
                                        let newNote = false;
                                        let shapeIndex = 0;
                                        if (useOldShape) {
                                            shapeIndex = validateRange(0, recentShapes.length - 1, bits.readLongTail(0, 0));
                                        }
                                        else {
                                            newNote = bits.read(1) == 1;
                                        }
                                        if (!useOldShape && !newNote) {
                                            if (isModChannel) {
                                                const isBackwards = bits.read(1) == 1;
                                                const restLength = bits.readPartDuration();
                                                if (isBackwards) {
                                                    curPart -= restLength;
                                                }
                                                else {
                                                    curPart += restLength;
                                                }
                                            }
                                            else {
                                                const restLength = (beforeSeven && fromBeepBox)
                                                    ? bits.readLegacyPartDuration() * Config.partsPerBeat / Config.rhythms[this.rhythm].stepsPerBeat
                                                    : bits.readPartDuration();
                                                curPart += restLength;
                                            }
                                        }
                                        else {
                                            let shape;
                                            if (useOldShape) {
                                                shape = recentShapes[shapeIndex];
                                                recentShapes.splice(shapeIndex, 1);
                                            }
                                            else {
                                                shape = {};
                                                if (!largerChords) {
                                                    shape.pitchCount = 1;
                                                    while (shape.pitchCount < 4 && bits.read(1) == 1)
                                                        shape.pitchCount++;
                                                }
                                                else {
                                                    if (bits.read(1) == 1) {
                                                        shape.pitchCount = bits.read(3) + 2;
                                                    }
                                                    else {
                                                        shape.pitchCount = 1;
                                                    }
                                                }
                                                shape.pinCount = bits.readPinCount();
                                                if (fromBeepBox) {
                                                    shape.initialSize = bits.read(2) * 2;
                                                }
                                                else if (!isModChannel) {
                                                    shape.initialSize = bits.read(bitsPerNoteSize);
                                                }
                                                else {
                                                    shape.initialSize = bits.read(18);
                                                }
                                                shape.pins = [];
                                                shape.length = 0;
                                                shape.bendCount = 0;
                                                for (let j = 0; j < shape.pinCount; j++) {
                                                    let pinObj = {};
                                                    pinObj.pitchBend = bits.read(1) == 1;
                                                    if (pinObj.pitchBend)
                                                        shape.bendCount++;
                                                    shape.length += (beforeSeven && fromBeepBox)
                                                        ? bits.readLegacyPartDuration() * Config.partsPerBeat / Config.rhythms[this.rhythm].stepsPerBeat
                                                        : bits.readPartDuration();
                                                    pinObj.time = shape.length;
                                                    if (fromBeepBox) {
                                                        pinObj.size = bits.read(2) * 2;
                                                    }
                                                    else if (!isModChannel) {
                                                        pinObj.size = bits.read(bitsPerNoteSize);
                                                    }
                                                    else {
                                                        pinObj.size = bits.read(18);
                                                    }
                                                    shape.pins.push(pinObj);
                                                    }
                                            }
                                            recentShapes.unshift(shape);
                                            if (recentShapes.length > 10)
                                                recentShapes.pop();
                                            let note;
                                            if (newNotes.length <= noteCount) {
                                                note = new Note(0, curPart, curPart + shape.length, shape.initialSize);
                                                newNotes[noteCount++] = note;
                                            }
                                            else {
                                                note = newNotes[noteCount++];
                                                note.start = curPart;
                                                note.end = curPart + shape.length;
                                                note.pins[0].size = shape.initialSize;
                                            }
                                            let pitch;
                                            let pitchCount = 0;
                                            const pitchBends = [];
                                            for (let j = 0; j < shape.pitchCount + shape.bendCount; j++) {
                                                const useOldPitch = bits.read(1) == 1;
                                                if (!useOldPitch) {
                                                    const interval = bits.readPitchInterval();
                                                    pitch = lastPitch;
                                                    let intervalIter = interval;
                                                    while (intervalIter > 0) {
                                                        pitch++;
                                                        while (recentPitches.indexOf(pitch) != -1)
                                                            pitch++;
                                                        intervalIter--;
                                                    }
                                                    while (intervalIter < 0) {
                                                        pitch--;
                                                        while (recentPitches.indexOf(pitch) != -1)
                                                            pitch--;
                                                        intervalIter++;
                                                    }
                                                }
                                                else {
                                                    const pitchIndex = validateRange(0, recentPitches.length - 1, bits.read(recentPitchBitLength));
                                                    pitch = recentPitches[pitchIndex];
                                                    recentPitches.splice(pitchIndex, 1);
                                                }
                                                recentPitches.unshift(pitch);
                                                if (recentPitches.length > recentPitchLength)
                                                    recentPitches.pop();
                                                if (j < shape.pitchCount) {
                                                    note.pitches[pitchCount++] = pitch;
                                                }
                                                else {
                                                    pitchBends.push(pitch);
                                                }
                                                if (j == shape.pitchCount - 1) {
                                                    lastPitch = note.pitches[0];
                                                }
                                                else {
                                                    lastPitch = pitch;
                                                }
                                            }
                                            note.pitches.length = pitchCount;
                                            pitchBends.unshift(note.pitches[0]);
                                            if (isModChannel) {
                                                note.pins[0].size *= detuneScaleNotes[newPattern.instruments[0]][note.pitches[0]];
                                            }
                                            let pinCount = 1;
                                            for (const pinObj of shape.pins) {
                                                if (pinObj.pitchBend)
                                                    pitchBends.shift();
                                                const interval = pitchBends[0] - note.pitches[0];
                                                if (note.pins.length <= pinCount) {
                                                    if (isModChannel) {
                                                        note.pins[pinCount++] = makeNotePin(interval, pinObj.time, pinObj.size * detuneScaleNotes[newPattern.instruments[0]][note.pitches[0]]);
                                                        
                                                    }
                                                    else {
                                                        note.pins[pinCount++] = makeNotePin(interval, pinObj.time, pinObj.size);
                                                    }
                                                }
                                                else {
                                                    const pin = note.pins[pinCount++];
                                                    pin.interval = interval;
                                                    pin.time = pinObj.time;
                                                    if (isModChannel) {
                                                        pin.size = pinObj.size * detuneScaleNotes[newPattern.instruments[0]][note.pitches[0]];
                                                    }
                                                    else {
                                                        pin.size = pinObj.size;
                                                    }
                                                }
                                            }
                                            note.pins.length = pinCount;
                                            if (note.start == 0) {
                                                if (!((beforeNine && fromBeepBox) || (beforeFive && fromJummBox))) {
                                                    note.continuesLastPattern = (bits.read(1) == 1);
                                                }
                                                else {
                                                    if (beforeFour || fromBeepBox) {
                                                        note.continuesLastPattern = false;
                                                    }
                                                    else {
                                                        note.continuesLastPattern = channel.instruments[newPattern.instruments[0]].legacyTieOver;
                                                    }
                                                }
                                            }
                                            curPart = validateRange(0, this.beatsPerBar * Config.partsPerBeat, note.end);
                                        }
                                    }
                                    newNotes.length = noteCount;
                                }
                                if (beforeThree && fromBeepBox) {
                                    break;
                                }
                                else {
                                    channelIndex++;
                                    if (channelIndex >= this.getChannelCount())
                                        break;
                                }
                            }
                            if (fromJummBox && beforeFive && songReverbIndex >= 0) {
                                for (let channelIndex = 0; channelIndex < this.channels.length; channelIndex++) {
                                    for (let instrumentIndex = 0; instrumentIndex < this.channels[channelIndex].instruments.length; instrumentIndex++) {
                                        const instrument = this.channels[channelIndex].instruments[instrumentIndex];
                                        if (effectsIncludeReverb(instrument.effects)) {
                                            instrument.reverb = Config.reverbRange - 1;
                                        }
                                        if (songReverbChannel == channelIndex && songReverbInstrument == instrumentIndex) {
                                            const patternIndex = this.channels[channelIndex].bars[0];
                                            if (patternIndex > 0) {
                                                const pattern = this.channels[channelIndex].patterns[patternIndex - 1];
                                                let lowestPart = 6;
                                                for (const note of pattern.notes) {
                                                    if (note.pitches[0] == Config.modCount - 1 - songReverbIndex) {
                                                        lowestPart = Math.min(lowestPart, note.start);
                                                    }
                                                }
                                                if (lowestPart > 0) {
                                                    pattern.notes.push(new Note(Config.modCount - 1 - songReverbIndex, 0, lowestPart, legacyGlobalReverb));
                                                }
                                            }
                                            else {
                                                if (this.channels[channelIndex].patterns.length < Config.barCountMax) {
                                                    const pattern = new Pattern();
                                                    this.channels[channelIndex].patterns.push(pattern);
                                                    this.channels[channelIndex].bars[0] = this.channels[channelIndex].patterns.length;
                                                    if (this.channels[channelIndex].patterns.length > this.patternsPerChannel) {
                                                        for (let chn = 0; chn < this.channels.length; chn++) {
                                                            if (this.channels[chn].patterns.length <= this.patternsPerChannel) {
                                                                this.channels[chn].patterns.push(new Pattern());
                                                            }
                                                        }
                                                        this.patternsPerChannel++;
                                                    }
                                                    pattern.instruments.length = 1;
                                                    pattern.instruments[0] = songReverbInstrument;
                                                    pattern.notes.length = 0;
                                                    pattern.notes.push(new Note(Config.modCount - 1 - songReverbIndex, 0, 6, legacyGlobalReverb));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    default:
                        {

/*const instrumentoo = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
console.log(JSON.stringify(instrumentoo));
console.log(("2:" + (command) + " at index " + (charIndex) + " "+compressed.charCodeAt(charIndex)))
*/


                 console.warn("Unrecognized song tag code " + String.fromCharCode(command) + " at index " + (charIndex - 1))            ;
                        }
                }
        }
        toJsonObject(enableIntro = true, loopCount = 1, enableOutro = true) {
            const channelArray = [];
            for (let channelIndex = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                const channel = this.channels[channelIndex];
                const instrumentArray = [];
                const isNoiseChannel = this.getChannelIsNoise(channelIndex);
                const isModChannel = this.getChannelIsMod(channelIndex);
                for (const instrument of channel.instruments) {
                    instrumentArray.push(instrument.toJsonObject());
                }
                const patternArray = [];
                for (const pattern of channel.patterns) {
                    const noteArray = [];
                    for (const note of pattern.notes) {
                        let instrument = channel.instruments[pattern.instruments[0]];
                        let mod = Config.modCount - note.pitches[0] - 1;
                        let volumeCap = this.getVolumeCapForSetting(isModChannel, instrument.modulators[mod], instrument.modFilterTypes[mod]);
                        const pointArray = [];
                        for (const pin of note.pins) {
                            let useVol = isModChannel ? Math.round(pin.size) : Math.round(pin.size * 100 / volumeCap);
                            pointArray.push({
                                "tick": (pin.time + note.start) * Config.rhythms[this.rhythm].stepsPerBeat / Config.partsPerBeat,
                                "pitchBend": pin.interval,
                                "volume": useVol,
                                "forMod": isModChannel,
                            });
                        }
                        const noteObject = {
                            "pitches": note.pitches,
                            "points": pointArray,
                        };
                        if (note.start == 0) {
                            noteObject["continuesLastPattern"] = note.continuesLastPattern;
                        }
                        noteArray.push(noteObject);
                    }
                    const patternObject = { "notes": noteArray };
                    if (this.patternInstruments) {
                        patternObject["instruments"] = pattern.instruments.map(i => i + 1);
                    }
                    patternArray.push(patternObject);
                }
                const sequenceArray = [];
                if (enableIntro)
                    for (let i = 0; i < this.loopStart; i++) {
                        sequenceArray.push(channel.bars[i]);
                    }
                for (let l = 0; l < loopCount; l++)
                    for (let i = this.loopStart; i < this.loopStart + this.loopLength; i++) {
                        sequenceArray.push(channel.bars[i]);
                    }
                if (enableOutro)
                    for (let i = this.loopStart + this.loopLength; i < this.barCount; i++) {
                        sequenceArray.push(channel.bars[i]);
                    }
                const channelObject = {
                    "type": isModChannel ? "mod" : (isNoiseChannel ? "drum" : "pitch"),
                    "name": channel.name,
                    "instruments": instrumentArray,
                    "patterns": patternArray,
                    "sequence": sequenceArray,
                };
                if (!isNoiseChannel) {
                    channelObject["octaveScrollBar"] = channel.octave - 1;
                }
                channelArray.push(channelObject);
            }
            return {
                "name": this.title,
                "format": Song._format,
                "version": Song._latestJummBoxVersion,
                "scale": Config.scales[this.scale].name,
                "key": Config.keys[this.key].name,
                "introBars": this.loopStart,
                "loopBars": this.loopLength,
                "beatsPerBar": this.beatsPerBar,
                "ticksPerBeat": Config.rhythms[this.rhythm].stepsPerBeat,
                "beatsPerMinute": this.tempo,
                "reverb": this.reverb,
                "masterGain": this.masterGain,
                "compressionThreshold": this.compressionThreshold,
                "limitThreshold": this.limitThreshold,
                "limitDecay": this.limitDecay,
                "limitRise": this.limitRise,
                "limitRatio": this.limitRatio,
                "compressionRatio": this.compressionRatio,
                "layeredInstruments": this.layeredInstruments,
                "patternInstruments": this.patternInstruments,
                "channels": channelArray,
             //   "songEq": this.eqFilter.toJsonObject(),
            };
        }
        fromJsonObject(jsonObject) {
            this.initToDefault(true);
            if (!jsonObject)
                return;
            if (jsonObject["name"] != undefined) {
                this.title = jsonObject["name"];
            }
            this.scale = 0;
            if (jsonObject["scale"] != undefined) {
                const oldScaleNames = {
                    "romani :)": "dbl harmonic :)",
                    "romani :(": "dbl harmonic :(",
                    "enigma": "strange",
                };
                const scaleName = (oldScaleNames[jsonObject["scale"]] != undefined) ? oldScaleNames[jsonObject["scale"]] : jsonObject["scale"];
                const scale = Config.scales.findIndex(scale => scale.name == scaleName);
                if (scale != -1)
                    this.scale = scale;
            }
            if (jsonObject["key"] != undefined) {
                if (typeof (jsonObject["key"]) == "number") {
                    this.key = ((jsonObject["key"] + 1200) >>> 0) % Config.keys.length;
                }
                else if (typeof (jsonObject["key"]) == "string") {
                    const key = jsonObject["key"];
                    const letter = key.charAt(0).toUpperCase();
                    const symbol = key.charAt(1).toLowerCase();
                    const letterMap = { "C": 0, "D": 2, "E": 4, "F": 5, "G": 7, "A": 9, "B": 11 };
                    const accidentalMap = { "#": 1, "♯": 1, "b": -1, "♭": -1 };
                    let index = letterMap[letter];
                    const offset = accidentalMap[symbol];
                    if (index != undefined) {
                        if (offset != undefined)
                            index += offset;
                        if (index < 0)
                            index += 12;
                        index = index % 12;
                        this.key = index;
                    }
                }
            }
            if (jsonObject["beatsPerMinute"] != undefined) {
                this.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, jsonObject["beatsPerMinute"] | 0);
            }
            let legacyGlobalReverb = 0;
            if (jsonObject["reverb"] != undefined) {
                legacyGlobalReverb = clamp(0, 32, jsonObject["reverb"] | 0);
            }
            if (jsonObject["beatsPerBar"] != undefined) {
                this.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, jsonObject["beatsPerBar"] | 0));
            }
            let importedPartsPerBeat = 4;
            if (jsonObject["ticksPerBeat"] != undefined) {
                importedPartsPerBeat = (jsonObject["ticksPerBeat"] | 0) || 4;
                this.rhythm = Config.rhythms.findIndex(rhythm => rhythm.stepsPerBeat == importedPartsPerBeat);
                if (this.rhythm == -1) {
                    this.rhythm = 1;
                }
            }
            if (jsonObject["masterGain"] != undefined) {
                this.masterGain = Math.max(0.0, Math.min(5.0, jsonObject["masterGain"] || 0));
            }
            else {
                this.masterGain = 1.0;
            }
            if (jsonObject["limitThreshold"] != undefined) {
                this.limitThreshold = Math.max(0.0, Math.min(2.0, jsonObject["limitThreshold"] || 0));
            }
            else {
                this.limitThreshold = 1.0;
            }
            if (jsonObject["compressionThreshold"] != undefined) {
                this.compressionThreshold = Math.max(0.0, Math.min(1.1, jsonObject["compressionThreshold"] || 0));
            }
            else {
                this.compressionThreshold = 1.0;
            }
            if (jsonObject["limitRise"] != undefined) {
                this.limitRise = Math.max(2000.0, Math.min(10000.0, jsonObject["limitRise"] || 0));
            }
            else {
                this.limitRise = 4000.0;
            }
            if (jsonObject["limitDecay"] != undefined) {
                this.limitDecay = Math.max(1.0, Math.min(30.0, jsonObject["limitDecay"] || 0));
            }
            else {
                this.limitDecay = 4.0;
            }
            if (jsonObject["limitRatio"] != undefined) {
                this.limitRatio = Math.max(0.0, Math.min(11.0, jsonObject["limitRatio"] || 0));
            }
            else {
                this.limitRatio = 1.0;
            }
            if (jsonObject["compressionRatio"] != undefined) {
                this.compressionRatio = Math.max(0.0, Math.min(1.168, jsonObject["compressionRatio"] || 0));
            }
            else {
                this.compressionRatio = 1.0;
            }
            let maxInstruments = 1;
            let maxPatterns = 1;
            let maxBars = 1;
            if (jsonObject["channels"] != undefined) {
                for (const channelObject of jsonObject["channels"]) {
                    if (channelObject["instruments"])
                        maxInstruments = Math.max(maxInstruments, channelObject["instruments"].length | 0);
                    if (channelObject["patterns"])
                        maxPatterns = Math.max(maxPatterns, channelObject["patterns"].length | 0);
                    if (channelObject["sequence"])
                        maxBars = Math.max(maxBars, channelObject["sequence"].length | 0);
                }
            }
            if (jsonObject["layeredInstruments"] != undefined) {
                this.layeredInstruments = !!jsonObject["layeredInstruments"];
            }
            else {
                this.layeredInstruments = false;
            }
            if (jsonObject["patternInstruments"] != undefined) {
                this.patternInstruments = !!jsonObject["patternInstruments"];
            }
            else {
                this.patternInstruments = (maxInstruments > 1);
            }
            this.patternsPerChannel = Math.min(maxPatterns, Config.barCountMax);
            this.barCount = Math.min(maxBars, Config.barCountMax);
            if (jsonObject["introBars"] != undefined) {
                this.loopStart = clamp(0, this.barCount, jsonObject["introBars"] | 0);
            }
            if (jsonObject["loopBars"] != undefined) {
                this.loopLength = clamp(1, this.barCount - this.loopStart + 1, jsonObject["loopBars"] | 0);
            }
            const newPitchChannels = [];
            const newNoiseChannels = [];
            const newModChannels = [];
            if (jsonObject["channels"] != undefined) {
                for (let channelIndex = 0; channelIndex < jsonObject["channels"].length; channelIndex++) {
                    let channelObject = jsonObject["channels"][channelIndex];
                    const channel = new Channel();
                    let isNoiseChannel = false;
                    let isModChannel = false;
                    if (channelObject["type"] != undefined) {
                        isNoiseChannel = (channelObject["type"] == "drum");
                        isModChannel = (channelObject["type"] == "mod");
                    }
                    else {
                        isNoiseChannel = (channelIndex >= 3);
                    }
                    if (isNoiseChannel) {
                        newNoiseChannels.push(channel);
                    }
                    else if (isModChannel) {
                        newModChannels.push(channel);
                    }
                    else {
                        newPitchChannels.push(channel);
                    }
                    if (channelObject["octaveScrollBar"] != undefined) {
                        channel.octave = clamp(0, Config.pitchOctaves, (channelObject["octaveScrollBar"] | 0) + 1);
                        if (isNoiseChannel)
                            channel.octave = 0;
                    }
                    if (channelObject["name"] != undefined) {
                        channel.name = channelObject["name"];
                    }
                    else {
                        channel.name = "";
                    }
                    if (Array.isArray(channelObject["instruments"])) {
                        const instrumentObjects = channelObject["instruments"];
                        for (let i = 0; i < instrumentObjects.length; i++) {
                            if (i >= this.getMaxInstrumentsPerChannel())
                                break;
                            const instrument = new Instrument(isNoiseChannel, isModChannel);
                            channel.instruments[i] = instrument;
                            instrument.fromJsonObject(instrumentObjects[i], isNoiseChannel, isModChannel, false, false, legacyGlobalReverb);
                        }
                    }
                    for (let i = 0; i < this.patternsPerChannel; i++) {
                        const pattern = new Pattern();
                        channel.patterns[i] = pattern;
                        let patternObject = undefined;
                        if (channelObject["patterns"])
                            patternObject = channelObject["patterns"][i];
                        if (patternObject == undefined)
                            continue;
                        if (this.patternInstruments) {
                            if (Array.isArray(patternObject["instruments"])) {
                                const instruments = patternObject["instruments"];
                                const instrumentCount = clamp(Config.instrumentCountMin, this.getMaxInstrumentsPerPatternForChannel(channel) + 1, instruments.length);
                                for (let j = 0; j < instrumentCount; j++) {
                                    pattern.instruments[j] = clamp(0, channel.instruments.length, (instruments[j] | 0) - 1);
                                }
                                pattern.instruments.length = instrumentCount;
                            }
                            else {
                                pattern.instruments[0] = clamp(0, channel.instruments.length, (patternObject["instrument"] | 0) - 1);
                                pattern.instruments.length = 1;
                            }
                        }
                        if (patternObject["notes"] && patternObject["notes"].length > 0) {
                            const maxNoteCount = Math.min(this.beatsPerBar * Config.partsPerBeat * (isModChannel ? Config.modCount : 1), patternObject["notes"].length >>> 0);
                            for (let j = 0; j < patternObject["notes"].length; j++) {
                                if (j >= maxNoteCount)
                                    break;
                                const noteObject = patternObject["notes"][j];
                                if (!noteObject || !noteObject["pitches"] || !(noteObject["pitches"].length >= 1) || !noteObject["points"] || !(noteObject["points"].length >= 2)) {
                                    continue;
                                }
                                const note = new Note(0, 0, 0, 0);
                                note.pitches = [];
                                note.pins = [];
                                for (let k = 0; k < noteObject["pitches"].length; k++) {
                                    const pitch = noteObject["pitches"][k] | 0;
                                    if (note.pitches.indexOf(pitch) != -1)
                                        continue;
                                    note.pitches.push(pitch);
                                    if (note.pitches.length >= Config.maxChordSize)
                                        break;
                                }
                                if (note.pitches.length < 1)
                                    continue;
                                let startInterval = 0;
                                for (let k = 0; k < noteObject["points"].length; k++) {
                                    const pointObject = noteObject["points"][k];
                                    if (pointObject == undefined || pointObject["tick"] == undefined)
                                        continue;
                                    const interval = (pointObject["pitchBend"] == undefined) ? 0 : (pointObject["pitchBend"] | 0);
                                    const time = Math.round((+pointObject["tick"]) * Config.partsPerBeat / importedPartsPerBeat);
                                    let instrument = channel.instruments[pattern.instruments[0]];
                                    let mod = Config.modCount - note.pitches[0] - 1;
                                    let volumeCap = this.getVolumeCapForSetting(isModChannel, instrument.modulators[mod], instrument.modFilterTypes[mod]);
                                    let size;
                                    if (pointObject["volume"] == undefined) {
                                        size = volumeCap;
                                    }
                                    else if (pointObject["forMod"] == undefined) {
                                        size = Math.max(0, Math.min(volumeCap, Math.round((pointObject["volume"] | 0) * volumeCap / 100)));
                                    }
                                    else {
                                        size = ((pointObject["forMod"] | 0) > 0) ? Math.round(pointObject["volume"] | 0) : Math.max(0, Math.min(volumeCap, Math.round((pointObject["volume"] | 0) * volumeCap / 100)));
                                    }
                                    if (time > this.beatsPerBar * Config.partsPerBeat)
                                        continue;
                                    if (note.pins.length == 0) {
                                        note.start = time;
                                        startInterval = interval;
                                    }
                                    note.pins.push(makeNotePin(interval - startInterval, time - note.start, size));
                                }
                                if (note.pins.length < 2)
                                    continue;
                                note.end = note.pins[note.pins.length - 1].time + note.start;
                                const maxPitch = isNoiseChannel ? Config.drumCount - 1 : Config.maxPitch;
                                let lowestPitch = maxPitch;
                                let highestPitch = 0;
                                for (let k = 0; k < note.pitches.length; k++) {
                                    note.pitches[k] += startInterval;
                                    if (note.pitches[k] < 0 || note.pitches[k] > maxPitch) {
                                        note.pitches.splice(k, 1);
                                        k--;
                                    }
                                    if (note.pitches[k] < lowestPitch)
                                        lowestPitch = note.pitches[k];
                                    if (note.pitches[k] > highestPitch)
                                        highestPitch = note.pitches[k];
                                }
                                if (note.pitches.length < 1)
                                    continue;
                                for (let k = 0; k < note.pins.length; k++) {
                                    const pin = note.pins[k];
                                    if (pin.interval + lowestPitch < 0)
                                        pin.interval = -lowestPitch;
                                    if (pin.interval + highestPitch > maxPitch)
                                        pin.interval = maxPitch - highestPitch;
                                    if (k >= 2) {
                                        if (pin.interval == note.pins[k - 1].interval &&
                                            pin.interval == note.pins[k - 2].interval &&
                                            pin.size == note.pins[k - 1].size &&
                                            pin.size == note.pins[k - 2].size) {
                                            note.pins.splice(k - 1, 1);
                                            k--;
                                        }
                                    }
                                }
                                if (note.start == 0) {
                                    note.continuesLastPattern = (noteObject["continuesLastPattern"] === true);
                                }
                                else {
                                    note.continuesLastPattern = false;
                                }
                                pattern.notes.push(note);
                            }
                        }
                    }
                    channel.patterns.length = this.patternsPerChannel;
                    for (let i = 0; i < this.barCount; i++) {
                        channel.bars[i] = (channelObject["sequence"] != undefined) ? Math.min(this.patternsPerChannel, channelObject["sequence"][i] >>> 0) : 0;
                    }
                    channel.bars.length = this.barCount;
                }
            }
            if (newPitchChannels.length > Config.pitchChannelCountMax)
                newPitchChannels.length = Config.pitchChannelCountMax;
            if (newNoiseChannels.length > Config.noiseChannelCountMax)
                newNoiseChannels.length = Config.noiseChannelCountMax;
            if (newModChannels.length > Config.modChannelCountMax)
                newModChannels.length = Config.modChannelCountMax;
            this.pitchChannelCount = newPitchChannels.length;
            this.noiseChannelCount = newNoiseChannels.length;
            this.modChannelCount = newModChannels.length;
            this.channels.length = 0;
            Array.prototype.push.apply(this.channels, newPitchChannels);
            Array.prototype.push.apply(this.channels, newNoiseChannels);
            Array.prototype.push.apply(this.channels, newModChannels);
        }
        getPattern(channelIndex, bar) {
            if (bar < 0 || bar >= this.barCount)
                return null;
            const patternIndex = this.channels[channelIndex].bars[bar];
            if (patternIndex == 0)
                return null;
            return this.channels[channelIndex].patterns[patternIndex - 1];
        }
        getBeatsPerMinute() {
            return this.tempo;
        }
        static getNeededBits(maxValue) {
            return 32 - Math.clz32(Math.ceil(maxValue + 1) - 1);
        }
        restoreLimiterDefaults() {
            this.compressionRatio = 1.0;
            this.limitRatio = 1.0;
            this.limitRise = 4000.0;
            this.limitDecay = 4.0;
            this.limitThreshold = 1.0;
            this.compressionThreshold = 1.0;
            this.masterGain = 1.0;
        }
    }
    Song._format = "FruityBox"; 
    Song._oldestBeepboxVersion = 2;
    Song._latestBeepboxVersion = 9;
    Song._oldestJummBoxVersion = 1;
    Song._latestJummBoxVersion = 5;
    Song._variant = 0x6A;
    class PickedString {
        constructor() {
            this.delayLine = null;
            this.reset();
        }
        reset() {
            this.delayIndex = -1;
            this.allPassSample = 0.0;
            this.allPassPrevInput = 0.0;
            this.shelfSample = 0.0;
            this.shelfPrevInput = 0.0;
            this.fractionalDelaySample = 0.0;
            this.prevDelayLength = -1.0;
            this.delayResetOffset = 0;
        }
    }
    class EnvelopeComputer {
        constructor() {
            this.noteSecondsStart = 0.0;
            this.noteSecondsEnd = 0.0;
            this.noteTicksStart = 0.0;
            this.noteTicksEnd = 0.0;
            this.noteSizeStart = Config.noteSizeMax;
            this.noteSizeEnd = Config.noteSizeMax;
            this.prevNoteSize = Config.noteSizeMax;
            this.nextNoteSize = Config.noteSizeMax;
            this._noteSizeFinal = Config.noteSizeMax;
            this.prevNoteSecondsStart = 0.0;
            this.prevNoteSecondsEnd = 0.0;
            this.prevNoteTicksStart = 0.0;
            this.prevNoteTicksEnd = 0.0;
            this._prevNoteSizeFinal = Config.noteSizeMax;
            this.prevSlideStart = false;
            this.prevSlideEnd = false;
            this.nextSlideStart = false;
            this.nextSlideEnd = false;
            this.prevSlideRatioStart = 0.0;
            this.prevSlideRatioEnd = 0.0;
            this.nextSlideRatioStart = 0.0;
            this.nextSlideRatioEnd = 0.0;
            this.envelopeStarts = [];
            this.envelopeEnds = [];
            this.lowpassCutoffDecayVolumeCompensation = 1.0;
            const length = 56;
            for (let i = 0; i < length; i++) {
                this.envelopeStarts[i] = 1.0;
                this.envelopeEnds[i] = 1.0;
            }
            this.reset();
        }
        reset() {
            this.noteSecondsEnd = 0.0;
            this.noteTicksEnd = 0.0;
            this._noteSizeFinal = Config.noteSizeMax;
            this.prevNoteSecondsEnd = 0.0;
            this.prevNoteTicksEnd = 0.0;
            this._prevNoteSizeFinal = Config.noteSizeMax;
        }
        computeEnvelopes(instrument, currentPart, tickTimeStart, tickTimeEnd, secondsPassing, tone) {
            const transition = instrument.getTransition();
            if (tone != null && tone.atNoteStart && !transition.continues && !tone.forceContinueAtStart) {
                this.prevNoteSecondsEnd = this.noteSecondsEnd;
                this.prevNoteTicksEnd = this.noteTicksEnd;
                this._prevNoteSizeFinal = this._noteSizeFinal;
                this.noteSecondsEnd = 0.0;
                this.noteTicksEnd = 0.0;
            }
            if (tone != null) {
                if (tone.note != null) {
                    this._noteSizeFinal = tone.note.pins[tone.note.pins.length - 1].size;
                }
                else {
                    this._noteSizeFinal = Config.noteSizeMax;
                }
            }
            const ticksPassing = tickTimeEnd - tickTimeStart;
            const noteSecondsStart = this.noteSecondsEnd;
            const noteSecondsEnd = noteSecondsStart + secondsPassing;
            const noteTicksStart = this.noteTicksEnd;
            const noteTicksEnd = noteTicksStart + ticksPassing;
            const prevNoteSecondsStart = this.prevNoteSecondsEnd;
            const prevNoteSecondsEnd = prevNoteSecondsStart + secondsPassing;
            const prevNoteTicksStart = this.prevNoteTicksEnd;
            const prevNoteTicksEnd = prevNoteTicksStart + ticksPassing;
            const beatsPerTick = 1.0 / (Config.ticksPerPart * Config.partsPerBeat);
            const beatTimeStart = beatsPerTick * tickTimeStart;
            const beatTimeEnd = beatsPerTick * tickTimeEnd;
            let noteSizeStart = this._noteSizeFinal;
            let noteSizeEnd = this._noteSizeFinal;
            let prevNoteSize = this._prevNoteSizeFinal;
            let nextNoteSize = 0;
            let prevSlideStart = false;
            let prevSlideEnd = false;
            let nextSlideStart = false;
            let nextSlideEnd = false;
            let prevSlideRatioStart = 0.0;
            let prevSlideRatioEnd = 0.0;
            let nextSlideRatioStart = 0.0;
            let nextSlideRatioEnd = 0.0;
            if (tone != null && tone.note != null && !tone.passedEndOfNote) {
                const endPinIndex = tone.note.getEndPinIndex(currentPart);
                const startPin = tone.note.pins[endPinIndex - 1];
                const endPin = tone.note.pins[endPinIndex];
                const startPinTick = (tone.note.start + startPin.time) * Config.ticksPerPart;
                const endPinTick = (tone.note.start + endPin.time) * Config.ticksPerPart;
                const ratioStart = (tickTimeStart - startPinTick) / (endPinTick - startPinTick);
                const ratioEnd = (tickTimeEnd - startPinTick) / (endPinTick - startPinTick);
                noteSizeStart = startPin.size + (endPin.size - startPin.size) * ratioStart;
                noteSizeEnd = startPin.size + (endPin.size - startPin.size) * ratioEnd;
                if (transition.slides) {
                    const noteStartTick = tone.noteStartPart * Config.ticksPerPart;
                    const noteEndTick = tone.noteEndPart * Config.ticksPerPart;
                    const noteLengthTicks = noteEndTick - noteStartTick;
                    const maximumSlideTicks = noteLengthTicks * 0.5;
                    const slideTicks = Math.min(maximumSlideTicks, transition.slideTicks);
                    if (tone.prevNote != null && !tone.forceContinueAtStart) {
                        if (tickTimeStart - noteStartTick < slideTicks) {
                            prevSlideStart = true;
                            prevSlideRatioStart = 0.5 * (1.0 - (tickTimeStart - noteStartTick) / slideTicks);
                        }
                        if (tickTimeEnd - noteStartTick < slideTicks) {
                            prevSlideEnd = true;
                            prevSlideRatioEnd = 0.5 * (1.0 - (tickTimeEnd - noteStartTick) / slideTicks);
                        }
                    }
                    if (tone.nextNote != null && !tone.forceContinueAtEnd) {
                        nextNoteSize = tone.nextNote.pins[0].size;
                        if (noteEndTick - tickTimeStart < slideTicks) {
                            nextSlideStart = true;
                            nextSlideRatioStart = 0.5 * (1.0 - (noteEndTick - tickTimeStart) / slideTicks);
                        }
                        if (noteEndTick - tickTimeEnd < slideTicks) {
                            nextSlideEnd = true;
                            nextSlideRatioEnd = 0.5 * (1.0 - (noteEndTick - tickTimeEnd) / slideTicks);
                        }
                    }
                }
            }
            let lowpassCutoffDecayVolumeCompensation = 1.0;
            let usedNoteSize = false;
            for (let envelopeIndex = 0; envelopeIndex <= instrument.envelopeCount; envelopeIndex++) {
                let automationTarget;
                let targetIndex;
                let envelope;
                if (envelopeIndex == instrument.envelopeCount) {
                    if (usedNoteSize)
                        break;
                    automationTarget = Config.instrumentAutomationTargets.dictionary["noteVolume"];
                    targetIndex = 0;
                    envelope = Config.envelopes.dictionary["note size"];
                }
                else {
                    let envelopeSettings = instrument.envelopes[envelopeIndex];
                    automationTarget = Config.instrumentAutomationTargets[envelopeSettings.target];
                    targetIndex = envelopeSettings.index;
                    envelope = Config.envelopes[envelopeSettings.envelope];
                      
                    if (envelope.type == 0)
                        usedNoteSize = true;
                }
                if (automationTarget.computeIndex != null) {
                    const computeIndex = automationTarget.computeIndex + targetIndex;
                    let envelopeStart = EnvelopeComputer.computeEnvelope(envelope, noteSecondsStart, beatTimeStart, noteSizeStart);
                    let envelopeEnd = EnvelopeComputer.computeEnvelope(envelope, noteSecondsEnd, beatTimeEnd, noteSizeEnd);
                    if (prevSlideStart) {
                        const other = EnvelopeComputer.computeEnvelope(envelope, prevNoteSecondsStart, beatTimeStart, prevNoteSize);
                        envelopeStart += (other - envelopeStart) * prevSlideRatioStart;
                    }
                    if (prevSlideEnd) {
                        const other = EnvelopeComputer.computeEnvelope(envelope, prevNoteSecondsEnd, beatTimeEnd, prevNoteSize);
                        envelopeEnd += (other - envelopeEnd) * prevSlideRatioEnd;
                    }
                    if (nextSlideStart) {
                        const other = EnvelopeComputer.computeEnvelope(envelope, 0.0, beatTimeStart, nextNoteSize);
                        envelopeStart += (other - envelopeStart) * nextSlideRatioStart;
                    }
                    if (nextSlideEnd) {
                        const other = EnvelopeComputer.computeEnvelope(envelope, 0.0, beatTimeEnd, nextNoteSize);
                        envelopeEnd += (other - envelopeEnd) * nextSlideRatioEnd;
                    }
                    this.envelopeStarts[computeIndex] *= envelopeStart;
                    this.envelopeEnds[computeIndex] *= envelopeEnd;
                    if (automationTarget.isFilter) {
                        const filterSettings = (instrument.tmpNoteFilterStart != null) ? instrument.tmpNoteFilterStart : instrument.noteFilter;
                        if (filterSettings.controlPointCount > targetIndex && filterSettings.controlPoints[targetIndex].type == 0) {
                            lowpassCutoffDecayVolumeCompensation = Math.max(lowpassCutoffDecayVolumeCompensation, EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(envelope));
                        }
                    }
                }
            }
            this.noteSecondsStart = noteSecondsStart;
            this.noteSecondsEnd = noteSecondsEnd;
            this.noteTicksStart = noteTicksStart;
            this.noteTicksEnd = noteTicksEnd;
            this.prevNoteSecondsStart = prevNoteSecondsStart;
            this.prevNoteSecondsEnd = prevNoteSecondsEnd;
            this.prevNoteTicksStart = prevNoteTicksStart;
            this.prevNoteTicksEnd = prevNoteTicksEnd;
            this.prevNoteSize = prevNoteSize;
            this.nextNoteSize = nextNoteSize;
            this.noteSizeStart = noteSizeStart;
            this.noteSizeEnd = noteSizeEnd;
            this.prevSlideStart = prevSlideStart;
            this.prevSlideEnd = prevSlideEnd;
            this.nextSlideStart = nextSlideStart;
            this.nextSlideEnd = nextSlideEnd;
            this.prevSlideRatioStart = prevSlideRatioStart;
            this.prevSlideRatioEnd = prevSlideRatioEnd;
            this.nextSlideRatioStart = nextSlideRatioStart;
            this.nextSlideRatioEnd = nextSlideRatioEnd;
            this.lowpassCutoffDecayVolumeCompensation = lowpassCutoffDecayVolumeCompensation;
        }
        clearEnvelopes(instrument) {
            for (let envelopeIndex = 0; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                const envelopeSettings = instrument.envelopes[envelopeIndex];
                const automationTarget = Config.instrumentAutomationTargets[envelopeSettings.target];
                if (automationTarget.computeIndex != null) {
                    const computeIndex = automationTarget.computeIndex + envelopeSettings.index;
                    this.envelopeStarts[computeIndex] = 1.0;
                    this.envelopeEnds[computeIndex] = 1.0;
                }
            }
            this.envelopeStarts[0] = 1.0;
            this.envelopeEnds[0] = 1.0;
        }
        static computeEnvelope(envelope, time, beats, noteSize) {
          
    switch (envelope.type) {
        case 0: return Synth.noteSizeToVolumeMult(noteSize);
        case 1: return 1.0;
        case 2: return Math.max(1.0, 2.0 - time * 10.0); // punch
        case 3: {
            const attack = 0.25 / Math.sqrt(envelope.speed);
            return time < attack ? time / attack : 1.0 / (1.0 + (time - attack) * envelope.speed);
        }
        case 4: return 1.0 / (1.0 + time * envelope.speed); // twang
        case 5: return 1.0 - 1.0 / (1.0 + time * envelope.speed); // swell
        case 6: return 0.5 - Math.cos(beats * 2.0 * Math.PI * envelope.speed) * 0.5; // tremolo
        case 7: return 0.75 - Math.cos(beats * 2.0 * Math.PI * envelope.speed) * 0.25; // tremolo alt
        case 8: return Math.pow(2, -envelope.speed * time); 
        case 9: {
            const attack = 0.05 / envelope.speed;
            const decay = 0.1 / envelope.speed;
            const sustain = 0.6;
            if (time < attack) return time / attack;
            if (time < attack + decay) return 1.0 - (1.0 - sustain) * ((time - attack) / decay);
            return sustain;
        }
        case 10: {
            const decay = Math.exp(-envelope.speed * time);
            const oscillation = Math.sin(time * envelope.speed * 10.0);
            return Math.abs(oscillation) * decay;
        }
case 11: { 
  return 1.0 - (1.0 - 1.0 / (1.0 + time * envelope.speed));
}

        case 12: {
            return 0.5 + 0.5 * Math.sin(beats * 2.0 * Math.PI * envelope.speed);
        }
        case 13: {
            return Math.min(1.0, time * envelope.speed);
        }
        case 14: {
            return Math.max(0.0, 1.0 - time * envelope.speed);
        }
        case 15: {
            return (Math.floor(beats * envelope.speed) % 2 === 0) ? 1.0 : 0.0;
        }
        case 16: { 
             const phase = (beats * envelope.speed) % 1.0;
            return phase < 0.5
                ? phase * 2.0        // rising edge
                : 2.0 - phase * 2.0; // falling edge
        }
case 17: { 
  const maxNoteSize = 10;
  const t = Math.min(noteSize / maxNoteSize, 1);
  return 1 - (1 - t) * (1 - t);
}
case 18: {
  if (envelope.speed >= 0) {
    return Math.min(1, time * envelope.speed);
  } else {
  const absSpeed = Math.abs(envelope.speed);
    return Math.max(0, 1 - time * absSpeed);
  }
}

case 19: {
  return 0.5 + 0.5 * Math.sin(beats * 2 * Math.PI * envelope.speed * 5);
}
case 20: {
  const base = 0.5 + 0.5 * Math.sin(beats * 2 * Math.PI * envelope.speed);
  const noise = (Math.sin(beats * 2 * Math.PI * envelope.speed * 20) * 0.1);
  return Math.min(1, Math.max(0, base + noise));
}


 

case 21: return 1.0 * +(time < (0.25 / Math.sqrt(envelope.speed)));//13

case 22: {//9
	let temp = 0.5 - Math.cos(beats * envelope.speed) * 0.5;
	temp = 1.0 / (1.0 + time * (envelope.speed - (temp / (1.5 / envelope.speed))));
	temp = temp > 0.0 ? temp : 0.0;
	return temp;
}

case 23: {//11
	let lin = (1.0 - (time / (16 / envelope.speed)));
	lin = lin > 0.0 ? lin : 0.0;
	return lin;
}

case 24: { //12
	let lin = (time / (16 / envelope.speed));
	lin = lin < 1.0 ? lin : 1.0;
	return lin;
}


        default: throw new Error("Unrecognized operator envelope type.");
    }
}

        static getLowpassCutoffDecayVolumeCompensation(envelope) {
            if (envelope.type == 8)
                return 1.25 + 0.025 * envelope.speed;
            if (envelope.type == 4)
                return 1.0 + 0.02 * envelope.speed;
            return 1.0;
        }
    }
    class Tone {
        constructor() {
            this.pitches = Array(Config.maxChordSize + 2).fill(0);
this.pitchCount = 0;
this.chordSize = 0;
this.drumsetPitch = null;
this.note = null;
this.prevNote = null;
this.nextNote = null;
this.prevNotePitchIndex = 0;
this.nextNotePitchIndex = 0;
this.freshlyAllocated = true;
this.atNoteStart = false;
this.isOnLastTick = false;
this.passedEndOfNote = false;
this.forceContinueAtStart = false;
this.forceContinueAtEnd = false;
this.noteStartPart = 0;
this.noteEndPart = 0;
this.ticksSinceReleased = 0;
this.liveInputSamplesHeld = 0;
this.lastInterval = 0;
this.stringSustainStart = 0;
this.stringSustainEnd = 0;
this.noiseSamples = [];
this.phases = [];
this.operatorWaves = [];
this.phaseDeltas = [];
this.expressionStarts = [];
this.expressionDeltas = [];
this.phaseDeltaScales = [];

this.directions = [];
this.chipWaveCompletions = [];
this.chipWavePrevWaves = [];
this.chipWaveCompletionsLastWave = [];
this.phaseDeltaScales = [];
this.expression = 1.0;
this.expressionDelta = 0.0;
this.operatorExpressions = [];
this.operatorExpressionDeltas = [];
this.prevPitchExpressions = Array(Config.maxPitchOrOperatorCount).fill(null);
this.prevVibrato = null;
this.prevStringDecay = null;
this.pulseWidth = 0.0;
this.pulseWidthDelta = 0.0;
this.decimalOffset = 0.0;
this.supersawDynamism = 0.0;
this.supersawDynamismDelta = 0.0;
this.supersawUnisonDetunes = [];
this.supersawShape = 0.0;
this.supersawShapeDelta = 0.0;
this.supersawDelayLength = 0.0;
this.supersawDelayLengthDelta = 0.0;
this.supersawDelayLine = null;
this.supersawDelayIndex = -1;
this.supersawPrevPhaseDelta = null;
this.pickedStrings = [];
this.noteFilters = [];
this.noteFilterCount = 0;
this.initialNoteFilterInput1 = 0.0;
this.initialNoteFilterInput2 = 0.0;
this.specialIntervalExpressionMult = 1.0;
this.feedbackOutputs = [];
this.feedbackMult = 0.0;
this.feedbackDelta = 0.0;
this.stereoVolumeLStart = 0.0;
this.stereoVolumeRStart = 0.0;
this.stereoVolumeLDelta = 0.0;
this.stereoVolumeRDelta = 0.0;
this.stereoDelayStart = 0.0;
this.stereoDelayEnd = 0.0;
this.stereoDelayDelta = 0.0;
this.customVolumeStart = 0.0;
this.customVolumeEnd = 0.0;
this.filterResonanceStart = 0.0;
this.filterResonanceDelta = 0.0;
this.isFirstOrder = false;
this.envelopeComputer = new EnvelopeComputer();
             
            this.reset();
        }
        reset() {
            this.sample = 0.0;
            const maxWaves = Math.max(Config.maxChordSize, Config.operatorCount);
            
for (let i = 0; i < Config.maxPitchOrOperatorCount; i++) {
	this.phases[i] = 0.0;
	this.directions[i] = 1;
	this.chipWaveCompletions[i] = 0;
	this.chipWavePrevWaves[i] = 0;
	this.chipWaveCompletionsLastWave[i] = 0;
	this.operatorWaves[i] = Config.operatorWaves[0];
	this.feedbackOutputs[i] = 0.0;
	this.prevPitchExpressions[i] = null;
}
            
            for (let i = 0; i < maxWaves; i++) {
                this.phases[i] = 0.0;
                this.feedbackOutputs[i] = 0.0;
            }
            for (let i = 0; i < this.noteFilterCount; i++) {
                this.noteFilters[i].resetOutput();
            }
            this.noteFilterCount = 0;
            this.initialNoteFilterInput1 = 0.0;
            this.initialNoteFilterInput2 = 0.0;
            this.liveInputSamplesHeld = 0;
            for (const pickedString of this.pickedStrings) {
                pickedString.reset();
            }
            this.envelopeComputer.reset();
            this.prevVibrato = null;
            this.drumsetPitch = null;
        }
    }
  //  alert(liverpadsample)
    class InstrumentState {
        constructor() {
            this.awake = false;
            this.computed = false;
            this.tonesAddedInThisTick = false;
            this.flushingDelayLines = false;
            this.deactivateAfterThisTick = false;
            this.attentuationProgress = 0.0;
            this.flushedSamples = 0;
            this.activeTones = new Deque();
            this.activeModTones = new Deque();
            this.releasedTones = new Deque();
            this.liveInputTones = new Deque();
            this.eqFilterVolumeStart = 1.0;
            this.eqFilterVolumeDelta = 0.0;
            this.mixVolumeStart = 1.0;
            this.mixVolumeDelta = 0.0;
            this.delayInputMultStart = 0.0;
            this.delayInputMultDelta = 0.0;
            this.distortionStart = 0.0;
            this.distortionEnd = 0.0;
            this.envelopeComputer = new EnvelopeComputer();
            
            this.synthesizer = null;
this.wave = [1,0];
this.ringModMix = 0;
this.ringModMixDelta = 0;
this.ringModPhase = 0;
this.ringModPhaseDelta = 0;
this.ringModPhaseDeltaScale = 1.0;
this.ringModWaveformIndex = 0.0;
this.ringModPulseWidth = 0.0;
this.ringModHzOffset = 0.0;
this.ringModMixFade = 1.0;
this.ringModMixFadeDelta = 0;
this.isUsingAdvancedLoopControls = false;
this.chipWaveLoopStart = 0;
this.chipWaveLoopEnd = 0;
this.chipWaveLoopMode = 0;
this.chipWavePlayBackwards = false;
this.chipWaveStartOffset = 0;
            this.volumeScale = 0;
            this.distortionFractionalInput1 = 0.0;
            this.distortionFractionalInput2 = 0.0;
            this.distortionFractionalInput3 = 0.0;
            this.distortionPrevInput = 0.0;
            this.distortionNextOutput = 0.0;
            this.bitcrusherPrevInput = 0.0;
            this.bitcrusherCurrentOutput = 0.0;
            this.bitcrusherPhase = 1.0;
            this.bitcrusherPhaseDelta = 0.0;
            this.bitcrusherPhaseDeltaScale = 1.0;
            this.bitcrusherScale = 1.0;
            this.bitcrusherScaleScale = 1.0;
            this.bitcrusherFoldLevel = 1.0;
            this.bitcrusherFoldLevelScale = 1.0;
            this.eqFilters = [];
            this.eqFilterCount = 0;
            this.initialEqFilterInput1 = 0.0;
            this.initialEqFilterInput2 = 0.0;
            this.panningDelayLine = null;
            this.panningDelayPos = 0;
            this.panningVolumeStartL = 0.0;
            this.panningVolumeStartR = 0.0;
            this.panningVolumeDeltaL = 0.0;
            this.panningVolumeDeltaR = 0.0;
            this.panningOffsetStartL = 0.0;
            this.panningOffsetStartR = 0.0;
            this.panningOffsetDeltaL = 0.0;
            this.panningOffsetDeltaR = 0.0;
            this.chorusDelayLineL = null;
            this.chorusDelayLineR = null;
            this.chorusDelayLineDirty = false;
            this.chorusDelayPos = 0;
            this.chorusPhase = 0;
            this.chorusStart = 0;
            this.chorusEnd = 0;
            this.echoDelayLineL = null;
            this.echoDelayLineR = null;
            this.echoDelayLineDirty = false;
            this.echoDelayPos = 0;
            this.echoDelayOffsetStart = 0;
            this.echoDelayOffsetEnd = 0;
            this.echoDelayOffsetLastTick = 0;
            this.echoDelayOffsetRatio = 0.0;
            this.echoDelayOffsetRatioDelta = 0.0;
            this.echoDelayOffsetLastTickIsComputed = false;
            this.echoMultStart = 0.0;
            this.echoMultDelta = 0.0;
            this.echoShelfA1 = 0.0;
            this.echoShelfB0 = 0.0;
            this.echoShelfB1 = 0.0;
            this.echoShelfSampleL = 0.0;
            this.echoShelfSampleR = 0.0;
            this.echoShelfPrevInputL = 0.0;
            this.echoShelfPrevInputR = 0.0;
            this.reverbDelayLine = null;
            this.reverbDelayLineDirty = false;
            this.reverbDelayPos = 0;
            this.reverbMultStart = 0.0;
            this.reverbMultDelta = 0.0;
            this.reverbShelfA1 = 0.0;
            this.reverbShelfB0 = 0.0;
            this.reverbShelfB1 = 0.0;
            this.reverbShelfSample0 = 0.0;
            this.reverbShelfSample1 = 0.0;
            this.reverbShelfSample2 = 0.0;
            this.reverbShelfSample3 = 0.0;
            this.reverbShelfPrevInput0 = 0.0;
            this.reverbShelfPrevInput1 = 0.0;
            this.reverbShelfPrevInput2 = 0.0;
            this.reverbShelfPrevInput3 = 0.0;
        }
        
updateWaves(instrument, samplesPerSecond) {
	this.volumeScale = 1.0;
	 
	if (instrument.type == 0) {
		 	this.wave =  Config.chipWaves[instrument.chipWave].samples ;
		
		this.isUsingAdvancedLoopControls = instrument.isUsingAdvancedLoopControls;
		this.chipWaveLoopStart = instrument.chipWaveLoopStart;
		this.chipWaveLoopEnd = instrument.chipWaveLoopEnd;
		this.chipWaveLoopMode = instrument.chipWaveLoopMode;
		this.chipWavePlayBackwards = instrument.chipWavePlayBackwards;
		this.chipWaveStartOffset = instrument.chipWaveStartOffset;
		this.unisonVoices = instrument.unisonVoices;
		this.unisonSpread = instrument.unisonSpread;
		this.unisonOffset = instrument.unisonOffset;
		this.unisonExpression = instrument.unisonExpression;
		this.unisonSign = instrument.unisonSign;
	} 
	else {
		this.wave = null;
	}
}
        
        allocateNecessaryBuffers(synth, instrument, samplesPerTick) {
            if (effectsIncludePanning(instrument.effects)) {
                if (this.panningDelayLine == null || this.panningDelayLine.length < synth.panningDelayBufferSize) {
                    this.panningDelayLine = new Float32Array(synth.panningDelayBufferSize);
                }
            }
            if (effectsIncludeChorus(instrument.effects)) {
                if (this.chorusDelayLineL == null || this.chorusDelayLineL.length < synth.chorusDelayBufferSize) {
                    this.chorusDelayLineL = new Float32Array(synth.chorusDelayBufferSize);
                }
                if (this.chorusDelayLineR == null || this.chorusDelayLineR.length < synth.chorusDelayBufferSize) {
                    this.chorusDelayLineR = new Float32Array(synth.chorusDelayBufferSize);
                }
            }
            if (effectsIncludeEcho(instrument.effects)) {
                const safeEchoDelaySteps = Math.max(Config.echoDelayRange >> 1, (instrument.echoDelay + 1));
                const baseEchoDelayBufferSize = Synth.fittingPowerOfTwo(safeEchoDelaySteps * Config.echoDelayStepTicks * samplesPerTick);
                const safeEchoDelayBufferSize = baseEchoDelayBufferSize * 2;
                if (this.echoDelayLineL == null || this.echoDelayLineR == null) {
                    this.echoDelayLineL = new Float32Array(safeEchoDelayBufferSize);
                    this.echoDelayLineR = new Float32Array(safeEchoDelayBufferSize);
                }
                else if (this.echoDelayLineL.length < safeEchoDelayBufferSize || this.echoDelayLineR.length < safeEchoDelayBufferSize) {
                    const newDelayLineL = new Float32Array(safeEchoDelayBufferSize);
                    const newDelayLineR = new Float32Array(safeEchoDelayBufferSize);
                    const oldMask = this.echoDelayLineL.length - 1;
                    for (let i = 0; i < this.echoDelayLineL.length; i++) {
                        newDelayLineL[i] = this.echoDelayLineL[(this.echoDelayPos + i) & oldMask];
                        newDelayLineR[i] = this.echoDelayLineL[(this.echoDelayPos + i) & oldMask];
                    }
                    this.echoDelayPos = this.echoDelayLineL.length;
                    this.echoDelayLineL = newDelayLineL;
                    this.echoDelayLineR = newDelayLineR;
                }
            }
            if (effectsIncludeReverb(instrument.effects)) {
                if (this.reverbDelayLine == null) {
                    this.reverbDelayLine = new Float32Array(Config.reverbDelayBufferSize);
                }
            }
        }
        deactivate() {
            this.bitcrusherPrevInput = 0.0;
            this.bitcrusherCurrentOutput = 0.0;
            this.bitcrusherPhase = 1.0;
            for (let i = 0; i < this.eqFilterCount; i++) {
                this.eqFilters[i].resetOutput();
            }
            this.eqFilterCount = 0;
            this.initialEqFilterInput1 = 0.0;
            this.initialEqFilterInput2 = 0.0;
            this.distortionFractionalInput1 = 0.0;
            this.distortionFractionalInput2 = 0.0;
            this.distortionFractionalInput3 = 0.0;
            this.distortionPrevInput = 0.0;
            this.distortionNextOutput = 0.0;
            this.panningDelayPos = 0;
            if (this.panningDelayLine != null)
                for (let i = 0; i < this.panningDelayLine.length; i++)
                    this.panningDelayLine[i] = 0.0;
            this.echoDelayOffsetLastTickIsComputed = false;
            this.echoShelfSampleL = 0.0;
            this.echoShelfSampleR = 0.0;
            this.echoShelfPrevInputL = 0.0;
            this.echoShelfPrevInputR = 0.0;
            this.reverbShelfSample0 = 0.0;
            this.reverbShelfSample1 = 0.0;
            this.reverbShelfSample2 = 0.0;
            this.reverbShelfSample3 = 0.0;
            this.reverbShelfPrevInput0 = 0.0;
            this.reverbShelfPrevInput1 = 0.0;
            this.reverbShelfPrevInput2 = 0.0;
            this.reverbShelfPrevInput3 = 0.0;
            this.awake = false;
            this.flushingDelayLines = false;
            this.deactivateAfterThisTick = false;
            this.attentuationProgress = 0.0;
            this.flushedSamples = 0;
        }
        resetAllEffects() {
            this.deactivate();
            if (this.chorusDelayLineDirty) {
                for (let i = 0; i < this.chorusDelayLineL.length; i++)
                    this.chorusDelayLineL[i] = 0.0;
                for (let i = 0; i < this.chorusDelayLineR.length; i++)
                    this.chorusDelayLineR[i] = 0.0;
            }
            if (this.echoDelayLineDirty) {
                for (let i = 0; i < this.echoDelayLineL.length; i++)
                    this.echoDelayLineL[i] = 0.0;
                for (let i = 0; i < this.echoDelayLineR.length; i++)
                    this.echoDelayLineR[i] = 0.0;
            }
            if (this.reverbDelayLineDirty) {
                for (let i = 0; i < this.reverbDelayLine.length; i++)
                    this.reverbDelayLine[i] = 0.0;
            }
            this.chorusPhase = 0.0;
            this.ringModPhase = 0.0;
            this.ringModMixFade = 1.0;
            
        }
        compute(synth, instrument, samplesPerTick, runLength, tone, channelIndex, instrumentIndex) {
            this.computed = true;
            this.allocateNecessaryBuffers(synth, instrument, samplesPerTick);
            const envelopeStarts = instrument.envelopeComputer.envelopeStarts;
    const envelopeEnds = instrument.envelopeComputer.envelopeEnds;

            const samplesPerSecond = synth.samplesPerSecond;
            const tickSampleCountdown = synth.tickSampleCountdown;
            const tickRemainingStart = (tickSampleCountdown) / samplesPerTick;
            const tickRemainingEnd = (tickSampleCountdown - runLength) / samplesPerTick;
            const usesDistortion = effectsIncludeDistortion(instrument.effects);
            const usesBitcrusher = effectsIncludeBitcrusher(instrument.effects);
            const usesPanning = effectsIncludePanning(instrument.effects);
            const usesChorus = effectsIncludeChorus(instrument.effects);
            const usesEcho = effectsIncludeEcho(instrument.effects);
            const usesReverb = effectsIncludeReverb(instrument.effects);
            const usesRingModulation = effectsIncludeRingModulation(instrument.effects);
            
            if (usesDistortion) {
                let useDistortionStart = instrument.distortion;
                let useDistortionEnd = instrument.distortion;
                if (synth.isModActive(Config.modulators.dictionary["distortion"].index, channelIndex, instrumentIndex)) {
                    useDistortionStart = synth.getModValue(Config.modulators.dictionary["distortion"].index, channelIndex, instrumentIndex, false);
                    useDistortionEnd = synth.getModValue(Config.modulators.dictionary["distortion"].index, channelIndex, instrumentIndex, true);
                }
                this.distortionStart = Math.min(1.0, useDistortionStart / (Config.distortionRange - 1));
                this.distortionEnd = Math.min(1.0, useDistortionEnd / (Config.distortionRange - 1));
            }
            if (usesBitcrusher) {
                let freqSettingStart = instrument.bitcrusherFreq;
                let freqSettingEnd = instrument.bitcrusherFreq;
                if (synth.isModActive(Config.modulators.dictionary["freq crush"].index, channelIndex, instrumentIndex)) {
                    freqSettingStart = synth.getModValue(Config.modulators.dictionary["freq crush"].index, channelIndex, instrumentIndex, false);
                    freqSettingEnd = synth.getModValue(Config.modulators.dictionary["freq crush"].index, channelIndex, instrumentIndex, true);
                }
                let quantizationSettingStart = instrument.bitcrusherQuantization;
                let quantizationSettingEnd = instrument.bitcrusherQuantization;
                if (synth.isModActive(Config.modulators.dictionary["bit crush"].index, channelIndex, instrumentIndex)) {
                    quantizationSettingStart = synth.getModValue(Config.modulators.dictionary["bit crush"].index, channelIndex, instrumentIndex, false);
                    quantizationSettingEnd = synth.getModValue(Config.modulators.dictionary["bit crush"].index, channelIndex, instrumentIndex, true);
                }
                const basePitch = Config.keys[synth.song.key].basePitch;
                const freqStart = Instrument.frequencyFromPitch(basePitch + 60) * Math.pow(2.0, (Config.bitcrusherFreqRange - 1 - freqSettingStart) * Config.bitcrusherOctaveStep);
                const freqEnd = Instrument.frequencyFromPitch(basePitch + 60) * Math.pow(2.0, (Config.bitcrusherFreqRange - 1 - freqSettingEnd) * Config.bitcrusherOctaveStep);
                const phaseDeltaStart = Math.min(1.0, freqStart / samplesPerSecond);
                const phaseDeltaEnd = Math.min(1.0, freqEnd / samplesPerSecond);
                this.bitcrusherPhaseDelta = phaseDeltaStart;
                this.bitcrusherPhaseDeltaScale = Math.pow(phaseDeltaEnd / phaseDeltaStart, 1.0 / runLength);
                const scaleStart = 2.0 * Config.bitcrusherBaseVolume * Math.pow(2.0, 1.0 - Math.pow(2.0, (Config.bitcrusherQuantizationRange - 1 - quantizationSettingStart) * 0.5));
                const scaleEnd = 2.0 * Config.bitcrusherBaseVolume * Math.pow(2.0, 1.0 - Math.pow(2.0, (Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd) * 0.5));
                this.bitcrusherScale = scaleStart;
                this.bitcrusherScaleScale = Math.pow(scaleEnd / scaleStart, 1.0 / runLength);
                const foldLevelStart = 2.0 * Config.bitcrusherBaseVolume * Math.pow(1.5, Config.bitcrusherQuantizationRange - 1 - quantizationSettingStart);
                const foldLevelEnd = 2.0 * Config.bitcrusherBaseVolume * Math.pow(1.5, Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd);
                this.bitcrusherFoldLevel = foldLevelStart;
                this.bitcrusherFoldLevelScale = Math.pow(foldLevelEnd / foldLevelStart, 1.0 / runLength);
            }
            let eqFilterVolume = 1.0;
            if (instrument.eqFilterType) {
                const eqFilterSettingsStart = instrument.eqFilter;
                if (instrument.eqSubFilters[1] == null)
                    instrument.eqSubFilters[1] = new FilterSettings();
                const eqFilterSettingsEnd = instrument.eqSubFilters[1];
                let startSimpleFreq = instrument.eqFilterSimpleCut;
                let startSimpleGain = instrument.eqFilterSimplePeak;
                let endSimpleFreq = instrument.eqFilterSimpleCut;
                let endSimpleGain = instrument.eqFilterSimplePeak;
                let filterChanges = false;
                if (synth.isModActive(Config.modulators.dictionary["eq filt cut"].index, channelIndex, instrumentIndex)) {
                    startSimpleFreq = synth.getModValue(Config.modulators.dictionary["eq filt cut"].index, channelIndex, instrumentIndex, false);
                    endSimpleFreq = synth.getModValue(Config.modulators.dictionary["eq filt cut"].index, channelIndex, instrumentIndex, true);
                    filterChanges = true;
                }
                if (synth.isModActive(Config.modulators.dictionary["eq filt peak"].index, channelIndex, instrumentIndex)) {
                    startSimpleGain = synth.getModValue(Config.modulators.dictionary["eq filt peak"].index, channelIndex, instrumentIndex, false);
                    endSimpleGain = synth.getModValue(Config.modulators.dictionary["eq filt peak"].index, channelIndex, instrumentIndex, true);
                    filterChanges = true;
                }
                let startPoint;
                if (filterChanges) {
                    eqFilterSettingsStart.convertLegacySettingsForSynth(startSimpleFreq, startSimpleGain);
                    eqFilterSettingsEnd.convertLegacySettingsForSynth(endSimpleFreq, endSimpleGain);
                    startPoint = eqFilterSettingsStart.controlPoints[0];
                    let endPoint = eqFilterSettingsEnd.controlPoints[0];
                    startPoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, 1.0, 1.0);
                    endPoint.toCoefficients(Synth.tempFilterEndCoefficients, samplesPerSecond, 1.0, 1.0);
                    if (this.eqFilters.length < 1)
                        this.eqFilters[0] = new DynamicBiquadFilter();
                    this.eqFilters[0].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / runLength, startPoint.type == 0);
                }
                else {
                    eqFilterSettingsStart.convertLegacySettingsForSynth(startSimpleFreq, startSimpleGain, true);
                    startPoint = eqFilterSettingsStart.controlPoints[0];
                    startPoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, 1.0, 1.0);
                    if (this.eqFilters.length < 1)
                        this.eqFilters[0] = new DynamicBiquadFilter();
                    this.eqFilters[0].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterStartCoefficients, 1.0 / runLength, startPoint.type == 0);
                }
                eqFilterVolume *= startPoint.getVolumeCompensationMult();
                this.eqFilterCount = 1;
                eqFilterVolume = Math.min(3.0, eqFilterVolume);
            }
            else {
                const eqFilterSettings = (instrument.tmpEqFilterStart != null) ? instrument.tmpEqFilterStart : instrument.eqFilter;
                for (let i = 0; i < eqFilterSettings.controlPointCount; i++) {
                    let startPoint = eqFilterSettings.controlPoints[i];
                    let endPoint = (instrument.tmpEqFilterEnd != null && instrument.tmpEqFilterEnd.controlPoints[i] != null) ? instrument.tmpEqFilterEnd.controlPoints[i] : eqFilterSettings.controlPoints[i];
                    startPoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, 1.0, 1.0);
                    endPoint.toCoefficients(Synth.tempFilterEndCoefficients, samplesPerSecond, 1.0, 1.0);
                    if (this.eqFilters.length <= i)
                        this.eqFilters[i] = new DynamicBiquadFilter();
                    this.eqFilters[i].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / runLength, startPoint.type == 0);
                    eqFilterVolume *= startPoint.getVolumeCompensationMult();
                }
                this.eqFilterCount = eqFilterSettings.controlPointCount;
                eqFilterVolume = Math.min(3.0, eqFilterVolume);
            }
            const mainInstrumentVolume = Synth.instrumentVolumeToVolumeMult(instrument.volume);
            this.mixVolumeStart = mainInstrumentVolume;
            const mixVolumeEnd = mainInstrumentVolume;
            this.mixVolumeDelta = (mixVolumeEnd - this.mixVolumeStart) / runLength;
            let eqFilterVolumeStart = eqFilterVolume;
            let eqFilterVolumeEnd = eqFilterVolume;
            let delayInputMultStart = 1.0;
            let delayInputMultEnd = 1.0;
            if (usesPanning) {
                let usePanStart = instrument.pan;
                let usePanEnd = instrument.pan;
                if (synth.isModActive(Config.modulators.dictionary["pan"].index, channelIndex, instrumentIndex)) {
                    usePanStart = synth.getModValue(Config.modulators.dictionary["pan"].index, channelIndex, instrumentIndex, false);
                    usePanEnd = synth.getModValue(Config.modulators.dictionary["pan"].index, channelIndex, instrumentIndex, true);
                }
                let panStart = Math.max(-1.0, Math.min(1.0, (usePanStart - Config.panCenter) / Config.panCenter));
                let panEnd = Math.max(-1.0, Math.min(1.0, (usePanEnd - Config.panCenter) / Config.panCenter));
                const volumeStartL = Math.cos((1 + panStart) * Math.PI * 0.25) * 1.414;
                const volumeStartR = Math.cos((1 - panStart) * Math.PI * 0.25) * 1.414;
                const volumeEndL = Math.cos((1 + panEnd) * Math.PI * 0.25) * 1.414;
                const volumeEndR = Math.cos((1 - panEnd) * Math.PI * 0.25) * 1.414;
                const maxDelaySamples = samplesPerSecond * Config.panDelaySecondsMax;
                let usePanDelayStart = instrument.panDelay;
                let usePanDelayEnd = instrument.panDelay;
                if (synth.isModActive(Config.modulators.dictionary["pan delay"].index, channelIndex, instrumentIndex)) {
                    usePanDelayStart = synth.getModValue(Config.modulators.dictionary["pan delay"].index, channelIndex, instrumentIndex, false);
                    usePanDelayEnd = synth.getModValue(Config.modulators.dictionary["pan delay"].index, channelIndex, instrumentIndex, true);
                }
                const delayStart = panStart * usePanDelayStart * maxDelaySamples / 10;
                const delayEnd = panEnd * usePanDelayEnd * maxDelaySamples / 10;
                const delayStartL = Math.max(0.0, delayStart);
                const delayStartR = Math.max(0.0, -delayStart);
                const delayEndL = Math.max(0.0, delayEnd);
                const delayEndR = Math.max(0.0, -delayEnd);
                this.panningVolumeStartL = volumeStartL;
                this.panningVolumeStartR = volumeStartR;
                this.panningVolumeDeltaL = (volumeEndL - volumeStartL) / runLength;
                this.panningVolumeDeltaR = (volumeEndR - volumeStartR) / runLength;
                this.panningOffsetStartL = delayStartL;
                this.panningOffsetStartR = delayStartR;
                this.panningOffsetDeltaL = (delayEndL - delayStartL) / runLength;
                this.panningOffsetDeltaR = (delayEndR - delayStartR) / runLength;
            }
            if (usesChorus) {
                let useChorusStart = instrument.chorus;
                let useChorusEnd = instrument.chorus;
                if (synth.isModActive(Config.modulators.dictionary["chorus"].index, channelIndex, instrumentIndex)) {
                    useChorusStart = synth.getModValue(Config.modulators.dictionary["chorus"].index, channelIndex, instrumentIndex, false);
                    useChorusEnd = synth.getModValue(Config.modulators.dictionary["chorus"].index, channelIndex, instrumentIndex, true);
                }
                const chorusStart = Math.min(1.0, useChorusStart / (Config.chorusRange - 1));
                const chorusEnd = Math.min(1.0, useChorusEnd / (Config.chorusRange - 1));
                this.chorusStart = chorusStart * 0.6 + (Math.pow(chorusStart, 6.0)) * 0.4;
                this.chorusEnd = chorusEnd * 0.6 + (Math.pow(chorusEnd, 6.0)) * 0.4;
            }

let usesCustomUnison=instrument.unison === Config.unisons.length
function step(value, stepSize) {
    return Math.round(value / stepSize) * stepSize;
}
if (usesCustomUnison) {
    instrument.unison = Config.unisons.length; 
if(instrument.detectForUnison==0){
	instrument.last_unisonVoices = instrument.unisonVoices
 instrument.last_unisonSign = instrument.unisonSign
 instrument.last_unisonExpression = instrument.unisonExpression
 instrument.last_unisonOffset = instrument.unisonOffset
 instrument.last_unisonSpread = instrument.unisonSpread
}
instrument.detectForUnison=1;
    if (synth.isModActive(Config.modulators.dictionary["unisonVoices"].index, channelIndex, instrumentIndex)) {
        instrument.unisonVoices = step(
            synth.getModValue(Config.modulators.dictionary["unisonVoices"].index, channelIndex, instrumentIndex, true),
            0.01
        )/10
    }
    if (synth.isModActive(Config.modulators.dictionary["unisonSpread"].index, channelIndex, instrumentIndex)) {
instrument.unisonSpread = (step(((
	synth.getModValue(Config.modulators.dictionary["unisonSpread"].index, channelIndex, instrumentIndex, true)
)) - (Config.unisonSpreadMax * 5), 0.01) / 5) - 0.2
    }
    if (synth.isModActive(Config.modulators.dictionary["unisonSign"].index, channelIndex, instrumentIndex)) {
instrument.unisonSign = (step(((
	synth.getModValue(Config.modulators.dictionary["unisonSign"].index, channelIndex, instrumentIndex, true)
)) - (Config.unisonSignMax * 5), 0.01) / 5) - 0.2
    }
    if (synth.isModActive(Config.modulators.dictionary["unisonExpression"].index, channelIndex, instrumentIndex)) {
        instrument.unisonExpression = step(
            synth.getModValue(Config.modulators.dictionary["unisonExpression"].index, channelIndex, instrumentIndex, true),
            0.01
        )/10;
    }
    if (synth.isModActive(Config.modulators.dictionary["unisonOffset"].index, channelIndex, instrumentIndex)) {
      instrument.unisonOffset = (step(((
        	synth.getModValue(Config.modulators.dictionary["unisonOffset"].index, channelIndex, instrumentIndex, true)
      ) ) - (Config.unisonOffsetMax*5 ) , 0.01)/5 )-0.2
    }
}



 if (usesRingModulation) {
  let useRingModStart = instrument.ringModulation;
  let useRingModEnd = instrument.ringModulation;
  let useRingModEnvelopeStart = envelopeStarts[49];
  let useRingModEnvelopeEnd = envelopeEnds[49];
  let useRingModHzStart = Math.min(1.0, instrument.ringModulationHz / (Config.ringModHzRange - 1));
  let useRingModHzEnd = Math.min(1.0, instrument.ringModulationHz / (Config.ringModHzRange - 1));
  let useRingModHzEnvelopeStart = envelopeStarts[50];
  let useRingModHzEnvelopeEnd = envelopeEnds[50];
  if (synth.isModActive(Config.modulators.dictionary["ring modulation"].index, channelIndex, instrumentIndex)) {
   useRingModStart = (synth.getModValue(Config.modulators.dictionary["ring modulation"].index, channelIndex, instrumentIndex, false));
   useRingModEnd = (synth.getModValue(Config.modulators.dictionary["ring modulation"].index, channelIndex, instrumentIndex, true));
  }
  if (synth.isModActive(Config.modulators.dictionary["ring mod hertz"].index, channelIndex, instrumentIndex)) {
   useRingModHzStart = Math.min(1.0, Math.max(0.0, (synth.getModValue(Config.modulators.dictionary["ring mod hertz"].index, channelIndex, instrumentIndex, false)) / (Config.ringModHzRange - 1)));
   useRingModHzEnd = Math.min(1.0, Math.max(0.0, (synth.getModValue(Config.modulators.dictionary["ring mod hertz"].index, channelIndex, instrumentIndex, false)) / (Config.ringModHzRange - 1)));
  }
  useRingModHzStart *= useRingModHzEnvelopeStart;
 useRingModHzEnd *= useRingModHzEnvelopeEnd;
  let ringModStart = Math.min(1.0, (useRingModStart * useRingModEnvelopeStart) / (Config.ringModRange - 1));
  let ringModEnd = Math.min(1.0, (useRingModEnd * useRingModEnvelopeEnd) / (Config.ringModRange - 1));
  this.ringModMix = ringModStart;
  this.ringModMixDelta = (ringModEnd - ringModStart) / samplesPerTick;
  this.ringModHzOffset = instrument.ringModHzOffset;
  let ringModPhaseDeltaStart = (Math.max(0, calculateRingModHertz(useRingModHzStart))) / synth.samplesPerSecond;
  let ringModPhaseDeltaEnd = (Math.max(0, calculateRingModHertz(useRingModHzEnd))) / synth.samplesPerSecond;
  this.ringModMixFadeDelta = 0;
  if (this.ringModMixFade < 0)
   this.ringModMixFade = 0;
  if (ringModPhaseDeltaStart <= 0 && ringModPhaseDeltaEnd <= 0 && this.ringModMixFade != 0) {
   this.ringModMixFadeDelta = this.ringModMixFade / -10;
  }
  else if (ringModPhaseDeltaStart > 0 && ringModPhaseDeltaEnd > 0) {
   this.ringModMixFade = 1.0;
  }
  this.ringModPhaseDelta = ringModPhaseDeltaStart;
  this.ringModPhaseDeltaScale = ringModPhaseDeltaStart == 0 ? 1 : Math.pow(ringModPhaseDeltaEnd / ringModPhaseDeltaStart, 1.0 / samplesPerTick);
  this.ringModWaveformIndex = instrument.ringModWaveformIndex;
  
if (synth.isModActive(Config.modulators.dictionary["ring pulse mod"].index, channelIndex, instrumentIndex)) {
this.ringModPulseWidth=	Math.floor(Math.min(1.0, Math.max(0.0, (synth.getModValue(Config.modulators.dictionary["ring pulse mod"].index, channelIndex, instrumentIndex, false)) / (Config.pwmOperatorWaves.length - 1 )))*10);
}else{
  this.ringModPulseWidth = instrument.ringModPulseWidth;
  
}
}
            
            
            let maxEchoMult = 0.0;
            if (usesEcho) {
                let useEchoSustainStart = instrument.echoSustain;
                let useEchoSustainEnd = instrument.echoSustain;
                if (synth.isModActive(Config.modulators.dictionary["echo"].index, channelIndex, instrumentIndex)) {
                    useEchoSustainStart = synth.getModValue(Config.modulators.dictionary["echo"].index, channelIndex, instrumentIndex, false);
                    useEchoSustainEnd = synth.getModValue(Config.modulators.dictionary["echo"].index, channelIndex, instrumentIndex, true);
                }
                const echoMultStart = Math.min(1.0, Math.pow(useEchoSustainStart / Config.echoSustainRange, 1.1)) * 0.9;
                const echoMultEnd = Math.min(1.0, Math.pow(useEchoSustainEnd / Config.echoSustainRange, 1.1)) * 0.9;
                this.echoMultStart = echoMultStart;
                this.echoMultDelta = (echoMultEnd - echoMultStart) / runLength;
                maxEchoMult = Math.max(echoMultStart, echoMultEnd);
                let useEchoDelayStart = instrument.echoDelay;
                let useEchoDelayEnd = instrument.echoDelay;
                let ignoreTicks = false;
                if (synth.isModActive(Config.modulators.dictionary["echo delay"].index, channelIndex, instrumentIndex)) {
                    useEchoDelayStart = synth.getModValue(Config.modulators.dictionary["echo delay"].index, channelIndex, instrumentIndex, false);
                    useEchoDelayEnd = synth.getModValue(Config.modulators.dictionary["echo delay"].index, channelIndex, instrumentIndex, true);
                    ignoreTicks = true;
                }
                const tmpEchoDelayOffsetStart = Math.round((useEchoDelayStart + 1) * Config.echoDelayStepTicks * samplesPerTick);
                const tmpEchoDelayOffsetEnd = Math.round((useEchoDelayEnd + 1) * Config.echoDelayStepTicks * samplesPerTick);
                if (this.echoDelayOffsetLastTickIsComputed && !ignoreTicks) {
                    this.echoDelayOffsetStart = this.echoDelayOffsetLastTick;
                }
                else {
                    this.echoDelayOffsetStart = tmpEchoDelayOffsetStart;
                }
                if (synth.isAtEndOfTick && !ignoreTicks) {
                    this.echoDelayOffsetLastTick = tmpEchoDelayOffsetEnd;
                    this.echoDelayOffsetLastTickIsComputed = true;
                }
                this.echoDelayOffsetEnd = tmpEchoDelayOffsetEnd;
                this.echoDelayOffsetRatio = 1.0 - tickRemainingStart;
                this.echoDelayOffsetRatioDelta = (tickRemainingStart - tickRemainingEnd) / runLength;
                const shelfRadians = 2.0 * Math.PI * Config.echoShelfHz / synth.samplesPerSecond;
                Synth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, Config.echoShelfGain);
                this.echoShelfA1 = Synth.tempFilterStartCoefficients.a[1];
                this.echoShelfB0 = Synth.tempFilterStartCoefficients.b[0];
                this.echoShelfB1 = Synth.tempFilterStartCoefficients.b[1];
            }
            let maxReverbMult = 0.0;
            if (usesReverb) {
                let useReverbStart = instrument.reverb;
                let useReverbEnd = instrument.reverb;
                if (synth.isModActive(Config.modulators.dictionary["reverb"].index, channelIndex, instrumentIndex)) {
                    useReverbStart = synth.getModValue(Config.modulators.dictionary["reverb"].index, channelIndex, instrumentIndex, false);
                    useReverbEnd = synth.getModValue(Config.modulators.dictionary["reverb"].index, channelIndex, instrumentIndex, true);
                }
                if (synth.isModActive(Config.modulators.dictionary["song reverb"].index, channelIndex, instrumentIndex)) {
                    useReverbStart *= (synth.getModValue(Config.modulators.dictionary["song reverb"].index, undefined, undefined, false) - Config.modulators.dictionary["song reverb"].convertRealFactor) / Config.reverbRange;
                    useReverbEnd *= (synth.getModValue(Config.modulators.dictionary["song reverb"].index, undefined, undefined, true) - Config.modulators.dictionary["song reverb"].convertRealFactor) / Config.reverbRange;
                }
                const reverbStart = Math.min(1.0, Math.pow(useReverbStart / Config.reverbRange, 0.667)) * 0.425;
                const reverbEnd = Math.min(1.0, Math.pow(useReverbEnd / Config.reverbRange, 0.667)) * 0.425;
                this.reverbMultStart = reverbStart;
                this.reverbMultDelta = (reverbEnd - reverbStart) / runLength;
                maxReverbMult = Math.max(reverbStart, reverbEnd);
                const shelfRadians = 2.0 * Math.PI * Config.reverbShelfHz / synth.samplesPerSecond;
                Synth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, Config.reverbShelfGain);
                this.reverbShelfA1 = Synth.tempFilterStartCoefficients.a[1];
                this.reverbShelfB0 = Synth.tempFilterStartCoefficients.b[0];
                this.reverbShelfB1 = Synth.tempFilterStartCoefficients.b[1];
            }
            if (this.tonesAddedInThisTick) {
                this.attentuationProgress = 0.0;
                this.flushedSamples = 0;
                this.flushingDelayLines = false;
            }
            else if (!this.flushingDelayLines) {
                if (this.attentuationProgress == 0.0) {
                    eqFilterVolumeStart *= tickRemainingStart;
                    eqFilterVolumeEnd *= tickRemainingEnd;
                }
                else {
                    eqFilterVolumeStart = 0.0;
                    eqFilterVolumeEnd = 0.0;
                }
                const attenuationThreshold = 1.0 / 256.0;
                const halfLifeMult = -Math.log2(attenuationThreshold);
                let delayDuration = 0.0;
                if (usesChorus) {
                    delayDuration += Config.chorusMaxDelay;
                }
                if (usesEcho) {
                    const averageDelaySeconds = (this.echoDelayOffsetStart + this.echoDelayOffsetEnd) * 0.5 / samplesPerSecond;
                    const attenuationPerSecond = Math.pow(maxEchoMult, 1.0 / averageDelaySeconds);
                    const halfLife = -1.0 / Math.log2(attenuationPerSecond);
                    const echoDuration = halfLife * halfLifeMult;
                    delayDuration += echoDuration;
                }
                if (usesReverb) {
                    const averageMult = maxReverbMult * 2.0;
                    const averageDelaySeconds = (Config.reverbDelayBufferSize / 4.0) / samplesPerSecond;
                    const attenuationPerSecond = Math.pow(averageMult, 1.0 / averageDelaySeconds);
                    const halfLife = -1.0 / Math.log2(attenuationPerSecond);
                    const reverbDuration = halfLife * halfLifeMult;
                    delayDuration += reverbDuration;
                }
                const secondsInTick = samplesPerTick / samplesPerSecond;
                const progressInTick = secondsInTick / delayDuration;
                const progressAtEndOfTick = this.attentuationProgress + progressInTick;
                if (progressAtEndOfTick >= 1.0) {
                    delayInputMultStart *= tickRemainingStart;
                    delayInputMultEnd *= tickRemainingEnd;
                }
                if (synth.isAtEndOfTick) {
                    this.attentuationProgress = progressAtEndOfTick;
                    if (this.attentuationProgress >= 1.0) {
                        this.flushingDelayLines = true;
                    }
                }
            }
            else {
                eqFilterVolumeStart = 0.0;
                eqFilterVolumeEnd = 0.0;
                delayInputMultStart = 0.0;
                delayInputMultEnd = 0.0;
                let totalDelaySamples = 0;
                if (usesChorus)
                    totalDelaySamples += synth.chorusDelayBufferSize;
                if (usesEcho)
                    totalDelaySamples += this.echoDelayLineL.length;
                if (usesReverb)
                    totalDelaySamples += Config.reverbDelayBufferSize;
                this.flushedSamples += runLength;
                if (this.flushedSamples >= totalDelaySamples) {
                    this.deactivateAfterThisTick = true;
                }
            }
            this.eqFilterVolumeStart = eqFilterVolumeStart;
            this.eqFilterVolumeDelta = (eqFilterVolumeEnd - eqFilterVolumeStart) / runLength;
            this.delayInputMultStart = delayInputMultStart;
            this.delayInputMultDelta = (delayInputMultEnd - delayInputMultStart) / runLength;
        }
    }
    class ChannelState {
        constructor() {
            this.instruments = [];
            this.muted = false;
            this.singleSeamlessInstrument = null;
        }
    }
    class Synth {
        constructor(song = null) {
            this.samplesPerSecond = 44100;
            this.song = null;
            this.liveInputDuration = 0;
            this.liveInputStarted = false;
            this.liveInputPitches = [];
this.liveBassInputPitches = [];
this.liveBassInputChannel = 0;



            this.liveInputChannel = 0;
            this.liveInputInstruments = [];
            this.loopRepeatCount = -1;
            this.volume = 1.0;
            this.renderingSong = false;
            this.wantToSkip = false;
            this.playheadInternal = 0.0;
            this.bar = 0;
            this.prevBar = null;
            this.nextBar = null;
            this.beat = 0;
            this.part = 0;
            this.tick = 0;
            this.isAtStartOfTick = true;
            this.isAtEndOfTick = true;
            this.tickSampleCountdown = 0;
            this.modValues = [];
            this.modInsValues = [];
            this.nextModValues = [];
            this.nextModInsValues = [];
this.isRecording = false;
this.isRecordingWhistle = false;
this.STABLE_N = 2
this.SILENCE_N = 3
this.MIN_NOTE_MS = 6
this.CHANGE_HOLD_MS = 5
this.SHIFT=-12
this.TOLERANCE=0.008
this.NOTE_HOLD_EXTRA=250
this.Db=75
            this.isPlayingSong = false;
            this.liveInputEndTime = 0.0;
            this.browserAutomaticallyClearsAudioBuffer = true;
            this.tempDrumSetControlPoint = new FilterControlPoint();
            this.tempFrequencyResponse = new FrequencyResponse();
            this.channels = [];
            this.tonePool = new Deque();
            this.tempMatchedPitchTones = Array(Config.maxChordSize).fill(null);
            this.limit = 0.0;
            this.tempMonoInstrumentSampleBuffer = null;
            this.audioCtx = null;
            this.scriptNode = null;
            this.audioProcessCallback = (audioProcessingEvent) => {
                const outputBuffer = audioProcessingEvent.outputBuffer;
                const outputDataL = outputBuffer.getChannelData(0);
                const outputDataR = outputBuffer.getChannelData(1);
                if (this.browserAutomaticallyClearsAudioBuffer && (outputDataL[0] != 0.0 || outputDataR[0] != 0.0 || outputDataL[outputBuffer.length - 1] != 0.0 || outputDataR[outputBuffer.length - 1] != 0.0)) {
                    this.browserAutomaticallyClearsAudioBuffer = false;
                }
                if (!this.browserAutomaticallyClearsAudioBuffer) {
                    const length = outputBuffer.length;
                    for (let i = 0; i < length; i++) {
                        outputDataL[i] = 0.0;
                        outputDataR[i] = 0.0;
                    }
                }
                const isPlayingLiveTones = performance.now() < this.liveInputEndTime;
                if (!isPlayingLiveTones && !this.isPlayingSong) {
                    this.deactivateAudio();
                }
                else {
                    this.synthesize(outputDataL, outputDataR, outputBuffer.length, this.isPlayingSong);
                }
            };
            this.computeDelayBufferSizes();
            if (song != null)
                this.setSong(song);
        }
get recording() {
	return this.isRecording;
}
        syncSongState() {
            const channelCount = this.song.getChannelCount();
            for (let i = this.channels.length; i < channelCount; i++) {
                this.channels[i] = new ChannelState();
            }
            this.channels.length = channelCount;
            for (let i = 0; i < channelCount; i++) {
                const channel = this.song.channels[i];
                const channelState = this.channels[i];
                for (let j = channelState.instruments.length; j < channel.instruments.length; j++) {
                    channelState.instruments[j] = new InstrumentState();
                }
                channelState.instruments.length = channel.instruments.length;
                if (channelState.muted != channel.muted) {
                    channelState.muted = channel.muted;
                    if (channelState.muted) {
                        for (const instrumentState of channelState.instruments) {
                            instrumentState.resetAllEffects();
                        }
                    }
                }
            }
        }
pause() {
	if (!this.isPlayingSong)
		return;
	this.isPlayingSong = false;
	this._doc.synth.isRecordingWhistle = false;
	this.isRecording = false;
	this.modValues = [];
	this.nextModValues = [];
	this.heldMods = [];
	if (this.song != null) {
		this.song.inVolumeCap = 0.0;
		this.song.outVolumeCap = 0.0;
		for (let channelIndex = 0; channelIndex < this.song.pitchChannelCount + this.song.noiseChannelCount; channelIndex++) {
			this.modInsValues[channelIndex] = [];
			this.nextModInsValues[channelIndex] = [];
		}
	}
}
        
startRecording() {
	this.preferLowerLatency = true;
	this.isRecording = true;
	this.play();
}
        warmUpSynthesizer(song) {
            if (song != null) {
                this.syncSongState();
                const samplesPerTick = this.getSamplesPerTick();
                for (let channelIndex = 0; channelIndex < song.getChannelCount(); channelIndex++) {
                    for (let instrumentIndex = 0; instrumentIndex < song.channels[channelIndex].instruments.length; instrumentIndex++) {
                        const instrument = song.channels[channelIndex].instruments[instrumentIndex];
                        const instrumentState = this.channels[channelIndex].instruments[instrumentIndex];
                        Synth.getInstrumentSynthFunction(instrument);
                        instrument.warmUp(this.samplesPerSecond);
                        instrumentState.updateWaves(instrument, this.samplesPerSecond);
                        instrumentState.allocateNecessaryBuffers(this, instrument, samplesPerTick);
                    }
                }
            }
        }
        computeLatestModValues() {
            if (this.song != null && this.song.modChannelCount > 0) {
                let latestModTimes = [];
                let latestModInsTimes = [];
                this.modValues = [];
                this.nextModValues = [];
                this.modInsValues = [];
                this.nextModInsValues = [];
                for (let channel = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {
                    latestModInsTimes[channel] = [];
                    this.modInsValues[channel] = [];
                    this.nextModInsValues[channel] = [];
                    for (let instrument = 0; instrument < this.song.channels[channel].instruments.length; instrument++) {
                        this.modInsValues[channel][instrument] = [];
                        this.nextModInsValues[channel][instrument] = [];
                        latestModInsTimes[channel][instrument] = [];
                    }
                }
                let currentPart = this.beat * Config.partsPerBeat + this.part;
                for (let channelIndex = this.song.pitchChannelCount + this.song.noiseChannelCount; channelIndex < this.song.getChannelCount(); channelIndex++) {
                    if (!(this.song.channels[channelIndex].muted)) {
                        let pattern;
                        for (let currentBar = this.bar; currentBar >= 0; currentBar--) {
                            pattern = this.song.getPattern(channelIndex, currentBar);
                            if (pattern != null) {
                                let instrumentIdx = pattern.instruments[0];
                                let instrument = this.song.channels[channelIndex].instruments[instrumentIdx];
                                let latestPinParts = [];
                                let latestPinValues = [];
                                let partsInBar = (currentBar == this.bar)
                                    ? currentPart
                                    : this.findPartsInBar(currentBar);
                                for (const note of pattern.notes) {
                                    if (note.start < partsInBar && (latestPinParts[Config.modCount - 1 - note.pitches[0]] == null || note.end > latestPinParts[Config.modCount - 1 - note.pitches[0]])) {
                                        if (note.end <= partsInBar) {
                                            latestPinParts[Config.modCount - 1 - note.pitches[0]] = note.end;
                                            latestPinValues[Config.modCount - 1 - note.pitches[0]] = note.pins[note.pins.length - 1].size;
                                        }
                                        else {
                                            latestPinParts[Config.modCount - 1 - note.pitches[0]] = partsInBar;
                                            for (let pinIdx = 0; pinIdx < note.pins.length; pinIdx++) {
                                                if (note.pins[pinIdx].time + note.start > partsInBar) {
                                                    const transitionLength = note.pins[pinIdx].time - note.pins[pinIdx - 1].time;
                                                    const toNextBarLength = partsInBar - note.start - note.pins[pinIdx - 1].time;
                                                    const deltaVolume = note.pins[pinIdx].size - note.pins[pinIdx - 1].size;
                                                    latestPinValues[Config.modCount - 1 - note.pitches[0]] = Math.round(note.pins[pinIdx - 1].size + deltaVolume * toNextBarLength / transitionLength);
                                                    pinIdx = note.pins.length;
                                                }
                                            }
                                        }
                                    }
                                }
                                for (let mod = 0; mod < Config.modCount; mod++) {
                                    if (latestPinParts[mod] != null) {
                                        if (Config.modulators[instrument.modulators[mod]].forSong) {
                                            if (latestModTimes[instrument.modulators[mod]] == null || currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod] > latestModTimes[instrument.modulators[mod]]) {
                                                this.setModValue(latestPinValues[mod], latestPinValues[mod], mod, instrument.modChannels[mod], instrument.modInstruments[mod], instrument.modulators[mod]);
                                                latestModTimes[instrument.modulators[mod]] = currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod];
                                            }
                                        }
                                        else {
                                            let usedInstruments = [];
                                            if (instrument.modInstruments[mod] == this.channels[instrument.modChannels[mod]].instruments.length) {
                                                for (let i = 0; i < this.channels[instrument.modChannels[mod]].instruments.length; i++) {
                                                    usedInstruments.push(i);
                                                }
                                            }
                                            else if (instrument.modInstruments[mod] > this.channels[instrument.modChannels[mod]].instruments.length) {
                                                const tgtPattern = this.song.getPattern(instrument.modChannels[mod], currentBar);
                                                if (tgtPattern != null)
                                                    usedInstruments = tgtPattern.instruments;
                                            }
                                            else {
                                                usedInstruments.push(instrument.modInstruments[mod]);
                                            }
                                            for (let instrumentIndex = 0; instrumentIndex < usedInstruments.length; instrumentIndex++) {
                                                const eqFilterParam = instrument.modulators[mod] == Config.modulators.dictionary["eq filter"].index;
                                                const noteFilterParam = instrument.modulators[mod] == Config.modulators.dictionary["note filter"].index;
                                                let modulatorAdjust = instrument.modulators[mod];
                                                if (eqFilterParam) {
                                                    modulatorAdjust = Config.modulators.length + instrument.modFilterTypes[mod];
                                                }
                                                else if (noteFilterParam) {
                                                    modulatorAdjust = Config.modulators.length + 1 + (2 * Config.filterMaxPoints) + instrument.modFilterTypes[mod];
                                                }
                                                if (latestModInsTimes[instrument.modChannels[mod]][usedInstruments[instrumentIndex]][modulatorAdjust] == null || currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod] > latestModInsTimes[instrument.modChannels[mod]][instrumentIndex][modulatorAdjust]) {
                                                    if (eqFilterParam) {
                                                        let tgtInstrument = this.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];
                                                        if (instrument.modFilterTypes[mod] == 0) {
                                                            tgtInstrument.tmpEqFilterStart = tgtInstrument.eqSubFilters[latestPinValues[mod]];
                                                        }
                                                        else {
                                                            for (let i = 0; i < Config.filterMorphCount; i++) {
                                                                if (tgtInstrument.tmpEqFilterStart == tgtInstrument.eqSubFilters[i]) {
                                                                    tgtInstrument.tmpEqFilterStart = new FilterSettings();
                                                                    tgtInstrument.tmpEqFilterStart.fromJsonObject(tgtInstrument.eqSubFilters[i].toJsonObject());
                                                                    i = Config.filterMorphCount;
                                                                }
                                                            }
                                                            if (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) < tgtInstrument.tmpEqFilterStart.controlPointCount) {
                                                                if (instrument.modFilterTypes[mod] % 2)
                                                                    tgtInstrument.tmpEqFilterStart.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].freq = latestPinValues[mod];
                                                                else
                                                                    tgtInstrument.tmpEqFilterStart.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].gain = latestPinValues[mod];
                                                            }
                                                        }
                                                        tgtInstrument.tmpEqFilterEnd = tgtInstrument.tmpEqFilterStart;
                                                    }
                                                    else if (noteFilterParam) {
                                                        let tgtInstrument = this.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];
                                                        if (instrument.modFilterTypes[mod] == 0) {
                                                            tgtInstrument.tmpNoteFilterStart = tgtInstrument.noteSubFilters[latestPinValues[mod]];
                                                        }
                                                        else {
                                                            for (let i = 0; i < Config.filterMorphCount; i++) {
                                                                if (tgtInstrument.tmpNoteFilterStart == tgtInstrument.noteSubFilters[i]) {
                                                                    tgtInstrument.tmpNoteFilterStart = new FilterSettings();
                                                                    tgtInstrument.tmpNoteFilterStart.fromJsonObject(tgtInstrument.noteSubFilters[i].toJsonObject());
                                                                    i = Config.filterMorphCount;
                                                                }
                                                            }
                                                            if (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) < tgtInstrument.tmpNoteFilterStart.controlPointCount) {
                                                                if (instrument.modFilterTypes[mod] % 2)
                                                                    tgtInstrument.tmpNoteFilterStart.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].freq = latestPinValues[mod];
                                                                else
                                                                    tgtInstrument.tmpNoteFilterStart.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].gain = latestPinValues[mod];
                                                            }
                                                        }
                                                        tgtInstrument.tmpNoteFilterEnd = tgtInstrument.tmpNoteFilterStart;
                                                    }
                                                    else
                                                        this.setModValue(latestPinValues[mod], latestPinValues[mod], mod, instrument.modChannels[mod], usedInstruments[instrumentIndex], modulatorAdjust);
                                                    latestModInsTimes[instrument.modChannels[mod]][instrumentIndex][modulatorAdjust] = currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod];
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        determineInvalidModulators(instrument) {
            if (this.song == null)
                return;
            for (let mod = 0; mod < Config.modCount; mod++) {
                instrument.invalidModulators[mod] = true;
                if (instrument.modChannels[mod] == -1) {
                    if (instrument.modulators[mod] != 0)
                        instrument.invalidModulators[mod] = false;
                    continue;
                }
                const channel = this.song.channels[instrument.modChannels[mod]];
                if (channel == null)
                    continue;
                let tgtInstrumentList = [];
                if (instrument.modInstruments[mod] >= channel.instruments.length) {
                    tgtInstrumentList = channel.instruments;
                }
                else {
                    tgtInstrumentList = [channel.instruments[instrument.modInstruments[mod]]];
                }
                for (let i = 0; i < tgtInstrumentList.length; i++) {
                    const tgtInstrument = tgtInstrumentList[i];
                    if (tgtInstrument == null)
                        continue;
                    const str = Config.modulators[instrument.modulators[mod]].name;
                    if  ( Config.modulators[instrument.modulators[mod]].associatedEffect== 13|| !((Config.modulators[instrument.modulators[mod]].associatedEffect != 12 && !(tgtInstrument.effects & (1 << Config.modulators[instrument.modulators[mod]].associatedEffect)))
                        || (tgtInstrument.type != 1 && (str == "fm slider 1" || str == "fm slider 2" || str == "fm slider 3" || str == "fm slider 4" || str == "fm feedback"))
                        || (tgtInstrument.type != 6 && (str == "pulse width"))
                        || (!tgtInstrument.getChord().arpeggiates && (str == "arp speed" || str == "reset arp"))
                        || (tgtInstrument.eqFilterType && str == "eq filter")
                        || (!tgtInstrument.eqFilterType && (str == "eq filt cut" || str == "eq filt peak"))
                        || (str == "eq filter" && Math.floor((instrument.modFilterTypes[mod] + 1) / 2) > tgtInstrument.eqFilter.controlPointCount)
                        || (tgtInstrument.noteFilterType && str == "note filter")
                        || (!tgtInstrument.noteFilterType && (str == "note filt cut" || str == "note filt peak"))
                        || (str == "note filter" && Math.floor((instrument.modFilterTypes[mod] + 1) / 2) > tgtInstrument.noteFilter.controlPointCount))) {
                        instrument.invalidModulators[mod] = false;
                        i = tgtInstrumentList.length;
                    }
                }
            }
        }
        static operatorAmplitudeCurve(amplitude) {
            return (Math.pow(16.0, amplitude / 15.0) - 1.0) / 15.0;
        }
        static wrap(x, b) {
	return (x % b + b) % b;
}
        get playing() {
            return this.isPlayingSong;
        }
        get playhead() {
            return this.playheadInternal;
        }
        set playhead(value) {
            if (this.song != null) {
                this.playheadInternal = Math.max(0, Math.min(this.song.barCount, value));
                let remainder = this.playheadInternal;
                this.bar = Math.floor(remainder);
                remainder = this.song.beatsPerBar * (remainder - this.bar);
                this.beat = Math.floor(remainder);
                remainder = Config.partsPerBeat * (remainder - this.beat);
                this.part = Math.floor(remainder);
                remainder = Config.ticksPerPart * (remainder - this.part);
                this.tick = Math.floor(remainder);
                const samplesPerTick = this.getSamplesPerTick();
                remainder = samplesPerTick * (remainder - this.tick);
                this.tickSampleCountdown = samplesPerTick - remainder;
                this.prevBar = null;
            }
        }
        getSamplesPerBar() {
            if (this.song == null)
                throw new Error();
            return this.getSamplesPerTick() * Config.ticksPerPart * Config.partsPerBeat * this.song.beatsPerBar;
        }
        getTicksIntoBar() {
            return (this.beat * Config.partsPerBeat + this.part) * Config.ticksPerPart + this.tick;
        }
        getCurrentPart() {
            return (this.beat * Config.partsPerBeat + this.part);
        }
        findPartsInBar(bar) {
            if (this.song == null)
                return 0;
            let partsInBar = Config.partsPerBeat * this.song.beatsPerBar;
            for (let channel = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {
                let pattern = this.song.getPattern(channel, bar);
                if (pattern != null) {
                    let instrument = this.song.channels[channel].instruments[pattern.instruments[0]];
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        if (instrument.modulators[mod] == Config.modulators.dictionary["next bar"].index) {
                            for (const note of pattern.notes) {
                                if (note.pitches[0] == (Config.modCount - 1 - mod)) {
                                    if (partsInBar > note.start)
                                        partsInBar = note.start;
                                }
                            }
                        }
                    }
                }
            }
            return partsInBar;
        }
        getTotalSamples(enableIntro, enableOutro, loop) {
            if (this.song == null)
                return -1;
            let startBar = enableIntro ? 0 : this.song.loopStart;
            let endBar = enableOutro ? this.song.barCount : (this.song.loopStart + this.song.loopLength);
            let hasTempoMods = false;
            let hasNextBarMods = false;
            let prevTempo = this.song.tempo;
            for (let channel = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {
                for (let bar = startBar; bar < endBar; bar++) {
                    let pattern = this.song.getPattern(channel, bar);
                    if (pattern != null) {
                        let instrument = this.song.channels[channel].instruments[pattern.instruments[0]];
                        for (let mod = 0; mod < Config.modCount; mod++) {
                            if (instrument.modulators[mod] == Config.modulators.dictionary["tempo"].index) {
                                hasTempoMods = true;
                            }
                            if (instrument.modulators[mod] == Config.modulators.dictionary["next bar"].index) {
                                hasNextBarMods = true;
                            }
                        }
                    }
                }
            }
            if (startBar > 0) {
                let latestTempoPin = null;
                let latestTempoValue = 0;
                for (let bar = startBar - 1; bar >= 0; bar--) {
                    for (let channel = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {
                        let pattern = this.song.getPattern(channel, bar);
                        if (pattern != null) {
                            let instrumentIdx = pattern.instruments[0];
                            let instrument = this.song.channels[channel].instruments[instrumentIdx];
                            let partsInBar = this.findPartsInBar(bar);
                            for (const note of pattern.notes) {
                                if (instrument.modulators[Config.modCount - 1 - note.pitches[0]] == Config.modulators.dictionary["tempo"].index) {
                                    if (note.start < partsInBar && (latestTempoPin == null || note.end > latestTempoPin)) {
                                        if (note.end <= partsInBar) {
                                            latestTempoPin = note.end;
                                            latestTempoValue = note.pins[note.pins.length - 1].size;
                                        }
                                        else {
                                            latestTempoPin = partsInBar;
                                            for (let pinIdx = 0; pinIdx < note.pins.length; pinIdx++) {
                                                if (note.pins[pinIdx].time + note.start > partsInBar) {
                                                    const transitionLength = note.pins[pinIdx].time - note.pins[pinIdx - 1].time;
                                                    const toNextBarLength = partsInBar - note.start - note.pins[pinIdx - 1].time;
                                                    const deltaVolume = note.pins[pinIdx].size - note.pins[pinIdx - 1].size;
                                                    latestTempoValue = Math.round(note.pins[pinIdx - 1].size + deltaVolume * toNextBarLength / transitionLength);
                                                    pinIdx = note.pins.length;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (latestTempoPin != null) {
                        prevTempo = latestTempoValue + Config.modulators.dictionary["tempo"].convertRealFactor;
                        bar = -1;
                    }
                }
            }
            if (hasTempoMods || hasNextBarMods) {
                let bar = startBar;
                let ended = false;
                let totalSamples = 0;
                while (!ended) {
                    let partsInBar = Config.partsPerBeat * this.song.beatsPerBar;
                    let currentPart = 0;
                    if (hasNextBarMods) {
                        partsInBar = this.findPartsInBar(bar);
                    }
                    if (hasTempoMods) {
                        let foundMod = false;
                        for (let channel = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {
                            if (foundMod == false) {
                                let pattern = this.song.getPattern(channel, bar);
                                if (pattern != null) {
                                    let instrument = this.song.channels[channel].instruments[pattern.instruments[0]];
                                    for (let mod = 0; mod < Config.modCount; mod++) {
                                        if (foundMod == false && instrument.modulators[mod] == Config.modulators.dictionary["tempo"].index
                                            && pattern.notes.find(n => n.pitches[0] == (Config.modCount - 1 - mod))) {
                                            foundMod = true;
                                            pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                                            for (const note of pattern.notes) {
                                                if (note.pitches[0] == (Config.modCount - 1 - mod)) {
                                                    totalSamples += (Math.min(partsInBar - currentPart, note.start - currentPart)) * Config.ticksPerPart * this.getSamplesPerTickSpecificBPM(prevTempo);
                                                    if (note.start < partsInBar) {
                                                        for (let pinIdx = 1; pinIdx < note.pins.length; pinIdx++) {
                                                            if (note.pins[pinIdx - 1].time + note.start <= partsInBar) {
                                                                const tickLength = Config.ticksPerPart * Math.min(partsInBar - (note.start + note.pins[pinIdx - 1].time), note.pins[pinIdx].time - note.pins[pinIdx - 1].time);
                                                                const prevPinTempo = note.pins[pinIdx - 1].size + Config.modulators.dictionary["tempo"].convertRealFactor;
                                                                let currPinTempo = note.pins[pinIdx].size + Config.modulators.dictionary["tempo"].convertRealFactor;
                                                                if (note.pins[pinIdx].time + note.start > partsInBar) {
                                                                    currPinTempo = note.pins[pinIdx - 1].size + (note.pins[pinIdx].size - note.pins[pinIdx - 1].size) * (partsInBar - (note.start + note.pins[pinIdx - 1].time)) / (note.pins[pinIdx].time - note.pins[pinIdx - 1].time) + Config.modulators.dictionary["tempo"].convertRealFactor;
                                                                }
                                                                let bpmScalar = Config.partsPerBeat * Config.ticksPerPart / 60;
                                                                if (currPinTempo != prevPinTempo) {
                                                                    totalSamples += -this.samplesPerSecond * tickLength * (Math.log(bpmScalar * currPinTempo * tickLength) - Math.log(bpmScalar * prevPinTempo * tickLength)) / (bpmScalar * (prevPinTempo - currPinTempo));
                                                                }
                                                                else {
                                                                    totalSamples += tickLength * this.getSamplesPerTickSpecificBPM(currPinTempo);
                                                                }
                                                                prevTempo = currPinTempo;
                                                            }
                                                            currentPart = Math.min(note.start + note.pins[pinIdx].time, partsInBar);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    totalSamples += (partsInBar - currentPart) * Config.ticksPerPart * this.getSamplesPerTickSpecificBPM(prevTempo);
                    bar++;
                    if (loop != 0 && bar == this.song.loopStart + this.song.loopLength) {
                        bar = this.song.loopStart;
                        if (loop > 0)
                            loop--;
                    }
                    if (bar >= endBar) {
                        ended = true;
                    }
                }
                return Math.ceil(totalSamples);
            }
            else {
                return this.getSamplesPerBar() * this.getTotalBars(enableIntro, enableOutro, loop);
            }
        }
        getTotalBars(enableIntro, enableOutro, useLoopCount = this.loopRepeatCount) {
            if (this.song == null)
                throw new Error();
            let bars = this.song.loopLength * (useLoopCount + 1);
            if (enableIntro)
                bars += this.song.loopStart;
            if (enableOutro)
                bars += this.song.barCount - (this.song.loopStart + this.song.loopLength);
            return bars;
        }
        setSong(song) {
            if (typeof (song) == "string") {
                this.song = new Song(song);
            }
            else if (song instanceof Song) {
                this.song = song;
            }
            this.prevBar = null;
        }
        computeDelayBufferSizes() {
            this.panningDelayBufferSize = Synth.fittingPowerOfTwo(this.samplesPerSecond * Config.panDelaySecondsMax);
            this.panningDelayBufferMask = this.panningDelayBufferSize - 1;
            this.chorusDelayBufferSize = Synth.fittingPowerOfTwo(this.samplesPerSecond * Config.chorusMaxDelay);
            this.chorusDelayBufferMask = this.chorusDelayBufferSize - 1;
        }
        activateAudio() {
            if (this.audioCtx == null || this.scriptNode == null) {
                this.audioCtx = this.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                this.samplesPerSecond = this.audioCtx.sampleRate;
                this.scriptNode = this.audioCtx.createScriptProcessor ? this.audioCtx.createScriptProcessor(2048, 0, 2) : this.audioCtx.createJavaScriptNode(2048, 0, 2);
                this.scriptNode.onaudioprocess = this.audioProcessCallback;
                this.scriptNode.channelCountMode = 'explicit';
                this.scriptNode.channelInterpretation = 'speakers';
                this.scriptNode.connect(this.audioCtx.destination);
                this.computeDelayBufferSizes();
            }
            this.audioCtx.resume();
        }
        deactivateAudio() {
            if (this.audioCtx != null && this.scriptNode != null) {
                this.scriptNode.disconnect(this.audioCtx.destination);
                this.scriptNode = null;
                if (this.audioCtx.close)
                    this.audioCtx.close();
                this.audioCtx = null;
            }
        }
        maintainLiveInput() {
            this.activateAudio();
            this.liveInputEndTime = performance.now() + 10000.0;
        }
        play() {
            if (this.isPlayingSong)
                return;
            this.isPlayingSong = true;
            this.activateAudio();
            this.warmUpSynthesizer(this.song);
            this.computeLatestModValues();
        }
        pause() {
            if (!this.isPlayingSong)
                return;
            this.isPlayingSong = false;
for (let channelIndex = 0; channelIndex < this.song.getChannelCount(); channelIndex++) {
	for (let instrumentIndex = 0; instrumentIndex < this.song.channels[channelIndex].instruments.length; instrumentIndex++) {
		const instrument = this.song.channels[channelIndex].instruments[instrumentIndex];
		let usesCustomUnison = instrument.unison === Config.unisons.length
	 if(usesCustomUnison){
		instrument.detectForUnison = 0
		instrument.unisonVoices = instrument.last_unisonVoices
		instrument.unisonSign = instrument.last_unisonSign
		instrument.unisonExpression = instrument.last_unisonExpression
		instrument.unisonOffset = instrument.last_unisonOffset
		instrument.unisonSpread = instrument.last_unisonSpread
		
let supeditor = editor
supeditor._unisonVoicesInputBox.value = instrument.last_unisonVoices + "";
supeditor._unisonSpreadInputBox.value = instrument.last_unisonSpread + "";
supeditor._unisonOffsetInputBox.value = instrument.last_unisonOffset + "";
supeditor._unisonExpressionInputBox.value = instrument.last_unisonExpression + "";
supeditor._unisonSignInputBox.value = instrument.last_unisonSign + "";
	 }
	}
}
            
            this.modValues = [];
            this.nextModValues = [];
            if (this.song != null) {
                this.song.inVolumeCap = 0.0;
                this.song.outVolumeCap = 0.0;
                for (let channelIndex = 0; channelIndex < this.song.pitchChannelCount + this.song.noiseChannelCount; channelIndex++) {
                    this.modInsValues[channelIndex] = [];
                    this.nextModInsValues[channelIndex] = [];
                }
            }
        }
        resetEffects() {
            this.limit = 0.0;
            this.freeAllTones();
            if (this.song != null) {
                for (const channelState of this.channels) {
                    for (const instrumentState of channelState.instruments) {
                        instrumentState.resetAllEffects();
                    }
                }
            }
        }
        setModValue(volumeStart, volumeEnd, mod, channelIndex, instrumentIndex, setting) {
            let val = volumeStart + Config.modulators[setting].convertRealFactor;
            let nextVal = volumeEnd + Config.modulators[setting].convertRealFactor;
            if (Config.modulators[setting].forSong) {
                if (this.modValues[setting] == null || this.modValues[setting] != val || this.nextModValues[setting] != nextVal) {
                    this.modValues[setting] = val;
                    this.nextModValues[setting] = nextVal;
                }
            }
            else {
                if (this.modInsValues[channelIndex][instrumentIndex][setting] == null
                    || this.modInsValues[channelIndex][instrumentIndex][setting] != val
                    || this.nextModInsValues[channelIndex][instrumentIndex][setting] != nextVal) {
                    this.modInsValues[channelIndex][instrumentIndex][setting] = val;
                    this.nextModInsValues[channelIndex][instrumentIndex][setting] = nextVal;
                }
            }
            return val;
        }
        getModValue(setting, channel, instrument, nextVal) {
            const forSong = Config.modulators[setting].forSong;
            if (forSong) {
                if (this.modValues[setting] != null && this.nextModValues[setting] != null) {
                    return nextVal ? this.nextModValues[setting] : this.modValues[setting];
                }
            }
            else if (channel != undefined && instrument != undefined) {
                if (this.modInsValues[channel][instrument][setting] != null && this.nextModInsValues[channel][instrument][setting] != null) {
                    return nextVal ? this.nextModInsValues[channel][instrument][setting] : this.modInsValues[channel][instrument][setting];
                }
            }
            return -1;
        }
        isAnyModActive(channel, instrument) {
            for (let setting = 0; setting < Config.modulators.length; setting++) {
                if ((this.modValues != undefined && this.modValues[setting] != null)
                    || (this.modInsValues != undefined && this.modInsValues[channel] != undefined && this.modInsValues[channel][instrument] != undefined && this.modInsValues[channel][instrument][setting] != null)) {
                    return true;
                }
            }
            return false;
        }
        unsetMod(setting, channel, instrument) {
            if (this.isModActive(setting) || (channel != undefined && instrument != undefined && this.isModActive(setting, channel, instrument))) {
                this.modValues[setting] = null;
                this.nextModValues[setting] = null;
                if (channel != undefined && instrument != undefined) {
                    this.modInsValues[channel][instrument][setting] = null;
                    this.nextModInsValues[channel][instrument][setting] = null;
                }
            }
        }
        isFilterModActive(forNoteFilter, channelIdx, instrumentIdx) {
            const instrument = this.song.channels[channelIdx].instruments[instrumentIdx];
            if (forNoteFilter) {
                if (instrument.noteFilterType)
                    return false;
                if (instrument.tmpNoteFilterEnd != null)
                    return true;
            }
            else {
                if (instrument.eqFilterType)
                    return false;
                if (instrument.tmpEqFilterEnd != null)
                    return true;
            }
            return false;
        }
        isModActive(setting, channel, instrument) {
            const forSong = Config.modulators[setting].forSong;
            if (forSong) {
                return (this.modValues != undefined && this.modValues[setting] != null);
            }
            else if (channel != undefined && instrument != undefined && this.modInsValues != undefined && this.modInsValues[channel] != null && this.modInsValues[channel][instrument] != null) {
                return (this.modInsValues[channel][instrument][setting] != null);
            }
            return false;
        }
        snapToStart() {
            this.bar = 0;
            this.resetEffects();
            this.snapToBar();
        }
        goToBar(bar) {
            this.bar = bar;
            this.resetEffects();
            this.playheadInternal = this.bar;
        }
        snapToBar() {
            this.playheadInternal = this.bar;
            this.beat = 0;
            this.part = 0;
            this.tick = 0;
            this.tickSampleCountdown = 0;
        }
        jumpIntoLoop() {
            if (!this.song)
                return;
            if (this.bar < this.song.loopStart || this.bar >= this.song.loopStart + this.song.loopLength) {
                const oldBar = this.bar;
                this.bar = this.song.loopStart;
                this.playheadInternal += this.bar - oldBar;
                if (this.playing)
                    this.computeLatestModValues();
            }
        }
        goToNextBar() {
            if (!this.song)
                return;
            this.prevBar = this.bar;
            const oldBar = this.bar;
            this.bar++;
            if (this.bar >= this.song.barCount) {
                this.bar = 0;
            }
            this.playheadInternal += this.bar - oldBar;
            if (this.playing)
                this.computeLatestModValues();
        }
        goToPrevBar() {
            if (!this.song)
                return;
            this.prevBar = null;
            const oldBar = this.bar;
            this.bar--;
            if (this.bar < 0 || this.bar >= this.song.barCount) {
                this.bar = this.song.barCount - 1;
            }
            this.playheadInternal += this.bar - oldBar;
            if (this.playing)
                this.computeLatestModValues();
        }
        skipBar() {
            if (!this.song)
                return;
            const samplesPerTick = this.getSamplesPerTick();
            this.bar++;
            this.beat = 0;
            this.part = 0;
            this.tick = 0;
            this.tickSampleCountdown = samplesPerTick;
            if (this.loopRepeatCount != 0 && this.bar == this.song.loopStart + this.song.loopLength) {
                this.bar = this.song.loopStart;
                if (this.loopRepeatCount > 0)
                    this.loopRepeatCount--;
            }
        }
        synthesize(outputDataL, outputDataR, outputBufferLength, playSong = true) {
            if (this.song == null) {
                for (let i = 0; i < outputBufferLength; i++) {
                    outputDataL[i] = 0.0;
                    outputDataR[i] = 0.0;
                }
                this.deactivateAudio();
                return;
            }
            const song = this.song;
            this.song.inVolumeCap = 0.0;
            this.song.outVolumeCap = 0.0;
            let samplesPerTick = this.getSamplesPerTick();
            let ended = false;
            while (this.tickSampleCountdown <= 0)
                this.tickSampleCountdown += samplesPerTick;
            if (this.tickSampleCountdown > samplesPerTick)
                this.tickSampleCountdown = samplesPerTick;
            if (playSong) {
                if (this.beat >= song.beatsPerBar) {
                    this.bar++;
                    this.beat = 0;
                    this.part = 0;
                    this.tick = 0;
                    this.tickSampleCountdown = samplesPerTick;
                    if (this.loopRepeatCount != 0 && this.bar == song.loopStart + song.loopLength) {
                        this.bar = song.loopStart;
                        if (this.loopRepeatCount > 0)
                            this.loopRepeatCount--;
                    }
                }
                if (this.bar >= song.barCount) {
                    this.bar = 0;
                    if (this.loopRepeatCount != -1) {
                        ended = true;
                        this.pause();
                    }
                }
            }
            this.syncSongState();
            if (this.tempMonoInstrumentSampleBuffer == null || this.tempMonoInstrumentSampleBuffer.length < outputBufferLength) {
                this.tempMonoInstrumentSampleBuffer = new Float32Array(outputBufferLength);
            }
            const volume = +this.volume;
            const limitDecay = 1.0 - Math.pow(0.5, 4.0 / this.samplesPerSecond);
            const limitRise = 1.0 - Math.pow(0.5, 4000.0 / this.samplesPerSecond);
            let limit = +this.limit;
            let bufferIndex = 0;
            while (bufferIndex < outputBufferLength && !ended) {
                this.nextBar = this.bar + 1;
                if (this.loopRepeatCount != 0 && this.nextBar == song.loopStart + song.loopLength) {
                    this.nextBar = song.loopStart;
                }
                if (this.nextBar >= song.barCount)
                    this.nextBar = null;
                const samplesLeftInBuffer = outputBufferLength - bufferIndex;
                const samplesLeftInTick = Math.ceil(this.tickSampleCountdown);
                const runLength = Math.min(samplesLeftInTick, samplesLeftInBuffer);
                this.isAtEndOfTick = (runLength >= this.tickSampleCountdown);
                if (this.isPlayingSong || this.renderingSong) {
                    for (let channelIndex = song.pitchChannelCount + song.noiseChannelCount; channelIndex < song.getChannelCount(); channelIndex++) {
                        const channel = song.channels[channelIndex];
                        const channelState = this.channels[channelIndex];
                        this.determineCurrentActiveTones(song, channelIndex, playSong);
                        for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                            const instrumentState = channelState.instruments[instrumentIndex];
                            for (let i = 0; i < instrumentState.activeModTones.count(); i++) {
                                const tone = instrumentState.activeModTones.get(i);
                                this.playModTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, false, false);
                            }
                        }
                    }
                }
                if (this.wantToSkip) {
                    this.wantToSkip = false;
                    this.skipBar();
                }
                for (let channelIndex = 0; channelIndex < song.pitchChannelCount + song.noiseChannelCount; channelIndex++) {
                    const channel = song.channels[channelIndex];
                    const channelState = this.channels[channelIndex];
                    this.determineCurrentActiveTones(song, channelIndex, playSong);
                    this.determineLiveInputTones(song, channelIndex);
                    for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                        const instrument = channel.instruments[instrumentIndex];
                        const instrumentState = channelState.instruments[instrumentIndex];
                        let tonesPlayedInThisInstrument = 0;
                        for (let i = 0; i < instrumentState.activeTones.count(); i++) {
                            const tone = instrumentState.activeTones.get(i);
                            this.playTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, false, false);
                            tonesPlayedInThisInstrument++;
                        }
                        for (let i = 0; i < instrumentState.liveInputTones.count(); i++) {
                            const tone = instrumentState.liveInputTones.get(i);
                            this.playTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, false, false);
                            tonesPlayedInThisInstrument++;
                        }
                        for (let i = 0; i < instrumentState.releasedTones.count(); i++) {
                            const tone = instrumentState.releasedTones.get(i);
                            if (tone.ticksSinceReleased >= Math.abs(instrument.getFadeOutTicks())) {
                                this.freeReleasedTone(instrumentState, i);
                                i--;
                                continue;
                            }
                            const shouldFadeOutFast = (tonesPlayedInThisInstrument >= Config.maximumTonesPerChannel);
                            this.playTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, true, shouldFadeOutFast);
                            tonesPlayedInThisInstrument++;
                        }
                        if (instrumentState.awake) {
                            if (!instrumentState.computed) {
                                instrumentState.compute(this, instrument, samplesPerTick, runLength, null, channelIndex, instrumentIndex);
                            }
                          Synth.effectsSynth(this, outputDataL, outputDataR, bufferIndex, runLength, instrument, instrumentState);
                          
                          instrumentState.computed = false;
                        }
                        const tickSampleCountdown = this.tickSampleCountdown;
                        const startRatio = 1.0 - (tickSampleCountdown) / samplesPerTick;
                        const endRatio = 1.0 - (tickSampleCountdown - runLength) / samplesPerTick;
                        const ticksIntoBar = (this.beat * Config.partsPerBeat + this.part) * Config.ticksPerPart + this.tick;
                        const partTimeTickStart = (ticksIntoBar) / Config.ticksPerPart;
                        const partTimeTickEnd = (ticksIntoBar + 1) / Config.ticksPerPart;
                        const partTimeStart = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * startRatio;
                        const partTimeEnd = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * endRatio;
                        let useVibratoSpeed = instrument.vibratoSpeed;
                        instrument.LFOtime = instrument.nextLFOtime;
                        if (this.isModActive(Config.modulators.dictionary["vibrato speed"].index, channelIndex, instrumentIndex)) {
                            useVibratoSpeed = this.getModValue(Config.modulators.dictionary["vibrato speed"].index, channelIndex, instrumentIndex);
                        }
                        if (useVibratoSpeed == 0) {
                            instrument.LFOtime = 0;
                            instrument.nextLFOtime = 0;
                        }
                        else {
                            instrument.nextLFOtime += useVibratoSpeed * 0.1 * (partTimeEnd - partTimeStart);
                        }
                    }
                }
                const runEnd = bufferIndex + runLength;
                for (let i = bufferIndex; i < runEnd; i++) {
                    const sampleL = outputDataL[i] * song.masterGain * song.masterGain;
                    const sampleR = outputDataR[i] * song.masterGain * song.masterGain;
                    const absL = sampleL < 0.0 ? -sampleL : sampleL;
                    const absR = sampleR < 0.0 ? -sampleR : sampleR;
                    const abs = absL > absR ? absL : absR;
                    this.song.inVolumeCap = (this.song.inVolumeCap > abs ? this.song.inVolumeCap : abs);
                    const limitRange = (+(abs > song.compressionThreshold)) + (+(abs > song.limitThreshold));
                    const limitTarget = (+(limitRange == 0)) * (((abs + 1 - song.compressionThreshold) * 0.8 + 0.25) * song.compressionRatio + 1.05 * (1 - song.compressionRatio))
                        + (+(limitRange == 1)) * (1.05)
                        + (+(limitRange == 2)) * (1.05 * ((abs + 1 - song.limitThreshold) * song.limitRatio + (1 - song.limitThreshold)));
                    limit += ((limitTarget - limit) * (limit < limitTarget ? limitRise : limitDecay));
                    const limitedVolume = volume / (limit >= 1 ? limit * 1.05 : limit * 0.8 + 0.25);
                    
                    
                    
                    outputDataL[i] = sampleL * limitedVolume;
                    outputDataR[i] = sampleR * limitedVolume;
                    this.song.outVolumeCap = (this.song.outVolumeCap > abs * limitedVolume ? this.song.outVolumeCap : abs * limitedVolume);
                }
                bufferIndex += runLength;
                this.isAtStartOfTick = false;
                this.tickSampleCountdown -= runLength;
                if (this.tickSampleCountdown <= 0) {
                    this.isAtStartOfTick = true;
                    for (const channelState of this.channels) {
                        for (const instrumentState of channelState.instruments) {
                            for (let i = 0; i < instrumentState.releasedTones.count(); i++) {
                                const tone = instrumentState.releasedTones.get(i);
                                if (tone.isOnLastTick) {
                                    this.freeReleasedTone(instrumentState, i);
                                    i--;
                                }
                                else {
                                    tone.ticksSinceReleased++;
                                }
                            }
                            if (instrumentState.deactivateAfterThisTick) {
                                instrumentState.deactivate();
                            }
                            instrumentState.tonesAddedInThisTick = false;
                        }
                    }
                    for (let channel = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {
                        for (let instrumentIdx = 0; instrumentIdx < this.song.channels[channel].instruments.length; instrumentIdx++) {
                            let instrument = this.song.channels[channel].instruments[instrumentIdx];
                            let useArpeggioSpeed = instrument.arpeggioSpeed;
                            if (this.isModActive(Config.modulators.dictionary["arp speed"].index, channel, instrumentIdx)) {
                                useArpeggioSpeed = this.getModValue(Config.modulators.dictionary["arp speed"].index, channel, instrumentIdx, false);
                                if (Number.isInteger(useArpeggioSpeed)) {
                                    instrument.arpTime += Config.arpSpeedScale[useArpeggioSpeed];
                                }
                                else {
                                    instrument.arpTime += (1 - (useArpeggioSpeed % 1)) * Config.arpSpeedScale[Math.floor(useArpeggioSpeed)] + (useArpeggioSpeed % 1) * Config.arpSpeedScale[Math.ceil(useArpeggioSpeed)];
                                }
                            }
                            else {
                                instrument.arpTime += Config.arpSpeedScale[useArpeggioSpeed];
                            }
                        }
                    }
                    for (let channel = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {
                        for (let instrumentIdx = 0; instrumentIdx < this.song.channels[channel].instruments.length; instrumentIdx++) {
                            let instrument = this.song.channels[channel].instruments[instrumentIdx];
                            if (instrument.tmpEqFilterEnd != null) {
                                instrument.tmpEqFilterStart = instrument.tmpEqFilterEnd;
                            }
                            else {
                                instrument.tmpEqFilterStart = instrument.eqFilter;
                            }
                            if (instrument.tmpNoteFilterEnd != null) {
                                instrument.tmpNoteFilterStart = instrument.tmpNoteFilterEnd;
                            }
                            else {
                                instrument.tmpNoteFilterStart = instrument.noteFilter;
                            }
                        }
                    }
                    this.tick++;
                    this.tickSampleCountdown += samplesPerTick;
                    if (this.tick == Config.ticksPerPart) {
                        this.tick = 0;
                        this.part++;
                        this.liveInputDuration--;
                        if (this.part == Config.partsPerBeat) {
                            this.part = 0;
                            if (playSong) {
                                this.beat++;
                                if (this.beat == song.beatsPerBar) {
                                    this.beat = 0;
                                    this.prevBar = this.bar;
                                    this.bar++;
                                    if (this.loopRepeatCount != 0 && this.bar == song.loopStart + song.loopLength) {
                                        this.bar = song.loopStart;
                                        if (this.loopRepeatCount > 0)
                                            this.loopRepeatCount--;
                                    }
                                    if (this.bar >= song.barCount) {
                                        this.bar = 0;
                                        if (this.loopRepeatCount != -1) {
                                            ended = true;
                                            this.resetEffects();
                                            this.pause();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                for (let setting = 0; setting < Config.modulators.length; setting++) {
                    if (this.nextModValues != null && this.nextModValues[setting] != null)
                        this.modValues[setting] = this.nextModValues[setting];
                }
                if (this.isModActive(Config.modulators.dictionary["tempo"].index)) {
                    samplesPerTick = this.getSamplesPerTick();
                    this.tickSampleCountdown = Math.min(this.tickSampleCountdown, samplesPerTick);
                }
                for (let channel = 0; channel < this.song.pitchChannelCount; channel++) {
                    for (let instrument of this.song.channels[channel].instruments) {
                        instrument.nextLFOtime = (instrument.nextLFOtime % (Config.vibratoTypes[instrument.vibratoType].period / (Config.ticksPerPart * samplesPerTick / this.samplesPerSecond)));
                        instrument.arpTime = (instrument.arpTime % (2520 * Config.ticksPerArpeggio));
                    }
                }
                for (let setting = 0; setting < Config.modulators.length; setting++) {
                    for (let channel = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {
                        for (let instrument = 0; instrument < this.song.getMaxInstrumentsPerChannel(); instrument++) {
                            if (this.nextModInsValues != null && this.nextModInsValues[channel] != null && this.nextModInsValues[channel][instrument] != null && this.nextModInsValues[channel][instrument][setting] != null) {
                                this.modInsValues[channel][instrument][setting] = this.nextModInsValues[channel][instrument][setting];
                            }
                        }
                    }
                }
            }
            if (!Number.isFinite(limit) || Math.abs(limit) < epsilon)
                limit = 0.0;
            this.limit = limit;
            if (playSong) {
                this.playheadInternal = (((this.tick + 1.0 - this.tickSampleCountdown / samplesPerTick) / 2.0 + this.part) / Config.partsPerBeat + this.beat) / song.beatsPerBar + this.bar;
            }
        }
        freeTone(tone) {
            this.tonePool.pushBack(tone);
        }
        newTone() {
            if (this.tonePool.count() > 0) {
                const tone = this.tonePool.popBack();
                tone.freshlyAllocated = true;
                return tone;
            }
            return new Tone();
        }
        releaseTone(instrumentState, tone) {
            instrumentState.releasedTones.pushFront(tone);
            tone.atNoteStart = false;
            tone.passedEndOfNote = true;
        }
        freeReleasedTone(instrumentState, toneIndex) {
            this.freeTone(instrumentState.releasedTones.get(toneIndex));
            instrumentState.releasedTones.remove(toneIndex);
        }
        freeAllTones() {
            for (const channelState of this.channels) {
                for (const instrumentState of channelState.instruments) {
                    while (instrumentState.activeTones.count() > 0)
                        this.freeTone(instrumentState.activeTones.popBack());
                    while (instrumentState.activeModTones.count() > 0)
                        this.freeTone(instrumentState.activeModTones.popBack());
                    while (instrumentState.releasedTones.count() > 0)
                        this.freeTone(instrumentState.releasedTones.popBack());
                    while (instrumentState.liveInputTones.count() > 0)
                        this.freeTone(instrumentState.liveInputTones.popBack());
                }
            }
        }
        determineLiveInputTones(song, channelIndex) {
            const channel = song.channels[channelIndex];
            const channelState = this.channels[channelIndex];
            const pitches = this.liveInputPitches;
            for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                const instrumentState = channelState.instruments[instrumentIndex];
                const toneList = instrumentState.liveInputTones;
                let toneCount = 0;
                if (this.liveInputDuration > 0 && channelIndex == this.liveInputChannel && pitches.length > 0 && this.liveInputInstruments.indexOf(instrumentIndex) != -1) {
                    const instrument = channel.instruments[instrumentIndex];
                    if (instrument.getChord().singleTone) {
                        let tone;
                        if (toneList.count() <= toneCount) {
                            tone = this.newTone();
                            toneList.pushBack(tone);
                        }
                        else if (!instrument.getTransition().isSeamless && this.liveInputStarted) {
                            this.releaseTone(instrumentState, toneList.get(toneCount));
                            tone = this.newTone();
                            toneList.set(toneCount, tone);
                        }
                        else {
                            tone = toneList.get(toneCount);
                        }
                        toneCount++;
                        for (let i = 0; i < pitches.length; i++) {
                            tone.pitches[i] = pitches[i];
                        }
                        tone.pitchCount = pitches.length;
                        tone.chordSize = 1;
                        tone.instrumentIndex = instrumentIndex;
                        tone.note = tone.prevNote = tone.nextNote = null;
                        tone.atNoteStart = this.liveInputStarted;
                        tone.forceContinueAtStart = false;
                        tone.forceContinueAtEnd = false;
                    }
                    else {
                        for (let i = 0; i < pitches.length; i++) {
                            let tone;
                            if (toneList.count() <= toneCount) {
                                tone = this.newTone();
                                toneList.pushBack(tone);
                            }
                            else if (!instrument.getTransition().isSeamless && this.liveInputStarted) {
                                this.releaseTone(instrumentState, toneList.get(toneCount));
                                tone = this.newTone();
                                toneList.set(toneCount, tone);
                            }
                            else {
                                tone = toneList.get(toneCount);
                            }
                            toneCount++;
                            tone.pitches[0] = pitches[i];
                            tone.pitchCount = 1;
                            tone.chordSize = pitches.length;
                            tone.instrumentIndex = instrumentIndex;
                            tone.note = tone.prevNote = tone.nextNote = null;
                            tone.atNoteStart = this.liveInputStarted;
                            tone.forceContinueAtStart = false;
                            tone.forceContinueAtEnd = false;
                        }
                    }
                }
                while (toneList.count() > toneCount) {
                    this.releaseTone(instrumentState, toneList.popBack());
                }
            }
            this.liveInputStarted = false;
        }
        adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern, otherPattern, instrumentIndex, transition, chord, note, otherNote, forceContinue) {
            if (song.patternInstruments && otherPattern.instruments.indexOf(instrumentIndex) == -1) {
                if (pattern.instruments.length > 1 || otherPattern.instruments.length > 1) {
                    return null;
                }
                const otherInstrument = channel.instruments[otherPattern.instruments[0]];
                if (forceContinue) {
                    return otherInstrument.getChord();
                }
                const otherTransition = otherInstrument.getTransition();
                if (transition.includeAdjacentPatterns && otherTransition.includeAdjacentPatterns && otherTransition.slides == transition.slides) {
                    return otherInstrument.getChord();
                }
                else {
                    return null;
                }
            }
            else {
                return (forceContinue || transition.includeAdjacentPatterns) ? chord : null;
            }
        }
        static adjacentNotesHaveMatchingPitches(firstNote, secondNote) {
            if (firstNote.pitches.length != secondNote.pitches.length)
                return false;
            const firstNoteInterval = firstNote.pins[firstNote.pins.length - 1].interval;
            for (const pitch of firstNote.pitches) {
                if (secondNote.pitches.indexOf(pitch + firstNoteInterval) == -1)
                    return false;
            }
            return true;
        }
        determineCurrentActiveTones(song, channelIndex, playSong) {
            const channel = song.channels[channelIndex];
            const channelState = this.channels[channelIndex];
            const pattern = song.getPattern(channelIndex, this.bar);
            const currentPart = this.getCurrentPart();
            const currentTick = this.tick + Config.ticksPerPart * currentPart;
            if (playSong && song.getChannelIsMod(channelIndex)) {
                let notes = [];
                let prevNotes = [];
                let nextNotes = [];
                let fillCount = Config.modCount;
                while (fillCount--) {
                    notes.push(null);
                    prevNotes.push(null);
                    nextNotes.push(null);
                }
                if (pattern != null && !channel.muted) {
                    for (let i = 0; i < pattern.notes.length; i++) {
                        if (pattern.notes[i].end <= currentPart) {
                            if (prevNotes[pattern.notes[i].pitches[0]] == null || pattern.notes[i].end > prevNotes[pattern.notes[i].pitches[0]].start) {
                                prevNotes[pattern.notes[i].pitches[0]] = pattern.notes[i];
                            }
                        }
                        else if (pattern.notes[i].start <= currentPart && pattern.notes[i].end > currentPart) {
                            notes[pattern.notes[i].pitches[0]] = pattern.notes[i];
                        }
                        else if (pattern.notes[i].start > currentPart) {
                            if (nextNotes[pattern.notes[i].pitches[0]] == null || pattern.notes[i].start < nextNotes[pattern.notes[i].pitches[0]].start) {
                                nextNotes[pattern.notes[i].pitches[0]] = pattern.notes[i];
                            }
                        }
                    }
                }
                let modToneCount = 0;
                const newInstrumentIndex = (song.patternInstruments && (pattern != null)) ? pattern.instruments[0] : 0;
                const instrumentState = channelState.instruments[newInstrumentIndex];
                const toneList = instrumentState.activeModTones;
                for (let mod = 0; mod < Config.modCount; mod++) {
                    if (notes[mod] != null) {
                        if (prevNotes[mod] != null && prevNotes[mod].end != notes[mod].start)
                            prevNotes[mod] = null;
                        if (nextNotes[mod] != null && nextNotes[mod].start != notes[mod].end)
                            nextNotes[mod] = null;
                    }
                    if (channelState.singleSeamlessInstrument != null && channelState.singleSeamlessInstrument != newInstrumentIndex && channelState.singleSeamlessInstrument < channelState.instruments.length) {
                        const sourceInstrumentState = channelState.instruments[channelState.singleSeamlessInstrument];
                        const destInstrumentState = channelState.instruments[newInstrumentIndex];
                        while (sourceInstrumentState.activeModTones.count() > 0) {
                            destInstrumentState.activeModTones.pushFront(sourceInstrumentState.activeModTones.popBack());
                        }
                    }
                    channelState.singleSeamlessInstrument = newInstrumentIndex;
                    if (notes[mod] != null) {
                        let prevNoteForThisInstrument = prevNotes[mod];
                        let nextNoteForThisInstrument = nextNotes[mod];
                        let forceContinueAtStart = false;
                        let forceContinueAtEnd = false;
                        const atNoteStart = (Config.ticksPerPart * notes[mod].start == currentTick) && this.isAtStartOfTick;
                        let tone;
                        if (toneList.count() <= modToneCount) {
                            tone = this.newTone();
                            toneList.pushBack(tone);
                        }
                        else if (atNoteStart && (prevNoteForThisInstrument == null)) {
                            const oldTone = toneList.get(modToneCount);
                            if (oldTone.isOnLastTick) {
                                this.freeTone(oldTone);
                            }
                            else {
                                this.releaseTone(instrumentState, oldTone);
                            }
                            tone = this.newTone();
                            toneList.set(modToneCount, tone);
                        }
                        else {
                            tone = toneList.get(modToneCount);
                        }
                        modToneCount++;
                        for (let i = 0; i < notes[mod].pitches.length; i++) {
                            tone.pitches[i] = notes[mod].pitches[i];
                        }
                        tone.pitchCount = notes[mod].pitches.length;
                        tone.chordSize = 1;
                        tone.instrumentIndex = newInstrumentIndex;
                        tone.note = notes[mod];
                        tone.noteStartPart = notes[mod].start;
                        tone.noteEndPart = notes[mod].end;
                        tone.prevNote = prevNoteForThisInstrument;
                        tone.nextNote = nextNoteForThisInstrument;
                        tone.prevNotePitchIndex = 0;
                        tone.nextNotePitchIndex = 0;
                        tone.atNoteStart = atNoteStart;
                        tone.passedEndOfNote = false;
                        tone.forceContinueAtStart = forceContinueAtStart;
                        tone.forceContinueAtEnd = forceContinueAtEnd;
                    }
                }
                while (toneList.count() > modToneCount) {
                    const tone = toneList.popBack();
                    const channel = song.channels[channelIndex];
                    if (tone.instrumentIndex < channel.instruments.length && !tone.isOnLastTick) {
                        const instrumentState = this.channels[channelIndex].instruments[tone.instrumentIndex];
                        this.releaseTone(instrumentState, tone);
                    }
                    else {
                        this.freeTone(tone);
                    }
                }
            }
            else if (!song.getChannelIsMod(channelIndex)) {
                let note = null;
                let prevNote = null;
                let nextNote = null;
                if (playSong && pattern != null && !channel.muted && (!this.isRecording || this.liveInputChannel != channelIndex)){
                
                    for (let i = 0; i < pattern.notes.length; i++) {
                        if (pattern.notes[i].end <= currentPart) {
                            prevNote = pattern.notes[i];
                        }
                        else if (pattern.notes[i].start <= currentPart && pattern.notes[i].end > currentPart) {
                            note = pattern.notes[i];
                        }
                        else if (pattern.notes[i].start > currentPart) {
                            nextNote = pattern.notes[i];
                            break;
                        }
                    }
                    if (note != null) {
                        if (prevNote != null && prevNote.end != note.start)
                            prevNote = null;
                        if (nextNote != null && nextNote.start != note.end)
                            nextNote = null;
                    }
                }
                if (pattern != null && (!song.layeredInstruments || channel.instruments.length == 1 || (song.patternInstruments && pattern.instruments.length == 1))) {
                    const newInstrumentIndex = song.patternInstruments ? pattern.instruments[0] : 0;
                    if (channelState.singleSeamlessInstrument != null && channelState.singleSeamlessInstrument != newInstrumentIndex && channelState.singleSeamlessInstrument < channelState.instruments.length) {
                        const sourceInstrumentState = channelState.instruments[channelState.singleSeamlessInstrument];
                        const destInstrumentState = channelState.instruments[newInstrumentIndex];
                        while (sourceInstrumentState.activeTones.count() > 0) {
                            destInstrumentState.activeTones.pushFront(sourceInstrumentState.activeTones.popBack());
                        }
                    }
                    channelState.singleSeamlessInstrument = newInstrumentIndex;
                }
                else {
                    channelState.singleSeamlessInstrument = null;
                }
                for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                    const instrumentState = channelState.instruments[instrumentIndex];
                    const toneList = instrumentState.activeTones;
                    let toneCount = 0;
                    if ((note != null) && (!song.patternInstruments || (pattern.instruments.indexOf(instrumentIndex) != -1))) {
                        const instrument = channel.instruments[instrumentIndex];
                        let prevNoteForThisInstrument = prevNote;
                        let nextNoteForThisInstrument = nextNote;
                        const partsPerBar = Config.partsPerBeat * song.beatsPerBar;
                        const transition = instrument.getTransition();
                        const chord = instrument.getChord();
                        let forceContinueAtStart = false;
                        let forceContinueAtEnd = false;
                        let tonesInPrevNote = 0;
                        let tonesInNextNote = 0;
                        if (note.start == 0) {
                            let prevPattern = (this.prevBar == null) ? null : song.getPattern(channelIndex, this.prevBar);
                            if (prevPattern != null) {
                                const lastNote = (prevPattern.notes.length <= 0) ? null : prevPattern.notes[prevPattern.notes.length - 1];
                                if (lastNote != null && lastNote.end == partsPerBar) {
                                    const patternForcesContinueAtStart = note.continuesLastPattern && Synth.adjacentNotesHaveMatchingPitches(lastNote, note);
                                    const chordOfCompatibleInstrument = this.adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern, prevPattern, instrumentIndex, transition, chord, note, lastNote, patternForcesContinueAtStart);
                                    if (chordOfCompatibleInstrument != null) {
                                        prevNoteForThisInstrument = lastNote;
                                        tonesInPrevNote = chordOfCompatibleInstrument.singleTone ? 1 : prevNoteForThisInstrument.pitches.length;
                                        forceContinueAtStart = patternForcesContinueAtStart;
                                    }
                                }
                            }
                        }
                        else if (prevNoteForThisInstrument != null) {
                            tonesInPrevNote = chord.singleTone ? 1 : prevNoteForThisInstrument.pitches.length;
                        }
                        if (note.end == partsPerBar) {
                            let nextPattern = (this.nextBar == null) ? null : song.getPattern(channelIndex, this.nextBar);
                            if (nextPattern != null) {
                                const firstNote = (nextPattern.notes.length <= 0) ? null : nextPattern.notes[0];
                                if (firstNote != null && firstNote.start == 0) {
                                    const nextPatternForcesContinueAtStart = firstNote.continuesLastPattern && Synth.adjacentNotesHaveMatchingPitches(note, firstNote);
                                    const chordOfCompatibleInstrument = this.adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern, nextPattern, instrumentIndex, transition, chord, note, firstNote, nextPatternForcesContinueAtStart);
                                    if (chordOfCompatibleInstrument != null) {
                                        nextNoteForThisInstrument = firstNote;
                                        tonesInNextNote = chordOfCompatibleInstrument.singleTone ? 1 : nextNoteForThisInstrument.pitches.length;
                                        forceContinueAtEnd = nextPatternForcesContinueAtStart;
                                    }
                                }
                            }
                        }
                        else if (nextNoteForThisInstrument != null) {
                            tonesInNextNote = chord.singleTone ? 1 : nextNoteForThisInstrument.pitches.length;
                        }
                        if (chord.singleTone) {
                            const atNoteStart = (Config.ticksPerPart * note.start == currentTick) && this.isAtStartOfTick;
                            let tone;
                            if (toneList.count() <= toneCount) {
                                tone = this.newTone();
                                toneList.pushBack(tone);
                            }
                            else if (atNoteStart && ((!(transition.isSeamless || instrument.clicklessTransition) && !forceContinueAtStart) || prevNoteForThisInstrument == null)) {
                                const oldTone = toneList.get(toneCount);
                                if (oldTone.isOnLastTick) {
                                    this.freeTone(oldTone);
                                }
                                else {
                                    this.releaseTone(instrumentState, oldTone);
                                }
                                tone = this.newTone();
                                toneList.set(toneCount, tone);
                            }
                            else {
                                tone = toneList.get(toneCount);
                            }
                            toneCount++;
                            for (let i = 0; i < note.pitches.length; i++) {
                                tone.pitches[i] = note.pitches[i];
                            }
                            tone.pitchCount = note.pitches.length;
                            tone.chordSize = 1;
                            tone.instrumentIndex = instrumentIndex;
                            tone.note = note;
                            tone.noteStartPart = note.start;
                            tone.noteEndPart = note.end;
                            tone.prevNote = prevNoteForThisInstrument;
                            tone.nextNote = nextNoteForThisInstrument;
                            tone.prevNotePitchIndex = 0;
                            tone.nextNotePitchIndex = 0;
                            tone.atNoteStart = atNoteStart;
                            tone.passedEndOfNote = false;
                            tone.forceContinueAtStart = forceContinueAtStart;
                            tone.forceContinueAtEnd = forceContinueAtEnd;
                        }
                        else {
                            const transition = instrument.getTransition();
                            if (((transition.isSeamless && !transition.slides && chord.strumParts == 0) || forceContinueAtStart) && (Config.ticksPerPart * note.start == currentTick) && this.isAtStartOfTick && prevNoteForThisInstrument != null) {
                                for (let i = 0; i < toneList.count(); i++) {
                                    const tone = toneList.get(i);
                                    const pitch = tone.pitches[0] + tone.lastInterval;
                                    for (let j = 0; j < note.pitches.length; j++) {
                                        if (note.pitches[j] == pitch) {
                                            this.tempMatchedPitchTones[j] = tone;
                                            toneList.remove(i);
                                            i--;
                                            break;
                                        }
                                    }
                                }
                                while (toneList.count() > 0) {
                                    const tone = toneList.popFront();
                                    for (let j = 0; j < this.tempMatchedPitchTones.length; j++) {
                                        if (this.tempMatchedPitchTones[j] == null) {
                                            this.tempMatchedPitchTones[j] = tone;
                                            break;
                                        }
                                    }
                                }
                            }
                            let strumOffsetParts = 0;
                            for (let i = 0; i < note.pitches.length; i++) {
                                let prevNoteForThisTone = (tonesInPrevNote > i) ? prevNoteForThisInstrument : null;
                                let noteForThisTone = note;
                                let nextNoteForThisTone = (tonesInNextNote > i) ? nextNoteForThisInstrument : null;
                                let noteStartPart = noteForThisTone.start + strumOffsetParts;
                                let passedEndOfNote = false;
                                if (noteStartPart > currentPart) {
                                    if (toneList.count() > i && (transition.isSeamless || forceContinueAtStart) && prevNoteForThisTone != null) {
                                        nextNoteForThisTone = noteForThisTone;
                                        noteForThisTone = prevNoteForThisTone;
                                        prevNoteForThisTone = null;
                                        noteStartPart = noteForThisTone.start + strumOffsetParts;
                                        passedEndOfNote = true;
                                    }
                                    else {
                                        break;
                                    }
                                }
                                let noteEndPart = noteForThisTone.end;
                                if ((transition.isSeamless || forceContinueAtStart) && nextNoteForThisTone != null) {
                                    noteEndPart = Math.min(Config.partsPerBeat * this.song.beatsPerBar, noteEndPart + strumOffsetParts);
                                }
                                if ((!transition.continues && !forceContinueAtStart) || prevNoteForThisTone == null) {
                                    strumOffsetParts += chord.strumParts;
                                }
                                const atNoteStart = (Config.ticksPerPart * noteStartPart == currentTick) && this.isAtStartOfTick;
                                let tone;
                                if (this.tempMatchedPitchTones[toneCount] != null) {
                                    tone = this.tempMatchedPitchTones[toneCount];
                                    this.tempMatchedPitchTones[toneCount] = null;
                                    toneList.pushBack(tone);
                                }
                                else if (toneList.count() <= toneCount) {
                                    tone = this.newTone();
                                    toneList.pushBack(tone);
                                }
                                else if (atNoteStart && ((!transition.isSeamless && !forceContinueAtStart) || prevNoteForThisTone == null)) {
                                    const oldTone = toneList.get(toneCount);
                                    if (oldTone.isOnLastTick) {
                                        this.freeTone(oldTone);
                                    }
                                    else {
                                        this.releaseTone(instrumentState, oldTone);
                                    }
                                    tone = this.newTone();
                                    toneList.set(toneCount, tone);
                                }
                                else {
                                    tone = toneList.get(toneCount);
                                }
                                toneCount++;
                                tone.pitches[0] = noteForThisTone.pitches[i];
                                tone.pitchCount = 1;
                                tone.chordSize = noteForThisTone.pitches.length;
                                tone.instrumentIndex = instrumentIndex;
                                tone.note = noteForThisTone;
                                tone.noteStartPart = noteStartPart;
                                tone.noteEndPart = noteEndPart;
                                tone.prevNote = prevNoteForThisTone;
                                tone.nextNote = nextNoteForThisTone;
                                tone.prevNotePitchIndex = i;
                                tone.nextNotePitchIndex = i;
                                tone.atNoteStart = atNoteStart;
                                tone.passedEndOfNote = passedEndOfNote;
                                tone.forceContinueAtStart = forceContinueAtStart && prevNoteForThisTone != null;
                                tone.forceContinueAtEnd = forceContinueAtEnd && nextNoteForThisTone != null;
                            }
                        }
                    }
                    while (toneList.count() > toneCount) {
                        const tone = toneList.popBack();
                        const channel = song.channels[channelIndex];
                        if (tone.instrumentIndex < channel.instruments.length && !tone.isOnLastTick) {
                            const instrumentState = this.channels[channelIndex].instruments[tone.instrumentIndex];
                            this.releaseTone(instrumentState, tone);
                        }
                        else {
                            this.freeTone(tone);
                        }
                    }
                    for (let i = toneCount; i < this.tempMatchedPitchTones.length; i++) {
                        const oldTone = this.tempMatchedPitchTones[i];
                        if (oldTone != null) {
                            if (oldTone.isOnLastTick) {
                                this.freeTone(oldTone);
                            }
                            else {
                                this.releaseTone(instrumentState, oldTone);
                            }
                            this.tempMatchedPitchTones[i] = null;
                        }
                    }
                }
            }
        }
        playTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, released, shouldFadeOutFast) {
            const channel = song.channels[channelIndex];
            
            const channelState = this.channels[channelIndex];
            const instrument = channel.instruments[tone.instrumentIndex];
            const instrumentState = channelState.instruments[tone.instrumentIndex];
            instrumentState.awake = true;
            instrumentState.tonesAddedInThisTick = true;
            if (!instrumentState.computed) {
                instrumentState.compute(this, instrument, samplesPerTick, runLength, tone, channelIndex, tone.instrumentIndex);
            }
            Synth.computeTone(this, song, channelIndex, samplesPerTick, runLength, tone, released, shouldFadeOutFast);
            const synthesizer = Synth.getInstrumentSynthFunction(instrument);
            synthesizer(this, bufferIndex, runLength, tone, instrument);
            tone.envelopeComputer.clearEnvelopes(instrument);
        }
        playModTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, released, shouldFadeOutFast) {
            const channel = song.channels[channelIndex];
            const instrument = channel.instruments[tone.instrumentIndex];
            if (tone.note != null) {
                const ticksIntoBar = this.getTicksIntoBar();
                const partTimeTickStart = (ticksIntoBar) / Config.ticksPerPart;
                const partTimeTickEnd = (ticksIntoBar + 1) / Config.ticksPerPart;
                const tickSampleCountdown = this.tickSampleCountdown;
                const startRatio = 1.0 - (tickSampleCountdown) / samplesPerTick;
                const endRatio = 1.0 - (tickSampleCountdown - runLength) / samplesPerTick;
                const partTimeStart = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * startRatio;
                const partTimeEnd = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * endRatio;
                const tickTimeStart = Config.ticksPerPart * partTimeStart;
                const tickTimeEnd = Config.ticksPerPart * partTimeEnd;
                const endPinIndex = tone.note.getEndPinIndex(this.getCurrentPart());
                const startPin = tone.note.pins[endPinIndex - 1];
                const endPin = tone.note.pins[endPinIndex];
                const startPinTick = (tone.note.start + startPin.time) * Config.ticksPerPart;
                const endPinTick = (tone.note.start + endPin.time) * Config.ticksPerPart;
                const ratioStart = (tickTimeStart - startPinTick) / (endPinTick - startPinTick);
                const ratioEnd = (tickTimeEnd - startPinTick) / (endPinTick - startPinTick);
                tone.expressionStarts[0] = startPin.size + (endPin.size - startPin.size) * ratioStart;
                tone.expressionDeltas[0] = (startPin.size + (endPin.size - startPin.size) * ratioEnd) - tone.expressionStarts[0];
                Synth.modSynth(this, bufferIndex, runLength, tone, instrument);
            }
        }
        static computeChordExpression(chordSize) {
            return 1.0 / ((chordSize - 1) * 0.25 + 1.0);
        }
        
        
        static loopableChipSynth(synth, bufferIndex, roundedSamplesPerTick, tone, instrumentState) {
	const voiceCount = Math.max(2, instrumentState.unisonVoices);
	
	const chipWaveLoopMode = instrumentState.chipWaveLoopMode;
	let chipFunction = Synth.loopableChipFunctionCache[instrumentState.unisonVoices][chipWaveLoopMode];
	if (chipFunction == undefined) {
		let chipSource = "return (synth, bufferIndex, roundedSamplesPerTick, tone, instrumentState) => {";
		chipSource += `
        const aliases = (effectsIncludeDistortion(instrumentState.effects) && instrumentState.aliases);
        // const aliases = false;
        
        const data = synth.tempMonoInstrumentSampleBuffer;
        
        const wave =  Config.chipWaves[instrumentState.chipWave].samples ;
         
        const volumeScale = instrumentState.volumeScale;
        
        const waveLength = (aliases && instrumentState.type == 8) ?  wave.length : wave.length - 1;
        let chipWaveLoopEnd = Math.max(0, Math.min(waveLength, instrumentState.chipWaveLoopEnd));
        
        let chipWaveLoopStart = Math.max(0, Math.min(chipWaveLoopEnd - 1, instrumentState.chipWaveLoopStart));
        // @TODO: This is where to set things up for the release loop mode.
        // const ticksSinceReleased = tone.ticksSinceReleased;
        // if (ticksSinceReleased > 0) {
        //     chipWaveLoopStart = 0;
        //     chipWaveLoopEnd = waveLength - 1;
        // }
        let chipWaveLoopLength = chipWaveLoopEnd - chipWaveLoopStart;
        if (chipWaveLoopLength < 2) {
            chipWaveLoopStart = 0;
            chipWaveLoopEnd = waveLength;
            chipWaveLoopLength = waveLength;
        }
        const chipWavePlayBackwards = instrumentState.chipWavePlayBackwards;
        const unisonSign = tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        
        `;
		for (let i = 0; i < voiceCount; i++) {
			chipSource += ` 
			let phaseDelta# = tone.phaseDeltas[#] * waveLength;
			
let direction# = tone.directions[#];
            
            
            let chipWaveCompletion# = tone.chipWaveCompletions[#];
            let phaseDeltaScale# = +tone.phaseDeltaScales[#];
            let lastWave# = tone.chipWaveCompletionsLastWave[#];
            let prevWave# = tone.chipWavePrevWaves[#];

            if (instrumentState.unisonVoices <= # && instrumentState.unisonSpread == 0 && !instrumentState.chord.customInterval) tone.phases[#] = tone.phases[# - 1];
            `.replaceAll("#", i + "");
		}
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `let phase# = Synth.wrap(tone.phases[#], 1) * waveLength;
            let prevWaveIntegral# = 0.0;
            `.replaceAll("#", i + "");
		}
		if (chipWaveLoopMode === 3 || chipWaveLoopMode === 2 || chipWaveLoopMode === 0) {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `
            if (!chipWavePlayBackwards) {
                direction# = 1;
            } else {
                direction# = -1;
            }
                `.replaceAll("#", i + "");
			}
		}
		if (chipWaveLoopMode === 0 || chipWaveLoopMode === 1) {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `
        chipWaveCompletion# = 0;
        `.replaceAll("#", i + "");
			}
		}
		chipSource += `let expression = +tone.expressionStarts[0];
		
        const expressionDelta = +tone.expressionDeltas[0];
        const chipWaveCompletionFadeLength = 1000;
        if (!aliases) {`;
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `const phase#Int = Math.floor(phase#);
                const index# = Synth.wrap(phase#Int, waveLength);
                prevWaveIntegral# = +wave[index#]
                const phaseRatio# = phase# - phase#Int;
                prevWaveIntegral# += (wave[Synth.wrap(index# + 1, waveLength)] - prevWaveIntegral#) * phaseRatio#;
                `.replaceAll("#", i + "");
		}
		chipSource += `
        } 
            
        const filters = tone.noteFilters;
        const filterCount = tone.noteFilterCount | 0;
        let initialFilterInput1 = +tone.initialNoteFilterInput1;
        let initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters;
        const stopIndex = bufferIndex + roundedSamplesPerTick;
        
        for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
            
            let wrapped = 0;`;
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `
                if (chipWaveCompletion# > 0 && chipWaveCompletion# < chipWaveCompletionFadeLength) {
                    chipWaveCompletion#++;
                }
                phase# += phaseDelta# * direction#;
                `.replaceAll("#", i + "");
		}
		if (chipWaveLoopMode === 2) {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `
                if (direction# === 1) {
                    if (phase# > waveLength) {
                        if (chipWaveCompletion# <= 0) {
                            lastWave# = prevWave#;
                            chipWaveCompletion#++;
                        }
                        wrapped = 1;
                    }
                } else if (direction# === -1) {
                    if (phase# < 0) {
                        if (chipWaveCompletion# <= 0) {
                            lastWave# = prevWave#;
                            chipWaveCompletion#++;
                        }
                        wrapped = 1;
                    }
                }
                `.replaceAll("#", i + "");
			}
		}
		else if (chipWaveLoopMode === 3) {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `
                if (direction# === 1) {
                    if (phase# > chipWaveLoopEnd) {
                        if (chipWaveCompletion# <= 0) {
                            lastWave# = prevWave#;
                            chipWaveCompletion#++;
                        }
                        wrapped = 1;
                    }
                } else if (direction# === -1) {
                    if (phase# < chipWaveLoopStart) {
                        if (chipWaveCompletion# <= 0) {
                            lastWave# = prevWave#;
                            chipWaveCompletion#++;
                        }
                        wrapped = 1;
                    }
                }
                `.replaceAll("#", i + "");
			}
		}
		else if (chipWaveLoopMode === 0) {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `
                if (direction# === 1) {
                    if (phase# > chipWaveLoopEnd) {
                        phase# = chipWaveLoopStart + Synth.wrap(phase# - chipWaveLoopEnd, chipWaveLoopLength);
                        // phase# = chipWaveLoopStart;
                        wrapped = 1;
                    }
                } else if (direction# === -1) {
                    if (phase# < chipWaveLoopStart) {
                        phase# = chipWaveLoopEnd - Synth.wrap(chipWaveLoopStart - phase#, chipWaveLoopLength);
                        // phase# = chipWaveLoopEnd;
                        wrapped = 1;
                    }
                }
                `.replaceAll("#", i + "");
			}
		}
		else if (chipWaveLoopMode === 1) {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `
                if (direction# === 1) {
                    if (phase# > chipWaveLoopEnd) {
                        phase# = chipWaveLoopEnd - Synth.wrap(phase# - chipWaveLoopEnd, chipWaveLoopLength);
                        // phase# = chipWaveLoopEnd;
                        direction# = -1;
                        wrapped = 1;
                    }
                } else if (direction# === -1) {
                    if (phase# < chipWaveLoopStart) {
                        phase# = chipWaveLoopStart + Synth.wrap(chipWaveLoopStart - phase#, chipWaveLoopLength);
                        // phase# = chipWaveLoopStart;
                        direction# = 1;
                        wrapped = 1;
                    }
                }
                `.replaceAll("#", i + "");
			}
		}
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `
                let wave# = 0;
                `.replaceAll("#", i + "");
		}
		chipSource += `let inputSample = 0;
            if (aliases) {
            `;
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `
                wave# = wave[Synth.wrap(Math.floor(phase#), waveLength)];
                
                prevWave# = wave#;
                const completionFade# = chipWaveCompletion# > 0 ? ((chipWaveCompletionFadeLength - Math.min(chipWaveCompletion#, chipWaveCompletionFadeLength)) / chipWaveCompletionFadeLength) : 1;
                if (chipWaveCompletion# > 0) {
                    inputSample += lastWave# * completionFade#;
                } else {
                    inputSample += wave#;
                }
                `.replaceAll("#", i + "");
		}
		chipSource += `} else {
            `;
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `
                const phase#Int = Math.floor(phase#);
                const index# = Synth.wrap(phase#Int, waveLength);
                let nextWaveIntegral# = wave[index#];
                const phaseRatio# = phase# - phase#Int;
                nextWaveIntegral# += (wave[Synth.wrap(index# + 1, waveLength)] - nextWaveIntegral#) * phaseRatio#;

                `.replaceAll("#", i + "");
		}
		if (!(chipWaveLoopMode === 0)) {
			chipSource += `if (!(chipWaveLoopStart === 0 && chipWaveLoopEnd === waveLength) && wrapped !== 0) {
                    `;
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `let pwi# = 0;
                    const phase#_ = Math.max(0, phase# - phaseDelta# * direction#);
                    const phase#Int = Math.floor(phase#_);
                    const index# = Synth.wrap(phase#Int, waveLength);
                    pwi# = wave[index#];
                    pwi# += (wave[Synth.wrap(index# + 1, waveLength)] - pwi#) * (phase#_ - phase#Int) * direction#;
                    prevWaveIntegral# = pwi#;
                `.replaceAll("#", i + "");
			}
			chipSource += "}";
		}
		if (chipWaveLoopMode === 1) {
			chipSource += `if (wrapped !== 0) {`;
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `wave# = prevWave#;
                    `.replaceAll("#", i + "");
			}
			chipSource += "} else {";
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `wave# = (nextWaveIntegral# - prevWaveIntegral#) / (phaseDelta# * direction#);
                    `.replaceAll("#", i + "");
			}
			chipSource += "}";
		}
		else {
			for (let i = 0; i < voiceCount; i++) {
				chipSource += `wave# = (nextWaveIntegral# - prevWaveIntegral#) / (phaseDelta# * direction#);
                    `.replaceAll("#", i + "");
			}
		}
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `prevWave# = wave#;
                prevWaveIntegral# = nextWaveIntegral#;
                const completionFade# = chipWaveCompletion# > 0 ? ((chipWaveCompletionFadeLength - Math.min(chipWaveCompletion#, chipWaveCompletionFadeLength)) / chipWaveCompletionFadeLength) : 1;
                if (chipWaveCompletion# > 0) {
                    inputSample += lastWave# * completionFade#;
                } else {
                    inputSample += wave#;
                }
                `.replaceAll("#", i + "");
		}
		chipSource += `}
            const sample = applyFilters(inputSample * volumeScale, initialFilterInput1, initialFilterInput2, filterCount, filters);
            initialFilterInput2 = initialFilterInput1;
            initialFilterInput1 = inputSample * volumeScale;
            const output = sample * expression;
             
            expression += expressionDelta;
            data[sampleIndex] += output;`;
		for (let i = 0; i < voiceCount; i++) {
			chipSource += ` phaseDelta# *= phaseDeltaScale#;
                    `.replaceAll("#", i + "");
		}
		chipSource += "}";
		for (let i = 0; i < voiceCount; i++) {
			chipSource += `tone.phases[#] = phase# / waveLength;
                tone.phaseDeltas[#] = phaseDelta# / waveLength;
                tone.directions[#] = direction#;
                tone.chipWaveCompletions[#] = chipWaveCompletion#;
                tone.chipWavePrevWaves[#] = prevWave#;
                tone.chipWaveCompletionsLastWave[#] = lastWave#;

                    `.replaceAll("#", i + "");
		}
		chipSource += `tone.expression = expression;
        synth.sanitizeFilters(filters);
        tone.initialNoteFilterInput1 = initialFilterInput1;
        tone.initialNoteFilterInput2 = initialFilterInput2;
        }`;
		chipFunction = new Function("Config", "Synth", "effectsIncludeDistortion", chipSource)(Config, Synth, effectsIncludeDistortion);
		Synth.loopableChipFunctionCache[instrumentState.unisonVoices][chipWaveLoopMode] = chipFunction;
	}
	//console.log(JSON.stringify(instrumentState))
	chipFunction(synth, bufferIndex, roundedSamplesPerTick, tone, instrumentState);
}
        
        
        static computeTone(synth, song, channelIndex, samplesPerTick, runLength, tone, released, shouldFadeOutFast) {
        	const roundedSamplesPerTick = Math.ceil(samplesPerTick);
const channel = song.channels[channelIndex];
  
const channelState = synth.channels[channelIndex];
const instrument = channel.instruments[tone.instrumentIndex];
const instrumentState = channelState.instruments[tone.instrumentIndex];
  
instrumentState.awake = true;
instrumentState.tonesAddedInThisTick = true;
if (!instrumentState.computed) {
	instrumentState.compute(this, instrument, samplesPerTick, roundedSamplesPerTick, tone, channelIndex, tone.instrumentIndex);
}
            
            const transition = instrument.getTransition();
            const chord = instrument.getChord();
            const chordExpression = chord.singleTone ? 1.0 : Synth.computeChordExpression(tone.chordSize);
            const isNoiseChannel = song.getChannelIsNoise(channelIndex);
            const intervalScale = isNoiseChannel ? Config.noiseInterval : 1;
            const secondsPerPart = Config.ticksPerPart * samplesPerTick / synth.samplesPerSecond;
            const sampleTime = 1.0 / synth.samplesPerSecond;
            const beatsPerPart = 1.0 / Config.partsPerBeat;
            const tickSampleCountdown = synth.tickSampleCountdown;
            const startRatio = 1.0 - (tickSampleCountdown) / samplesPerTick;
            const endRatio = 1.0 - (tickSampleCountdown - runLength) / samplesPerTick;
            const ticksIntoBar = synth.getTicksIntoBar();
            const partTimeTickStart = (ticksIntoBar) / Config.ticksPerPart;
            const partTimeTickEnd = (ticksIntoBar + 1) / Config.ticksPerPart;
            
            let fadeExpressionStart = 1.0;
let fadeExpressionEnd = 1.0;
            
            const partTimeStart = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * startRatio;
            const partTimeEnd = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * endRatio;
            const currentPart = synth.getCurrentPart();
            let specialIntervalMult = 1.0;
            tone.specialIntervalMult = 1.0;
            tone.specialIntervalExpressionMult = 1.0;
            let toneIsOnLastTick = shouldFadeOutFast;
            let intervalStart = 0.0;
            let intervalEnd = 0.0;
            let transitionExpressionStart = 1.0;
            let transitionExpressionEnd = 1.0;
            let chordExpressionStart = chordExpression;
            let chordExpressionEnd = chordExpression;
            let expressionReferencePitch = 16;
            let basePitch = Config.keys[song.key].basePitch;
            let baseExpression = 1.0;
            let pitchDamping = 48;
            if (instrument.type == 3) {
                baseExpression = Config.spectrumBaseExpression;
                if (isNoiseChannel) {
                    basePitch = Config.spectrumBasePitch;
                    baseExpression *= 2.0;
                }
                expressionReferencePitch = Config.spectrumBasePitch;
                pitchDamping = 28;
            }
            else if (instrument.type == 4) {
                basePitch = Config.spectrumBasePitch;
                baseExpression = Config.drumsetBaseExpression;
                expressionReferencePitch = basePitch;
            }
            else if (instrument.type == 2) {
                basePitch = Config.chipNoises[instrument.chipNoise].basePitch;
                baseExpression = Config.noiseBaseExpression;
                expressionReferencePitch = basePitch;
                pitchDamping = Config.chipNoises[instrument.chipNoise].isSoft ? 24.0 : 60.0;
            }
            else if (instrument.type == 1) {
                baseExpression = Config.fmBaseExpression;
            }
			else if (instrument.type == 8) {
                baseExpression = Config.fmBaseExpression;
            }
            else if (instrument.type == 0) {
              
              
if (
  instrument?.chipWave !== undefined &&
  typeof Config?.chipWaves === "object" &&
  instrument.chipWave in Config.chipWaves
) {
   

                baseExpression = Config.chipBaseExpression;
				if (Config.chipWaves[instrument.chipWave].isSampled == true && Config.chipWaves[instrument.chipWave].isPercussion == false) {
					basePitch = basePitch - 63 + Config.chipWaves[instrument.chipWave].extraSampleDetune
				}
				else if (Config.chipWaves[instrument.chipWave].isSampled == true && Config.chipWaves[instrument.chipWave].isPercussion == true) {
					basePitch = -51 + Config.chipWaves[instrument.chipWave].extraSampleDetune
				}
				
}
            }
			else if (instrument.type == 9) {
                baseExpression = Config.chipBaseExpression;
            }
            else if (instrument.type == 5) {
                baseExpression = Config.harmonicsBaseExpression;
            }
            else if (instrument.type == 6) {
                baseExpression = Config.pwmBaseExpression;
            }
            else if (instrument.type == 7) {
                baseExpression = Config.pickedStringBaseExpression;
            }
            else if (instrument.type == 9) {
                baseExpression = 1.0;
                expressionReferencePitch = 0;
                pitchDamping = 1.0;
                basePitch = 0;
            }
            else {
                throw new Error("Unknown instrument type in computeTone.");
            }
if ((tone.atNoteStart && !transition.isSeamless && !tone.forceContinueAtStart) || tone.freshlyAllocated) {
	tone.reset();
	
	instrumentState.envelopeComputer.reset();
	if (instrument.type == 0 && instrument.isUsingAdvancedLoopControls) {
		
		const chipWaveLength = Config.chipWaves[instrument.chipWave].samples.length - 1;
		const firstOffset = instrument.chipWaveStartOffset / chipWaveLength;
		const lastOffset = 0.999999999999999;
		 
		 
		for (let i = 0; i < Config.maxPitchOrOperatorCount; i++) {
			 
			tone.phases[i] = instrument.chipWavePlayBackwards ? Math.max(0, Math.min(lastOffset, firstOffset)) : Math.max(0, firstOffset);
			tone.directions[i] = instrument.chipWavePlayBackwards ? -1 : 1;
			tone.chipWaveCompletions[i] = 0;
			tone.chipWavePrevWaves[i] = 0;
			tone.chipWaveCompletionsLastWave[i] = 0;
		}
		
		
	}
}
 

            tone.freshlyAllocated = false;
            const maxWaves = Math.max(Config.maxChordSize, Config.operatorCount);
            for (let i = 0; i < maxWaves; i++) {
                tone.phaseDeltas[i] = 0.0;
                tone.expressionStarts[i] = 0.0;
                tone.expressionDeltas[i] = 0.0;
                tone.phaseDeltaScales[i] = 0.0;
            }
            
            if (released) {
                const startTicksSinceReleased = tone.ticksSinceReleased + startRatio;
                const endTicksSinceReleased = tone.ticksSinceReleased + endRatio;
                intervalStart = intervalEnd = tone.lastInterval;
                const fadeOutTicks = Math.abs(instrument.getFadeOutTicks());
                transitionExpressionStart = Synth.noteSizeToVolumeMult((1.0 - startTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax);
                transitionExpressionEnd = Synth.noteSizeToVolumeMult((1.0 - endTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax);
                if (shouldFadeOutFast) {
                    transitionExpressionStart *= 1.0 - startRatio;
                    transitionExpressionEnd *= 1.0 - endRatio;
                }
                if (tone.ticksSinceReleased + 1 >= fadeOutTicks)
                    toneIsOnLastTick = true;
            }
            else if (tone.note == null) {
                transitionExpressionStart = transitionExpressionEnd = 1;
                tone.lastInterval = 0;
                tone.ticksSinceReleased = 0;
                tone.liveInputSamplesHeld += runLength;
            }
            else {
                const note = tone.note;
                const nextNote = tone.nextNote;
                const noteStartPart = tone.noteStartPart;
                const noteEndPart = tone.noteEndPart;
                const endPinIndex = note.getEndPinIndex(currentPart);
                const startPin = note.pins[endPinIndex - 1];
                const endPin = note.pins[endPinIndex];
                const noteStartTick = noteStartPart * Config.ticksPerPart;
                const noteEndTick = noteEndPart * Config.ticksPerPart;
                const pinStart = (note.start + startPin.time) * Config.ticksPerPart;
                const pinEnd = (note.start + endPin.time) * Config.ticksPerPart;
                tone.ticksSinceReleased = 0;
                const tickTimeStart = currentPart * Config.ticksPerPart + synth.tick;
                const tickTimeEnd = currentPart * Config.ticksPerPart + synth.tick + 1;
                const noteTicksPassedTickStart = tickTimeStart - noteStartTick;
                const noteTicksPassedTickEnd = tickTimeEnd - noteStartTick;
                const pinRatioStart = Math.min(1.0, (tickTimeStart - pinStart) / (pinEnd - pinStart));
                const pinRatioEnd = Math.min(1.0, (tickTimeEnd - pinStart) / (pinEnd - pinStart));
                let transitionExpressionTickStart = 1.0;
                let transitionExpressionTickEnd = 1.0;
                let intervalTickStart = startPin.interval + (endPin.interval - startPin.interval) * pinRatioStart;
                let intervalTickEnd = startPin.interval + (endPin.interval - startPin.interval) * pinRatioEnd;
                tone.lastInterval = intervalTickEnd;
                if ((!transition.isSeamless && !tone.forceContinueAtEnd) || nextNote == null) {
                    const fadeOutTicks = -instrument.getFadeOutTicks();
                    if (fadeOutTicks > 0.0) {
                        const noteLengthTicks = noteEndTick - noteStartTick;
                        transitionExpressionTickStart *= Math.min(1.0, (noteLengthTicks - noteTicksPassedTickStart) / fadeOutTicks);
                        transitionExpressionTickEnd *= Math.min(1.0, (noteLengthTicks - noteTicksPassedTickEnd) / fadeOutTicks);
                        if (tickTimeEnd >= noteStartTick + noteLengthTicks)
                            toneIsOnLastTick = true;
                    }
                }
                intervalStart = intervalTickStart + (intervalTickEnd - intervalTickStart) * startRatio;
                intervalEnd = intervalTickStart + (intervalTickEnd - intervalTickStart) * endRatio;
                transitionExpressionStart = transitionExpressionTickStart + (transitionExpressionTickEnd - transitionExpressionTickStart) * startRatio;
                transitionExpressionEnd = transitionExpressionTickStart + (transitionExpressionTickEnd - transitionExpressionTickStart) * endRatio;
            }
            tone.isOnLastTick = toneIsOnLastTick;
            let tmpNoteFilter = instrument.noteFilter;
            let startPoint;
            let endPoint;
            if (instrument.noteFilterType) {
                const noteFilterSettingsStart = instrument.noteFilter;
                if (instrument.noteSubFilters[1] == null)
                    instrument.noteSubFilters[1] = new FilterSettings();
                const noteFilterSettingsEnd = instrument.noteSubFilters[1];
                let startSimpleFreq = instrument.noteFilterSimpleCut;
                let startSimpleGain = instrument.noteFilterSimplePeak;
                let endSimpleFreq = instrument.noteFilterSimpleCut;
                let endSimpleGain = instrument.noteFilterSimplePeak;
                let filterChanges = false;
                if (synth.isModActive(Config.modulators.dictionary["note filt cut"].index, channelIndex, tone.instrumentIndex)) {
                    startSimpleFreq = synth.getModValue(Config.modulators.dictionary["note filt cut"].index, channelIndex, tone.instrumentIndex, false);
                    endSimpleFreq = synth.getModValue(Config.modulators.dictionary["note filt cut"].index, channelIndex, tone.instrumentIndex, true);
                    filterChanges = true;
                }
                if (synth.isModActive(Config.modulators.dictionary["note filt peak"].index, channelIndex, tone.instrumentIndex)) {
                    startSimpleGain = synth.getModValue(Config.modulators.dictionary["note filt peak"].index, channelIndex, tone.instrumentIndex, false);
                    endSimpleGain = synth.getModValue(Config.modulators.dictionary["note filt peak"].index, channelIndex, tone.instrumentIndex, true);
                    filterChanges = true;
                }
                noteFilterSettingsStart.convertLegacySettingsForSynth(startSimpleFreq, startSimpleGain, !filterChanges);
                noteFilterSettingsEnd.convertLegacySettingsForSynth(endSimpleFreq, endSimpleGain, !filterChanges);
                startPoint = noteFilterSettingsStart.controlPoints[0];
                endPoint = noteFilterSettingsEnd.controlPoints[0];
                instrument.noteFilter = noteFilterSettingsStart;
                instrument.tmpNoteFilterStart = noteFilterSettingsStart;
            }
            const envelopeComputer = tone.envelopeComputer;
            envelopeComputer.computeEnvelopes(instrument, currentPart, Config.ticksPerPart * partTimeStart, Config.ticksPerPart * partTimeEnd, secondsPerPart * (partTimeEnd - partTimeStart), tone);
            const envelopeStarts = tone.envelopeComputer.envelopeStarts;
            const envelopeEnds = tone.envelopeComputer.envelopeEnds;
            instrument.noteFilter = tmpNoteFilter;
            if (tone.note != null && transition.slides) {
                const prevNote = tone.prevNote;
                const nextNote = tone.nextNote;
                if (prevNote != null) {
                    const intervalDiff = prevNote.pitches[tone.prevNotePitchIndex] + prevNote.pins[prevNote.pins.length - 1].interval - tone.pitches[0];
                    if (envelopeComputer.prevSlideStart)
                        intervalStart += intervalDiff * envelopeComputer.prevSlideRatioStart;
                    if (envelopeComputer.prevSlideEnd)
                        intervalEnd += intervalDiff * envelopeComputer.prevSlideRatioEnd;
                    if (!chord.singleTone) {
                        const chordSizeDiff = prevNote.pitches.length - tone.chordSize;
                        if (envelopeComputer.prevSlideStart)
                            chordExpressionStart = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.prevSlideRatioStart);
                        if (envelopeComputer.prevSlideEnd)
                            chordExpressionEnd = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.prevSlideRatioEnd);
                    }
                }
                if (nextNote != null) {
                    const intervalDiff = nextNote.pitches[tone.nextNotePitchIndex] - (tone.pitches[0] + tone.note.pins[tone.note.pins.length - 1].interval);
                    if (envelopeComputer.nextSlideStart)
                        intervalStart += intervalDiff * envelopeComputer.nextSlideRatioStart;
                    if (envelopeComputer.nextSlideEnd)
                        intervalEnd += intervalDiff * envelopeComputer.nextSlideRatioEnd;
                    if (!chord.singleTone) {
                        const chordSizeDiff = nextNote.pitches.length - tone.chordSize;
                        if (envelopeComputer.nextSlideStart)
                            chordExpressionStart = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.nextSlideRatioStart);
                        if (envelopeComputer.nextSlideEnd)
                            chordExpressionEnd = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.nextSlideRatioEnd);
                    }
                }
            }
            
            
            if (  synth.isModActive(Config.modulators.dictionary["song limitratio"].index, channelIndex, tone.instrumentIndex)) {
            	   
            doc.song.limitRatio=((synth.getModValue(Config.modulators.dictionary["song limitratio"].index, channelIndex, tone.instrumentIndex, false)+255)/5)-1
            	 ;
            }
           if (  synth.isModActive(Config.modulators.dictionary["song mastergain"].index, channelIndex, tone.instrumentIndex)) {
            	   
            doc.song.masterGain=((synth.getModValue(Config.modulators.dictionary["song mastergain"].index, channelIndex, tone.instrumentIndex, false)+255)/5)-1
            	 ;
            }
            
            if (effectsIncludePitchShift(instrument.effects)) {
                let pitchShift = Config.justIntonationSemitones[instrument.pitchShift] / intervalScale;
                let pitchShiftScalarStart = 1.0;
                let pitchShiftScalarEnd = 1.0;
                if (synth.isModActive(Config.modulators.dictionary["pitch shift"].index, channelIndex, tone.instrumentIndex)) {
                    pitchShift = Config.justIntonationSemitones[Config.justIntonationSemitones.length - 1];
                    pitchShiftScalarStart = (synth.getModValue(Config.modulators.dictionary["pitch shift"].index, channelIndex, tone.instrumentIndex, false)) / (Config.pitchShiftCenter);
                    pitchShiftScalarEnd = (synth.getModValue(Config.modulators.dictionary["pitch shift"].index, channelIndex, tone.instrumentIndex, true)) / (Config.pitchShiftCenter);
                }
                const envelopeStart = envelopeStarts[14];
                
                const envelopeEnd = envelopeEnds[14];
                intervalStart += pitchShift * envelopeStart * pitchShiftScalarStart;
                intervalEnd += pitchShift * envelopeEnd * pitchShiftScalarEnd;
            }
            if (effectsIncludeDetune(instrument.effects) || synth.isModActive(Config.modulators.dictionary["song detune"].index, channelIndex, tone.instrumentIndex)) {
                const envelopeStart = envelopeStarts[15];
                const envelopeEnd = envelopeEnds[15];
                let modDetuneStart = instrument.detune;
                let modDetuneEnd = instrument.detune;
                if (synth.isModActive(Config.modulators.dictionary["detune"].index, channelIndex, tone.instrumentIndex)) {
                    modDetuneStart = synth.getModValue(Config.modulators.dictionary["detune"].index, channelIndex, tone.instrumentIndex, false) + Config.detuneCenter;
                    modDetuneEnd = synth.getModValue(Config.modulators.dictionary["detune"].index, channelIndex, tone.instrumentIndex, true) + Config.detuneCenter;
                }
                if (synth.isModActive(Config.modulators.dictionary["song detune"].index, channelIndex, tone.instrumentIndex)) {
                    modDetuneStart += 4 * synth.getModValue(Config.modulators.dictionary["song detune"].index, channelIndex, tone.instrumentIndex, false);
                    modDetuneEnd += 4 * synth.getModValue(Config.modulators.dictionary["song detune"].index, channelIndex, tone.instrumentIndex, true);
                }
                intervalStart += Synth.detuneToCents((modDetuneStart) * envelopeStart) * Config.pitchesPerOctave / (12.0 * 100.0);
                intervalEnd += Synth.detuneToCents((modDetuneEnd) * envelopeEnd) * Config.pitchesPerOctave / (12.0 * 100.0);
            }
            if (effectsIncludeVibrato(instrument.effects)) {
                let delayTicks;
                let vibratoAmplitudeStart;
                let vibratoAmplitudeEnd;
                if (instrument.vibrato == Config.vibratos.length) {
                    delayTicks = instrument.vibratoDelay * 2;
                    if (instrument.vibratoDelay == Config.modulators.dictionary["vibrato delay"].maxRawVol)
                        delayTicks = Number.POSITIVE_INFINITY;
                    vibratoAmplitudeStart = instrument.vibratoDepth;
                    vibratoAmplitudeEnd = vibratoAmplitudeStart;
                }
                else {
                    delayTicks = Config.vibratos[instrument.vibrato].delayTicks;
                    vibratoAmplitudeStart = Config.vibratos[instrument.vibrato].amplitude;
                    vibratoAmplitudeEnd = vibratoAmplitudeStart;
                }
                if (synth.isModActive(Config.modulators.dictionary["vibrato delay"].index, channelIndex, tone.instrumentIndex)) {
                    delayTicks = synth.getModValue(Config.modulators.dictionary["vibrato delay"].index, channelIndex, tone.instrumentIndex, false) * 2;
                    if (delayTicks == Config.modulators.dictionary["vibrato delay"].maxRawVol * 2)
                        delayTicks = Number.POSITIVE_INFINITY;
                }
                if (synth.isModActive(Config.modulators.dictionary["vibrato depth"].index, channelIndex, tone.instrumentIndex)) {
                    vibratoAmplitudeStart = synth.getModValue(Config.modulators.dictionary["vibrato depth"].index, channelIndex, tone.instrumentIndex, false) / 25;
                    vibratoAmplitudeEnd = synth.getModValue(Config.modulators.dictionary["vibrato depth"].index, channelIndex, tone.instrumentIndex, true) / 25;
                }
                let vibratoStart;
                if (tone.prevVibrato != null) {
                    vibratoStart = tone.prevVibrato;
                }
                else {
                    let lfoStart = Synth.getLFOAmplitude(instrument, secondsPerPart * instrument.LFOtime);
                    const vibratoDepthEnvelopeStart = envelopeStarts[16];
                    vibratoStart = vibratoAmplitudeStart * lfoStart * vibratoDepthEnvelopeStart;
                    if (delayTicks > 0.0) {
                        const ticksUntilVibratoStart = delayTicks - envelopeComputer.noteTicksStart;
                        vibratoStart *= Math.max(0.0, Math.min(1.0, 1.0 - ticksUntilVibratoStart / 2.0));
                    }
                }
                let lfoEnd = Synth.getLFOAmplitude(instrument, secondsPerPart * instrument.nextLFOtime);
                const vibratoDepthEnvelopeEnd = envelopeEnds[16];
                if (instrument.type != 9) {
                    let vibratoEnd = vibratoAmplitudeEnd * lfoEnd * vibratoDepthEnvelopeEnd;
                    if (delayTicks > 0.0) {
                        const ticksUntilVibratoEnd = delayTicks - envelopeComputer.noteTicksEnd;
                        vibratoEnd *= Math.max(0.0, Math.min(1.0, 1.0 - ticksUntilVibratoEnd / 2.0));
                    }
                    tone.prevVibrato = vibratoEnd;
                    intervalStart += vibratoStart;
                    intervalEnd += vibratoEnd;
                }
            }
            if ((!transition.isSeamless && !tone.forceContinueAtStart) || tone.prevNote == null) {
                const fadeInSeconds = instrument.getFadeInSeconds();
                if (fadeInSeconds > 0.0) {
                    transitionExpressionStart *= Math.min(1.0, envelopeComputer.noteSecondsStart / fadeInSeconds);
                    transitionExpressionEnd *= Math.min(1.0, envelopeComputer.noteSecondsEnd / fadeInSeconds);
                }
            }
            if (instrument.type == 4 && tone.drumsetPitch == null) {
                tone.drumsetPitch = tone.pitches[0];
                if (tone.note != null)
                    tone.drumsetPitch += tone.note.pickMainInterval();
                tone.drumsetPitch = Math.max(0, Math.min(Config.drumCount - 1, tone.drumsetPitch));
            }
            let noteFilterExpression = envelopeComputer.lowpassCutoffDecayVolumeCompensation;
            if (!effectsIncludeNoteFilter(instrument.effects)) {
                tone.noteFilterCount = 0;
            }
            else {
                const noteAllFreqsEnvelopeStart = envelopeStarts[1];
                const noteAllFreqsEnvelopeEnd = envelopeEnds[1];
                if (instrument.noteFilterType) {
                    const noteFreqEnvelopeStart = envelopeStarts[17];
                    const noteFreqEnvelopeEnd = envelopeEnds[17];
                    const notePeakEnvelopeStart = envelopeStarts[25];
                    const notePeakEnvelopeEnd = envelopeEnds[25];
                    startPoint.toCoefficients(Synth.tempFilterStartCoefficients, synth.samplesPerSecond, noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart, notePeakEnvelopeStart);
                    endPoint.toCoefficients(Synth.tempFilterEndCoefficients, synth.samplesPerSecond, noteAllFreqsEnvelopeEnd * noteFreqEnvelopeEnd, notePeakEnvelopeEnd);
                    if (tone.noteFilters.length < 1)
                        tone.noteFilters[0] = new DynamicBiquadFilter();
                    tone.noteFilters[0].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / runLength, startPoint.type == 0);
                    noteFilterExpression *= startPoint.getVolumeCompensationMult();
                    tone.noteFilterCount = 1;
                }
                else {
                    const noteFilterSettings = (instrument.tmpNoteFilterStart != null) ? instrument.tmpNoteFilterStart : instrument.noteFilter;
                    for (let i = 0; i < noteFilterSettings.controlPointCount; i++) {
                        const noteFreqEnvelopeStart = envelopeStarts[17 + i];
                        const noteFreqEnvelopeEnd = envelopeEnds[17 + i];
                        const notePeakEnvelopeStart = envelopeStarts[25 + i];
                        const notePeakEnvelopeEnd = envelopeEnds[25 + i];
                        const startPoint = noteFilterSettings.controlPoints[i];
                        const endPoint = (instrument.tmpNoteFilterEnd != null && instrument.tmpNoteFilterEnd.controlPoints[i] != null) ? instrument.tmpNoteFilterEnd.controlPoints[i] : noteFilterSettings.controlPoints[i];
                        startPoint.toCoefficients(Synth.tempFilterStartCoefficients, synth.samplesPerSecond, noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart, notePeakEnvelopeStart);
                        endPoint.toCoefficients(Synth.tempFilterEndCoefficients, synth.samplesPerSecond, noteAllFreqsEnvelopeEnd * noteFreqEnvelopeEnd, notePeakEnvelopeEnd);
                        if (tone.noteFilters.length <= i)
                            tone.noteFilters[i] = new DynamicBiquadFilter();
                        tone.noteFilters[i].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / runLength, startPoint.type == 0);
                        noteFilterExpression *= startPoint.getVolumeCompensationMult();
                    }
                    tone.noteFilterCount = noteFilterSettings.controlPointCount;
                }
            }
            if (instrument.type == 4) {
                const drumsetFilterEnvelope = instrument.getDrumsetEnvelope(tone.drumsetPitch);
                noteFilterExpression *= EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(drumsetFilterEnvelope);
                let drumsetFilterEnvelopeStart = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.noteSecondsStart, beatsPerPart * partTimeStart, envelopeComputer.noteSizeStart);
                let drumsetFilterEnvelopeEnd = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.noteSecondsEnd, beatsPerPart * partTimeEnd, envelopeComputer.noteSizeEnd);
                if (envelopeComputer.prevSlideStart) {
                    const other = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.prevNoteSecondsStart, beatsPerPart * partTimeStart, envelopeComputer.prevNoteSize);
                    drumsetFilterEnvelopeStart += (other - drumsetFilterEnvelopeStart) * envelopeComputer.prevSlideRatioStart;
                }
                if (envelopeComputer.prevSlideEnd) {
                    const other = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.prevNoteSecondsEnd, beatsPerPart * partTimeEnd, envelopeComputer.prevNoteSize);
                    drumsetFilterEnvelopeEnd += (other - drumsetFilterEnvelopeEnd) * envelopeComputer.prevSlideRatioEnd;
                }
                if (envelopeComputer.nextSlideStart) {
                    const other = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, 0.0, beatsPerPart * partTimeStart, envelopeComputer.nextNoteSize);
                    drumsetFilterEnvelopeStart += (other - drumsetFilterEnvelopeStart) * envelopeComputer.nextSlideRatioStart;
                }
                if (envelopeComputer.nextSlideEnd) {
                    const other = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, 0.0, beatsPerPart * partTimeEnd, envelopeComputer.nextNoteSize);
                    drumsetFilterEnvelopeEnd += (other - drumsetFilterEnvelopeEnd) * envelopeComputer.nextSlideRatioEnd;
                }
                const point = synth.tempDrumSetControlPoint;
                point.type = 0;
                point.gain = FilterControlPoint.getRoundedSettingValueFromLinearGain(0.5);
                point.freq = FilterControlPoint.getRoundedSettingValueFromHz(8000.0);
                point.toCoefficients(Synth.tempFilterStartCoefficients, synth.samplesPerSecond, drumsetFilterEnvelopeStart * (1.0 + drumsetFilterEnvelopeStart), 1.0);
                point.toCoefficients(Synth.tempFilterEndCoefficients, synth.samplesPerSecond, drumsetFilterEnvelopeEnd * (1.0 + drumsetFilterEnvelopeEnd), 1.0);
                if (tone.noteFilters.length == tone.noteFilterCount)
                    tone.noteFilters[tone.noteFilterCount] = new DynamicBiquadFilter();
                tone.noteFilters[tone.noteFilterCount].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / runLength, true);
                tone.noteFilterCount++;
            }
            noteFilterExpression = Math.min(3.0, noteFilterExpression);
            if (instrument.type == 1) {
                let sineExpressionBoost = 1.0;
                let totalCarrierExpression = 0.0;
                let arpeggioInterval = 0;
                const arpeggiates = chord.arpeggiates;
                if (tone.pitchCount > 1 && arpeggiates) {
                    const arpeggio = Math.floor(instrument.arpTime / Config.ticksPerArpeggio);
                    arpeggioInterval = tone.pitches[getArpeggioPitchIndex(tone.pitchCount, instrument.fastTwoNoteArp, arpeggio)] - tone.pitches[0];
                }
                const carrierCount = Config.algorithms[instrument.algorithm].carrierCount;
                for (let i = 0; i < Config.operatorCount; i++) {
                    const associatedCarrierIndex = Config.algorithms[instrument.algorithm].associatedCarrier[i] - 1;
                    const pitch = tone.pitches[arpeggiates ? 0 : ((i < tone.pitchCount) ? i : ((associatedCarrierIndex < tone.pitchCount) ? associatedCarrierIndex : 0))];
                    const freqMult = Config.operatorFrequencies[instrument.operators[i].frequency].mult;
                    const interval = Config.operatorCarrierInterval[associatedCarrierIndex] + arpeggioInterval;
                    const pitchStart = basePitch + (pitch + intervalStart) * intervalScale + interval;
                    const pitchEnd = basePitch + (pitch + intervalEnd) * intervalScale + interval;
                    const baseFreqStart = Instrument.frequencyFromPitch(pitchStart);
                    const baseFreqEnd = Instrument.frequencyFromPitch(pitchEnd);
                    const hzOffset = Config.operatorFrequencies[instrument.operators[i].frequency].hzOffset;
                    const targetFreqStart = freqMult * baseFreqStart + hzOffset;
                    const targetFreqEnd = freqMult * baseFreqEnd + hzOffset;
                    const freqEnvelopeStart = envelopeStarts[5 + i];
                    const freqEnvelopeEnd = envelopeEnds[5 + i];
                    let freqStart;
                    let freqEnd;
                    if (freqEnvelopeStart != 1.0 || freqEnvelopeEnd != 1.0) {
                        freqStart = Math.pow(2.0, Math.log2(targetFreqStart / baseFreqStart) * freqEnvelopeStart) * baseFreqStart;
                        freqEnd = Math.pow(2.0, Math.log2(targetFreqEnd / baseFreqEnd) * freqEnvelopeEnd) * baseFreqEnd;
                    }
                    else {
                        freqStart = targetFreqStart;
                        freqEnd = targetFreqEnd;
                    }
                    tone.phaseDeltas[i] = freqStart * sampleTime * Config.sineWaveLength;
                    tone.phaseDeltaScales[i] = Math.pow(freqEnd / freqStart, 1.0 / runLength);
                    let amplitudeStart = instrument.operators[i].amplitude;
                    let amplitudeEnd = instrument.operators[i].amplitude;
                    if (synth.isModActive(Config.modulators.dictionary["fm slider 1"].index + i, channelIndex, tone.instrumentIndex)) {
                        amplitudeStart *= synth.getModValue(Config.modulators.dictionary["fm slider 1"].index + i, channelIndex, tone.instrumentIndex, false) / 15.0;
                        amplitudeEnd *= synth.getModValue(Config.modulators.dictionary["fm slider 1"].index + i, channelIndex, tone.instrumentIndex, true) / 15.0;
                    }
                    const amplitudeCurveStart = Synth.operatorAmplitudeCurve(amplitudeStart);
                    const amplitudeCurveEnd = Synth.operatorAmplitudeCurve(amplitudeEnd);
                    const amplitudeMultStart = amplitudeCurveStart * Config.operatorFrequencies[instrument.operators[i].frequency].amplitudeSign;
                    const amplitudeMultEnd = amplitudeCurveEnd * Config.operatorFrequencies[instrument.operators[i].frequency].amplitudeSign;
                    let expressionStart = amplitudeMultStart;
                    let expressionEnd = amplitudeMultEnd;
                    if (i < carrierCount) {
                        const pitchExpressionStart = Math.pow(2.0, -(pitchStart - expressionReferencePitch) / pitchDamping);
                        const pitchExpressionEnd = Math.pow(2.0, -(pitchEnd - expressionReferencePitch) / pitchDamping);
                        expressionStart *= baseExpression * pitchExpressionStart * transitionExpressionStart * noteFilterExpression * chordExpressionStart;
                        expressionEnd *= baseExpression * pitchExpressionEnd * transitionExpressionEnd * noteFilterExpression * chordExpressionEnd;
                        expressionStart *= envelopeStarts[0];
                        expressionEnd *= envelopeEnds[0];
                        totalCarrierExpression += amplitudeCurveEnd;
                    }
                    else {
                        expressionStart *= Config.sineWaveLength * 1.5;
                        expressionEnd *= Config.sineWaveLength * 1.5;
                        sineExpressionBoost *= 1.0 - Math.min(1.0, instrument.operators[i].amplitude / 15);
                    }
                    expressionStart *= envelopeStarts[9 + i];
                    expressionEnd *= envelopeEnds[9 + i];
                    if (synth.isModActive(Config.modulators.dictionary["volume"].index, channelIndex, tone.instrumentIndex)) {
                        const startVal = synth.getModValue(Config.modulators.dictionary["volume"].index, channelIndex, tone.instrumentIndex, false);
                        const endVal = synth.getModValue(Config.modulators.dictionary["volume"].index, channelIndex, tone.instrumentIndex, true);
                        expressionStart *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(startVal));
                        expressionEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(endVal));
                    }
 if (synth.isModActive(Config.modulators.dictionary["extra volume"].index, channelIndex, tone.instrumentIndex)) {
	const startVal = synth.getModValue(Config.modulators.dictionary["extra volume"].index, channelIndex, tone.instrumentIndex, false);
	const endVal = synth.getModValue(Config.modulators.dictionary["extra volume"].index, channelIndex, tone.instrumentIndex, true);
	
	expressionStart *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(startVal));
	expressionEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(endVal));
}
                    if (synth.isModActive(Config.modulators.dictionary["song volume"].index)) {
                        expressionStart *= (synth.getModValue(Config.modulators.dictionary["song volume"].index, undefined, undefined, false)) / 100.0;
                        expressionEnd *= (synth.getModValue(Config.modulators.dictionary["song volume"].index, undefined, undefined, true)) / 100.0;
                    }
                    tone.expressionStarts[i] = expressionStart;
                    tone.expressionDeltas[i] = (expressionEnd - expressionStart) / runLength;
                }
                sineExpressionBoost *= (Math.pow(2.0, (2.0 - 1.4 * instrument.feedbackAmplitude / 15.0)) - 1.0) / 3.0;
                sineExpressionBoost *= 1.0 - Math.min(1.0, Math.max(0.0, totalCarrierExpression - 1) / 2.0);
                sineExpressionBoost = 1.0 + sineExpressionBoost * 3.0;
                for (let i = 0; i < carrierCount; i++) {
                    tone.expressionStarts[i] *= sineExpressionBoost;
                    tone.expressionDeltas[i] *= sineExpressionBoost;
                }
                let useFeedbackAmplitudeStart = instrument.feedbackAmplitude;
                let useFeedbackAmplitudeEnd = instrument.feedbackAmplitude;
                if (synth.isModActive(Config.modulators.dictionary["fm feedback"].index, channelIndex, tone.instrumentIndex)) {
                    useFeedbackAmplitudeStart *= synth.getModValue(Config.modulators.dictionary["fm feedback"].index, channelIndex, tone.instrumentIndex, false) / 15.0;
                    useFeedbackAmplitudeEnd *= synth.getModValue(Config.modulators.dictionary["fm feedback"].index, channelIndex, tone.instrumentIndex, true) / 15.0;
                }
                let feedbackAmplitudeStart = Config.sineWaveLength * 0.3 * useFeedbackAmplitudeStart / 15.0;
                const feedbackAmplitudeEnd = Config.sineWaveLength * 0.3 * useFeedbackAmplitudeEnd / 15.0;
                let feedbackStart = feedbackAmplitudeStart * envelopeStarts[13];
                let feedbackEnd = feedbackAmplitudeEnd * envelopeEnds[13];
                tone.feedbackMult = feedbackStart;
                tone.feedbackDelta = (feedbackEnd - tone.feedbackMult) / runLength;
            }
            else {
                const basePhaseDeltaScale = Math.pow(2.0, ((intervalEnd - intervalStart) * intervalScale / 12.0) / runLength);
                let pitch = tone.pitches[0];
                if (tone.pitchCount > 1 && (chord.arpeggiates || chord.customInterval)) {
                    const arpeggio = Math.floor(instrument.arpTime / Config.ticksPerArpeggio);
                    if (chord.customInterval) {
                        const intervalOffset = tone.pitches[1 + getArpeggioPitchIndex(tone.pitchCount - 1, instrument.fastTwoNoteArp, arpeggio)] - tone.pitches[0];
                        tone.specialIntervalMult = Math.pow(2.0, intervalOffset / 12.0);
                        tone.specialIntervalExpressionMult = Math.pow(2.0, -intervalOffset / pitchDamping);
                    }
                    else {
                        pitch = tone.pitches[getArpeggioPitchIndex(tone.pitchCount, instrument.fastTwoNoteArp, arpeggio)];
                    }
                }
                const startPitch = basePitch + (pitch + intervalStart) * intervalScale;
                const endPitch = basePitch + (pitch + intervalEnd) * intervalScale;
                let pitchExpressionStart = Math.pow(2.0, -(startPitch - expressionReferencePitch) / pitchDamping);
                let pitchExpressionEnd = Math.pow(2.0, -(endPitch - expressionReferencePitch) / pitchDamping);
                let settingsExpressionMult = baseExpression * noteFilterExpression;
                if (instrument.type == 2) {
                    settingsExpressionMult *= Config.chipNoises[instrument.chipNoise].expression;
                }
                if (instrument.type == 0) {
                    settingsExpressionMult *= Config.chipWaves[instrument.chipWave].expression;
                }
                if (instrument.type == 6) {
                    const basePulseWidth = getPulseWidthRatio(instrument.pulseWidth);
                    let pulseWidthModStart = basePulseWidth;
                    let pulseWidthModEnd = basePulseWidth;
                    if (synth.isModActive(Config.modulators.dictionary["pulse width"].index, channelIndex, tone.instrumentIndex)) {
                        pulseWidthModStart = (synth.getModValue(Config.modulators.dictionary["pulse width"].index, channelIndex, tone.instrumentIndex, false)) / (Config.pulseWidthRange * 2);
                        pulseWidthModEnd = (synth.getModValue(Config.modulators.dictionary["pulse width"].index, channelIndex, tone.instrumentIndex, true)) / (Config.pulseWidthRange * 2);
                    }
                    const pulseWidthStart = pulseWidthModStart * envelopeStarts[2];
                    const pulseWidthEnd = pulseWidthModEnd * envelopeEnds[2];
                    tone.pulseWidth = pulseWidthStart;
                    tone.pulseWidthDelta = (pulseWidthEnd - pulseWidthStart) / runLength;
                }
                if (instrument.type == 7) {
                    let useSustainStart = instrument.stringSustain;
                    let useSustainEnd = instrument.stringSustain;
                    if (synth.isModActive(Config.modulators.dictionary["sustain"].index, channelIndex, tone.instrumentIndex)) {
                        useSustainStart = synth.getModValue(Config.modulators.dictionary["sustain"].index, channelIndex, tone.instrumentIndex, false);
                        useSustainEnd = synth.getModValue(Config.modulators.dictionary["sustain"].index, channelIndex, tone.instrumentIndex, false);
                    }
                    tone.stringSustainStart = useSustainStart;
                    tone.stringSustainEnd = useSustainEnd;
                    settingsExpressionMult *= Math.pow(2.0, 0.7 * (1.0 - useSustainStart / (Config.stringSustainRange - 1)));
                    const unison = Config.unisons[instrument.unison];
                    const unisonVoices = instrument.unisonVoices;
                    for (let i = tone.pickedStrings.length; i < instrument.unisonVoices; i++) {
                        tone.pickedStrings[i] = new PickedString();
                    }
                    if (tone.atNoteStart && !transition.continues && !tone.forceContinueAtStart) {
                        for (const pickedString of tone.pickedStrings) {
                            pickedString.delayIndex = -1;
                        }
                    }
                }
                const startFreq = Instrument.frequencyFromPitch(startPitch);
                if (instrument.type == 0 || instrument.type == 8 || instrument.type == 5|| instrument.type == 7|| instrument.type == 6 /*pulse width*/) {
                /*    const unison = Config.unisons[instrument.unison];
                    const voiceCountExpression = (instrument.type == 7) ? 1 : unison.voices / 2.0;
                    settingsExpressionMult *= unison.expression * voiceCountExpression;
                    const unisonEnvelopeStart = envelopeStarts[4];
                    const unisonEnvelopeEnd = envelopeEnds[4];
                    const unisonAStart = Math.pow(2.0, (unison.offset + unison.spread) * unisonEnvelopeStart / 12.0);
                    const unisonAEnd = Math.pow(2.0, (unison.offset + unison.spread) * unisonEnvelopeEnd / 12.0);
                    const unisonBStart = Math.pow(2.0, (unison.offset - unison.spread) * unisonEnvelopeStart / 12.0) * tone.specialIntervalMult;
                    const unisonBEnd = Math.pow(2.0, (unison.offset - unison.spread) * unisonEnvelopeEnd / 12.0) * tone.specialIntervalMult;
                    tone.phaseDeltas[0] = startFreq * sampleTime * unisonAStart;
                    tone.phaseDeltas[1] = startFreq * sampleTime * unisonBStart;
                    tone.phaseDeltaScales[0] = basePhaseDeltaScale * Math.pow(unisonAEnd / unisonAStart, 1.0 / runLength);
                    tone.phaseDeltaScales[1] = basePhaseDeltaScale * Math.pow(unisonBEnd / unisonBStart, 1.0 / runLength);*/
                    
const startFreq = Instrument.frequencyFromPitch(startPitch);
if (instrument.type == 0 || instrument.type == 9 || instrument.type == 5 || instrument.type == 7 || instrument.type == 8 || instrument.type == 3 || instrument.type == 6 || instrument.type == 2) {
	const unisonVoices = instrument.unisonVoices;
	const unisonSpread = instrument.unisonSpread;
	const unisonOffset = instrument.unisonOffset;
	const unisonExpression = instrument.unisonExpression;
	const voiceCountExpression = (instrument.type == 7) ? 1 : unisonVoices / 2.0;
	settingsExpressionMult *= unisonExpression * voiceCountExpression;
	const unisonEnvelopeStart = envelopeStarts[4];
	const unisonEnvelopeEnd = envelopeEnds[4];
	const unisonAStart = Math.pow(2.0, (unisonOffset + unisonSpread) * unisonEnvelopeStart / 12.0);
	const unisonAEnd = Math.pow(2.0, (unisonOffset + unisonSpread) * unisonEnvelopeEnd / 12.0);
	const unisonBStart = Math.pow(2.0, (unisonOffset - unisonSpread) * unisonEnvelopeStart / 12.0) * specialIntervalMult;
	const unisonBEnd = Math.pow(2.0, (unisonOffset - unisonSpread) * unisonEnvelopeEnd / 12.0) * specialIntervalMult;
	tone.phaseDeltas[0] = startFreq * sampleTime * unisonAStart;
	tone.phaseDeltas[1] = startFreq * sampleTime * unisonBStart;
	tone.phaseDeltaScales[0] = basePhaseDeltaScale * Math.pow(unisonAEnd / unisonAStart, 1.0 / runLength);
	tone.phaseDeltaScales[1] = basePhaseDeltaScale * Math.pow(unisonBEnd / unisonBStart, 1.0 / runLength);
}
else {
	tone.phaseDeltas[0] = startFreq * sampleTime;
	tone.phaseDeltaScales[0] = basePhaseDeltaScale;
}
                }
                else {
                    tone.phaseDeltas[0] = startFreq * sampleTime;
                    tone.phaseDeltaScales[0] = basePhaseDeltaScale;
                }
                let expressionStart = settingsExpressionMult * transitionExpressionStart * chordExpressionStart * pitchExpressionStart * envelopeStarts[0];
                let expressionEnd = settingsExpressionMult * transitionExpressionEnd * chordExpressionEnd * pitchExpressionEnd * envelopeEnds[0];
                
                
                if (synth.isModActive(Config.modulators.dictionary["volume"].index, channelIndex, tone.instrumentIndex)) {
                    const startVal = synth.getModValue(Config.modulators.dictionary["volume"].index, channelIndex, tone.instrumentIndex, false);
                    const endVal = synth.getModValue(Config.modulators.dictionary["volume"].index, channelIndex, tone.instrumentIndex, true);
                    expressionStart *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(startVal));
                    expressionEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(endVal));
                }
                
if (synth.isModActive(Config.modulators.dictionary["extra volume"].index, channelIndex, tone.instrumentIndex)) {
	const startVal = synth.getModValue(Config.modulators.dictionary["extra volume"].index, channelIndex, tone.instrumentIndex, false);
	const endVal = synth.getModValue(Config.modulators.dictionary["extra volume"].index, channelIndex, tone.instrumentIndex, true);
	
	expressionStart *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(startVal));
expressionEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : this.instrumentVolumeToVolumeMult(endVal));
}
                
                
if (synth.isModActive(Config.modulators.dictionary["song volume"].index)) {
    expressionStart *= synth.getModValue(Config.modulators.dictionary["song volume"].index, undefined, undefined, false) / 100.0;
    expressionEnd *= synth.getModValue(Config.modulators.dictionary["song volume"].index, undefined, undefined, true) / 100.0;
}

  




tone.expressionStarts[0] = expressionStart;
tone.expressionDeltas[0] = (expressionEnd - expressionStart) / runLength;

            }
        }
        static getLFOAmplitude(instrument, secondsIntoBar) {
            let effect = 0.0;
            for (const vibratoPeriodSeconds of Config.vibratoTypes[instrument.vibratoType].periodsSeconds) {
                effect += Math.sin(Math.PI * 2.0 * secondsIntoBar / vibratoPeriodSeconds);
            }
            return effect;
        }
        static getInstrumentSynthFunction(instrument) {
            if (instrument.type == 1) {
            	
            	
            	let toout = JSON.stringify(Synth.fmSourceTemplate)
            	const synthSource = [];
            	const fingerprint = instrument.algorithm + "_" + instrument.feedbackType;
            	if (true) {
            		for (const line of Synth.fmSourceTemplate) {
            			if (line.indexOf("// CARRIER OUTPUTS") != -1) {
            				const outputs = [];
            				
 const carriers = [];
for (let i = 0; i < Config.operatorCount; i++) {
    if (Config.algorithms[instrument.algorithm].associatedCarrier[i] === i + 1) {
        carriers.push(i);
    }
}

            				
            				toout = carriers
            				
            				for (const j of carriers) {
            					outputs.push("operator" + j + "Scaled");
            				}
            				synthSource.push(line.replace("/*operator#Scaled*/", outputs.join(" + ")));
            			}
            			else if (line.indexOf("// INSERT OPERATOR COMPUTATION HERE") != -1) {
            				const operatorCount = instrument.operators.length;
toout=operatorCount
            				for (let j = Config.operatorCount - 1; j >= 0; j--) {
            					for (const operatorLine of Synth.operatorSourceTemplate) {
            						if (operatorLine.indexOf("/* + operator@Scaled*/") != -1) {
            							let modulators = "";
            							const modList = Config.algorithms[instrument.algorithm].modulatedBy[j] || [];
            							for (const modulatorNumber of modList) {
            								modulators += " + operator" + (modulatorNumber - 1) + "Scaled";
            							}
            							const feedbackIndices = Config.feedbacks[instrument.feedbackType].indices[j] || [];
            							if (feedbackIndices.length > 0) {
            								modulators += " + feedbackMult * (";
            								const feedbacks = [];
            								for (const modulatorNumber of feedbackIndices) {
            									feedbacks.push("operator" + (modulatorNumber - 1) + "Output");
            								}
            								modulators += feedbacks.join(" + ") + ")";
            							}
            							synthSource.push(operatorLine.replace(/\#/g, j + "").replace("/* + operator@Scaled*/", modulators));
            						}
            						else {
            							
            							synthSource.push(operatorLine.replace(/\#/g, j + ""));
            						}
            					}
            				}
            			}
            			else if (line.indexOf("#") != -1) {
            				for (let j = 0; j < Config.operatorCount; j++) {
            					synthSource.push(line.replace(/\#/g, j + ""));
            				}
            			}
            			else {
            				synthSource.push(line);
            			}
            		}
            		Synth.fmSynthFunctionCache[fingerprint] = new Function("synth", "bufferIndex", "runLength", "tone", "instrument", synthSource.join("\n"));
            //		toout = synthSource.join("\n")
            	}
            //	console.log(toout)
            	return Synth.fmSynthFunctionCache[fingerprint];
            	
            	
            	
            	
            	
            	
            	
            	
            	
            	
            	
            	
            	
            }
            else if (instrument.type == 0) {
	if (instrument.isUsingAdvancedLoopControls) {
		return Synth.loopableChipSynth;
	}
	return Synth.chipSynth;
}
            else if (instrument.type == 8) {
                return Synth.chipSynth;
            }
            else if (instrument.type == 5) {
                return Synth.harmonicsSynth;
            }
            else if (instrument.type == 6) {
                return Synth.pulseWidthSynth;
            }
            else if (instrument.type == 7) {
                return Synth.pickedStringSynth;
            }
            else if (instrument.type == 2) {
                return Synth.noiseSynth;
            }
            else if (instrument.type == 3) {
                return Synth.spectrumSynth;
            }
            else if (instrument.type == 4) {
                return Synth.drumsetSynth;
            }
            else if (instrument.type == 9) {
                return Synth.modSynth;
            }
            else {
                throw new Error("Unrecognized instrument type: " + instrument.type);
            }
        }
static chipSynth(synth, bufferIndex, runLength, tone, instrument) {
            const aliases = (effectsIncludeDistortion(instrument.effects) && instrument.aliases);
            const isCustomWave = (instrument.type == 8);
            const data = synth.tempMonoInstrumentSampleBuffer;
            var wave;
            var volumeScale = 1.0;
            if (!isCustomWave) {
                if (aliases) {
                    wave = Config.chipWaves[instrument.chipWave].samples;
                }
                else {
                    wave = Config.chipWaves[instrument.chipWave].samples;
                }
            }
            else {
                if (aliases) {
                    wave = instrument.customChipWave;
                    volumeScale = 0.05;
                }
                else {
                    wave = instrument.customChipWaveIntegral;
                    volumeScale = 0.05;
                }
            }
            const waveLength = wave.length - 1;


const unisonSign = tone.specialIntervalExpressionMult * instrument.unisonSign;
if (instrument.unisonVoices == 1 && instrument.unisonSpread == 0 && !instrument.chord.customInterval)
	tone.phases[1] = tone.phases[0];
	
	
            if (instrument.unison == 0 && !instrument.getChord().customInterval)
                tone.phases[1] = tone.phases[0];
            let phaseDeltaA = tone.phaseDeltas[0] * waveLength;
            let phaseDeltaB = tone.phaseDeltas[1] * waveLength;
            const phaseDeltaScaleA = +tone.phaseDeltaScales[0];
            const phaseDeltaScaleB = +tone.phaseDeltaScales[1];
            let expression = +tone.expressionStarts[0];
            const expressionDelta = +tone.expressionDeltas[0];
            let phaseA = (tone.phases[0] % 1) * waveLength;
            let phaseB = (tone.phases[1] % 1) * waveLength;
            const filters = tone.noteFilters;
            const filterCount = tone.noteFilterCount | 0;
            let initialFilterInput1 = +tone.initialNoteFilterInput1;
            let initialFilterInput2 = +tone.initialNoteFilterInput2;
            const applyFilters = Synth.applyFilters;
            let prevWaveIntegralA = 0;
            let prevWaveIntegralB = 0;
            if (!aliases) {
                const phaseAInt = phaseA | 0;
                const phaseBInt = phaseB | 0;
                const indexA = phaseAInt % waveLength;
                const indexB = phaseBInt % waveLength;
                const phaseRatioA = phaseA - phaseAInt;
                const phaseRatioB = phaseB - phaseBInt;
                prevWaveIntegralA = +wave[indexA];
                prevWaveIntegralB = +wave[indexB];
                prevWaveIntegralA += (wave[indexA + 1] - prevWaveIntegralA) * phaseRatioA;
                prevWaveIntegralB += (wave[indexB + 1] - prevWaveIntegralB) * phaseRatioB;
            }
            const stopIndex = bufferIndex + runLength;
            for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
                phaseA += phaseDeltaA;
                phaseB += phaseDeltaB;
                let waveA;
                let waveB;
                let inputSample;
                if (aliases) {
                    waveA = wave[(0 | phaseA) % waveLength];
                    waveB = wave[(0 | phaseB) % waveLength];
                    inputSample = waveA + waveB;
                }
                else {
                    const phaseAInt = phaseA | 0;
                    const phaseBInt = phaseB | 0;
                    const indexA = phaseAInt % waveLength;
                    const indexB = phaseBInt % waveLength;
                    let nextWaveIntegralA = wave[indexA];
                    let nextWaveIntegralB = wave[indexB];
                    const phaseRatioA = phaseA - phaseAInt;
                    const phaseRatioB = phaseB - phaseBInt;
                    nextWaveIntegralA += (wave[indexA + 1] - nextWaveIntegralA) * phaseRatioA;
                    nextWaveIntegralB += (wave[indexB + 1] - nextWaveIntegralB) * phaseRatioB;
                    waveA = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA;
                    waveB = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;
                    prevWaveIntegralA = nextWaveIntegralA;
                    prevWaveIntegralB = nextWaveIntegralB;
                    inputSample = waveA + waveB * unisonSign;
                }
                const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
                initialFilterInput2 = initialFilterInput1;
                initialFilterInput1 = inputSample;
                phaseDeltaA *= phaseDeltaScaleA;
                phaseDeltaB *= phaseDeltaScaleB;
                const output = sample * expression * volumeScale;
                expression += expressionDelta;
                data[sampleIndex] += output;
            }
            tone.phases[0] = phaseA / waveLength;
            tone.phases[1] = phaseB / waveLength;
            synth.sanitizeFilters(filters);
            tone.initialNoteFilterInput1 = initialFilterInput1;
            tone.initialNoteFilterInput2 = initialFilterInput2;
        }
        static harmonicsSynth(synth, bufferIndex, runLength, tone, instrument) {
            const data = synth.tempMonoInstrumentSampleBuffer;
            const wave = instrument.harmonicsWave.getCustomWave(instrument.type);
            const waveLength = wave.length - 1;
            
            

const unisonSign = tone.specialIntervalExpressionMult * instrument.unisonSign;
if (instrument.unisonVoices == 1 && instrument.unisonSpread == 0 && !instrument.chord.customInterval)
	tone.phases[1] = tone.phases[0];
            
            
            if (instrument.unison == 0 && !instrument.getChord().customInterval)
                tone.phases[1] = tone.phases[0];
            let phaseDeltaA = tone.phaseDeltas[0] * waveLength;
            let phaseDeltaB = tone.phaseDeltas[1] * waveLength;
            const phaseDeltaScaleA = +tone.phaseDeltaScales[0];
            const phaseDeltaScaleB = +tone.phaseDeltaScales[1];
            let expression = +tone.expressionStarts[0];
            const expressionDelta = +tone.expressionDeltas[0];
            let phaseA = (tone.phases[0] % 1) * waveLength;
            let phaseB = (tone.phases[1] % 1) * waveLength;
            const filters = tone.noteFilters;
            const filterCount = tone.noteFilterCount | 0;
            let initialFilterInput1 = +tone.initialNoteFilterInput1;
            let initialFilterInput2 = +tone.initialNoteFilterInput2;
            const applyFilters = Synth.applyFilters;
            const phaseAInt = phaseA | 0;
            const phaseBInt = phaseB | 0;
            const indexA = phaseAInt % waveLength;
            const indexB = phaseBInt % waveLength;
            const phaseRatioA = phaseA - phaseAInt;
            const phaseRatioB = phaseB - phaseBInt;
            let prevWaveIntegralA = +wave[indexA];
            let prevWaveIntegralB = +wave[indexB];
            prevWaveIntegralA += (wave[indexA + 1] - prevWaveIntegralA) * phaseRatioA;
            prevWaveIntegralB += (wave[indexB + 1] - prevWaveIntegralB) * phaseRatioB;
            const stopIndex = bufferIndex + runLength;
            for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
                phaseA += phaseDeltaA;
                phaseB += phaseDeltaB;
                const phaseAInt = phaseA | 0;
                const phaseBInt = phaseB | 0;
                const indexA = phaseAInt % waveLength;
                const indexB = phaseBInt % waveLength;
                let nextWaveIntegralA = wave[indexA];
                let nextWaveIntegralB = wave[indexB];
                const phaseRatioA = phaseA - phaseAInt;
                const phaseRatioB = phaseB - phaseBInt;
                nextWaveIntegralA += (wave[indexA + 1] - nextWaveIntegralA) * phaseRatioA;
                nextWaveIntegralB += (wave[indexB + 1] - nextWaveIntegralB) * phaseRatioB;
                const waveA = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA;
                const waveB = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;
                prevWaveIntegralA = nextWaveIntegralA;
                prevWaveIntegralB = nextWaveIntegralB;
                const inputSample = waveA + waveB * unisonSign;
                const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
                initialFilterInput2 = initialFilterInput1;
                initialFilterInput1 = inputSample;
                phaseDeltaA *= phaseDeltaScaleA;
                phaseDeltaB *= phaseDeltaScaleB;
                const output = sample * expression;
                expression += expressionDelta;
                data[sampleIndex] += output;
            }
            tone.phases[0] = phaseA / waveLength;
            tone.phases[1] = phaseB / waveLength;
            synth.sanitizeFilters(filters);
            tone.initialNoteFilterInput1 = initialFilterInput1;
            tone.initialNoteFilterInput2 = initialFilterInput2;
        }
        static pickedStringSynth(synth, bufferIndex, runLength, tone, instrument) {
            const voiceCount = instrument.unisonVoices;
            let pickedStringFunction = Synth.pickedStringFunctionCache[voiceCount];
            if (pickedStringFunction == undefined) {
                let pickedStringSource = "";
                pickedStringSource += `
				
				const Config = beepbox.Config;
				const Synth = beepbox.Synth;
				const NoteAutomationStringSustainIndex = ${3};
				const voiceCount = ${voiceCount};
				const data = synth.tempMonoInstrumentSampleBuffer;
				
				const sustainEnvelopeStart = tone.envelopeComputer.envelopeStarts[NoteAutomationStringSustainIndex];
				const sustainEnvelopeEnd   = tone.envelopeComputer.envelopeEnds[  NoteAutomationStringSustainIndex];
				const stringDecayStart = 1.0 - Math.min(1.0, sustainEnvelopeStart * tone.stringSustainStart / (Config.stringSustainRange - 1));
				const stringDecayEnd   = 1.0 - Math.min(1.0, sustainEnvelopeEnd   * tone.stringSustainEnd / (Config.stringSustainRange - 1));
				
				let pickedString# = tone.pickedStrings[#];
				
				const prevDelayLength# = +pickedString#.prevDelayLength;
				let allPassSample# = +pickedString#.allPassSample;
				let allPassPrevInput# = +pickedString#.allPassPrevInput;
				let shelfSample# = +pickedString#.shelfSample;
				let shelfPrevInput# = +pickedString#.shelfPrevInput;
				let fractionalDelaySample# = +pickedString#.fractionalDelaySample;
				
				let expression = +tone.expressionStarts[0];
				const expressionDelta = +tone.expressionDeltas[0];
				
				const phaseDeltaStart# = +tone.phaseDeltas[#];
				const phaseDeltaScale# = +tone.phaseDeltaScales[#];
				const phaseDeltaEnd# = phaseDeltaStart# * Math.pow(phaseDeltaScale#, runLength);
				
				const radiansPerSampleStart# = Math.PI * 2.0 * phaseDeltaStart#;
				const radiansPerSampleEnd#   = Math.PI * 2.0 * phaseDeltaEnd#;
				
				const centerHarmonicStart# = radiansPerSampleStart# * 2.0;
				const centerHarmonicEnd#   = radiansPerSampleEnd# * 2.0;
				
				const allPassCenter = 2.0 * Math.PI * Config.pickedStringDispersionCenterFreq / synth.samplesPerSecond;
				const allPassRadiansStart# = Math.min(Math.PI, radiansPerSampleStart# * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleStart#, Config.pickedStringDispersionFreqScale));
				const allPassRadiansEnd# = Math.min(Math.PI, radiansPerSampleEnd# * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleEnd#, Config.pickedStringDispersionFreqScale));
				
				const shelfRadians = 2.0 * Math.PI * Config.pickedStringShelfHz / synth.samplesPerSecond;
				const decayCurveStart = (Math.pow(100.0, stringDecayStart) - 1.0) / 99.0;
				const decayCurveEnd   = (Math.pow(100.0, stringDecayEnd  ) - 1.0) / 99.0;
				const decayRateStart# = Math.pow(0.5, decayCurveStart * shelfRadians / radiansPerSampleStart#);
				const decayRateEnd#   = Math.pow(0.5, decayCurveEnd   * shelfRadians / radiansPerSampleEnd#);
				const shelfGainStart# = Math.pow(decayRateStart#, Config.stringDecayRate);
				const shelfGainEnd#   = Math.pow(decayRateEnd#,   Config.stringDecayRate);
				const expressionDecayStart# = Math.pow(decayRateStart#, 0.002);
				const expressionDecayEnd#   = Math.pow(decayRateEnd#,   0.002);`;
                for (let voice = 0; voice < voiceCount; voice++) {
                    pickedStringSource += `
				
				Synth.tempFilterStartCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansStart#);
				synth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart#);
				let allPassG# = +Synth.tempFilterStartCoefficients.b[0]; /* same as a[1] */
				const allPassPhaseDelayStart# = -synth.tempFrequencyResponse.angle() / centerHarmonicStart#;
				
				Synth.tempFilterEndCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansEnd#);
				synth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd#);
				const allPassGEnd# = +Synth.tempFilterEndCoefficients.b[0]; /* same as a[1] */
				const allPassPhaseDelayEnd# = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd#;
				
				Synth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, shelfGainStart#);
				synth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart#)
				let shelfA1# = +Synth.tempFilterStartCoefficients.a[1]
				let shelfB0# = Synth.tempFilterStartCoefficients.b[0] * expressionDecayStart#
				let shelfB1# = Synth.tempFilterStartCoefficients.b[1] * expressionDecayStart#
				const shelfPhaseDelayStart# = -synth.tempFrequencyResponse.angle() / centerHarmonicStart#;
				
				Synth.tempFilterEndCoefficients.highShelf1stOrder(shelfRadians, shelfGainEnd#)
				synth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd#)
				const shelfA1End# = +Synth.tempFilterEndCoefficients.a[1]
				const shelfB0End# = Synth.tempFilterEndCoefficients.b[0] * expressionDecayEnd#
				const shelfB1End# = Synth.tempFilterEndCoefficients.b[1] * expressionDecayEnd#
				const shelfPhaseDelayEnd# = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd#;`.replace(/\#/g, String(voice));
                }
                pickedStringSource += `
				
				const periodLengthStart# = 1.0 / phaseDeltaStart#;
				const periodLengthEnd# = 1.0 / phaseDeltaEnd#;
				const minBufferLength# = Math.ceil(Math.max(periodLengthStart#, periodLengthEnd#) * 2);
				let delayLength# = periodLengthStart# - allPassPhaseDelayStart# - shelfPhaseDelayStart#;
				const delayLengthEnd# = periodLengthEnd# - allPassPhaseDelayEnd# - shelfPhaseDelayEnd#;
				
				const delayLengthDelta# = (delayLengthEnd# - delayLength#) / runLength;
				const allPassGDelta# = (allPassGEnd# - allPassG#) / runLength;
				const shelfA1Delta# = (shelfA1End# - shelfA1#) / runLength;
				const shelfB0Delta# = (shelfB0End# - shelfB0#) / runLength;
				const shelfB1Delta# = (shelfB1End# - shelfB1#) / runLength;
				
				const filters = tone.noteFilters;
				const filterCount = tone.noteFilterCount|0;
				let initialFilterInput1 = +tone.initialNoteFilterInput1;
				let initialFilterInput2 = +tone.initialNoteFilterInput2;
				const applyFilters = Synth.applyFilters;
				
				const pitchChanged# = Math.abs(Math.log2(delayLength# / prevDelayLength#)) > 0.01;
				let delayIndex# = pickedString#.delayIndex|0;`;
                for (let voice = 0; voice < voiceCount; voice++) {
                    pickedStringSource += `
					
				const reinitializeImpulse# = (delayIndex# == -1 || pitchChanged#);
				if (pickedString#.delayLine == null || pickedString#.delayLine.length <= minBufferLength#) {
					// The delay line buffer will get reused for other tones so might as well
					// start off with a buffer size that is big enough for most notes.
					const likelyMaximumLength = Math.ceil(2 * synth.samplesPerSecond / beepbox.Instrument.frequencyFromPitch(12));
					const newDelayLine = new Float32Array(Synth.fittingPowerOfTwo(Math.max(likelyMaximumLength, minBufferLength#)));
					if (!reinitializeImpulse# && pickedString#.delayLine != null) {
						// If the tone has already started but the buffer needs to be reallocated,
						// transfer the old data to the new buffer.
						const oldDelayBufferMask = (pickedString#.delayLine.length - 1) >> 0;
						const startCopyingFromIndex = delayIndex# + pickedString#.delayResetOffset;
						delayIndex# = pickedString#.delayLine.length - pickedString#.delayResetOffset;
						for (let i = 0; i < pickedString#.delayLine.length; i++) {
							newDelayLine[i] = pickedString#.delayLine[(startCopyingFromIndex + i) & oldDelayBufferMask];
						}
					}
					pickedString#.delayLine = newDelayLine;
				}
				const delayLine# = pickedString#.delayLine;
				const delayBufferMask# = (delayLine#.length - 1) >> 0;

				if (reinitializeImpulse#) {
					// -1 delay index means the tone was reset.
					// Also, if the pitch changed suddenly (e.g. from seamless or arpeggio) then reset the wave.
					
					delayIndex# = 0;
					allPassSample# = 0.0;
					allPassPrevInput# = 0.0;
					shelfSample# = 0.0;
					shelfPrevInput# = 0.0;
					fractionalDelaySample# = 0.0;
					
					// Clear away a region of the delay buffer for the new impulse.
					const startImpulseFrom = -delayLength#;
					const startZerosFrom = Math.floor(startImpulseFrom - periodLengthStart# / 2);
					const stopZerosAt = Math.ceil(startZerosFrom + periodLengthStart# * 2);
					pickedString#.delayResetOffset = stopZerosAt; // And continue clearing the area in front of the delay line.
					for (let i = startZerosFrom; i <= stopZerosAt; i++) {
						delayLine#[i & delayBufferMask#] = 0.0;
					}
					
					const impulseWave = instrument.harmonicsWave.getCustomWave(instrument.type);
					const impulseWaveLength = impulseWave.length - 1; // The first sample is duplicated at the end, don't double-count it.
					const impulsePhaseDelta = impulseWaveLength / periodLengthStart#;
					
					const fadeDuration = Math.min(periodLengthStart# * 0.2, synth.samplesPerSecond * 0.003);
					const startImpulseFromSample = Math.ceil(startImpulseFrom);
					const stopImpulseAt = startImpulseFrom + periodLengthStart# + fadeDuration;
					const stopImpulseAtSample = stopImpulseAt;
					let impulsePhase = (startImpulseFromSample - startImpulseFrom) * impulsePhaseDelta;
					let prevWaveIntegral = 0.0;
					for (let i = startImpulseFromSample; i <= stopImpulseAtSample; i++) {
						const impulsePhaseInt = impulsePhase|0;
						const index = impulsePhaseInt % impulseWaveLength;
						let nextWaveIntegral = impulseWave[index];
						const phaseRatio = impulsePhase - impulsePhaseInt;
						nextWaveIntegral += (impulseWave[index+1] - nextWaveIntegral) * phaseRatio;
						const sample = (nextWaveIntegral - prevWaveIntegral) / impulsePhaseDelta;
						const fadeIn = Math.min(1.0, (i - startImpulseFrom) / fadeDuration);
						const fadeOut = Math.min(1.0, (stopImpulseAt - i) / fadeDuration);
						const combinedFade = fadeIn * fadeOut;
						const curvedFade = combinedFade * combinedFade * (3.0 - 2.0 * combinedFade); // A cubic sigmoid from 0 to 1.
						delayLine#[i & delayBufferMask#] += sample * curvedFade;
						prevWaveIntegral = nextWaveIntegral;
						impulsePhase += impulsePhaseDelta;
					}
				}
				delayIndex# = (delayIndex# & delayBufferMask#) + delayLine#.length;`.replace(/\#/g, String(voice));
                }
                pickedStringSource += `

				const unisonSign = tone.specialIntervalExpressionMult * instrument.unisonSign;
				
				
				
				
				const delayResetOffset# = pickedString#.delayResetOffset|0;
            //const floorStereoDelay: number = absStereoDelay | 0;
				const stopIndex = bufferIndex + runLength;
				for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
					const targetSampleTime# = delayIndex# - delayLength#;
					const lowerIndex# = (targetSampleTime# + 0.125) | 0; // Offset to improve stability of all-pass filter.
					const upperIndex# = lowerIndex# + 1;
					const fractionalDelay# = upperIndex# - targetSampleTime#;
					const fractionalDelayG# = (1.0 - fractionalDelay#) / (1.0 + fractionalDelay#); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay
					const prevInput# = delayLine#[lowerIndex# & delayBufferMask#];
					const input# = delayLine#[upperIndex# & delayBufferMask#];
					fractionalDelaySample# = fractionalDelayG# * input# + prevInput# - fractionalDelayG# * fractionalDelaySample#;
					
					allPassSample# = fractionalDelaySample# * allPassG# + allPassPrevInput# - allPassG# * allPassSample#;
					allPassPrevInput# = fractionalDelaySample#;
					
					shelfSample# = shelfB0# * allPassSample# + shelfB1# * shelfPrevInput# - shelfA1# * shelfSample#;
					shelfPrevInput# = allPassSample#;
					
					delayLine#[delayIndex# & delayBufferMask#] += shelfSample#;
					delayLine#[(delayIndex# + delayResetOffset#) & delayBufferMask#] = 0.0;
					delayIndex#++;
					
					const inputSample = (`;
                const sampleList = [];
                for (let voice = 0; voice < voiceCount; voice++) {
                    sampleList.push("fractionalDelaySample" + voice + (voice == 1 ? " * unisonSign" : ""));
                }
                pickedStringSource += sampleList.join(" + ");
                pickedStringSource += `) * expression;
					const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
					initialFilterInput2 = initialFilterInput1;
					initialFilterInput1 = inputSample;
					data[sampleIndex] += sample;
					
					expression += expressionDelta;
					delayLength# += delayLengthDelta#;
					allPassG# += allPassGDelta#;
					shelfA1# += shelfA1Delta#;
					shelfB0# += shelfB0Delta#;
					shelfB1# += shelfB1Delta#;
				}
				
				// Avoid persistent denormal or NaN values in the delay buffers and filter history.
				const epsilon = (1.0e-24);
				if (!Number.isFinite(allPassSample#) || Math.abs(allPassSample#) < epsilon) allPassSample# = 0.0;
				if (!Number.isFinite(allPassPrevInput#) || Math.abs(allPassPrevInput#) < epsilon) allPassPrevInput# = 0.0;
				if (!Number.isFinite(shelfSample#) || Math.abs(shelfSample#) < epsilon) shelfSample# = 0.0;
				if (!Number.isFinite(shelfPrevInput#) || Math.abs(shelfPrevInput#) < epsilon) shelfPrevInput# = 0.0;
				if (!Number.isFinite(fractionalDelaySample#) || Math.abs(fractionalDelaySample#) < epsilon) fractionalDelaySample# = 0.0;
				pickedString#.allPassSample = allPassSample#;
				pickedString#.allPassPrevInput = allPassPrevInput#;
				pickedString#.shelfSample = shelfSample#;
				pickedString#.shelfPrevInput = shelfPrevInput#;
				pickedString#.fractionalDelaySample = fractionalDelaySample#;
				pickedString#.delayIndex = delayIndex#;
				pickedString#.prevDelayLength = delayLength#;
				
				synth.sanitizeFilters(filters);
				tone.initialNoteFilterInput1 = initialFilterInput1;
				tone.initialNoteFilterInput2 = initialFilterInput2;`;
                pickedStringSource = pickedStringSource.replace(/^.*\#.*$/mg, line => {
                    const lines = [];
                    for (let voice = 0; voice < voiceCount; voice++) {
                        lines.push(line.replace(/\#/g, String(voice)));
                    }
                    return lines.join("\n");
                });
                pickedStringFunction = new Function("synth", "bufferIndex", "runLength", "tone", "instrument", pickedStringSource);
                Synth.pickedStringFunctionCache[voiceCount] = pickedStringFunction;
            }
            pickedStringFunction(synth, bufferIndex, runLength, tone, instrument);
        }
        static effectsSynth(synth, outputDataL, outputDataR, bufferIndex, runLength, instrument, instrumentState) { 
            const usesDistortion = effectsIncludeDistortion(instrument.effects);
            const usesBitcrusher = effectsIncludeBitcrusher(instrument.effects);
            const usesEqFilter = instrumentState.eqFilterCount > 0;
            const usesPanning = effectsIncludePanning(instrument.effects);
            const usesChorus = effectsIncludeChorus(instrument.effects);
            const usesEcho = effectsIncludeEcho(instrument.effects);
            const usesReverb = effectsIncludeReverb(instrument.effects);
            const usesRingModulation = effectsIncludeRingModulation(instrument.effects);
             
            let signature = 0;
            if (usesDistortion)
                signature = signature | 1;
            signature = signature << 1;
            if (usesBitcrusher)
                signature = signature | 1;
            signature = signature << 1;
            if (usesEqFilter)
                signature = signature | 1;
            signature = signature << 1;
            if (usesPanning)
                signature = signature | 1;
            signature = signature << 1;
            if (usesChorus)
                signature = signature | 1;
            signature = signature << 1;
            if (usesEcho)
                signature = signature | 1;
            signature = signature << 1;
            if (usesReverb)
                signature = signature | 1;
            if (usesRingModulation){
                signature = signature | 1;
            }
            let effectsFunction = Synth.effectsFunctionCache[signature];
            if (effectsFunction == undefined) {
                let effectsSource = "";
                const usesDelays = usesChorus || usesReverb || usesEcho;
                effectsSource += `
				const tempMonoInstrumentSampleBuffer = synth.tempMonoInstrumentSampleBuffer;
				
				let mixVolume = +instrumentState.mixVolumeStart;
				const mixVolumeDelta = +instrumentState.mixVolumeDelta;`;
                if (usesDelays) {
                    effectsSource += `
				
				let delayInputMult = +instrumentState.delayInputMultStart;
				const delayInputMultDelta = +instrumentState.delayInputMultDelta;`;
                }
                if (usesDistortion) {
                    effectsSource += `
				
				const distortionBaseVolume = +beepbox.Config.distortionBaseVolume;
				const distortionStart = +Math.pow(1.0 - 0.895 * (Math.pow(20.0, instrumentState.distortionStart) - 1.0) / 19.0, 2.0)
				const distortionEnd   = +Math.pow(1.0 - 0.895 * (Math.pow(20.0, instrumentState.distortionEnd  ) - 1.0) / 19.0, 2.0)
				let distortion = distortionStart;
				const distortionDelta = (distortionEnd - distortionStart) / runLength;
				const distortionDriveStart = (1.0 + 2.0 * instrumentState.distortionStart) / distortionBaseVolume;
				const distortionDriveEnd   = (1.0 + 2.0 * instrumentState.distortionEnd)   / distortionBaseVolume;
				let distortionDrive = distortionDriveStart;
				const distortionDriveDelta = (distortionDriveEnd - distortionDriveStart) / runLength;
				const distortionFractionalResolution = 4.0;
				const distortionOversampleCompensation = distortionBaseVolume / distortionFractionalResolution;
				const distortionFractionalDelay1 = 1.0 / distortionFractionalResolution;
				const distortionFractionalDelay2 = 2.0 / distortionFractionalResolution;
				const distortionFractionalDelay3 = 3.0 / distortionFractionalResolution;
				const distortionFractionalDelayG1 = (1.0 - distortionFractionalDelay1) / (1.0 + distortionFractionalDelay1); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay
				const distortionFractionalDelayG2 = (1.0 - distortionFractionalDelay2) / (1.0 + distortionFractionalDelay2); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay
				const distortionFractionalDelayG3 = (1.0 - distortionFractionalDelay3) / (1.0 + distortionFractionalDelay3); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay
				const distortionNextOutputWeight1 = Math.cos(Math.PI * distortionFractionalDelay1) * 0.5 + 0.5;
				const distortionNextOutputWeight2 = Math.cos(Math.PI * distortionFractionalDelay2) * 0.5 + 0.5;
				const distortionNextOutputWeight3 = Math.cos(Math.PI * distortionFractionalDelay3) * 0.5 + 0.5;
				const distortionPrevOutputWeight1 = 1.0 - distortionNextOutputWeight1;
				const distortionPrevOutputWeight2 = 1.0 - distortionNextOutputWeight2;
				const distortionPrevOutputWeight3 = 1.0 - distortionNextOutputWeight3;
				
				let distortionFractionalInput1 = +instrumentState.distortionFractionalInput1;
				let distortionFractionalInput2 = +instrumentState.distortionFractionalInput2;
				let distortionFractionalInput3 = +instrumentState.distortionFractionalInput3;
				let distortionPrevInput = +instrumentState.distortionPrevInput;
				let distortionNextOutput = +instrumentState.distortionNextOutput;`;
                }
                if (usesBitcrusher) {
                    effectsSource += `
				
				let bitcrusherPrevInput = +instrumentState.bitcrusherPrevInput;
				let bitcrusherCurrentOutput = +instrumentState.bitcrusherCurrentOutput;
				let bitcrusherPhase = +instrumentState.bitcrusherPhase;
				let bitcrusherPhaseDelta = +instrumentState.bitcrusherPhaseDelta;
				const bitcrusherPhaseDeltaScale = +instrumentState.bitcrusherPhaseDeltaScale;
				let bitcrusherScale = +instrumentState.bitcrusherScale;
				const bitcrusherScaleScale = +instrumentState.bitcrusherScaleScale;
				let bitcrusherFoldLevel = +instrumentState.bitcrusherFoldLevel;
				const bitcrusherFoldLevelScale = +instrumentState.bitcrusherFoldLevelScale;`;
                }

                if (usesEqFilter) {
                    effectsSource += `
				
				let filters = instrumentState.eqFilters;
				const filterCount = instrumentState.eqFilterCount|0;
				let initialFilterInput1 = +instrumentState.initialEqFilterInput1;
				let initialFilterInput2 = +instrumentState.initialEqFilterInput2;
				const applyFilters = beepbox.Synth.applyFilters;`;
                }
                effectsSource += `
				
				let eqFilterVolume = +instrumentState.eqFilterVolumeStart;
				const eqFilterVolumeDelta = +instrumentState.eqFilterVolumeDelta;`;
				
				                if (usesRingModulation) {
                	
                	effectsSource += `
				 
                let ringModMix = +instrumentState.ringModMix;
                
                let ringModMixDelta = +instrumentState.ringModMixDelta;
                let ringModPhase = +instrumentState.ringModPhase;
                let ringModPhaseDelta = +instrumentState.ringModPhaseDelta;
                let ringModPhaseDeltaScale = +instrumentState.ringModPhaseDeltaScale;
                let ringModWaveformIndex = +instrumentState.ringModWaveformIndex;
                let ringModMixFade = +instrumentState.ringModMixFade;
                let ringModMixFadeDelta = +instrumentState.ringModMixFadeDelta;
                
                let ringModPulseWidth = +instrumentState.ringModPulseWidth;

                let waveform = beepbox.Config.operatorWaves[ringModWaveformIndex].samples; 
                
                if (ringModWaveformIndex == 2) {
                 
                    waveform = beepbox.Synth.getOperatorWave(ringModWaveformIndex, ringModPulseWidth).samples;
                }
                let waveformLength = waveform.length - 1;
                
                `;
                }
                if (usesPanning) {
                    effectsSource += `
				
				const panningMask = synth.panningDelayBufferMask >>> 0;
				const panningDelayLine = instrumentState.panningDelayLine;
				let panningDelayPos = instrumentState.panningDelayPos & panningMask;
				let   panningVolumeL      = +instrumentState.panningVolumeStartL;
				let   panningVolumeR      = +instrumentState.panningVolumeStartR;
				const panningVolumeDeltaL = +instrumentState.panningVolumeDeltaL;
				const panningVolumeDeltaR = +instrumentState.panningVolumeDeltaR;
				let   panningOffsetL      = panningDelayPos - instrumentState.panningOffsetStartL + synth.panningDelayBufferSize;
				let   panningOffsetR      = panningDelayPos - instrumentState.panningOffsetStartR + synth.panningDelayBufferSize;
				const panningOffsetDeltaL = 1.0 - instrumentState.panningOffsetDeltaL;
				const panningOffsetDeltaR = 1.0 - instrumentState.panningOffsetDeltaR;`;
                }
                if (usesChorus) {
                    effectsSource += `
				
				const chorusMask = synth.chorusDelayBufferMask >>> 0;
				const chorusDelayLineL = instrumentState.chorusDelayLineL;
				const chorusDelayLineR = instrumentState.chorusDelayLineR;
				instrumentState.chorusDelayLineDirty = true;
				let chorusDelayPos = instrumentState.chorusDelayPos & chorusMask;
				
				const chorusStart = +instrumentState.chorusStart;
				const chorusEnd   = +instrumentState.chorusEnd;
				let chorusVoiceMult = chorusStart;
				const chorusVoiceMultDelta = (chorusEnd - chorusStart) / runLength;
				let chorusCombinedMult = 1.0 / Math.sqrt(3.0 * chorusStart * chorusStart + 1.0);
				const chorusCombinedMultEnd = 1.0 / Math.sqrt(3.0 * chorusEnd * chorusEnd + 1.0);
				const chorusCombinedMultDelta = (chorusCombinedMultEnd - chorusCombinedMult) / runLength;
				
				const chorusDuration = +beepbox.Config.chorusPeriodSeconds;
				const chorusAngle = Math.PI * 2.0 / (chorusDuration * synth.samplesPerSecond);
				const chorusRange = synth.samplesPerSecond * beepbox.Config.chorusDelayRange;
				const chorusOffset0 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][0] * chorusRange;
				const chorusOffset1 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][1] * chorusRange;
				const chorusOffset2 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][2] * chorusRange;
				const chorusOffset3 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][0] * chorusRange;
				const chorusOffset4 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][1] * chorusRange;
				const chorusOffset5 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][2] * chorusRange;
				let chorusPhase = instrumentState.chorusPhase % (Math.PI * 2.0);
				let chorusTap0Index = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]);
				let chorusTap1Index = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]);
				let chorusTap2Index = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]);
				let chorusTap3Index = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]);
				let chorusTap4Index = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]);
				let chorusTap5Index = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]);
				chorusPhase += chorusAngle * runLength;
				const chorusTap0End = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]) + runLength;
				const chorusTap1End = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]) + runLength;
				const chorusTap2End = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]) + runLength;
				const chorusTap3End = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]) + runLength;
				const chorusTap4End = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]) + runLength;
				const chorusTap5End = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]) + runLength;
				const chorusTap0Delta = (chorusTap0End - chorusTap0Index) / runLength;
				const chorusTap1Delta = (chorusTap1End - chorusTap1Index) / runLength;
				const chorusTap2Delta = (chorusTap2End - chorusTap2Index) / runLength;
				const chorusTap3Delta = (chorusTap3End - chorusTap3Index) / runLength;
				const chorusTap4Delta = (chorusTap4End - chorusTap4Index) / runLength;
				const chorusTap5Delta = (chorusTap5End - chorusTap5Index) / runLength;`;
                }
                if (usesEcho) {
                    effectsSource += `
				
				let echoMult = +instrumentState.echoMultStart;
				const echoMultDelta = +instrumentState.echoMultDelta;
				
				const echoDelayLineL = instrumentState.echoDelayLineL;
				const echoDelayLineR = instrumentState.echoDelayLineR;
				const echoMask = (echoDelayLineL.length - 1) >>> 0;
				instrumentState.echoDelayLineDirty = true;
				
				let echoDelayPos = instrumentState.echoDelayPos & echoMask;
				const echoDelayOffsetStart = (echoDelayLineL.length - instrumentState.echoDelayOffsetStart) & echoMask;
				const echoDelayOffsetEnd   = (echoDelayLineL.length - instrumentState.echoDelayOffsetEnd) & echoMask;
				let echoDelayOffsetRatio = +instrumentState.echoDelayOffsetRatio;
				const echoDelayOffsetRatioDelta = +instrumentState.echoDelayOffsetRatioDelta;
				
				const echoShelfA1 = +instrumentState.echoShelfA1;
				const echoShelfB0 = +instrumentState.echoShelfB0;
				const echoShelfB1 = +instrumentState.echoShelfB1;
				let echoShelfSampleL = +instrumentState.echoShelfSampleL;
				let echoShelfSampleR = +instrumentState.echoShelfSampleR;
				let echoShelfPrevInputL = +instrumentState.echoShelfPrevInputL;
				let echoShelfPrevInputR = +instrumentState.echoShelfPrevInputR;`;
                }
                if (usesReverb) {
                    effectsSource += `
				
				const reverbMask = beepbox.Config.reverbDelayBufferMask >>> 0; //TODO: Dynamic reverb buffer size.
				const reverbDelayLine = instrumentState.reverbDelayLine;
				instrumentState.reverbDelayLineDirty = true;
				let reverbDelayPos = instrumentState.reverbDelayPos & reverbMask;
				
				let reverb = +instrumentState.reverbMultStart;
				const reverbDelta = +instrumentState.reverbMultDelta;
				
				const reverbShelfA1 = +instrumentState.reverbShelfA1;
				const reverbShelfB0 = +instrumentState.reverbShelfB0;
				const reverbShelfB1 = +instrumentState.reverbShelfB1;
				let reverbShelfSample0 = +instrumentState.reverbShelfSample0;
				let reverbShelfSample1 = +instrumentState.reverbShelfSample1;
				let reverbShelfSample2 = +instrumentState.reverbShelfSample2;
				let reverbShelfSample3 = +instrumentState.reverbShelfSample3;
				let reverbShelfPrevInput0 = +instrumentState.reverbShelfPrevInput0;
				let reverbShelfPrevInput1 = +instrumentState.reverbShelfPrevInput1;
				let reverbShelfPrevInput2 = +instrumentState.reverbShelfPrevInput2;
				let reverbShelfPrevInput3 = +instrumentState.reverbShelfPrevInput3;`;
                }
                effectsSource += `
				
				const stopIndex = bufferIndex + runLength;
				for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
					let sample = tempMonoInstrumentSampleBuffer[sampleIndex];
					tempMonoInstrumentSampleBuffer[sampleIndex] = 0.0;`;
                if (usesDistortion) {
                    effectsSource += `
					
					const distortionReverse = 1.0 - distortion;
					const distortionNextInput = sample * distortionDrive;
					sample = distortionNextOutput;
					distortionNextOutput = distortionNextInput / (distortionReverse * Math.abs(distortionNextInput) + distortion);
					distortionFractionalInput1 = distortionFractionalDelayG1 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG1 * distortionFractionalInput1;
					distortionFractionalInput2 = distortionFractionalDelayG2 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG2 * distortionFractionalInput2;
					distortionFractionalInput3 = distortionFractionalDelayG3 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG3 * distortionFractionalInput3;
					const distortionOutput1 = distortionFractionalInput1 / (distortionReverse * Math.abs(distortionFractionalInput1) + distortion);
					const distortionOutput2 = distortionFractionalInput2 / (distortionReverse * Math.abs(distortionFractionalInput2) + distortion);
					const distortionOutput3 = distortionFractionalInput3 / (distortionReverse * Math.abs(distortionFractionalInput3) + distortion);
					distortionNextOutput += distortionOutput1 * distortionNextOutputWeight1 + distortionOutput2 * distortionNextOutputWeight2 + distortionOutput3 * distortionNextOutputWeight3;
					sample += distortionOutput1 * distortionPrevOutputWeight1 + distortionOutput2 * distortionPrevOutputWeight2 + distortionOutput3 * distortionPrevOutputWeight3;
					sample *= distortionOversampleCompensation;
					distortionPrevInput = distortionNextInput;
					distortion += distortionDelta;
					distortionDrive += distortionDriveDelta;`;
                }
                if (usesBitcrusher) {
                    effectsSource += `
					
					bitcrusherPhase += bitcrusherPhaseDelta;
					if (bitcrusherPhase < 1.0) {
						bitcrusherPrevInput = sample;
						sample = bitcrusherCurrentOutput;
					} else {
						bitcrusherPhase = bitcrusherPhase % 1.0;
						const ratio = bitcrusherPhase / bitcrusherPhaseDelta;
						
						const lerpedInput = sample + (bitcrusherPrevInput - sample) * ratio;
						bitcrusherPrevInput = sample;
						
						const bitcrusherWrapLevel = bitcrusherFoldLevel * 4.0;
						const wrappedSample = (((lerpedInput + bitcrusherFoldLevel) % bitcrusherWrapLevel) + bitcrusherWrapLevel) % bitcrusherWrapLevel;
						const foldedSample = bitcrusherFoldLevel - Math.abs(bitcrusherFoldLevel * 2.0 - wrappedSample);
						const scaledSample = foldedSample / bitcrusherScale;
						const oldValue = bitcrusherCurrentOutput;
						const newValue = (((scaledSample > 0 ? scaledSample + 1 : scaledSample)|0)-.5) * bitcrusherScale;
						
						sample = oldValue + (newValue - oldValue) * ratio;
						bitcrusherCurrentOutput = newValue;
					}
					bitcrusherPhaseDelta *= bitcrusherPhaseDeltaScale;
					bitcrusherScale *= bitcrusherScaleScale;
					bitcrusherFoldLevel *= bitcrusherFoldLevelScale;`;
                }

                if (usesEqFilter) {
                    effectsSource += `
					
					const inputSample = sample;
					sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
					initialFilterInput2 = initialFilterInput1;
					initialFilterInput1 = inputSample;`;
                }
                
if (usesRingModulation) {
 effectsSource += ` 
                
                const ringModOutput = sample * waveform[(ringModPhase*waveformLength)|0];
                const ringModMixF = Math.max(0, ringModMix * ringModMixFade);
                
                sample = sample * (1 - ringModMixF) + ringModOutput * ringModMixF;
 
                ringModMix += ringModMixDelta;
                ringModPhase += ringModPhaseDelta;
                 
                 
                ringModPhase = ringModPhase % 1.0;
                ringModPhaseDelta *= ringModPhaseDeltaScale;
                ringModMixFade += ringModMixFadeDelta;
                  
                `;
}
                
                effectsSource += `
					
					sample *= eqFilterVolume;
					eqFilterVolume += eqFilterVolumeDelta;`;
                if (usesPanning) {
                    effectsSource += `
					
					panningDelayLine[panningDelayPos] = sample;
					const panningRatioL  = panningOffsetL % 1;
					const panningRatioR  = panningOffsetR % 1;
					const panningTapLA   = panningDelayLine[(panningOffsetL) & panningMask];
					const panningTapLB   = panningDelayLine[(panningOffsetL + 1) & panningMask];
					const panningTapRA   = panningDelayLine[(panningOffsetR) & panningMask];
					const panningTapRB   = panningDelayLine[(panningOffsetR + 1) & panningMask];
					const panningTapL    = panningTapLA + (panningTapLB - panningTapLA) * panningRatioL;
					const panningTapR    = panningTapRA + (panningTapRB - panningTapRA) * panningRatioR;
					let sampleL = panningTapL * panningVolumeL;
					let sampleR = panningTapR * panningVolumeR;
					panningDelayPos = (panningDelayPos + 1) & panningMask;
					panningVolumeL += panningVolumeDeltaL;
					panningVolumeR += panningVolumeDeltaR;
					panningOffsetL += panningOffsetDeltaL;
					panningOffsetR += panningOffsetDeltaR;`;
                }
                else {
                    effectsSource += `
					
					let sampleL = sample;
					let sampleR = sample;`;
                }
                if (usesChorus) {
                    effectsSource += `
					
					const chorusTap0Ratio = chorusTap0Index % 1;
					const chorusTap1Ratio = chorusTap1Index % 1;
					const chorusTap2Ratio = chorusTap2Index % 1;
					const chorusTap3Ratio = chorusTap3Index % 1;
					const chorusTap4Ratio = chorusTap4Index % 1;
					const chorusTap5Ratio = chorusTap5Index % 1;
					const chorusTap0A = chorusDelayLineL[(chorusTap0Index) & chorusMask];
					const chorusTap0B = chorusDelayLineL[(chorusTap0Index + 1) & chorusMask];
					const chorusTap1A = chorusDelayLineL[(chorusTap1Index) & chorusMask];
					const chorusTap1B = chorusDelayLineL[(chorusTap1Index + 1) & chorusMask];
					const chorusTap2A = chorusDelayLineL[(chorusTap2Index) & chorusMask];
					const chorusTap2B = chorusDelayLineL[(chorusTap2Index + 1) & chorusMask];
					const chorusTap3A = chorusDelayLineR[(chorusTap3Index) & chorusMask];
					const chorusTap3B = chorusDelayLineR[(chorusTap3Index + 1) & chorusMask];
					const chorusTap4A = chorusDelayLineR[(chorusTap4Index) & chorusMask];
					const chorusTap4B = chorusDelayLineR[(chorusTap4Index + 1) & chorusMask];
					const chorusTap5A = chorusDelayLineR[(chorusTap5Index) & chorusMask];
					const chorusTap5B = chorusDelayLineR[(chorusTap5Index + 1) & chorusMask];
					const chorusTap0 = chorusTap0A + (chorusTap0B - chorusTap0A) * chorusTap0Ratio;
					const chorusTap1 = chorusTap1A + (chorusTap1B - chorusTap1A) * chorusTap1Ratio;
					const chorusTap2 = chorusTap2A + (chorusTap2B - chorusTap2A) * chorusTap2Ratio;
					const chorusTap3 = chorusTap3A + (chorusTap3B - chorusTap3A) * chorusTap3Ratio;
					const chorusTap4 = chorusTap4A + (chorusTap4B - chorusTap4A) * chorusTap4Ratio;
					const chorusTap5 = chorusTap5A + (chorusTap5B - chorusTap5A) * chorusTap5Ratio;
					chorusDelayLineL[chorusDelayPos] = sampleL * delayInputMult;
					chorusDelayLineR[chorusDelayPos] = sampleR * delayInputMult;
					sampleL = chorusCombinedMult * (sampleL + chorusVoiceMult * (chorusTap1 - chorusTap0 - chorusTap2));
					sampleR = chorusCombinedMult * (sampleR + chorusVoiceMult * (chorusTap4 - chorusTap3 - chorusTap5));
					chorusDelayPos = (chorusDelayPos + 1) & chorusMask;
					chorusTap0Index += chorusTap0Delta;
					chorusTap1Index += chorusTap1Delta;
					chorusTap2Index += chorusTap2Delta;
					chorusTap3Index += chorusTap3Delta;
					chorusTap4Index += chorusTap4Delta;
					chorusTap5Index += chorusTap5Delta;
					chorusVoiceMult += chorusVoiceMultDelta;
					chorusCombinedMult += chorusCombinedMultDelta;`;
                }
                if (usesEcho) {
                    effectsSource += `
					
					const echoTapStartIndex = (echoDelayPos + echoDelayOffsetStart) & echoMask;
					const echoTapEndIndex   = (echoDelayPos + echoDelayOffsetEnd  ) & echoMask;
					const echoTapStartL = echoDelayLineL[echoTapStartIndex];
					const echoTapEndL   = echoDelayLineL[echoTapEndIndex];
					const echoTapStartR = echoDelayLineR[echoTapStartIndex];
					const echoTapEndR   = echoDelayLineR[echoTapEndIndex];
					const echoTapL = (echoTapStartL + (echoTapEndL - echoTapStartL) * echoDelayOffsetRatio) * echoMult;
					const echoTapR = (echoTapStartR + (echoTapEndR - echoTapStartR) * echoDelayOffsetRatio) * echoMult;
					
					echoShelfSampleL = echoShelfB0 * echoTapL + echoShelfB1 * echoShelfPrevInputL - echoShelfA1 * echoShelfSampleL;
					echoShelfSampleR = echoShelfB0 * echoTapR + echoShelfB1 * echoShelfPrevInputR - echoShelfA1 * echoShelfSampleR;
					echoShelfPrevInputL = echoTapL;
					echoShelfPrevInputR = echoTapR;
					sampleL += echoShelfSampleL;
					sampleR += echoShelfSampleR;
					
					echoDelayLineL[echoDelayPos] = sampleL * delayInputMult;
					echoDelayLineR[echoDelayPos] = sampleR * delayInputMult;
					echoDelayPos = (echoDelayPos + 1) & echoMask;
					echoDelayOffsetRatio += echoDelayOffsetRatioDelta;
					echoMult += echoMultDelta;`;
                }
                if (usesReverb) {
                    effectsSource += `
					
					// Reverb, implemented using a feedback delay network with a Hadamard matrix and lowpass filters.
					// good ratios:    0.555235 + 0.618033 + 0.818 +   1.0 = 2.991268
					// Delay lengths:  3041     + 3385     + 4481  +  5477 = 16384 = 2^14
					// Buffer offsets: 3041    -> 6426   -> 10907 -> 16384
					const reverbDelayPos1 = (reverbDelayPos +  3041) & reverbMask;
					const reverbDelayPos2 = (reverbDelayPos +  6426) & reverbMask;
					const reverbDelayPos3 = (reverbDelayPos + 10907) & reverbMask;
					const reverbSample0 = (reverbDelayLine[reverbDelayPos]);
					const reverbSample1 = reverbDelayLine[reverbDelayPos1];
					const reverbSample2 = reverbDelayLine[reverbDelayPos2];
					const reverbSample3 = reverbDelayLine[reverbDelayPos3];
					const reverbTemp0 = -(reverbSample0 + sampleL) + reverbSample1;
					const reverbTemp1 = -(reverbSample0 + sampleR) - reverbSample1;
					const reverbTemp2 = -reverbSample2 + reverbSample3;
					const reverbTemp3 = -reverbSample2 - reverbSample3;
					const reverbShelfInput0 = (reverbTemp0 + reverbTemp2) * reverb;
					const reverbShelfInput1 = (reverbTemp1 + reverbTemp3) * reverb;
					const reverbShelfInput2 = (reverbTemp0 - reverbTemp2) * reverb;
					const reverbShelfInput3 = (reverbTemp1 - reverbTemp3) * reverb;
					reverbShelfSample0 = reverbShelfB0 * reverbShelfInput0 + reverbShelfB1 * reverbShelfPrevInput0 - reverbShelfA1 * reverbShelfSample0;
					reverbShelfSample1 = reverbShelfB0 * reverbShelfInput1 + reverbShelfB1 * reverbShelfPrevInput1 - reverbShelfA1 * reverbShelfSample1;
					reverbShelfSample2 = reverbShelfB0 * reverbShelfInput2 + reverbShelfB1 * reverbShelfPrevInput2 - reverbShelfA1 * reverbShelfSample2;
					reverbShelfSample3 = reverbShelfB0 * reverbShelfInput3 + reverbShelfB1 * reverbShelfPrevInput3 - reverbShelfA1 * reverbShelfSample3;
					reverbShelfPrevInput0 = reverbShelfInput0;
					reverbShelfPrevInput1 = reverbShelfInput1;
					reverbShelfPrevInput2 = reverbShelfInput2;
					reverbShelfPrevInput3 = reverbShelfInput3;
					reverbDelayLine[reverbDelayPos1] = reverbShelfSample0 * delayInputMult;
					reverbDelayLine[reverbDelayPos2] = reverbShelfSample1 * delayInputMult;
					reverbDelayLine[reverbDelayPos3] = reverbShelfSample2 * delayInputMult;
					reverbDelayLine[reverbDelayPos ] = reverbShelfSample3 * delayInputMult;
					reverbDelayPos = (reverbDelayPos + 1) & reverbMask;
					sampleL += reverbSample1 + reverbSample2 + reverbSample3;
					sampleR += reverbSample0 + reverbSample2 - reverbSample3;
					reverb += reverbDelta;`;
                }
                effectsSource += `
					
					outputDataL[sampleIndex] += sampleL * mixVolume;
					outputDataR[sampleIndex] += sampleR * mixVolume;
					mixVolume += mixVolumeDelta;`;
                if (usesDelays) {
                    effectsSource += `
					
					delayInputMult += delayInputMultDelta;`;
                }
                effectsSource += `
				}
				
				// Avoid persistent denormal or NaN values in the delay buffers and filter history.
				const epsilon = (1.0e-24);`;
                if (usesDistortion) {
                    effectsSource += `
				
				if (!Number.isFinite(distortionFractionalInput1) || Math.abs(distortionFractionalInput1) < epsilon) distortionFractionalInput1 = 0.0;
				if (!Number.isFinite(distortionFractionalInput2) || Math.abs(distortionFractionalInput2) < epsilon) distortionFractionalInput2 = 0.0;
				if (!Number.isFinite(distortionFractionalInput3) || Math.abs(distortionFractionalInput3) < epsilon) distortionFractionalInput3 = 0.0;
				if (!Number.isFinite(distortionPrevInput) || Math.abs(distortionPrevInput) < epsilon) distortionPrevInput = 0.0;
				if (!Number.isFinite(distortionNextOutput) || Math.abs(distortionNextOutput) < epsilon) distortionNextOutput = 0.0;
				
				instrumentState.distortionFractionalInput1 = distortionFractionalInput1;
				instrumentState.distortionFractionalInput2 = distortionFractionalInput2;
				instrumentState.distortionFractionalInput3 = distortionFractionalInput3;
				instrumentState.distortionPrevInput = distortionPrevInput;
				instrumentState.distortionNextOutput = distortionNextOutput;`;
                }
                if (usesBitcrusher) {
                    effectsSource += `
					
				if (Math.abs(bitcrusherPrevInput) < epsilon) bitcrusherPrevInput = 0.0;
				if (Math.abs(bitcrusherCurrentOutput) < epsilon) bitcrusherCurrentOutput = 0.0;
				instrumentState.bitcrusherPrevInput = bitcrusherPrevInput;
				instrumentState.bitcrusherCurrentOutput = bitcrusherCurrentOutput;
				instrumentState.bitcrusherPhase = bitcrusherPhase;`;
                }
                
                if (usesRingModulation) {
                 effectsSource += ` 
                instrumentState.ringModMix = ringModMix;
instrumentState.ringModMixDelta = ringModMixDelta;
instrumentState.ringModPhase = ringModPhase;
instrumentState.ringModPhaseDelta = ringModPhaseDelta;
instrumentState.ringModPhaseDeltaScale = ringModPhaseDeltaScale;
instrumentState.ringModWaveformIndex = ringModWaveformIndex;
instrumentState.ringModPulseWidth = ringModPulseWidth;
instrumentState.ringModMixFade = ringModMixFade;
                 `;
                 
                }
                if (usesEqFilter) {
                    effectsSource += `
					
				synth.sanitizeFilters(filters);
				// The filter input here is downstream from another filter so we
				// better make sure it's safe too.
				if (!(initialFilterInput1 < 100) || !(initialFilterInput2 < 100)) {
					initialFilterInput1 = 0.0;
					initialFilterInput2 = 0.0;
				}
				if (Math.abs(initialFilterInput1) < epsilon) initialFilterInput1 = 0.0;
				if (Math.abs(initialFilterInput2) < epsilon) initialFilterInput2 = 0.0;
				instrumentState.initialEqFilterInput1 = initialFilterInput1;
				instrumentState.initialEqFilterInput2 = initialFilterInput2;`;
                }
                if (usesPanning) {
                    effectsSource += `
				
				beepbox.Synth.sanitizeDelayLine(panningDelayLine, panningDelayPos, panningMask);
				instrumentState.panningDelayPos = panningDelayPos;`;
                }
                if (usesChorus) {
                    effectsSource += `
				
				beepbox.Synth.sanitizeDelayLine(chorusDelayLineL, chorusDelayPos, chorusMask);
				beepbox.Synth.sanitizeDelayLine(chorusDelayLineR, chorusDelayPos, chorusMask);
				instrumentState.chorusPhase = chorusPhase;
				instrumentState.chorusDelayPos = chorusDelayPos;`;
                }
                if (usesEcho) {
                    effectsSource += `
				
				beepbox.Synth.sanitizeDelayLine(echoDelayLineL, echoDelayPos, echoMask);
				beepbox.Synth.sanitizeDelayLine(echoDelayLineR, echoDelayPos, echoMask);
				instrumentState.echoDelayPos = echoDelayPos;
				
				if (!Number.isFinite(echoShelfSampleL) || Math.abs(echoShelfSampleL) < epsilon) echoShelfSampleL = 0.0;
				if (!Number.isFinite(echoShelfSampleR) || Math.abs(echoShelfSampleR) < epsilon) echoShelfSampleR = 0.0;
				if (!Number.isFinite(echoShelfPrevInputL) || Math.abs(echoShelfPrevInputL) < epsilon) echoShelfPrevInputL = 0.0;
				if (!Number.isFinite(echoShelfPrevInputR) || Math.abs(echoShelfPrevInputR) < epsilon) echoShelfPrevInputR = 0.0;
				instrumentState.echoShelfSampleL = echoShelfSampleL;
				instrumentState.echoShelfSampleR = echoShelfSampleR;
				instrumentState.echoShelfPrevInputL = echoShelfPrevInputL;
				instrumentState.echoShelfPrevInputR = echoShelfPrevInputR;`;
                }
                if (usesReverb) {
                    effectsSource += `
				
				beepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos        , reverbMask);
				beepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  3041, reverbMask);
				beepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  6426, reverbMask);
				beepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos + 10907, reverbMask);
				instrumentState.reverbDelayPos  = reverbDelayPos;
				
				if (!Number.isFinite(reverbShelfSample0) || Math.abs(reverbShelfSample0) < epsilon) reverbShelfSample0 = 0.0;
				if (!Number.isFinite(reverbShelfSample1) || Math.abs(reverbShelfSample1) < epsilon) reverbShelfSample1 = 0.0;
				if (!Number.isFinite(reverbShelfSample2) || Math.abs(reverbShelfSample2) < epsilon) reverbShelfSample2 = 0.0;
				if (!Number.isFinite(reverbShelfSample3) || Math.abs(reverbShelfSample3) < epsilon) reverbShelfSample3 = 0.0;
				if (!Number.isFinite(reverbShelfPrevInput0) || Math.abs(reverbShelfPrevInput0) < epsilon) reverbShelfPrevInput0 = 0.0;
				if (!Number.isFinite(reverbShelfPrevInput1) || Math.abs(reverbShelfPrevInput1) < epsilon) reverbShelfPrevInput1 = 0.0;
				if (!Number.isFinite(reverbShelfPrevInput2) || Math.abs(reverbShelfPrevInput2) < epsilon) reverbShelfPrevInput2 = 0.0;
				if (!Number.isFinite(reverbShelfPrevInput3) || Math.abs(reverbShelfPrevInput3) < epsilon) reverbShelfPrevInput3 = 0.0;
				instrumentState.reverbShelfSample0 = reverbShelfSample0;
				instrumentState.reverbShelfSample1 = reverbShelfSample1;
				instrumentState.reverbShelfSample2 = reverbShelfSample2;
				instrumentState.reverbShelfSample3 = reverbShelfSample3;
				instrumentState.reverbShelfPrevInput0 = reverbShelfPrevInput0;
				instrumentState.reverbShelfPrevInput1 = reverbShelfPrevInput1;
				instrumentState.reverbShelfPrevInput2 = reverbShelfPrevInput2;
				instrumentState.reverbShelfPrevInput3 = reverbShelfPrevInput3;`;
                }
                effectsFunction = new Function("synth", "outputDataL", "outputDataR", "bufferIndex", "runLength", "instrument", "instrumentState", effectsSource);
                Synth.effectsFunctionCache[signature] = effectsFunction;
            }
            effectsFunction(synth, outputDataL, outputDataR, bufferIndex, runLength, instrument, instrumentState);
        }
        static pulseWidthSynth(synth, bufferIndex, runLength, tone, instrument) {
            const data = synth.tempMonoInstrumentSampleBuffer;
            let phaseDelta = tone.phaseDeltas[0];
            const phaseDeltaScale = +tone.phaseDeltaScales[0];
            let expression = +tone.expressionStarts[0];
            const expressionDelta = +tone.expressionDeltas[0];
            let phase = (tone.phases[0] % 1);
            let pulseWidth = tone.pulseWidth;
            const pulseWidthDelta = tone.pulseWidthDelta;
            const filters = tone.noteFilters;
            const filterCount = tone.noteFilterCount | 0;
            let initialFilterInput1 = +tone.initialNoteFilterInput1;
            let initialFilterInput2 = +tone.initialNoteFilterInput2;
            const applyFilters = Synth.applyFilters;
            const stopIndex = bufferIndex + runLength;
            for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
                const sawPhaseA = phase % 1;
                const sawPhaseB = (phase + pulseWidth) % 1;
                let pulseWave = sawPhaseB - sawPhaseA;
                if (!instrument.aliases) {
                    if (sawPhaseA < phaseDelta) {
                        var t = sawPhaseA / phaseDelta;
                        pulseWave += (t + t - t * t - 1) * 0.5;
                    }
                    else if (sawPhaseA > 1.0 - phaseDelta) {
                        var t = (sawPhaseA - 1.0) / phaseDelta;
                        pulseWave += (t + t + t * t + 1) * 0.5;
                    }
                    if (sawPhaseB < phaseDelta) {
                        var t = sawPhaseB / phaseDelta;
                        pulseWave -= (t + t - t * t - 1) * 0.5;
                    }
                    else if (sawPhaseB > 1.0 - phaseDelta) {
                        var t = (sawPhaseB - 1.0) / phaseDelta;
                        pulseWave -= (t + t + t * t + 1) * 0.5;
                    }
                }
                const inputSample = pulseWave;
                const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
                initialFilterInput2 = initialFilterInput1;
                initialFilterInput1 = inputSample;
                phase += phaseDelta;
                phaseDelta *= phaseDeltaScale;
                pulseWidth += pulseWidthDelta;
                const output = sample * expression;
                expression += expressionDelta;
                data[sampleIndex] += output;
            }
            tone.phases[0] = phase;
            synth.sanitizeFilters(filters);
            tone.initialNoteFilterInput1 = initialFilterInput1;
            tone.initialNoteFilterInput2 = initialFilterInput2;
        }
        static noiseSynth(synth, bufferIndex, runLength, tone, instrument) {
            const data = synth.tempMonoInstrumentSampleBuffer;
            let wave = instrument.getDrumWave();
            let phaseDelta = +tone.phaseDeltas[0];
            const phaseDeltaScale = +tone.phaseDeltaScales[0];
            let expression = +tone.expressionStarts[0];
            const expressionDelta = +tone.expressionDeltas[0];
            let phase = (tone.phases[0] % 1) * Config.chipNoiseLength;
            if (tone.phases[0] == 0) {
                phase = Math.random() * Config.chipNoiseLength;
            }
            const phaseMask = Config.chipNoiseLength - 1;
            let noiseSample = +tone.sample;
            const filters = tone.noteFilters;
            const filterCount = tone.noteFilterCount | 0;
            let initialFilterInput1 = +tone.initialNoteFilterInput1;
            let initialFilterInput2 = +tone.initialNoteFilterInput2;
            const applyFilters = Synth.applyFilters;
            const pitchRelativefilter = Math.min(1.0, tone.phaseDeltas[0] * Config.chipNoises[instrument.chipNoise].pitchFilterMult);
            const stopIndex = bufferIndex + runLength;
            for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
                const waveSample = wave[phase & phaseMask];
                noiseSample += (waveSample - noiseSample) * pitchRelativefilter;
                const inputSample = noiseSample;
                const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
                initialFilterInput2 = initialFilterInput1;
                initialFilterInput1 = inputSample;
                phase += phaseDelta;
                phaseDelta *= phaseDeltaScale;
                const output = sample * expression;
                expression += expressionDelta;
                data[sampleIndex] += output;
            }
            tone.phases[0] = phase / Config.chipNoiseLength;
            tone.sample = noiseSample;
            synth.sanitizeFilters(filters);
            tone.initialNoteFilterInput1 = initialFilterInput1;
            tone.initialNoteFilterInput2 = initialFilterInput2;
        }
        static spectrumSynth(synth, bufferIndex, runLength, tone, instrument) {
            const data = synth.tempMonoInstrumentSampleBuffer;
            let wave = instrument.getDrumWave();
            let phaseDelta = tone.phaseDeltas[0] * (1 << 7);
            const phaseDeltaScale = +tone.phaseDeltaScales[0];
            let expression = +tone.expressionStarts[0];
            const expressionDelta = +tone.expressionDeltas[0];
            let noiseSample = +tone.sample;
            const filters = tone.noteFilters;
            const filterCount = tone.noteFilterCount | 0;
            let initialFilterInput1 = +tone.initialNoteFilterInput1;
            let initialFilterInput2 = +tone.initialNoteFilterInput2;
            const applyFilters = Synth.applyFilters;
            let phase = (tone.phases[0] % 1) * Config.spectrumNoiseLength;
            if (tone.phases[0] == 0)
                phase = Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) + phaseDelta;
            const phaseMask = Config.spectrumNoiseLength - 1;
            const pitchRelativefilter = Math.min(1.0, phaseDelta);
            const stopIndex = bufferIndex + runLength;
            for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
                const phaseInt = phase | 0;
                const index = phaseInt & phaseMask;
                let waveSample = wave[index];
                const phaseRatio = phase - phaseInt;
                waveSample += (wave[index + 1] - waveSample) * phaseRatio;
                noiseSample += (waveSample - noiseSample) * pitchRelativefilter;
                const inputSample = noiseSample;
                const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
                initialFilterInput2 = initialFilterInput1;
                initialFilterInput1 = inputSample;
                phase += phaseDelta;
                phaseDelta *= phaseDeltaScale;
                const output = sample * expression;
                expression += expressionDelta;
                data[sampleIndex] += output;
            }
            tone.phases[0] = phase / Config.spectrumNoiseLength;
            tone.sample = noiseSample;
            synth.sanitizeFilters(filters);
            tone.initialNoteFilterInput1 = initialFilterInput1;
            tone.initialNoteFilterInput2 = initialFilterInput2;
        }
        static drumsetSynth(synth, bufferIndex, runLength, tone, instrument) {
            const data = synth.tempMonoInstrumentSampleBuffer;
            let wave = instrument.getDrumsetWave(tone.drumsetPitch);
            let phaseDelta = tone.phaseDeltas[0] / Instrument.drumsetIndexReferenceDelta(tone.drumsetPitch);
            const phaseDeltaScale = +tone.phaseDeltaScales[0];
            let expression = +tone.expressionStarts[0];
            const expressionDelta = +tone.expressionDeltas[0];
            const filters = tone.noteFilters;
            const filterCount = tone.noteFilterCount | 0;
            let initialFilterInput1 = +tone.initialNoteFilterInput1;
            let initialFilterInput2 = +tone.initialNoteFilterInput2;
            const applyFilters = Synth.applyFilters;
            let phase = (tone.phases[0] % 1) * Config.spectrumNoiseLength;
            if (tone.phases[0] == 0)
                phase = Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) + phaseDelta;
            const phaseMask = Config.spectrumNoiseLength - 1;
            const stopIndex = bufferIndex + runLength;
            for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
                const phaseInt = phase | 0;
                const index = phaseInt & phaseMask;
                let noiseSample = wave[index];
                const phaseRatio = phase - phaseInt;
                noiseSample += (wave[index + 1] - noiseSample) * phaseRatio;
                const inputSample = noiseSample;
                const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
                initialFilterInput2 = initialFilterInput1;
                initialFilterInput1 = inputSample;
                phase += phaseDelta;
                phaseDelta *= phaseDeltaScale;
                const output = sample * expression;
                expression += expressionDelta;
                data[sampleIndex] += output;
            }
            tone.phases[0] = phase / Config.spectrumNoiseLength;
            synth.sanitizeFilters(filters);
            tone.initialNoteFilterInput1 = initialFilterInput1;
            tone.initialNoteFilterInput2 = initialFilterInput2;
        }
        static modSynth(synth, stereoBufferIndex, runLength, tone, instrument) {
            if (!synth.song)
                return;
            let mod = Config.modCount - 1 - tone.pitches[0];
            if (instrument.invalidModulators[mod])
                return;
            let setting = instrument.modulators[mod];
            let usedInstruments = [];
            if (Config.modulators[instrument.modulators[mod]].forSong) {
                usedInstruments.push(0);
            }
            else {
                if (instrument.modInstruments[mod] == synth.song.channels[instrument.modChannels[mod]].instruments.length) {
                    for (let i = 0; i < synth.song.channels[instrument.modChannels[mod]].instruments.length; i++) {
                        usedInstruments.push(i);
                    }
                }
                else if (instrument.modInstruments[mod] > synth.song.channels[instrument.modChannels[mod]].instruments.length) {
                    if (synth.song.getPattern(instrument.modChannels[mod], synth.bar) != null)
                        usedInstruments = synth.song.getPattern(instrument.modChannels[mod], synth.bar).instruments;
                }
                else {
                    usedInstruments.push(instrument.modInstruments[mod]);
                }
            }
            for (let instrumentIndex = 0; instrumentIndex < usedInstruments.length; instrumentIndex++) {
                synth.setModValue(tone.expressionStarts[0], tone.expressionStarts[0] + tone.expressionDeltas[0], mod, instrument.modChannels[mod], usedInstruments[instrumentIndex], setting);
                if (setting == Config.modulators.dictionary["reset arp"].index && synth.tick == 0 && tone.noteStartPart == synth.beat * Config.partsPerBeat + synth.part) {
                    synth.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]].arpTime = 0;
                }
                else if (setting == Config.modulators.dictionary["next bar"].index) {
                    synth.wantToSkip = true;
                }
                else if (setting == Config.modulators.dictionary["eq filter"].index && !instrument.eqFilterType) {
                    let dotTarget = instrument.modFilterTypes[mod];
                    const tgtInstrument = synth.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];
                    if (dotTarget == 0) {
                        let pinIdx = 0;
                        const currentPart = synth.getTicksIntoBar() / Config.ticksPerPart;
                        while (tone.note.start + tone.note.pins[pinIdx].time <= currentPart)
                            pinIdx++;
                        let lerpEndRatio = ((currentPart + (runLength / (synth.getSamplesPerTick() * Config.ticksPerPart)) * Config.ticksPerPart) - tone.note.pins[pinIdx - 1].time) / (tone.note.pins[pinIdx].time - tone.note.pins[pinIdx - 1].time);
                        if (tgtInstrument.eqSubFilters[tone.note.pins[pinIdx - 1].size] != null || tgtInstrument.eqSubFilters[tone.note.pins[pinIdx].size] != null) {
                            tgtInstrument.tmpEqFilterEnd = FilterSettings.lerpFilters(tgtInstrument.eqSubFilters[tone.note.pins[pinIdx - 1].size], tgtInstrument.eqSubFilters[tone.note.pins[pinIdx].size], lerpEndRatio);
                        }
                        else {
                            tgtInstrument.tmpEqFilterEnd = tgtInstrument.eqFilter;
                        }
                    }
                    else {
                        for (let i = 0; i < Config.filterMorphCount; i++) {
                            if (tgtInstrument.tmpEqFilterEnd == tgtInstrument.eqSubFilters[i] && tgtInstrument.tmpEqFilterEnd != null) {
                                tgtInstrument.tmpEqFilterEnd = new FilterSettings();
                                tgtInstrument.tmpEqFilterEnd.fromJsonObject(tgtInstrument.eqSubFilters[i].toJsonObject());
                            }
                        }
                        if (tgtInstrument.tmpEqFilterEnd == null) {
                            tgtInstrument.tmpEqFilterEnd = new FilterSettings();
                            tgtInstrument.tmpEqFilterEnd.fromJsonObject(tgtInstrument.eqFilter.toJsonObject());
                        }
                        if (tgtInstrument.tmpEqFilterEnd.controlPointCount > Math.floor((dotTarget - 1) / 2)) {
                            if (dotTarget % 2) {
                                tgtInstrument.tmpEqFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].freq = tone.expressionStarts[0] + tone.expressionDeltas[0];
                            }
                            else {
                                tgtInstrument.tmpEqFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].gain = tone.expressionStarts[0] + tone.expressionDeltas[0];
                            }
                        }
                    }
                }
                else if (setting == Config.modulators.dictionary["note filter"].index && !instrument.noteFilterType) {
                    let dotTarget = instrument.modFilterTypes[mod];
                    const tgtInstrument = synth.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];
                    if (dotTarget == 0) {
                        let pinIdx = 0;
                        const currentPart = synth.getTicksIntoBar() / Config.ticksPerPart;
                        while (tone.note.start + tone.note.pins[pinIdx].time <= currentPart)
                            pinIdx++;
                        let lerpEndRatio = ((currentPart + (runLength / (synth.getSamplesPerTick() * Config.ticksPerPart)) * Config.ticksPerPart) - tone.note.pins[pinIdx - 1].time) / (tone.note.pins[pinIdx].time - tone.note.pins[pinIdx - 1].time);
                        if (tgtInstrument.noteSubFilters[tone.note.pins[pinIdx - 1].size] != null || tgtInstrument.noteSubFilters[tone.note.pins[pinIdx].size] != null) {
                            tgtInstrument.tmpNoteFilterEnd = FilterSettings.lerpFilters(tgtInstrument.noteSubFilters[tone.note.pins[pinIdx - 1].size], tgtInstrument.noteSubFilters[tone.note.pins[pinIdx].size], lerpEndRatio);
                        }
                        else {
                            tgtInstrument.tmpNoteFilterEnd = tgtInstrument.noteFilter;
                        }
                    }
                    else {
                        for (let i = 0; i < Config.filterMorphCount; i++) {
                            if (tgtInstrument.tmpNoteFilterEnd == tgtInstrument.noteSubFilters[i] && tgtInstrument.tmpNoteFilterEnd != null) {
                                tgtInstrument.tmpNoteFilterEnd = new FilterSettings();
                                tgtInstrument.tmpNoteFilterEnd.fromJsonObject(tgtInstrument.noteSubFilters[i].toJsonObject());
                            }
                        }
                        if (tgtInstrument.tmpNoteFilterEnd == null) {
                            tgtInstrument.tmpNoteFilterEnd = new FilterSettings();
                            tgtInstrument.tmpNoteFilterEnd.fromJsonObject(tgtInstrument.noteFilter.toJsonObject());
                        }
                        if (tgtInstrument.tmpNoteFilterEnd.controlPointCount > Math.floor((dotTarget - 1) / 2)) {
                            if (dotTarget % 2) {
                                tgtInstrument.tmpNoteFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].freq = tone.expressionStarts[0] + tone.expressionDeltas[0];
                            }
                            else {
                                tgtInstrument.tmpNoteFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].gain = tone.expressionStarts[0] + tone.expressionDeltas[0];
                            }
                        }
                    }
                }
            }
        }
        static findRandomZeroCrossing(wave, waveLength) {
            let phase = Math.random() * waveLength;
            const phaseMask = waveLength - 1;
            let indexPrev = phase & phaseMask;
            let wavePrev = wave[indexPrev];
            const stride = 16;
            for (let attemptsRemaining = 128; attemptsRemaining > 0; attemptsRemaining--) {
                const indexNext = (indexPrev + stride) & phaseMask;
                const waveNext = wave[indexNext];
                if (wavePrev * waveNext <= 0.0) {
                    for (let i = 0; i < stride; i++) {
                        const innerIndexNext = (indexPrev + 1) & phaseMask;
                        const innerWaveNext = wave[innerIndexNext];
                        if (wavePrev * innerWaveNext <= 0.0) {
                            const slope = innerWaveNext - wavePrev;
                            phase = indexPrev;
                            if (Math.abs(slope) > 0.00000001) {
                                phase += -wavePrev / slope;
                            }
                            phase = Math.max(0, phase) % waveLength;
                            break;
                        }
                        else {
                            indexPrev = innerIndexNext;
                            wavePrev = innerWaveNext;
                        }
                    }
                    break;
                }
                else {
                    indexPrev = indexNext;
                    wavePrev = waveNext;
                }
            }
            return phase;
        }
        static instrumentVolumeToVolumeMult(instrumentVolume) {
            return (instrumentVolume == -Config.volumeRange / 2.0) ? 0.0 : Math.pow(2, Config.volumeLogScale * instrumentVolume);
        }
        static volumeMultToInstrumentVolume(volumeMult) {
            return (volumeMult <= 0.0) ? -Config.volumeRange / 2 : Math.min(Config.volumeRange, (Math.log(volumeMult) / Math.LN2) / Config.volumeLogScale);
        }
        static noteSizeToVolumeMult(size) {
            return Math.pow(Math.max(0.0, size) / Config.noteSizeMax, 1.5);
        }
        static volumeMultToNoteSize(volumeMult) {
            return Math.pow(Math.max(0.0, volumeMult), 1 / 1.5) * Config.noteSizeMax;
        }
        static fadeInSettingToSeconds(setting) {
            return 0.0125 * (0.95 * setting + 0.05 * setting * setting);
        }
        static secondsToFadeInSetting(seconds) {
            return clamp(0, Config.fadeInRange, Math.round((-0.95 + Math.sqrt(0.9025 + 0.2 * seconds / 0.0125)) / 0.1));
        }
        static fadeOutSettingToTicks(setting) {
            return Config.fadeOutTicks[setting];
        }
        static ticksToFadeOutSetting(ticks) {
            let lower = Config.fadeOutTicks[0];
            if (ticks <= lower)
                return 0;
            for (let i = 1; i < Config.fadeOutTicks.length; i++) {
                let upper = Config.fadeOutTicks[i];
                if (ticks <= upper)
                    return (ticks < (lower + upper) / 2) ? i - 1 : i;
                lower = upper;
            }
            return Config.fadeOutTicks.length - 1;
        }
        static detuneToCents(detune) {
            return detune - Config.detuneCenter;
        }
        static centsToDetune(cents) {
            return cents + Config.detuneCenter;
        }
        static getOperatorWave(waveform, pulseWidth) {
	if (waveform != 2) {
		return Config.operatorWaves[waveform];
	}
	else {
		return Config.pwmOperatorWaves[pulseWidth];
	}
}
        
        getSamplesPerTick() {
            if (this.song == null)
                return 0;
            let beatsPerMinute = this.song.getBeatsPerMinute();
            if (this.isModActive(Config.modulators.dictionary["tempo"].index)) {
                beatsPerMinute = this.getModValue(Config.modulators.dictionary["tempo"].index);
            }
            return this.getSamplesPerTickSpecificBPM(beatsPerMinute);
        }
        getSamplesPerTickSpecificBPM(beatsPerMinute) {
            const beatsPerSecond = beatsPerMinute / 60.0;
            const partsPerSecond = Config.partsPerBeat * beatsPerSecond;
            const tickPerSecond = Config.ticksPerPart * partsPerSecond;
            return this.samplesPerSecond / tickPerSecond;
        }
        static fittingPowerOfTwo(x) {
            return 1 << (32 - Math.clz32(Math.ceil(x) - 1));
        }
        sanitizeFilters(filters) {
            let reset = false;
            for (const filter of filters) {
                const output1 = Math.abs(filter.output1);
                const output2 = Math.abs(filter.output2);
                if (!(output1 < 100) || !(output2 < 100)) {
                    reset = true;
                    break;
                }
                if (output1 < epsilon)
                    filter.output1 = 0.0;
                if (output2 < epsilon)
                    filter.output2 = 0.0;
            }
            if (reset) {
                for (const filter of filters) {
                    filter.output1 = 0.0;
                    filter.output2 = 0.0;
                }
            }
        }
        static sanitizeDelayLine(delayLine, lastIndex, mask) {
            while (true) {
                lastIndex--;
                const index = lastIndex & mask;
                const sample = Math.abs(delayLine[index]);
                if (Number.isFinite(sample) && (sample == 0.0 || sample >= epsilon))
                    break;
                delayLine[index] = 0.0;
            }
        }
        static applyFilters(sample, input1, input2, filterCount, filters) {
            for (let i = 0; i < filterCount; i++) {
                const filter = filters[i];
                const output1 = filter.output1;
                const output2 = filter.output2;
                const a1 = filter.a1;
                const a2 = filter.a2;
                const b0 = filter.b0;
                const b1 = filter.b1;
                const b2 = filter.b2;
                sample = b0 * sample + b1 * input1 + b2 * input2 - a1 * output1 - a2 * output2;
                filter.a1 = a1 + filter.a1Delta;
                filter.a2 = a2 + filter.a2Delta;
                if (filter.useMultiplicativeInputCoefficients) {
                    filter.b0 = b0 * filter.b0Delta;
                    filter.b1 = b1 * filter.b1Delta;
                    filter.b2 = b2 * filter.b2Delta;
                }
                else {
                    filter.b0 = b0 + filter.b0Delta;
                    filter.b1 = b1 + filter.b1Delta;
                    filter.b2 = b2 + filter.b2Delta;
                }
                filter.output2 = output1;
                filter.output1 = sample;
                input2 = output2;
                input1 = output1;
            }
            return sample;
        }
    }
    Synth.tempFilterStartCoefficients = new FilterCoefficients();
    Synth.tempFilterEndCoefficients = new FilterCoefficients();
    Synth.fmSynthFunctionCache = {};
    Synth.effectsFunctionCache = Array(1 << 7).fill(undefined);
    Synth.pickedStringFunctionCache = Array(3).fill(undefined);
    Synth.loopableChipFunctionCache = Array(Config.unisonVoicesMax + 1).fill([]);
    Synth.fmSourceTemplate = (`
		const data = synth.tempMonoInstrumentSampleBuffer;
			const sineWave = beepbox.Config.sineWave;
			
			// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.
			let operator#Phase       = +((tone.phases[#] % 1) + 1000) * beepbox.Config.sineWaveLength;
			let operator#PhaseDelta  = + tone.phaseDeltas[#];
		let operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];
		let operator#OutputMult  = +tone.expressionStarts[#];
		const operator#OutputDelta = +tone.expressionDeltas[#];
			let operator#Output      = +tone.feedbackOutputs[#];
			let feedbackMult         = +tone.feedbackMult;
			const feedbackDelta        = +tone.feedbackDelta;
		
		const filters = tone.noteFilters;
		const filterCount = tone.noteFilterCount|0;
		let initialFilterInput1 = +tone.initialNoteFilterInput1;
		let initialFilterInput2 = +tone.initialNoteFilterInput2;
		const applyFilters = beepbox.Synth.applyFilters;
		
		const stopIndex = bufferIndex + runLength;
		for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
				// INSERT OPERATOR COMPUTATION HERE
				const fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS
				
			const inputSample = fmOutput;
			const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
			initialFilterInput2 = initialFilterInput1;
			initialFilterInput1 = inputSample;
				
				feedbackMult += feedbackDelta;
				operator#OutputMult += operator#OutputDelta;
				operator#Phase += operator#PhaseDelta;
			operator#PhaseDelta *= operator#PhaseDeltaScale;
			
				
//const absStereoDelay: number = Math.abs(stereoDelay);
//const fracStereoDelay: number = absStereoDelay % 1;
//const floorStereoDelay: number = absStereoDelay | 0;

//delays = stereoDelay < 0 ? [0, 0, floorStereoDelay * 2, fracStereoDelay] : [floorStereoDelay * 2, fracStereoDelay, 0, 0];

// Optimized ver: can remove the above three declarations, but muddier conceptually. Still has that conditional, too...
			data[sampleIndex] += sample;
			}
			
			tone.phases[#] = operator#Phase / ` + Config.sineWaveLength + `;
			tone.feedbackOutputs[#] = operator#Output;
			
		synth.sanitizeFilters(filters);
		tone.initialNoteFilterInput1 = initialFilterInput1;
		tone.initialNoteFilterInput2 = initialFilterInput2;
		`).split("\n");
    Synth.operatorSourceTemplate = (`
const operator#Wave     = beepbox.Synth.getOperatorWave(instrument.operators[#].waveform, instrument.operators[#].pulseWidth).samples;
				const operator#PhaseMix = operator#Phase/* + operator@Scaled*/;
				const operator#PhaseInt = operator#PhaseMix|0;
				const operator#Index    = operator#PhaseInt & ` + Config.sineWaveMask + `;
const operator#Sample   = operator#Wave[operator#Index];
operator#Output       = operator#Sample + (operator#Wave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);
				const operator#Scaled   = operator#OutputMult * operator#Output;
		`).split("\n");

    class Change {
        constructor() {
            this._noop = true;
        }
        _didSomething() {
            this._noop = false;
        }
        isNoop() {
	return this._noop;
}
        commit() { }
    }
    class UndoableChange extends Change {
        constructor(reversed) {
            super();
            this._reversed = reversed;
            this._doneForwards = !reversed;
        }
        undo() {
            if (this._reversed) {
                this._doForwards();
                this._doneForwards = true;
            }
            else {
                this._doBackwards();
                this._doneForwards = false;
            }
        }
        redo() {
            if (this._reversed) {
                this._doBackwards();
                this._doneForwards = false;
            }
            else {
                this._doForwards();
                this._doneForwards = true;
            }
        }
        _isDoneForwards() {
            return this._doneForwards;
        }
        _doForwards() {
            throw new Error("Change.doForwards(): Override me.");
        }
        _doBackwards() {
            throw new Error("Change.doBackwards(): Override me.");
        }
    }
    class ChangeGroup extends Change {
        constructor() {
            super();
        }
        append(change) {
            if (change.isNoop())
                return;
            this._didSomething();
        }
    }
    class ChangeSequence extends UndoableChange {
        constructor(changes) {
            super(false);
            if (changes == undefined) {
                this._changes = [];
            }
            else {
                this._changes = changes.concat();
            }
        }
        append(change) {
            if (change.isNoop())
                return;
            this._changes[this._changes.length] = change;
            this._didSomething();
        }
        _doForwards() {
            for (let i = 0; i < this._changes.length; i++) {
                this._changes[i].redo();
            }
        }
        _doBackwards() {
            for (let i = this._changes.length - 1; i >= 0; i--) {
                this._changes[i].undo();
            }
        }
    }

    function patternsContainSameInstruments(pattern1Instruments, pattern2Instruments) {
        const pattern2Has1Instruments = pattern1Instruments.every(instrument => pattern2Instruments.indexOf(instrument) != -1);
        const pattern1Has2Instruments = pattern2Instruments.every(instrument => pattern1Instruments.indexOf(instrument) != -1);
        return pattern2Has1Instruments && pattern1Has2Instruments && pattern2Instruments.length == pattern1Instruments.length;
    }
    function discardInvalidPatternInstruments(instruments, song, channelIndex) {
        const uniqueInstruments = new Set(instruments);
        instruments.length = 0;
        instruments.push(...uniqueInstruments);
        for (let i = 0; i < instruments.length; i++) {
            if (instruments[i] >= song.channels[channelIndex].instruments.length) {
                instruments.splice(i, 1);
                i--;
            }
        }
        if (instruments.length > song.getMaxInstrumentsPerPattern(channelIndex)) {
            instruments.length = song.getMaxInstrumentsPerPattern(channelIndex);
        }
        if (instruments.length <= 0) {
            instruments[0] = 0;
        }
    }
    function unionOfUsedNotes(pattern, flags) {
        for (const note of pattern.notes) {
            for (const pitch of note.pitches) {
                for (const pin of note.pins) {
                    const key = (pitch + pin.interval) % 12;
                    if (!flags[key]) {
                        flags[key] = true;
                    }
                }
            }
        }
    }
    function generateScaleMap(oldScaleFlags, newScaleValue) {
        const newScaleFlags = Config.scales[newScaleValue].flags;
        const oldScale = [];
        const newScale = [];
        for (let i = 0; i < 12; i++) {
            if (oldScaleFlags[i])
                oldScale.push(i);
            if (newScaleFlags[i])
                newScale.push(i);
        }
        const largerToSmaller = oldScale.length > newScale.length;
        const smallerScale = largerToSmaller ? newScale : oldScale;
        const largerScale = largerToSmaller ? oldScale : newScale;
        const roles = ["root", "second", "second", "third", "third", "fourth", "tritone", "fifth", "sixth", "sixth", "seventh", "seventh", "root"];
        let bestScore = Number.MAX_SAFE_INTEGER;
        let bestIndexMap = [];
        const stack = [[0]];
        while (stack.length > 0) {
            const indexMap = stack.pop();
            if (indexMap.length == smallerScale.length) {
                let score = 0;
                for (let i = 0; i < indexMap.length; i++) {
                    score += Math.abs(smallerScale[i] - largerScale[indexMap[i]]);
                    if (roles[smallerScale[i]] != roles[largerScale[indexMap[i]]]) {
                        score += 0.75;
                    }
                }
                if (bestScore > score) {
                    bestScore = score;
                    bestIndexMap = indexMap;
                }
            }
            else {
                const lowIndex = indexMap[indexMap.length - 1] + 1;
                const highIndex = largerScale.length - smallerScale.length + indexMap.length;
                for (let i = lowIndex; i <= highIndex; i++) {
                    stack.push(indexMap.concat(i));
                }
            }
        }
        const sparsePitchMap = [];
        for (let i = 0; i < bestIndexMap.length; i++) {
            const smallerScalePitch = smallerScale[i];
            const largerScalePitch = largerScale[bestIndexMap[i]];
            sparsePitchMap[i] = largerToSmaller
                ? [largerScalePitch, smallerScalePitch]
                : [smallerScalePitch, largerScalePitch];
        }
        sparsePitchMap.push([12, 12]);
        newScale.push(12);
        let sparseIndex = 0;
        const fullPitchMap = [];
        for (let i = 0; i < 12; i++) {
            const oldLow = sparsePitchMap[sparseIndex][0];
            const newLow = sparsePitchMap[sparseIndex][1];
            const oldHigh = sparsePitchMap[sparseIndex + 1][0];
            const newHigh = sparsePitchMap[sparseIndex + 1][1];
            if (i == oldHigh - 1)
                sparseIndex++;
            const transformedPitch = (i - oldLow) * (newHigh - newLow) / (oldHigh - oldLow) + newLow;
            let nearestPitch = 0;
            let nearestPitchDistance = Number.MAX_SAFE_INTEGER;
            for (const newPitch of newScale) {
                let distance = Math.abs(newPitch - transformedPitch);
                if (roles[newPitch] != roles[i]) {
                    distance += 0.1;
                }
                if (nearestPitchDistance > distance) {
                    nearestPitchDistance = distance;
                    nearestPitch = newPitch;
                }
            }
            fullPitchMap[i] = nearestPitch;
        }
        return fullPitchMap;
    }
    function removeRedundantPins(pins) {
        for (let i = 1; i < pins.length - 1;) {
            if (pins[i - 1].interval == pins[i].interval &&
                pins[i].interval == pins[i + 1].interval &&
                pins[i - 1].size == pins[i].size &&
                pins[i].size == pins[i + 1].size) {
                pins.splice(i, 1);
            }
            else {
                i++;
            }
        }
    }
    function projectNoteIntoBar(oldNote, timeOffset, noteStartPart, noteEndPart, newNotes) {
        const newNote = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, false);
        newNote.pins.length = 0;
        newNote.pitches.length = 0;
        const newNoteLength = noteEndPart - noteStartPart;
        for (const pitch of oldNote.pitches) {
            newNote.pitches.push(pitch);
        }
        for (let pinIndex = 0; pinIndex < oldNote.pins.length; pinIndex++) {
            const pin = oldNote.pins[pinIndex];
            const newPinTime = pin.time + timeOffset;
            if (newPinTime < 0) {
                if (pinIndex + 1 >= oldNote.pins.length)
                    throw new Error("Error converting pins in note overflow.");
                const nextPin = oldNote.pins[pinIndex + 1];
                const nextPinTime = nextPin.time + timeOffset;
                if (nextPinTime > 0) {
                    const ratio = (-newPinTime) / (nextPinTime - newPinTime);
                    newNote.pins.push(makeNotePin(Math.round(pin.interval + ratio * (nextPin.interval - pin.interval)), 0, Math.round(pin.size + ratio * (nextPin.size - pin.size))));
                }
            }
            else if (newPinTime <= newNoteLength) {
                newNote.pins.push(makeNotePin(pin.interval, newPinTime, pin.size));
            }
            else {
                if (pinIndex < 1)
                    throw new Error("Error converting pins in note overflow.");
                const prevPin = oldNote.pins[pinIndex - 1];
                const prevPinTime = prevPin.time + timeOffset;
                if (prevPinTime < newNoteLength) {
                    const ratio = (newNoteLength - prevPinTime) / (newPinTime - prevPinTime);
                    newNote.pins.push(makeNotePin(Math.round(prevPin.interval + ratio * (pin.interval - prevPin.interval)), newNoteLength, Math.round(prevPin.size + ratio * (pin.size - prevPin.size))));
                }
            }
        }
        const offsetInterval = newNote.pins[0].interval;
        for (let pitchIdx = 0; pitchIdx < newNote.pitches.length; pitchIdx++) {
            newNote.pitches[pitchIdx] += offsetInterval;
        }
        for (let pinIdx = 0; pinIdx < newNote.pins.length; pinIdx++) {
            newNote.pins[pinIdx].interval -= offsetInterval;
        }
        let joinedWithPrevNote = false;
        if (newNote.start == 0) {
            newNote.continuesLastPattern = (timeOffset < 0 || oldNote.continuesLastPattern);
        }
        else {
            newNote.continuesLastPattern = false;
            if (newNotes.length > 0 && oldNote.continuesLastPattern) {
                const prevNote = newNotes[newNotes.length - 1];
                if (prevNote.end == newNote.start && Synth.adjacentNotesHaveMatchingPitches(prevNote, newNote)) {
                    joinedWithPrevNote = true;
                    const newIntervalOffset = prevNote.pins[prevNote.pins.length - 1].interval;
                    const newTimeOffset = prevNote.end - prevNote.start;
                    for (let pinIndex = 1; pinIndex < newNote.pins.length; pinIndex++) {
                        const tempPin = newNote.pins[pinIndex];
                        const transformedPin = makeNotePin(tempPin.interval + newIntervalOffset, tempPin.time + newTimeOffset, tempPin.size);
                        prevNote.pins.push(transformedPin);
                        prevNote.end = prevNote.start + transformedPin.time;
                    }
                    removeRedundantPins(prevNote.pins);
                }
            }
        }
        if (!joinedWithPrevNote) {
            newNotes.push(newNote);
        }
    }
    class ChangeMoveAndOverflowNotes extends ChangeGroup {
        constructor(doc, newBeatsPerBar, partsToMove) {
            super();
            const pitchChannels = [];
            const noiseChannels = [];
            const modChannels = [];
            for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                const oldChannel = doc.song.channels[channelIndex];
                const newChannel = new Channel();
                if (channelIndex < doc.song.pitchChannelCount) {
                    pitchChannels.push(newChannel);
                }
                else if (channelIndex < doc.song.pitchChannelCount + doc.song.noiseChannelCount) {
                    noiseChannels.push(newChannel);
                }
                else {
                    modChannels.push(newChannel);
                }
                newChannel.muted = oldChannel.muted;
                newChannel.octave = oldChannel.octave;
                newChannel.name = oldChannel.name;
                for (const instrument of oldChannel.instruments) {
                    newChannel.instruments.push(instrument);
                }
                const oldPartsPerBar = Config.partsPerBeat * doc.song.beatsPerBar;
                const newPartsPerBar = Config.partsPerBeat * newBeatsPerBar;
                let currentBar = -1;
                let pattern = null;
                for (let oldBar = 0; oldBar < doc.song.barCount; oldBar++) {
                    const oldPattern = doc.song.getPattern(channelIndex, oldBar);
                    if (oldPattern != null) {
                        const oldBarStart = oldBar * oldPartsPerBar;
                        for (const oldNote of oldPattern.notes) {
                            const absoluteNoteStart = oldNote.start + oldBarStart + partsToMove;
                            const absoluteNoteEnd = oldNote.end + oldBarStart + partsToMove;
                            const startBar = Math.floor(absoluteNoteStart / newPartsPerBar);
                            const endBar = Math.ceil(absoluteNoteEnd / newPartsPerBar);
                            for (let bar = startBar; bar < endBar; bar++) {
                                const barStartPart = bar * newPartsPerBar;
                                const noteStartPart = Math.max(0, absoluteNoteStart - barStartPart);
                                const noteEndPart = Math.min(newPartsPerBar, absoluteNoteEnd - barStartPart);
                                if (noteStartPart < noteEndPart) {
                                    if (currentBar < bar || pattern == null) {
                                        currentBar++;
                                        while (currentBar < bar) {
                                            newChannel.bars[currentBar] = 0;
                                            currentBar++;
                                        }
                                        pattern = new Pattern();
                                        newChannel.patterns.push(pattern);
                                        newChannel.bars[currentBar] = newChannel.patterns.length;
                                        pattern.instruments.length = 0;
                                        pattern.instruments.push(...oldPattern.instruments);
                                    }
                                    pattern = newChannel.patterns[newChannel.bars[bar] - 1];
                                    projectNoteIntoBar(oldNote, absoluteNoteStart - barStartPart - noteStartPart, noteStartPart, noteEndPart, pattern.notes);
                                }
                            }
                        }
                    }
                }
            }
            removeDuplicatePatterns(pitchChannels);
            removeDuplicatePatterns(noiseChannels);
            removeDuplicatePatterns(modChannels);
            this.append(new ChangeReplacePatterns(doc, pitchChannels, noiseChannels, modChannels));
        }
    }
    class ChangePins extends UndoableChange {
        constructor(_doc, _note) {
            super(false);
            this._doc = _doc;
            this._note = _note;
            this._oldStart = this._note.start;
            this._oldEnd = this._note.end;
            this._newStart = this._note.start;
            this._newEnd = this._note.end;
            this._oldPins = this._note.pins;
            this._newPins = [];
            this._oldPitches = this._note.pitches;
            this._newPitches = [];
            this._oldContinuesLastPattern = this._note.continuesLastPattern;
            this._newContinuesLastPattern = this._note.continuesLastPattern;
        }
        _finishSetup(continuesLastPattern) {
            for (let i = 0; i < this._newPins.length - 1;) {
                if (this._newPins[i].time >= this._newPins[i + 1].time) {
                    this._newPins.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            removeRedundantPins(this._newPins);
            const firstInterval = this._newPins[0].interval;
            const firstTime = this._newPins[0].time;
            for (let i = 0; i < this._oldPitches.length; i++) {
                this._newPitches[i] = this._oldPitches[i] + firstInterval;
            }
            for (let i = 0; i < this._newPins.length; i++) {
                this._newPins[i].interval -= firstInterval;
                this._newPins[i].time -= firstTime;
            }
            this._newStart = this._oldStart + firstTime;
            this._newEnd = this._newStart + this._newPins[this._newPins.length - 1].time;
            if (continuesLastPattern != undefined) {
                this._newContinuesLastPattern = continuesLastPattern;
            }
            if (this._newStart != 0) {
                this._newContinuesLastPattern = false;
            }
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._note.pins = this._newPins;
            this._note.pitches = this._newPitches;
            this._note.start = this._newStart;
            this._note.end = this._newEnd;
            this._note.continuesLastPattern = this._newContinuesLastPattern;
            if (this._doc != null)
                this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pins = this._oldPins;
            this._note.pitches = this._oldPitches;
            this._note.start = this._oldStart;
            this._note.end = this._oldEnd;
            this._note.continuesLastPattern = this._oldContinuesLastPattern;
            if (this._doc != null)
                this._doc.notifier.changed();
        }
    }
    class ChangeCustomWave extends Change {
        constructor(doc, newArray) {
            super();
            const oldArray = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].customChipWave;
            var comparisonResult = true;
            for (let i = 0; i < oldArray.length; i++) {
                if (oldArray[i] != newArray[i]) {
                    comparisonResult = false;
                    i = oldArray.length;
                }
            }
            if (comparisonResult == false) {
                let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
                for (let i = 0; i < newArray.length; i++) {
                    instrument.customChipWave[i] = newArray[i];
                }
                let sum = 0.0;
                for (let i = 0; i < instrument.customChipWave.length; i++) {
                    sum += instrument.customChipWave[i];
                }
                const average = sum / instrument.customChipWave.length;
                let cumulative = 0;
                let wavePrev = 0;
                for (let i = 0; i < instrument.customChipWave.length; i++) {
                    cumulative += wavePrev;
                    wavePrev = instrument.customChipWave[i] - average;
                    instrument.customChipWaveIntegral[i] = cumulative;
                }
                instrument.customChipWaveIntegral[64] = 0.0;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangePreset extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.preset;
            if (oldValue != newValue) {
                const preset = EditorConfig.valueToPreset(newValue);
                if (preset != null) {
                    if (preset.customType != undefined) {
                        instrument.type = preset.customType;
                        if (!Config.instrumentTypeHasSpecialInterval[instrument.type] && Config.chords[instrument.chord].customInterval) {
                            instrument.chord = 0;
                        }
                        instrument.clearInvalidEnvelopeTargets();
                    }
                    else if (preset.settings != undefined) {
                        const tempVolume = instrument.volume;
                        const tempPan = instrument.pan;
                        const tempPanDelay = instrument.panDelay;
                        const usesPanning = effectsIncludePanning(instrument.effects);
                        instrument.fromJsonObject(preset.settings, doc.song.getChannelIsNoise(doc.channel), doc.song.getChannelIsMod(doc.channel), doc.song.rhythm == 0 || doc.song.rhythm == 2, doc.song.rhythm >= 2);
                        instrument.volume = tempVolume;
                        instrument.pan = tempPan;
                        instrument.panDelay = tempPanDelay;
                        if (usesPanning && instrument.pan != Config.panCenter) {
                            instrument.effects = (instrument.effects | (1 << 2));
                        }
                    }
                }
                instrument.preset = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeRandomGeneratedInstrument extends Change {
        constructor(doc) {
            super();
            function selectWeightedRandom(entries) {
                let total = 0;
                for (const entry of entries) {
                    total += entry.weight;
                }
                let random = Math.random() * total;
                for (const entry of entries) {
                    random -= entry.weight;
                    if (random <= 0.0)
                        return entry.item;
                }
                return entries[(Math.random() * entries.length) | 0].item;
            }
            function selectCurvedDistribution(min, max, peak, width) {
                const entries = [];
                for (let i = min; i <= max; i++) {
                    entries.push({ item: i, weight: 1.0 / (Math.pow((i - peak) / width, 2.0) + 1.0) });
                }
                return selectWeightedRandom(entries);
            }
            class PotentialFilterPoint {
                constructor(chance, type, minFreq, maxFreq, centerHz, centerGain) {
                    this.chance = chance;
                    this.type = type;
                    this.minFreq = minFreq;
                    this.maxFreq = maxFreq;
                    this.centerHz = centerHz;
                    this.centerGain = centerGain;
                }
                ;
            }
            function applyFilterPoints(filter, potentialPoints) {
                filter.reset();
                const usedFreqs = [];
                for (const potentialPoint of potentialPoints) {
                    if (Math.random() > potentialPoint.chance)
                        continue;
                    const point = new FilterControlPoint();
                    point.type = potentialPoint.type;
                    point.freq = selectCurvedDistribution(potentialPoint.minFreq, potentialPoint.maxFreq, FilterControlPoint.getRoundedSettingValueFromHz(potentialPoint.centerHz), 1.0 / Config.filterFreqStep);
                    point.gain = selectCurvedDistribution(0, Config.filterGainRange - 1, Config.filterGainCenter + potentialPoint.centerGain, 2.0 / Config.filterGainStep);
                    if (point.type == 2 && point.gain == Config.filterGainCenter)
                        continue;
                    if (usedFreqs.includes(point.freq))
                        continue;
                    usedFreqs.push(point.freq);
                    filter.controlPoints[filter.controlPointCount] = point;
                    filter.controlPointCount++;
                }
            }
            const isNoise = doc.song.getChannelIsNoise(doc.channel);
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.effects &= 1 << 2;
            instrument.envelopeCount = 0;
            const midFreq = FilterControlPoint.getRoundedSettingValueFromHz(700.0);
            const maxFreq = Config.filterFreqRange - 1;
            applyFilterPoints(instrument.eqFilter, [
                new PotentialFilterPoint(0.8, 0, midFreq, maxFreq, 4000.0, -1),
                new PotentialFilterPoint(0.4, 1, 0, midFreq - 1, 250.0, -1),
                new PotentialFilterPoint(0.5, 2, 0, maxFreq, 2000.0, 0),
                new PotentialFilterPoint(0.4, 2, 0, maxFreq, 1400.0, 0),
                new PotentialFilterPoint(0.3, 2, 0, maxFreq, 1000.0, 0),
                new PotentialFilterPoint(0.2, 2, 0, maxFreq, 500.0, 0),
            ]);
            if (isNoise) {
                const type = selectWeightedRandom([
                    { item: 2, weight: 1 },
                    { item: 3, weight: 3 },
                ]);
                instrument.preset = instrument.type = type;
                instrument.fadeIn = (Math.random() < 0.8) ? 0 : selectCurvedDistribution(0, Config.fadeInRange - 1, 0, 2);
                instrument.fadeOut = selectCurvedDistribution(0, Config.fadeOutTicks.length - 1, Config.fadeOutNeutral, 2);
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 10;
                    instrument.transition = Config.transitions.dictionary[selectWeightedRandom([
                        { item: "normal", weight: 30 },
                        { item: "interrupt", weight: 1 },
                        { item: "slide", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.2) {
                    instrument.effects |= 1 << 11;
                    instrument.chord = Config.chords.dictionary[selectWeightedRandom([
                        { item: "strum", weight: 2 },
                        { item: "arpeggio", weight: 1 },
                    ])].index;
                }
                if (Math.random() < 0.1) {
                    instrument.pitchShift = selectCurvedDistribution(0, Config.pitchShiftRange - 1, Config.pitchShiftCenter, 2);
                    if (instrument.pitchShift != Config.pitchShiftCenter) {
                        instrument.effects |= 1 << 7;
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["pitchShift"].index, 0, Config.envelopes.dictionary[selectWeightedRandom([
                            { item: "flare 1", weight: 2 },
                            { item: "flare 2", weight: 1 },
                            { item: "flare 3", weight: 1 },
                            { item: "twang 1", weight: 16 },
                            { item: "twang 2", weight: 8 },
                            { item: "twang 3", weight: 4 },
                            { item: "tremolo1", weight: 1 },
                            { item: "tremolo2", weight: 1 },
                            { item: "tremolo3", weight: 1 },
                            { item: "decay 1", weight: 4 },
                            { item: "decay 2", weight: 2 },
                            { item: "decay 3", weight: 1 },
                        ])].index);
                    }
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 9;
                    instrument.vibrato = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.vibrato = Config.vibratos.dictionary[selectWeightedRandom([
                        { item: "light", weight: 2 },
                        { item: "delayed", weight: 2 },
                        { item: "heavy", weight: 1 },
                        { item: "shaky", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.8) {
                    instrument.effects |= 1 << 5;
                    applyFilterPoints(instrument.noteFilter, [
                        new PotentialFilterPoint(1.0, 0, midFreq, maxFreq, 8000.0, -1),
                    ]);
                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteFilterAllFreqs"].index, 0, Config.envelopes.dictionary[selectWeightedRandom([
                        { item: "punch", weight: 4 },
                        { item: "flare 1", weight: 2 },
                        { item: "flare 2", weight: 2 },
                        { item: "flare 3", weight: 2 },
                        { item: "twang 1", weight: 8 },
                        { item: "twang 2", weight: 8 },
                        { item: "twang 3", weight: 8 },
                        { item: "swell 1", weight: 2 },
                        { item: "swell 2", weight: 2 },
                        { item: "swell 3", weight: 1 },
                        { item: "tremolo1", weight: 1 },
                        { item: "tremolo2", weight: 1 },
                        { item: "tremolo3", weight: 1 },
                        { item: "tremolo4", weight: 1 },
                        { item: "tremolo5", weight: 1 },
                        { item: "tremolo6", weight: 1 },
                        { item: "decay 1", weight: 4 },
                        { item: "decay 2", weight: 4 },
                        { item: "decay 3", weight: 4 },
                    ])].index);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 3;
                    instrument.distortion = selectCurvedDistribution(1, Config.distortionRange - 1, Config.distortionRange - 1, 2);
                } 
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 4;
                    instrument.bitcrusherFreq = selectCurvedDistribution(0, Config.bitcrusherFreqRange - 1, Config.bitcrusherFreqRange >> 1, 2);
                    instrument.bitcrusherQuantization = selectCurvedDistribution(0, Config.bitcrusherQuantizationRange - 1, Config.bitcrusherQuantizationRange >> 1, 2);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 1;
                    instrument.chorus = selectCurvedDistribution(1, Config.chorusRange - 1, Config.chorusRange - 1, 1);
                }
                if (Math.random() < 0.1) {
                    instrument.echoSustain = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.echoDelay = selectCurvedDistribution(0, Config.echoDelayRange - 1, Config.echoDelayRange >> 1, 2);
                    if (instrument.echoSustain != 0 || instrument.echoDelay != 0) {
                        instrument.effects |= 1 << 6;
                    }
                }
                if (Math.random() < 0.5) {
                    instrument.effects |= 1 << 0;
                    instrument.reverb = selectCurvedDistribution(1, Config.reverbRange - 1, 1, 1);
                }
                function normalize(harmonics) {
                    let max = 0;
                    for (const value of harmonics) {
                        if (value > max)
                            max = value;
                    }
                    for (let i = 0; i < harmonics.length; i++) {
                        harmonics[i] = Config.harmonicsMax * harmonics[i] / max;
                    }
                }
                switch (type) {
                    case 2:
                        {
                            instrument.chipNoise = (Math.random() * Config.chipNoises.length) | 0;
                        }
                        break;
                    case 3:
                        {
                            const spectrumGenerators = [
                                () => {
                                    const spectrum = [];
                                    for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                        spectrum[i] = (Math.random() < 0.5) ? Math.random() : 0.0;
                                    }
                                    return spectrum;
                                },
                                () => {
                                    let current = 1.0;
                                    const spectrum = [current];
                                    for (let i = 1; i < Config.spectrumControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.52);
                                        spectrum[i] = current;
                                    }
                                    return spectrum;
                                },
                                () => {
                                    let current = 1.0;
                                    const spectrum = [current];
                                    for (let i = 1; i < Config.spectrumControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.52);
                                        spectrum[i] = current * Math.random();
                                    }
                                    return spectrum;
                                },
                            ];
                            const generator = spectrumGenerators[(Math.random() * spectrumGenerators.length) | 0];
                            const spectrum = generator();
                            normalize(spectrum);
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                instrument.spectrumWave.spectrum[i] = Math.round(spectrum[i]);
                            }
                            instrument.spectrumWave.markCustomWaveDirty();
                        }
                        break;
                    default: throw new Error("Unhandled noise instrument type in random generator.");
                }
            }
            else {
                const type = selectWeightedRandom([
                    { item: 0, weight: 4 },
                    { item: 6, weight: 4 },
                    { item: 5, weight: 5 },
                    { item: 7, weight: 5 },
                    { item: 3, weight: 1 },
                    { item: 1, weight: 5 },
                ]);
                instrument.preset = instrument.type = type;
                instrument.fadeIn = (Math.random() < 0.5) ? 0 : selectCurvedDistribution(0, Config.fadeInRange - 1, 0, 2);
                instrument.fadeOut = selectCurvedDistribution(0, Config.fadeOutTicks.length - 1, Config.fadeOutNeutral, 2);
                if (type == 0 || type == 5 || type == 7) {
                    instrument.unison = Config.unisons.dictionary[selectWeightedRandom([
                        { item: "none", weight: 10 },
                        { item: "shimmer", weight: 5 },
                        { item: "hum", weight: 4 },
                        { item: "honky tonk", weight: 3 },
                        { item: "dissonant", weight: 1 },
                        { item: "fifth", weight: 1 },
                        { item: "octave", weight: 2 },
                        { item: "bowed", weight: 2 },
                        { item: "piano", weight: 5 },
                        { item: "warbled", weight: 3 },
                        { item: "octave/2", weight: 1.5 },
                        { item: "super", weight: 1 },
                        { item: "chorus", weight: 1 },
                        { item: "phased", weight: 1 },
                        { item: "inv fifth", weight: 1 },
                        { item: "detuned", weight: 1 },
                        { item: "boost", weight: 1 },
                        { item: "resonance", weight: 1 },
                        { item: "dirty", weight: 1 },
 
                        
                    ])].index;
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 10;
                    instrument.transition = Config.transitions.dictionary[selectWeightedRandom([
                        { item: "interrupt", weight: 1 },
                        { item: "slide", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.2) {
                    instrument.effects |= 1 << 11;
                    instrument.chord = Config.chords.dictionary[selectWeightedRandom([
                        { item: "strum", weight: 2 },
                        { item: "arpeggio", weight: 1 },
                    ])].index;
                }
                if (Math.random() < 0.05) {
                    instrument.pitchShift = selectCurvedDistribution(0, Config.pitchShiftRange - 1, Config.pitchShiftCenter, 1);
                    if (instrument.pitchShift != Config.pitchShiftCenter) {
                        instrument.effects |= 1 << 7;
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["pitchShift"].index, 0, Config.envelopes.dictionary[selectWeightedRandom([
                            { item: "flare 1", weight: 2 },
                            { item: "flare 2", weight: 1 },
                            { item: "flare 3", weight: 1 },
                            { item: "twang 1", weight: 16 },
                            { item: "twang 2", weight: 8 },
                            { item: "twang 3", weight: 4 },
                            { item: "decay 1", weight: 4 },
                            { item: "decay 2", weight: 2 },
                            { item: "decay 3", weight: 1 },
                        ])].index);
                    }
                }
                if (Math.random() < 0.25) {
                    instrument.effects |= 1 << 9;
                    instrument.vibrato = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.vibrato = Config.vibratos.dictionary[selectWeightedRandom([
                        { item: "light", weight: 2 },
                        { item: "delayed", weight: 2 },
                        { item: "heavy", weight: 1 },
                        { item: "shaky", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 3;
                    instrument.distortion = selectCurvedDistribution(1, Config.distortionRange - 1, Config.distortionRange - 1, 2);
                }
                if (effectsIncludeDistortion(instrument.effects) && Math.random() < 0.8) {
                    instrument.effects |= 1 << 5;
                    applyFilterPoints(instrument.noteFilter, [
                        new PotentialFilterPoint(1.0, 0, midFreq, maxFreq, 2000.0, -1),
                        new PotentialFilterPoint(0.9, 1, 0, midFreq - 1, 500.0, -1),
                        new PotentialFilterPoint(0.4, 2, 0, maxFreq, 1400.0, 0),
                    ]);
                }
                else if (Math.random() < 0.5) {
                    instrument.effects |= 1 << 5;
                    applyFilterPoints(instrument.noteFilter, [
                        new PotentialFilterPoint(1.0, 0, midFreq, maxFreq, 8000.0, -1),
                    ]);
                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteFilterAllFreqs"].index, 0, Config.envelopes.dictionary[selectWeightedRandom([
                        { item: "punch", weight: 6 },
                        { item: "flare 1", weight: 2 },
                        { item: "flare 2", weight: 4 },
                        { item: "flare 3", weight: 2 },
                        { item: "twang 1", weight: 2 },
                        { item: "twang 2", weight: 4 },
                        { item: "twang 3", weight: 4 },
                        { item: "swell 1", weight: 4 },
                        { item: "swell 2", weight: 2 },
                        { item: "swell 3", weight: 1 },
                        { item: "tremolo1", weight: 1 },
                        { item: "tremolo2", weight: 1 },
                        { item: "tremolo3", weight: 1 },
                        { item: "tremolo4", weight: 1 },
                        { item: "tremolo5", weight: 1 },
                        { item: "tremolo6", weight: 1 },
                        { item: "decay 1", weight: 1 },
                        { item: "decay 2", weight: 2 },
                        { item: "decay 3", weight: 2 },
                    ])].index);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 4;
                    instrument.bitcrusherFreq = selectCurvedDistribution(0, Config.bitcrusherFreqRange - 1, 0, 2);
                    instrument.bitcrusherQuantization = selectCurvedDistribution(0, Config.bitcrusherQuantizationRange - 1, Config.bitcrusherQuantizationRange >> 1, 2);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 1;
                    instrument.chorus = selectCurvedDistribution(1, Config.chorusRange - 1, Config.chorusRange - 1, 1);
                }
                if (Math.random() < 0.1) {
                    instrument.echoSustain = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.echoDelay = selectCurvedDistribution(0, Config.echoDelayRange - 1, Config.echoDelayRange >> 1, 2);
                    if (instrument.echoSustain != 0 || instrument.echoDelay != 0) {
                        instrument.effects |= 1 << 6;
                    }
                }
                if (Math.random() < 0.5) {
                    instrument.effects |= 1 << 0;
                    instrument.reverb = selectCurvedDistribution(1, Config.reverbRange - 1, 1, 1);
                }
                function normalize(harmonics) {
                    let max = 0;
                    for (const value of harmonics) {
                        if (value > max)
                            max = value;
                    }
                    for (let i = 0; i < harmonics.length; i++) {
                        harmonics[i] = Config.harmonicsMax * harmonics[i] / max;
                    }
                }
                switch (type) {
                    case 0:
                        {
                            instrument.chipWave = (Math.random() * Config.chipWaves.length) | 0;
                            
                        }
                        break;
                    case 6:
                        {
                            instrument.pulseWidth = selectCurvedDistribution(0, Config.pulseWidthRange - 1, Config.pulseWidthRange - 1, 2);
                            if (Math.random() < 0.6) {
                                instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["pulseWidth"].index, 0, Config.envelopes.dictionary[selectWeightedRandom([
                                    { item: "punch", weight: 6 },
                                    { item: "flare 1", weight: 2 },
                                    { item: "flare 2", weight: 4 },
                                    { item: "flare 3", weight: 2 },
                                    { item: "twang 1", weight: 2 },
                                    { item: "twang 2", weight: 4 },
                                    { item: "twang 3", weight: 4 },
                                    { item: "swell 1", weight: 4 },
                                    { item: "swell 2", weight: 2 },
                                    { item: "swell 3", weight: 1 },
                                    { item: "tremolo1", weight: 1 },
                                    { item: "tremolo2", weight: 1 },
                                    { item: "tremolo3", weight: 1 },
                                    { item: "tremolo4", weight: 1 },
                                    { item: "tremolo5", weight: 1 },
                                    { item: "tremolo6", weight: 1 },
                                    { item: "decay 1", weight: 1 },
                                    { item: "decay 2", weight: 2 },
                                    { item: "decay 3", weight: 2 },
                                ])].index);
                            }
                        }
                        break;
                    case 7:
                    case 5:
                        {
                            if (type == 7) {
                                instrument.stringSustain = (Math.random() * Config.stringSustainRange) | 0;
                            }
                            const harmonicGenerators = [
                                () => {
                                    const harmonics = [];
                                    for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                                        harmonics[i] = (Math.random() < 0.4) ? Math.random() : 0.0;
                                    }
                                    harmonics[(Math.random() * 8) | 0] = Math.pow(Math.random(), 0.25);
                                    return harmonics;
                                },
                                () => {
                                    let current = 1.0;
                                    const harmonics = [current];
                                    for (let i = 1; i < Config.harmonicsControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.55);
                                        harmonics[i] = current;
                                    }
                                    return harmonics;
                                },
                                () => {
                                    let current = 1.0;
                                    const harmonics = [current];
                                    for (let i = 1; i < Config.harmonicsControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.55);
                                        harmonics[i] = current * Math.random();
                                    }
                                    return harmonics;
                                },
                            ];
                            const generator = harmonicGenerators[(Math.random() * harmonicGenerators.length) | 0];
                            const harmonics = generator();
                            normalize(harmonics);
                            for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                                instrument.harmonicsWave.harmonics[i] = Math.round(harmonics[i]);
                            }
                            instrument.harmonicsWave.markCustomWaveDirty();
                        }
                        break;
                    case 3:
                        {
                            const spectrum = [];
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                const isHarmonic = i == 0 || i == 7 || i == 11 || i == 14 || i == 16 || i == 18 || i == 21;
                                if (isHarmonic) {
                                    spectrum[i] = Math.pow(Math.random(), 0.25);
                                }
                                else {
                                    spectrum[i] = Math.pow(Math.random(), 3) * 0.5;
                                }
                            }
                            normalize(spectrum);
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                instrument.spectrumWave.spectrum[i] = Math.round(spectrum[i]);
                            }
                            instrument.spectrumWave.markCustomWaveDirty();
                        }
                        break;
                    case 1:
                        {
                            instrument.algorithm = (Math.random() * Config.algorithms.length) | 0;
                            instrument.feedbackType = (Math.random() * Config.feedbacks.length) | 0;
                            const algorithm = Config.algorithms[instrument.algorithm];
                            for (let i = 0; i < algorithm.carrierCount; i++) {
                                instrument.operators[i].frequency = selectCurvedDistribution(0, Config.operatorFrequencies.length - 1, 0, 3);
                                instrument.operators[i].amplitude = selectCurvedDistribution(0, Config.operatorAmplitudeMax, Config.operatorAmplitudeMax - 1, 2);
                                instrument.operators[i].waveform = Config.operatorWaves.dictionary[selectWeightedRandom([
                                    { item: "sine", weight: 10 },
                                    { item: "triangle", weight: 6 },
                                    { item: "sawtooth", weight: 3 },
                                    { item: "pulse width", weight: 6 },
                                    { item: "ramp", weight: 3 },
                                    { item: "trapezoid", weight: 4 },
                                ])].index;
                                if (instrument.operators[i].waveform == 3) {
                                    instrument.operators[i].pulseWidth = selectWeightedRandom([
                                        { item: 0, weight: 3 },
                                        { item: 1, weight: 5 },
                                        { item: 2, weight: 7 },
                                        { item: 3, weight: 10 },
                                        { item: 4, weight: 15 },
                                        { item: 5, weight: 25 },
                                        { item: 6, weight: 15 },
                                        { item: 7, weight: 10 },
                                        { item: 8, weight: 7 },
                                        { item: 9, weight: 5 },
                                        { item: 9, weight: 3 },
                                    ]);
                                }
                            }
                            for (let i = algorithm.carrierCount; i < Config.operatorCount; i++) {
                                instrument.operators[i].frequency = selectCurvedDistribution(3, Config.operatorFrequencies.length - 1, 0, 3);
                                instrument.operators[i].amplitude = (Math.pow(Math.random(), 2) * Config.operatorAmplitudeMax) | 0;
                                if (instrument.envelopeCount < Config.maxEnvelopeCount && Math.random() < 0.4) {
                                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["operatorAmplitude"].index, i, Config.envelopes.dictionary[selectWeightedRandom([
                                        { item: "punch", weight: 2 },
                                        { item: "flare 1", weight: 2 },
                                        { item: "flare 2", weight: 2 },
                                        { item: "flare 3", weight: 2 },
                                        { item: "twang 1", weight: 2 },
                                        { item: "twang 2", weight: 2 },
                                        { item: "twang 3", weight: 2 },
                                        { item: "swell 1", weight: 2 },
                                        { item: "swell 2", weight: 2 },
                                        { item: "swell 3", weight: 2 },
                                        { item: "tremolo1", weight: 1 },
                                        { item: "tremolo2", weight: 1 },
                                        { item: "tremolo3", weight: 1 },
                                        { item: "tremolo4", weight: 1 },
                                        { item: "tremolo5", weight: 1 },
                                        { item: "tremolo6", weight: 1 },
                                        { item: "decay 1", weight: 1 },
                                        { item: "decay 2", weight: 1 },
                                        { item: "decay 3", weight: 1 },
                                    ])].index);
                                    instrument.operators[i].waveform = Config.operatorWaves.dictionary[selectWeightedRandom([
                                        { item: "sine", weight: 10 },
                                        { item: "triangle", weight: 6 },
                                        { item: "sawtooth", weight: 3 },
                                        { item: "pulse width", weight: 6 },
                                        { item: "ramp", weight: 3 },
                                        { item: "trapezoid", weight: 4 },
                                    ])].index;
                                    if (instrument.operators[i].waveform == 3) {
                                        instrument.operators[i].pulseWidth = selectWeightedRandom([
                                            { item: 0, weight: 3 },
                                            { item: 1, weight: 5 },
                                            { item: 2, weight: 7 },
                                            { item: 3, weight: 10 },
                                            { item: 4, weight: 15 },
                                            { item: 5, weight: 25 },
                                            { item: 6, weight: 15 },
                                            { item: 7, weight: 10 },
                                            { item: 8, weight: 7 },
                                            { item: 9, weight: 5 },
                                            { item: 9, weight: 3 },
                                        ]);
                                    }
                                }
                                if (instrument.envelopeCount < Config.maxEnvelopeCount && Math.random() < 0.05) {
                                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["operatorFrequency"].index, i, Config.envelopes.dictionary[selectWeightedRandom([
                                        { item: "punch", weight: 4 },
                                        { item: "flare 1", weight: 4 },
                                        { item: "flare 2", weight: 2 },
                                        { item: "flare 3", weight: 1 },
                                        { item: "twang 1", weight: 16 },
                                        { item: "twang 2", weight: 2 },
                                        { item: "twang 3", weight: 1 },
                                        { item: "swell 1", weight: 4 },
                                        { item: "swell 2", weight: 2 },
                                        { item: "swell 3", weight: 1 },
                                        { item: "decay 1", weight: 2 },
                                        { item: "decay 2", weight: 1 },
                                        { item: "decay 3", weight: 1 },
                                    ])].index);
                                }
                            }
                            instrument.feedbackAmplitude = (Math.pow(Math.random(), 3) * Config.operatorAmplitudeMax) | 0;
                            if (instrument.envelopeCount < Config.maxEnvelopeCount && Math.random() < 0.4) {
                                instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["feedbackAmplitude"].index, 0, Config.envelopes.dictionary[selectWeightedRandom([
                                    { item: "punch", weight: 2 },
                                    { item: "flare 1", weight: 2 },
                                    { item: "flare 2", weight: 2 },
                                    { item: "flare 3", weight: 2 },
                                    { item: "twang 1", weight: 2 },
                                    { item: "twang 2", weight: 2 },
                                    { item: "twang 3", weight: 2 },
                                    { item: "swell 1", weight: 2 },
                                    { item: "swell 2", weight: 2 },
                                    { item: "swell 3", weight: 2 },
                                    { item: "tremolo1", weight: 1 },
                                    { item: "tremolo2", weight: 1 },
                                    { item: "tremolo3", weight: 1 },
                                    { item: "tremolo4", weight: 1 },
                                    { item: "tremolo5", weight: 1 },
                                    { item: "tremolo6", weight: 1 },
                                    { item: "decay 1", weight: 1 },
                                    { item: "decay 2", weight: 1 },
                                    { item: "decay 3", weight: 1 },
                                ])].index);
                            }
                        }
                        break;
                    default: throw new Error("Unhandled pitched instrument type in random generator.");
                }
                
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeTransition extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.transition;
            if (oldValue != newValue) {
                this._didSomething();
                instrument.transition = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
            }
        }
    }
    class ChangeToggleEffects extends Change {
        constructor(doc, toggleFlag) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.effects;
            const wasSelected = ((oldValue & (1 << toggleFlag)) != 0);
            const newValue = wasSelected ? (oldValue & (~(1 << toggleFlag))) : (oldValue | (1 << toggleFlag));
            instrument.effects = newValue;
            if (toggleFlag != 2)
                instrument.preset = instrument.type;
            if (wasSelected)
                instrument.clearInvalidEnvelopeTargets();
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangePatternNumbers extends Change {
        constructor(doc, value, startBar, startChannel, width, height) {
            super();
            if (value > doc.song.patternsPerChannel)
                throw new Error("invalid pattern");
            for (let bar = startBar; bar < startBar + width; bar++) {
                for (let channelIndex = startChannel; channelIndex < startChannel + height; channelIndex++) {
                    if (doc.song.channels[channelIndex].bars[bar] != value) {
                        doc.song.channels[channelIndex].bars[bar] = value;
                        this._didSomething();
                    }
                }
            }
            doc.notifier.changed();
        }
    }
    class ChangeBarCount extends Change {
        constructor(doc, newValue, atBeginning) {
            super();
            if (doc.song.barCount != newValue) {
                for (const channel of doc.song.channels) {
                    if (atBeginning) {
                        while (channel.bars.length < newValue) {
                            channel.bars.unshift(0);
                        }
                        if (doc.song.barCount > newValue) {
                            channel.bars.splice(0, doc.song.barCount - newValue);
                        }
                    }
                    else {
                        while (channel.bars.length < newValue) {
                            channel.bars.push(0);
                        }
                        channel.bars.length = newValue;
                    }
                }
                if (atBeginning) {
                    const diff = newValue - doc.song.barCount;
                    doc.bar = Math.max(0, doc.bar + diff);
                    if (diff < 0 || doc.barScrollPos > 0) {
                        doc.barScrollPos = Math.max(0, doc.barScrollPos + diff);
                    }
                    doc.song.loopStart = Math.max(0, doc.song.loopStart + diff);
                }
                doc.bar = Math.min(doc.bar, newValue - 1);
                doc.barScrollPos = Math.max(0, Math.min(newValue - doc.trackVisibleBars, doc.barScrollPos));
                doc.song.loopLength = Math.min(newValue, doc.song.loopLength);
                doc.song.loopStart = Math.min(newValue - doc.song.loopLength, doc.song.loopStart);
                doc.song.barCount = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeInsertBars extends Change {
        constructor(doc, start, count) {
            super();
            const newLength = Math.min(Config.barCountMax, doc.song.barCount + count);
            count = newLength - doc.song.barCount;
            if (count == 0)
                return;
            for (const channel of doc.song.channels) {
                while (channel.bars.length < newLength) {
                    channel.bars.splice(start, 0, 0);
                }
            }
            doc.song.barCount = newLength;
            doc.bar += count;
            doc.barScrollPos = Math.min(newLength - doc.trackVisibleBars, doc.barScrollPos + count);
            if (doc.song.loopStart >= start) {
                doc.song.loopStart += count;
            }
            else if (doc.song.loopStart + doc.song.loopLength >= start) {
                doc.song.loopLength += count;
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeDeleteBars extends Change {
        constructor(doc, start, count) {
            super();
            for (const channel of doc.song.channels) {
                channel.bars.splice(start, count);
                if (channel.bars.length == 0)
                    channel.bars.push(0);
            }
            doc.song.barCount = Math.max(1, doc.song.barCount - count);
            doc.bar = Math.max(0, doc.bar - count);
            doc.barScrollPos = Math.max(0, doc.barScrollPos - count);
            if (doc.song.loopStart >= start) {
                doc.song.loopStart = Math.max(0, doc.song.loopStart - count);
            }
            else if (doc.song.loopStart + doc.song.loopLength > start) {
                doc.song.loopLength -= count;
            }
            doc.song.loopLength = Math.max(1, Math.min(doc.song.barCount - doc.song.loopStart, doc.song.loopLength));
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeLimiterSettings extends Change {
        constructor(doc, limitRatio, compressionRatio, limitThreshold, compressionThreshold, limitRise, limitDecay, masterGain) {
            super();
            doc.song.limitRatio = limitRatio; 
            doc.song.compressionRatio = compressionRatio;
            doc.song.limitThreshold = limitThreshold;
            doc.song.compressionThreshold = compressionThreshold;
            doc.song.limitRise = limitRise;
            doc.song.limitDecay = limitDecay;
            doc.song.masterGain = masterGain;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeChannelOrder extends Change {
        constructor(doc, selectionMin, selectionMax, offset) {
            super();
            doc.song.channels.splice(selectionMin + offset, 0, ...doc.song.channels.splice(selectionMin, selectionMax - selectionMin + 1));
            selectionMax = Math.max(selectionMax, selectionMin);
            for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                for (let instrumentIdx = 0; instrumentIdx < doc.song.channels[channelIndex].instruments.length; instrumentIdx++) {
                    let instrument = doc.song.channels[channelIndex].instruments[instrumentIdx];
                    for (let i = 0; i < Config.modCount; i++) {
                        if (instrument.modChannels[i] >= selectionMin && instrument.modChannels[i] <= selectionMax) {
                            instrument.modChannels[i] += offset;
                        }
                        else if (instrument.modChannels[i] >= selectionMin + offset && instrument.modChannels[i] <= selectionMax + offset) {
                            instrument.modChannels[i] -= offset * (selectionMax - selectionMin + 1);
                        }
                    }
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeChannelCount extends Change {
        constructor(doc, newPitchChannelCount, newNoiseChannelCount, newModChannelCount) {
            super();
            if (doc.song.pitchChannelCount != newPitchChannelCount || doc.song.noiseChannelCount != newNoiseChannelCount || doc.song.modChannelCount != newModChannelCount) {
                const newChannels = [];
                function changeGroup(newCount, oldCount, newStart, oldStart, octave, isNoise, isMod) {
                    for (let i = 0; i < newCount; i++) {
                        const channelIndex = i + newStart;
                        const oldChannel = i + oldStart;
                        if (i < oldCount) {
                            newChannels[channelIndex] = doc.song.channels[oldChannel];
                        }
                        else {
                            newChannels[channelIndex] = new Channel();
                            newChannels[channelIndex].octave = octave;
                            for (let j = 0; j < Config.instrumentCountMin; j++) {
                                const instrument = new Instrument(isNoise, isMod);
                                if (!isMod) {
                                    const presetValue = pickRandomPresetValue(isNoise);
                                    const preset = EditorConfig.valueToPreset(presetValue);
                                    instrument.fromJsonObject(preset.settings, isNoise, isMod, doc.song.rhythm == 0 || doc.song.rhythm == 2, doc.song.rhythm >= 2);
                                    instrument.preset = presetValue;
                                }
                                newChannels[channelIndex].instruments[j] = instrument;
                            }
                            for (let j = 0; j < doc.song.patternsPerChannel; j++) {
                                newChannels[channelIndex].patterns[j] = new Pattern();
                            }
                            for (let j = 0; j < doc.song.barCount; j++) {
                                newChannels[channelIndex].bars[j] = 0;
                            }
                        }
                    }
                }
                changeGroup(newPitchChannelCount, doc.song.pitchChannelCount, 0, 0, 3, false, false);
                changeGroup(newNoiseChannelCount, doc.song.noiseChannelCount, newPitchChannelCount, doc.song.pitchChannelCount, 0, true, false);
                changeGroup(newModChannelCount, doc.song.modChannelCount, newNoiseChannelCount + newPitchChannelCount, doc.song.pitchChannelCount + doc.song.noiseChannelCount, 0, false, true);
                let oldPitchCount = doc.song.pitchChannelCount;
                doc.song.pitchChannelCount = newPitchChannelCount;
                doc.song.noiseChannelCount = newNoiseChannelCount;
                doc.song.modChannelCount = newModChannelCount;
                for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                    doc.song.channels[channelIndex] = newChannels[channelIndex];
                }
                doc.song.channels.length = doc.song.getChannelCount();
                doc.channel = Math.min(doc.channel, newPitchChannelCount + newNoiseChannelCount + newModChannelCount - 1);
                doc.channelScrollPos = Math.max(0, Math.min(doc.song.getChannelCount() - doc.trackVisibleChannels, doc.channelScrollPos));
                for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                    for (let instrumentIdx = 0; instrumentIdx < doc.song.channels[channelIndex].instruments.length; instrumentIdx++) {
                        for (let mod = 0; mod < Config.modCount; mod++) {
                            let instrument = doc.song.channels[channelIndex].instruments[instrumentIdx];
                            let modChannel = instrument.modChannels[mod];
                            if ((modChannel >= doc.song.pitchChannelCount && modChannel < oldPitchCount) || modChannel >= doc.song.pitchChannelCount + doc.song.noiseChannelCount) {
                                instrument.modulators[mod] = Config.modulators.dictionary["none"].index;
                            }
                            if (modChannel >= oldPitchCount && oldPitchCount < newPitchChannelCount) {
                                instrument.modChannels[mod] += newPitchChannelCount - oldPitchCount;
                            }
                        }
                    }
                }
                doc.notifier.changed();
                ColorConfig.resetColors();
                this._didSomething();
            }
        }
    }
    class ChangeAddChannel extends ChangeGroup {
        constructor(doc, index, isNoise, isMod) {
            super();
            const newPitchChannelCount = doc.song.pitchChannelCount + (isNoise || isMod ? 0 : 1);
            const newNoiseChannelCount = doc.song.noiseChannelCount + (!isNoise || isMod ? 0 : 1);
            const newModChannelCount = doc.song.modChannelCount + (isNoise || !isMod ? 0 : 1);
            if (newPitchChannelCount <= Config.pitchChannelCountMax && newNoiseChannelCount <= Config.noiseChannelCountMax && newModChannelCount <= Config.modChannelCountMax) {
                const addedChannelIndex = isNoise ? doc.song.pitchChannelCount + doc.song.noiseChannelCount : doc.song.pitchChannelCount;
                this.append(new ChangeChannelCount(doc, newPitchChannelCount, newNoiseChannelCount, newModChannelCount));
                if (addedChannelIndex - 1 >= index) {
                    this.append(new ChangeChannelOrder(doc, index, addedChannelIndex - 1, 1));
                }
                doc.synth.computeLatestModValues();
                doc.recalcChannelNames = true;
            }
        }
    }
    class ChangeRemoveChannel extends ChangeGroup {
        constructor(doc, minIndex, maxIndex) {
            super();
            const oldMax = maxIndex;
            for (let modChannel = doc.song.pitchChannelCount + doc.song.noiseChannelCount; modChannel < doc.song.channels.length; modChannel++) {
                for (let instrumentIndex = 0; instrumentIndex < doc.song.channels[modChannel].instruments.length; instrumentIndex++) {
                    const modInstrument = doc.song.channels[modChannel].instruments[instrumentIndex];
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        if (modInstrument.modChannels[mod] >= minIndex && modInstrument.modChannels[mod] <= oldMax) {
                            this.append(new ChangeModChannel(doc, mod, 0, modInstrument));
                        }
                        else if (modInstrument.modChannels[mod] > oldMax) {
                            this.append(new ChangeModChannel(doc, mod, modInstrument.modChannels[mod] - (oldMax - minIndex + 1) + 2, modInstrument));
                        }
                    }
                }
            }
            while (maxIndex >= minIndex) {
                const isNoise = doc.song.getChannelIsNoise(maxIndex);
                const isMod = doc.song.getChannelIsMod(maxIndex);
                doc.song.channels.splice(maxIndex, 1);
                if (isNoise) {
                    doc.song.noiseChannelCount--;
                }
                else if (isMod) {
                    doc.song.modChannelCount--;
                }
                else {
                    doc.song.pitchChannelCount--;
                }
                maxIndex--;
            }
            if (doc.song.pitchChannelCount < Config.pitchChannelCountMin) {
                this.append(new ChangeChannelCount(doc, Config.pitchChannelCountMin, doc.song.noiseChannelCount, doc.song.modChannelCount));
            }
            ColorConfig.resetColors();
            doc.recalcChannelNames = true;
            this.append(new ChangeChannelBar(doc, Math.max(0, minIndex - 1), doc.bar));
            doc.synth.computeLatestModValues();
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangeChannelBar extends Change {
        constructor(doc, newChannel, newBar, silently = false) {
            super();
            const oldChannel = doc.channel;
            const oldBar = doc.bar;
            doc.channel = newChannel;
            doc.bar = newBar;
            if (!silently) {
                doc.barScrollPos = Math.min(doc.bar, Math.max(doc.bar - (doc.trackVisibleBars - 1), doc.barScrollPos));
                doc.channelScrollPos = Math.min(doc.channel, Math.max(doc.channel - (doc.trackVisibleChannels - 1), doc.channelScrollPos));
            }
            doc.notifier.changed();
            if (oldChannel != newChannel || oldBar != newBar) {
                this._didSomething();
            }
        }
    }
 /*   class ChangeUnison extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.unison;
            if (oldValue != newValue) {
                this._didSomething();
                instrument.unison = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
            }
        }
    }*/
    
    
 class ChangeUnison extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		const oldValue = instrument.unison;
		if (oldValue != newValue) {
			instrument.unison = newValue;
			instrument.unisonVoices = Config.unisons[instrument.unison].voices;
			instrument.unisonSpread = Config.unisons[instrument.unison].spread;
			instrument.unisonOffset = Config.unisons[instrument.unison].offset;
			instrument.unisonExpression = Config.unisons[instrument.unison].expression;
			instrument.unisonSign = Config.unisons[instrument.unison].sign;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
} class ChangeUnisonVoices extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		let prevUnison = instrument.unison;
		if (oldValue != newValue || prevUnison != Config.unisons.length) {
			instrument.unisonVoices = newValue;
			instrument.unison = Config.unisons.length;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
} class ChangeUnisonSpread extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		let prevUnison = instrument.unison;
		if (oldValue != newValue || prevUnison != Config.unisons.length) {
			instrument.unisonSpread = newValue;
			instrument.unison = Config.unisons.length;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
} class ChangeUnisonOffset extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		let prevUnison = instrument.unison;
		if (oldValue != newValue || prevUnison != Config.unisons.length) {
			instrument.unisonOffset = newValue;
			instrument.unison = Config.unisons.length;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
} class ChangeUnisonExpression extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		let prevUnison = instrument.unison;
		if (oldValue != newValue || prevUnison != Config.unisons.length) {
			instrument.unisonExpression = newValue;
			instrument.unison = Config.unisons.length;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
} class ChangeUnisonSign extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		let prevUnison = instrument.unison;
		if (oldValue != newValue || prevUnison != Config.unisons.length) {
			instrument.unisonSign = newValue;
			instrument.unison = Config.unisons.length;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
    
    class ChangeChord extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.chord;
            if (oldValue != newValue) {
                this._didSomething();
                instrument.chord = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
            }
        }
    }
    class ChangeVibrato extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.vibrato;
            if (oldValue != newValue) {
                instrument.vibrato = newValue;
                instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;
                instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;
                instrument.vibratoSpeed = 10;
                instrument.vibratoType = Config.vibratos[instrument.vibrato].type;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoDepth extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevVibrato = instrument.vibrato;
            doc.synth.unsetMod(Config.modulators.dictionary["vibrato depth"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoDepth = newValue / 25;
                instrument.vibrato = Config.vibratos.length;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
class ChangeEnvelopeSpeed extends Change {
 constructor(doc, oldValue, newValue) {
  super();
  const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
  doc.synth.unsetMod(Config.modulators.dictionary["envelope speed"].index, doc.channel, doc.getCurrentInstrument());
  doc.notifier.changed();
  if (oldValue != newValue) {
   instrument.envelopeSpeed = newValue;
   instrument.preset = instrument.type;
   doc.notifier.changed();
   this._didSomething();
  }
 }
}
    class ChangeVibratoSpeed extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevVibrato = instrument.vibrato;
            doc.synth.unsetMod(Config.modulators.dictionary["vibrato speed"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoSpeed = newValue;
                instrument.vibrato = Config.vibratos.length;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoDelay extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevVibrato = instrument.vibrato;
            doc.synth.unsetMod(Config.modulators.dictionary["vibrato delay"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoDelay = newValue;
                instrument.vibrato = Config.vibratos.length;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoType extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.vibratoType;
            let prevVibrato = instrument.vibrato;
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoType = newValue;
                instrument.vibrato = Config.vibratos.length;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeArpeggioSpeed extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.arpeggioSpeed = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["arp speed"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeFastTwoNoteArp extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.fastTwoNoteArp;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.fastTwoNoteArp = newValue;
                this._didSomething();
            }
        }
    }
    class ChangeClicklessTransition extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.clicklessTransition;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.clicklessTransition = newValue;
                this._didSomething();
            }
        }
    }
    class ChangeAliasing extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.aliases;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.aliases = newValue;
                this._didSomething();
            }
        }
    }
    class ChangeSpectrum extends Change {
        constructor(doc, instrument, spectrumWave) {
            super();
            spectrumWave.markCustomWaveDirty();
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeHarmonics extends Change {
        constructor(doc, instrument, harmonicsWave) {
            super();
            harmonicsWave.markCustomWaveDirty();
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeDrumsetEnvelope extends Change {
        constructor(doc, drumIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.drumsetEnvelopes[drumIndex];
            if (oldValue != newValue) {
                instrument.drumsetEnvelopes[drumIndex] = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeInstrumentSlider extends Change {
        constructor(_doc) {
            super();
            this._doc = _doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
        }
        commit() {
            if (!this.isNoop()) {
                this._instrument.preset = this._instrument.type;
                this._doc.notifier.changed();
            }
        }
    }
    class ChangePulseWidth extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.pulseWidth = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["pulse width"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePitchShift extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.pitchShift = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeDetune extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.detune = newValue + Config.detuneCenter;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["detune"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
     class ChangeRingMod extends ChangeInstrumentSlider {
	constructor(doc, oldValue, newValue) {
		super(doc);
		this._instrument.ringModulation = newValue;
		doc.notifier.changed();
		doc.synth.unsetMod(Config.modulators.dictionary["ring modulation"].index, doc.channel, doc.getCurrentInstrument());
		if (oldValue != newValue)
			this._didSomething();
	}
}
class ChangeRingModHz extends ChangeInstrumentSlider {
	constructor(doc, oldValue, newValue) {
		super(doc);
		this._instrument.ringModulationHz = newValue;
		doc.notifier.changed();
		doc.synth.unsetMod(Config.modulators.dictionary["ring mod hertz"].index, doc.channel, doc.getCurrentInstrument());
		if (oldValue != newValue)
			this._didSomething();
	}
}
class ChangeRingModChipWave extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.ringModWaveformIndex != newValue) {
			instrument.ringModWaveformIndex = newValue;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
class ChangeRingModPulseWidth extends ChangeInstrumentSlider {
	constructor(doc, oldValue, newValue) {
		super(doc);
		this._instrument.ringModPulseWidth = newValue;
		doc.notifier.changed();
		if (oldValue != newValue)
			this._didSomething();
	}
}
class ChangeGranular extends ChangeInstrumentSlider {
	constructor(doc, oldValue, newValue) {
		super(doc);
		this._instrument.granular = newValue;
		doc.notifier.changed();
		doc.synth.unsetMod(Config.modulators.dictionary["granular"].index, doc.channel, doc.getCurrentInstrument());
		if (oldValue != newValue)
			this._didSomething();
	}
}
    class ChangeDistortion extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.distortion = newValue;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["distortion"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeBitcrusherFreq extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.bitcrusherFreq = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeBitcrusherQuantization extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.bitcrusherQuantization = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeStringSustain extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.stringSustain = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["sustain"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEQFilterType extends Change {
        constructor(doc, instrument, newValue) {
            super();
            instrument.eqFilterType = newValue;
            if (newValue == true) {
                instrument.eqFilter.reset();
                instrument.tmpEqFilterStart = instrument.eqFilter;
                instrument.tmpEqFilterEnd = null;
            }
            else {
                instrument.eqFilter.convertLegacySettings(instrument.eqFilterSimpleCut, instrument.eqFilterSimplePeak, Config.envelopes.dictionary["none"]);
                instrument.tmpEqFilterStart = instrument.eqFilter;
                instrument.tmpEqFilterEnd = null;
            }
            instrument.clearInvalidEnvelopeTargets();
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeNoteFilterType extends Change {
        constructor(doc, instrument, newValue) {
            super();
            instrument.noteFilterType = newValue;
            if (newValue == true) {
                instrument.noteFilter.reset();
                instrument.tmpNoteFilterStart = instrument.noteFilter;
                instrument.tmpNoteFilterEnd = null;
            }
            else {
                instrument.noteFilter.convertLegacySettings(instrument.noteFilterSimpleCut, instrument.noteFilterSimplePeak, Config.envelopes.dictionary["none"]);
                instrument.tmpNoteFilterStart = instrument.noteFilter;
                instrument.tmpNoteFilterEnd = null;
            }
            instrument.clearInvalidEnvelopeTargets();
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeEQFilterSimpleCut extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.eqFilterSimpleCut = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["eq filt cut"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEQFilterSimplePeak extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.eqFilterSimplePeak = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["eq filt peak"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeNoteFilterSimpleCut extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.noteFilterSimpleCut = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["note filt cut"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeNoteFilterSimplePeak extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.noteFilterSimplePeak = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["note filt peak"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeFilterAddPoint extends UndoableChange {
        constructor(doc, filterSettings, point, index, isNoteFilter, deletion = false) {
            super(deletion);
            this._envelopeTargetsAdd = [];
            this._envelopeIndicesAdd = [];
            this._envelopeTargetsRemove = [];
            this._envelopeIndicesRemove = [];
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = deletion ? this._instrument.preset : this._instrument.type;
            this._instrumentPrevPreset = deletion ? this._instrument.type : this._instrument.preset;
            this._filterSettings = filterSettings;
            this._point = point;
            this._index = index;
            for (let envelopeIndex = 0; envelopeIndex < this._instrument.envelopeCount; envelopeIndex++) {
                let target = this._instrument.envelopes[envelopeIndex].target;
                let targetIndex = this._instrument.envelopes[envelopeIndex].index;
                this._envelopeTargetsAdd.push(target);
                this._envelopeIndicesAdd.push(targetIndex);
                if (deletion) {
                    const automationTarget = Config.instrumentAutomationTargets[target];
                    if (automationTarget.isFilter && (automationTarget.effect == 5) == isNoteFilter) {
                        if (automationTarget.maxCount == Config.filterMaxPoints) {
                            if (targetIndex == index) {
                                target = Config.instrumentAutomationTargets.dictionary["none"].index;
                                targetIndex = 0;
                            }
                            else if (targetIndex > index) {
                                targetIndex--;
                            }
                        }
                        else {
                            if (filterSettings.controlPointCount <= 1) {
                                target = Config.instrumentAutomationTargets.dictionary["none"].index;
                                targetIndex = 0;
                            }
                        }
                    }
                }
                this._envelopeTargetsRemove.push(target);
                this._envelopeIndicesRemove.push(targetIndex);
            }
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._filterSettings.controlPoints.splice(this._index, 0, this._point);
            this._filterSettings.controlPointCount++;
            this._filterSettings.controlPoints.length = this._filterSettings.controlPointCount;
            this._instrument.preset = this._instrumentNextPreset;
            for (let envelopeIndex = 0; envelopeIndex < this._instrument.envelopeCount; envelopeIndex++) {
                this._instrument.envelopes[envelopeIndex].target = this._envelopeTargetsAdd[envelopeIndex];
                this._instrument.envelopes[envelopeIndex].index = this._envelopeIndicesAdd[envelopeIndex];
            }
            this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
            this._instrument.tmpEqFilterEnd = null;
            this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
            this._instrument.tmpNoteFilterEnd = null;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._filterSettings.controlPoints.splice(this._index, 1);
            this._filterSettings.controlPointCount--;
            this._filterSettings.controlPoints.length = this._filterSettings.controlPointCount;
            this._instrument.preset = this._instrumentPrevPreset;
            for (let envelopeIndex = 0; envelopeIndex < this._instrument.envelopeCount; envelopeIndex++) {
                this._instrument.envelopes[envelopeIndex].target = this._envelopeTargetsRemove[envelopeIndex];
                this._instrument.envelopes[envelopeIndex].index = this._envelopeIndicesRemove[envelopeIndex];
            }
            this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
            this._instrument.tmpEqFilterEnd = null;
            this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
            this._instrument.tmpNoteFilterEnd = null;
            this._doc.notifier.changed();
        }
    }
    class ChangeFilterMovePoint extends UndoableChange {
        constructor(doc, point, oldFreq, newFreq, oldGain, newGain) {
            super(false);
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = this._instrument.type;
            this._instrumentPrevPreset = this._instrument.preset;
            this._point = point;
            this._oldFreq = oldFreq;
            this._newFreq = newFreq;
            this._oldGain = oldGain;
            this._newGain = newGain;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._point.freq = this._newFreq;
            this._point.gain = this._newGain;
            this._instrument.preset = this._instrumentNextPreset;
            this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
            this._instrument.tmpEqFilterEnd = null;
            this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
            this._instrument.tmpNoteFilterEnd = null;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._point.freq = this._oldFreq;
            this._point.gain = this._oldGain;
            this._instrument.preset = this._instrumentPrevPreset;
            this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
            this._instrument.tmpEqFilterEnd = null;
            this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
            this._instrument.tmpNoteFilterEnd = null;
            this._doc.notifier.changed();
        }
    }
    class ChangeFilterSettings extends UndoableChange {
        constructor(doc, settings, oldSettings, useNoteFilter, subFilters = null, oldSubFilters = null) {
            super(false);
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = this._instrument.type;
            this._instrumentPrevPreset = this._instrument.preset;
            this._oldSettings = oldSettings;
            this._useNoteFilter = useNoteFilter;
            this._filterSettings = settings;
            if (subFilters != null && oldSubFilters != null) {
                this._subFilters = subFilters;
                this._oldSubFilters = oldSubFilters;
            }
            this._instrument.clearInvalidEnvelopeTargets();
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            if (this._useNoteFilter) {
                this._instrument.noteFilter = this._filterSettings;
                if (this._subFilters != null)
                    this._instrument.noteSubFilters = this._subFilters;
                this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
                this._instrument.tmpNoteFilterEnd = null;
            }
            else {
                this._instrument.eqFilter = this._filterSettings;
                if (this._subFilters != null)
                    this._instrument.eqSubFilters = this._subFilters;
                this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
                this._instrument.tmpEqFilterEnd = null;
            }
            this._instrument.preset = this._instrumentNextPreset;
            this._instrument.clearInvalidEnvelopeTargets();
            this._doc.notifier.changed();
        }
        _doBackwards() {
            if (this._useNoteFilter) {
                this._instrument.noteFilter = this._oldSettings;
                if (this._oldSubFilters != null)
                    this._instrument.noteSubFilters = this._oldSubFilters;
                this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
                this._instrument.tmpNoteFilterEnd = null;
            }
            else {
                this._instrument.eqFilter = this._oldSettings;
                if (this._oldSubFilters != null)
                    this._instrument.eqSubFilters = this._oldSubFilters;
                this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
                this._instrument.tmpEqFilterEnd = null;
            }
            this._instrument.preset = this._instrumentPrevPreset;
            this._instrument.clearInvalidEnvelopeTargets();
            this._doc.notifier.changed();
        }
    }
    class ChangeFadeInOut extends UndoableChange {
        constructor(doc, fadeIn, fadeOut) {
            super(false);
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = this._instrument.type;
            this._instrumentPrevPreset = this._instrument.preset;
            this._oldFadeIn = this._instrument.fadeIn;
            this._oldFadeOut = this._instrument.fadeOut;
            this._newFadeIn = fadeIn;
            this._newFadeOut = fadeOut;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._instrument.fadeIn = this._newFadeIn;
            this._instrument.fadeOut = this._newFadeOut;
            this._instrument.preset = this._instrumentNextPreset;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._instrument.fadeIn = this._oldFadeIn;
            this._instrument.fadeOut = this._oldFadeOut;
            this._instrument.preset = this._instrumentPrevPreset;
            this._doc.notifier.changed();
        }
    }
    class ChangeAlgorithm extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.algorithm;
            if (oldValue != newValue) {
                instrument.algorithm = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeFeedbackType extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.feedbackType;
            if (oldValue != newValue) {
                instrument.feedbackType = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeOperatorWaveform extends Change {
        constructor(doc, operatorIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.operators[operatorIndex].waveform;
            if (oldValue != newValue) {
                instrument.operators[operatorIndex].waveform = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeOperatorPulseWidth extends Change {
        constructor(doc, operatorIndex, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.operators[operatorIndex].pulseWidth = newValue;
            instrument.preset = instrument.type;
            doc.notifier.changed();
            if (oldValue != newValue) {
                this._didSomething();
            }
        }
    }
    class ChangeOperatorFrequency extends Change {
        constructor(doc, operatorIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.operators[operatorIndex].frequency;
            if (oldValue != newValue) {
                instrument.operators[operatorIndex].frequency = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeOperatorAmplitude extends ChangeInstrumentSlider {
        constructor(doc, operatorIndex, oldValue, newValue) {
            super(doc);
            this._instrument.operators[operatorIndex].amplitude = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeFeedbackAmplitude extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.feedbackAmplitude = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeAddChannelInstrument extends Change {
        constructor(doc) {
            super();
            const channel = doc.song.channels[doc.channel];
            const isNoise = doc.song.getChannelIsNoise(doc.channel);
            const isMod = doc.song.getChannelIsMod(doc.channel);
            const maxInstruments = doc.song.getMaxInstrumentsPerChannel();
            if (channel.instruments.length >= maxInstruments)
                return;
            const presetValue = pickRandomPresetValue(isNoise);
            const preset = EditorConfig.valueToPreset(presetValue);
            const instrument = new Instrument(isNoise, isMod);
            instrument.fromJsonObject(preset.settings, isNoise, isMod, false, false, 1);
            instrument.preset = presetValue;
            instrument.volume = 0;
            channel.instruments.push(instrument);
            if (!isMod) {
                doc.viewedInstrument[doc.channel] = channel.instruments.length - 1;
            }
            for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                for (let instrumentIndex = 0; instrumentIndex < doc.song.channels[channelIndex].instruments.length; instrumentIndex++) {
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        let instrument = doc.song.channels[channelIndex].instruments[instrumentIndex];
                        let modInstrument = instrument.modInstruments[mod];
                        if (modInstrument >= doc.song.channels[channelIndex].instruments.length) {
                            instrument.modInstruments[mod]++;
                        }
                    }
                }
            }
            doc.synth.computeLatestModValues();
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeRemoveChannelInstrument extends Change {
        constructor(doc) {
            super();
            const channel = doc.song.channels[doc.channel];
            if (channel.instruments.length <= Config.instrumentCountMin)
                return;
            const removedIndex = doc.viewedInstrument[doc.channel];
            channel.instruments.splice(removedIndex, 1);
            if (doc.song.patternInstruments) {
                for (const pattern of channel.patterns) {
                    for (let i = 0; i < pattern.instruments.length; i++) {
                        if (pattern.instruments[i] == removedIndex) {
                            pattern.instruments.splice(i, 1);
                            i--;
                        }
                        else if (pattern.instruments[i] > removedIndex) {
                            pattern.instruments[i]--;
                        }
                    }
                    if (pattern.instruments.length <= 0) {
                        pattern.instruments[0] = 0;
                    }
                }
            }
            for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                for (let instrumentIdx = 0; instrumentIdx < doc.song.channels[channelIndex].instruments.length; instrumentIdx++) {
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        let instrument = doc.song.channels[channelIndex].instruments[instrumentIdx];
                        let modInstrument = instrument.modInstruments[mod];
                        if (modInstrument > doc.song.channels[channelIndex].instruments.length) {
                            instrument.modInstruments[mod]--;
                        }
                        else if (modInstrument == doc.song.channels[channelIndex].instruments.length) {
                            instrument.modInstruments[mod] = 0;
                            instrument.modulators[mod] = 0;
                        }
                    }
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeViewInstrument extends Change {
        constructor(doc, index) {
            super();
            if (doc.viewedInstrument[doc.channel] != index) {
                doc.viewedInstrument[doc.channel] = index;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeInstrumentsFlags extends Change {
        constructor(doc, newLayeredInstruments, newPatternInstruments) {
            super();
            const oldLayeredInstruments = doc.song.layeredInstruments;
            const oldPatternInstruments = doc.song.patternInstruments;
            if (oldLayeredInstruments == newLayeredInstruments && oldPatternInstruments == newPatternInstruments)
                return;
            doc.song.layeredInstruments = newLayeredInstruments;
            doc.song.patternInstruments = newPatternInstruments;
            for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                const channel = doc.song.channels[channelIndex];
                if (channel.instruments.length > doc.song.getMaxInstrumentsPerChannel()) {
                    channel.instruments.length = doc.song.getMaxInstrumentsPerChannel();
                }
                for (let j = 0; j < doc.song.patternsPerChannel; j++) {
                    const pattern = channel.patterns[j];
                    if (!oldPatternInstruments && newPatternInstruments) {
                        for (let i = 0; i < channel.instruments.length; i++) {
                            pattern.instruments[i] = i;
                        }
                        pattern.instruments.length = channel.instruments.length;
                    }
                    discardInvalidPatternInstruments(pattern.instruments, doc.song, channelIndex);
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeKey extends Change {
        constructor(doc, newValue) {
            super();
            if (doc.song.key != newValue) {
                doc.song.key = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeLoop extends Change {
        constructor(_doc, oldStart, oldLength, newStart, newLength) {
            super();
            this._doc = _doc;
            this.oldStart = oldStart;
            this.oldLength = oldLength;
            this.newStart = newStart;
            this.newLength = newLength;
            this._doc.song.loopStart = this.newStart;
            this._doc.song.loopLength = this.newLength;
            this._doc.notifier.changed();
            if (this.oldStart != this.newStart || this.oldLength != this.newLength) {
                this._didSomething();
            }
        }
    }
    class ChangePitchAdded extends UndoableChange {
        constructor(doc, note, pitch, index, deletion = false) {
            super(deletion);
            this._doc = doc;
            this._note = note;
            this._pitch = pitch;
            this._index = index;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._note.pitches.splice(this._index, 0, this._pitch);
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pitches.splice(this._index, 1);
            this._doc.notifier.changed();
        }
    }
    class ChangeOctave extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            this.oldValue = oldValue;
            doc.song.channels[doc.channel].octave = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeRhythm extends ChangeGroup {
        constructor(doc, newValue) {
            super();
            if (doc.song.rhythm != newValue) {
                doc.song.rhythm = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangePaste extends ChangeGroup {
        constructor(doc, pattern, notes, selectionStart, selectionEnd, oldPartDuration) {
            super();
            this.append(new ChangeNoteTruncate(doc, pattern, selectionStart, selectionEnd, null, true));
            let noteInsertionIndex = 0;
            if (!doc.song.getChannelIsMod(doc.channel)) {
                for (let i = 0; i < pattern.notes.length; i++) {
                    if (pattern.notes[i].start < selectionStart) {
                        if (pattern.notes[i].end > selectionStart)
                            throw new Error();
                        noteInsertionIndex = i + 1;
                    }
                    else if (pattern.notes[i].start < selectionEnd) {
                        throw new Error();
                    }
                }
            }
            else {
                noteInsertionIndex = pattern.notes.length;
            }
            while (selectionStart < selectionEnd) {
                for (const noteObject of notes) {
                    const noteStart = noteObject["start"] + selectionStart;
                    const noteEnd = noteObject["end"] + selectionStart;
                    if (noteStart >= selectionEnd)
                        break;
                    const note = new Note(noteObject["pitches"][0], noteStart, noteEnd, noteObject["pins"][0]["size"], false);
                    note.pitches.length = 0;
                    for (const pitch of noteObject["pitches"]) {
                        note.pitches.push(pitch);
                    }
                    note.pins.length = 0;
                    for (const pin of noteObject["pins"]) {
                        note.pins.push(makeNotePin(pin.interval, pin.time, pin.size));
                    }
                    note.continuesLastPattern = (noteObject["continuesLastPattern"] === true) && (note.start == 0);
                    pattern.notes.splice(noteInsertionIndex++, 0, note);
                    if (note.end > selectionEnd) {
                        this.append(new ChangeNoteLength(doc, note, note.start, selectionEnd));
                    }
                }
                selectionStart += oldPartDuration;
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangePasteInstrument extends ChangeGroup {
        constructor(doc, instrument, instrumentCopy) {
            super();
            instrument.fromJsonObject(instrumentCopy, instrumentCopy["isDrum"], instrumentCopy["isMod"], false, false);
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeSetPatternInstruments extends Change {
        constructor(doc, channelIndex, instruments, pattern) {
            super();
            if (!patternsContainSameInstruments(instruments, pattern.instruments)) {
                pattern.instruments.length = 0;
                pattern.instruments.push(...instruments);
                discardInvalidPatternInstruments(pattern.instruments, doc.song, channelIndex);
                this._didSomething();
                doc.notifier.changed();
            }
        }
    }
    class ChangeModChannel extends Change {
        constructor(doc, mod, index, useInstrument) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (useInstrument != undefined)
                instrument = useInstrument;
            if (index == 0 || (Config.modulators[instrument.modulators[mod]].forSong && index >= 2) || (!Config.modulators[instrument.modulators[mod]].forSong && index < 2)) {
                instrument.modulators[mod] = Config.modulators.dictionary["none"].index;
            }
            instrument.modChannels[mod] = index - 2;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeModInstrument extends Change {
        constructor(doc, mod, tgtInstrument) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.modInstruments[mod] != tgtInstrument) {
                instrument.modInstruments[mod] = tgtInstrument;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeModSetting extends Change {
        constructor(doc, mod, text) {
            super();
            let setting = Config.modulators.dictionary[text].index;
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.modulators[mod] != setting) {
                instrument.modulators[mod] = setting;
                let cap = Config.modulators[setting].maxRawVol;
                for (let i = 0; i < doc.song.patternsPerChannel; i++) {
                    const pattern = doc.song.channels[doc.channel].patterns[i];
                    if (pattern.instruments[0] == doc.getCurrentInstrument()) {
                        for (let j = 0; j < pattern.notes.length; j++) {
                            const note = pattern.notes[j];
                            if (note.pitches[0] == Config.modCount - mod - 1) {
                                for (let k = 0; k < note.pins.length; k++) {
                                    const pin = note.pins[k];
                                    if (pin.size > cap)
                                        pin.size = cap;
                                }
                            }
                        }
                    }
                }
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeModFilter extends Change {
        constructor(doc, mod, type) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];


            if (instrument.modFilterTypes[mod] != type) {
                instrument.modFilterTypes[mod] = type;
                let cap = doc.song.getVolumeCapForSetting(true, instrument.modulators[mod], instrument.modFilterTypes[mod]);
                for (let i = 0; i < doc.song.patternsPerChannel; i++) {
                    const pattern = doc.song.channels[doc.channel].patterns[i];
                    if (pattern.instruments[0] == doc.getCurrentInstrument()) {
                        for (let j = 0; j < pattern.notes.length; j++) {
                            const note = pattern.notes[j];
                            if (note.pitches[0] == Config.modCount - mod - 1) {
                                for (let k = 0; k < note.pins.length; k++) {
                                    const pin = note.pins[k];
                                    if (pin.size > cap)
                                        pin.size = cap;
                                }
                            }
                        }
                    }
                }
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangePatternsPerChannel extends Change {
        constructor(doc, newValue) {
            super();
            if (doc.song.patternsPerChannel != newValue) {
                for (let i = 0; i < doc.song.getChannelCount(); i++) {
                    const channelBars = doc.song.channels[i].bars;
                    const channelPatterns = doc.song.channels[i].patterns;
                    for (let j = 0; j < channelBars.length; j++) {
                        if (channelBars[j] > newValue)
                            channelBars[j] = 0;
                    }
                    for (let j = channelPatterns.length; j < newValue; j++) {
                        channelPatterns[j] = new Pattern();
                    }
                    channelPatterns.length = newValue;
                }
                doc.song.patternsPerChannel = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEnsurePatternExists extends UndoableChange {
        constructor(doc, channelIndex, bar) {
            super(false);
            this._patternOldNotes = null;
            this._oldPatternInstruments = null;
            const song = doc.song;
            if (song.channels[channelIndex].bars[bar] != 0)
                return;
            this._doc = doc;
            this._bar = bar;
            this._channelIndex = channelIndex;
            this._oldPatternCount = song.patternsPerChannel;
            this._newPatternCount = song.patternsPerChannel;
            this._newPatternInstruments = doc.recentPatternInstruments[channelIndex].concat();
            let firstEmptyUnusedIndex = null;
            let firstUnusedIndex = null;
            for (let patternIndex = 1; patternIndex <= song.patternsPerChannel; patternIndex++) {
                let used = false;
                for (let barIndex = 0; barIndex < song.barCount; barIndex++) {
                    if (song.channels[channelIndex].bars[barIndex] == patternIndex) {
                        used = true;
                        break;
                    }
                }
                if (used)
                    continue;
                if (firstUnusedIndex == null) {
                    firstUnusedIndex = patternIndex;
                }
                const pattern = song.channels[channelIndex].patterns[patternIndex - 1];
                if (pattern.notes.length == 0) {
                    firstEmptyUnusedIndex = patternIndex;
                    break;
                }
            }
            if (firstEmptyUnusedIndex != null) {
                this._patternIndex = firstEmptyUnusedIndex;
                this._oldPatternInstruments = song.channels[channelIndex].patterns[firstEmptyUnusedIndex - 1].instruments.concat();
            }
            else if (song.patternsPerChannel < song.barCount) {
                this._newPatternCount = song.patternsPerChannel + 1;
                this._patternIndex = song.patternsPerChannel + 1;
            }
            else if (firstUnusedIndex != null) {
                this._patternIndex = firstUnusedIndex;
                this._patternOldNotes = song.channels[channelIndex].patterns[firstUnusedIndex - 1].notes;
                this._oldPatternInstruments = song.channels[channelIndex].patterns[firstUnusedIndex - 1].instruments.concat();
            }
            else {
                throw new Error();
            }
            this._didSomething();
            this._doForwards();
        }
        _doForwards() {
            const song = this._doc.song;
            for (let j = song.patternsPerChannel; j < this._newPatternCount; j++) {
                for (let i = 0; i < song.getChannelCount(); i++) {
                    song.channels[i].patterns[j] = new Pattern();
                }
            }
            song.patternsPerChannel = this._newPatternCount;
            const pattern = song.channels[this._channelIndex].patterns[this._patternIndex - 1];
            pattern.notes = [];
            pattern.instruments.length = 0;
            pattern.instruments.push(...this._newPatternInstruments);
            song.channels[this._channelIndex].bars[this._bar] = this._patternIndex;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            const song = this._doc.song;
            const pattern = song.channels[this._channelIndex].patterns[this._patternIndex - 1];
            if (this._patternOldNotes != null)
                pattern.notes = this._patternOldNotes;
            if (this._oldPatternInstruments != null) {
                pattern.instruments.length = 0;
                pattern.instruments.push(...this._oldPatternInstruments);
            }
            song.channels[this._channelIndex].bars[this._bar] = 0;
            for (let i = 0; i < song.getChannelCount(); i++) {
                song.channels[i].patterns.length = this._oldPatternCount;
            }
            song.patternsPerChannel = this._oldPatternCount;
            this._doc.notifier.changed();
        }
    }
    class ChangePinTime extends ChangePins {
        constructor(doc, note, pinIndex, shiftedTime, continuesLastPattern) {
            super(doc, note);
            shiftedTime -= this._oldStart;
            const originalTime = this._oldPins[pinIndex].time;
            const skipStart = Math.min(originalTime, shiftedTime);
            const skipEnd = Math.max(originalTime, shiftedTime);
            let setPin = false;
            for (let i = 0; i < this._oldPins.length; i++) {
                const oldPin = note.pins[i];
                const time = oldPin.time;
                if (time < skipStart) {
                    this._newPins.push(makeNotePin(oldPin.interval, time, oldPin.size));
                }
                else if (time > skipEnd) {
                    if (!setPin) {
                        if (this._newPins.length > 0)
                            continuesLastPattern = note.continuesLastPattern;
                        this._newPins.push(makeNotePin(this._oldPins[pinIndex].interval, shiftedTime, this._oldPins[pinIndex].size));
                        setPin = true;
                    }
                    this._newPins.push(makeNotePin(oldPin.interval, time, oldPin.size));
                }
            }
            if (!setPin) {
                continuesLastPattern = note.continuesLastPattern;
                this._newPins.push(makeNotePin(this._oldPins[pinIndex].interval, shiftedTime, this._oldPins[pinIndex].size));
            }
            this._finishSetup(continuesLastPattern);
        }
    }
    class ChangePitchBend extends ChangePins {
        constructor(doc, note, bendStart, bendEnd, bendTo, pitchIndex) {
            super(doc, note);
            bendStart -= this._oldStart;
            bendEnd -= this._oldStart;
            bendTo -= note.pitches[pitchIndex];
            let setStart = false;
            let setEnd = false;
            let prevInterval = 0;
            let prevSize = Config.noteSizeMax;
            let persist = true;
            let i;
            let direction;
            let stop;
            let push;
            if (bendEnd > bendStart) {
                i = 0;
                direction = 1;
                stop = note.pins.length;
                push = (item) => { this._newPins.push(item); };
            }
            else {
                i = note.pins.length - 1;
                direction = -1;
                stop = -1;
                push = (item) => { this._newPins.unshift(item); };
            }
            for (; i != stop; i += direction) {
                const oldPin = note.pins[i];
                const time = oldPin.time;
                for (;;) {
                    if (!setStart) {
                        if (time * direction <= bendStart * direction) {
                            prevInterval = oldPin.interval;
                            prevSize = oldPin.size;
                        }
                        if (time * direction < bendStart * direction) {
                            push(makeNotePin(oldPin.interval, time, oldPin.size));
                            break;
                        }
                        else {
                            push(makeNotePin(prevInterval, bendStart, prevSize));
                            setStart = true;
                        }
                    }
                    else if (!setEnd) {
                        if (time * direction <= bendEnd * direction) {
                            prevInterval = oldPin.interval;
                            prevSize = oldPin.size;
                        }
                        if (time * direction < bendEnd * direction) {
                            break;
                        }
                        else {
                            push(makeNotePin(bendTo, bendEnd, prevSize));
                            setEnd = true;
                        }
                    }
                    else {
                        if (time * direction == bendEnd * direction) {
                            break;
                        }
                        else {
                            if (oldPin.interval != prevInterval)
                                persist = false;
                            push(makeNotePin(persist ? bendTo : oldPin.interval, time, oldPin.size));
                            break;
                        }
                    }
                }
            }
            if (!setEnd) {
                push(makeNotePin(bendTo, bendEnd, prevSize));
            }
            this._finishSetup();
        }
    }
    class ChangePatternRhythm extends ChangeSequence {
        constructor(doc, pattern) {
            super();
            const minDivision = Config.partsPerBeat / Config.rhythms[doc.song.rhythm].stepsPerBeat;
            const changeRhythm = function (oldTime) {
                let thresholds = Config.rhythms[doc.song.rhythm].roundUpThresholds;
                if (thresholds != null) {
                    const beatStart = Math.floor(oldTime / Config.partsPerBeat) * Config.partsPerBeat;
                    const remainder = oldTime - beatStart;
                    let newTime = beatStart;
                    for (const threshold of thresholds) {
                        if (remainder >= threshold) {
                            newTime += minDivision;
                        }
                        else {
                            break;
                        }
                    }
                    return newTime;
                }
                else {
                    return Math.round(oldTime / minDivision) * minDivision;
                }
            };
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (changeRhythm(note.start) >= changeRhythm(note.end)) {
                    this.append(new ChangeNoteAdded(doc, pattern, note, i, true));
                }
                else {
                    this.append(new ChangeRhythmNote(doc, note, changeRhythm));
                    i++;
                }
            }
        }
    }
    class ChangeRhythmNote extends ChangePins {
        constructor(doc, note, changeRhythm) {
            super(doc, note);
            for (const oldPin of this._oldPins) {
                this._newPins.push(makeNotePin(oldPin.interval, changeRhythm(oldPin.time + this._oldStart) - this._oldStart, oldPin.size));
            }
            this._finishSetup();
        }
    }
    class ChangeMoveNotesSideways extends ChangeGroup {
        constructor(doc, beatsToMove, strategy) {
            super();
            let partsToMove = Math.round((beatsToMove % doc.song.beatsPerBar) * Config.partsPerBeat);
            if (partsToMove < 0)
                partsToMove += doc.song.beatsPerBar * Config.partsPerBeat;
            if (partsToMove == 0.0)
                return;
            switch (strategy) {
                case "wrapAround":
                    {
                        const partsPerBar = Config.partsPerBeat * doc.song.beatsPerBar;
                        for (const channel of doc.song.channels) {
                            for (const pattern of channel.patterns) {
                                const newNotes = [];
                                for (let bar = 1; bar >= 0; bar--) {
                                    const barStartPart = bar * partsPerBar;
                                    for (const oldNote of pattern.notes) {
                                        const absoluteNoteStart = oldNote.start + partsToMove;
                                        const absoluteNoteEnd = oldNote.end + partsToMove;
                                        const noteStartPart = Math.max(0, absoluteNoteStart - barStartPart);
                                        const noteEndPart = Math.min(partsPerBar, absoluteNoteEnd - barStartPart);
                                        if (noteStartPart < noteEndPart) {
                                            projectNoteIntoBar(oldNote, absoluteNoteStart - barStartPart - noteStartPart, noteStartPart, noteEndPart, newNotes);
                                        }
                                    }
                                }
                                pattern.notes = newNotes;
                            }
                        }
                    }
                    break;
                case "overflow":
                    {
                        let originalBarCount = doc.song.barCount;
                        let originalLoopStart = doc.song.loopStart;
                        let originalLoopLength = doc.song.loopLength;
                        this.append(new ChangeMoveAndOverflowNotes(doc, doc.song.beatsPerBar, partsToMove));
                        if (beatsToMove < 0) {
                            let firstBarIsEmpty = true;
                            for (const channel of doc.song.channels) {
                                if (channel.bars[0] != 0)
                                    firstBarIsEmpty = false;
                            }
                            if (firstBarIsEmpty) {
                                for (const channel of doc.song.channels) {
                                    channel.bars.shift();
                                }
                                doc.song.barCount--;
                            }
                            else {
                                originalBarCount++;
                                originalLoopStart++;
                                doc.bar++;
                            }
                        }
                        while (doc.song.barCount < originalBarCount) {
                            for (const channel of doc.song.channels) {
                                channel.bars.push(0);
                            }
                            doc.song.barCount++;
                        }
                        doc.song.loopStart = originalLoopStart;
                        doc.song.loopLength = originalLoopLength;
                    }
                    break;
                default: throw new Error("Unrecognized beats-per-bar conversion strategy.");
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeBeatsPerBar extends ChangeGroup {
        constructor(doc, newValue, strategy) {
            super();
            if (doc.song.beatsPerBar != newValue) {
                switch (strategy) {
                    case "splice":
                        {
                            if (doc.song.beatsPerBar > newValue) {
                                const sequence = new ChangeSequence();
                                for (let i = 0; i < doc.song.getChannelCount(); i++) {
                                    for (let j = 0; j < doc.song.channels[i].patterns.length; j++) {
                                        sequence.append(new ChangeNoteTruncate(doc, doc.song.channels[i].patterns[j], newValue * Config.partsPerBeat, doc.song.beatsPerBar * Config.partsPerBeat, null, true));
                                    }
                                }
                            }
                        }
                        break;
                    case "stretch":
                        {
                            const changeRhythm = function (oldTime) {
                                return Math.round(oldTime * newValue / doc.song.beatsPerBar);
                            };
                            for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                                for (let patternIndex = 0; patternIndex < doc.song.channels[channelIndex].patterns.length; patternIndex++) {
                                    const pattern = doc.song.channels[channelIndex].patterns[patternIndex];
                                    let noteIndex = 0;
                                    while (noteIndex < pattern.notes.length) {
                                        const note = pattern.notes[noteIndex];
                                        if (changeRhythm(note.start) >= changeRhythm(note.end)) {
                                            this.append(new ChangeNoteAdded(doc, pattern, note, noteIndex, true));
                                        }
                                        else {
                                            this.append(new ChangeRhythmNote(doc, note, changeRhythm));
                                            noteIndex++;
                                        }
                                    }
                                }
                            }
                            this.append(new ChangeTempo(doc, doc.song.tempo, doc.song.tempo * newValue / doc.song.beatsPerBar));
                        }
                        break;
                    case "overflow":
                        {
                            this.append(new ChangeMoveAndOverflowNotes(doc, newValue, 0));
                            doc.song.loopStart = 0;
                            doc.song.loopLength = doc.song.barCount;
                        }
                        break;
                    default: throw new Error("Unrecognized beats-per-bar conversion strategy.");
                }
                doc.song.beatsPerBar = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeScale extends ChangeGroup {
        constructor(doc, newValue) {
            super();
            if (doc.song.scale != newValue) {
                doc.song.scale = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeDetectKey extends ChangeGroup {
        constructor(doc) {
            super();
            const song = doc.song;
            const basePitch = Config.keys[song.key].basePitch;
            const keyWeights = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (let channelIndex = 0; channelIndex < song.pitchChannelCount; channelIndex++) {
                for (let barIndex = 0; barIndex < song.barCount; barIndex++) {
                    const pattern = song.getPattern(channelIndex, barIndex);
                    if (pattern != null) {
                        for (const note of pattern.notes) {
                            const prevPin = note.pins[0];
                            for (let pinIndex = 1; pinIndex < note.pins.length; pinIndex++) {
                                const nextPin = note.pins[pinIndex];
                                if (prevPin.interval == nextPin.interval) {
                                    let weight = nextPin.time - prevPin.time;
                                    weight += Math.max(0, Math.min(Config.partsPerBeat, nextPin.time + note.start) - (prevPin.time + note.start));
                                    weight *= nextPin.size + prevPin.size;
                                    for (const pitch of note.pitches) {
                                        const key = (basePitch + prevPin.interval + pitch) % 12;
                                        keyWeights[key] += weight;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let bestKey = 0;
            let bestKeyWeight = 0;
            for (let key = 0; key < 12; key++) {
                const keyWeight = keyWeights[key] * (3 * keyWeights[(key + 7) % 12] + keyWeights[(key + 4) % 12] + keyWeights[(key + 3) % 12]);
                if (bestKeyWeight < keyWeight) {
                    bestKeyWeight = keyWeight;
                    bestKey = key;
                }
            }
            if (bestKey != song.key) {
                const diff = song.key - bestKey;
                const absoluteDiff = Math.abs(diff);
                for (let channelIndex = 0; channelIndex < song.pitchChannelCount; channelIndex++) {
                    for (const pattern of song.channels[channelIndex].patterns) {
                        for (let i = 0; i < absoluteDiff; i++) {
                            this.append(new ChangeTranspose(doc, channelIndex, pattern, diff > 0, true));
                        }
                    }
                }
                song.key = bestKey;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    function pickRandomPresetValue(isNoise) {
        const eligiblePresetValues = [];
        for (let categoryIndex = 0; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {
            const category = EditorConfig.presetCategories[categoryIndex];
            if (category.name == "Novelty Presets")
                continue;
            for (let presetIndex = 0; presetIndex < category.presets.length; presetIndex++) {
                const preset = category.presets[presetIndex];
                if (preset.settings != undefined && (preset.isNoise == true) == isNoise) {
                    eligiblePresetValues.push((categoryIndex << 6) + presetIndex);
                }
            }
        }
        return eligiblePresetValues[(Math.random() * eligiblePresetValues.length) | 0];
    }
    function setDefaultInstruments(song) {
        for (let channelIndex = 0; channelIndex < song.channels.length; channelIndex++) {
            for (const instrument of song.channels[channelIndex].instruments) {
                const isNoise = song.getChannelIsNoise(channelIndex);
                const isMod = song.getChannelIsMod(channelIndex);
                const presetValue = (channelIndex == song.pitchChannelCount) ? EditorConfig.nameToPresetValue(Math.random() > 0.5 ? "chip noise" : "standard drumset") : pickRandomPresetValue(isNoise);
                const preset = EditorConfig.valueToPreset(presetValue);
                instrument.fromJsonObject(preset.settings, isNoise, isMod, song.rhythm == 0 || song.rhythm == 2, song.rhythm >= 2, 1);
                instrument.preset = presetValue;
            }
        }
    }
    class ChangeSong extends ChangeGroup {
        constructor(doc, newHash) {
            super();
            let pitchChannelCount = doc.song.pitchChannelCount;
            


            
            let noiseChannelCount = doc.song.noiseChannelCount;
            let modChannelCount = doc.song.modChannelCount;
            doc.song.fromBase64String(newHash);
            

            if (pitchChannelCount != doc.song.pitchChannelCount || noiseChannelCount != doc.song.noiseChannelCount || modChannelCount != doc.song.modChannelCount) {
                ColorConfig.resetColors();
            }
            if (newHash == "") {
                this.append(new ChangePatternSelection(doc, 0, 0));
                doc.selection.resetBoxSelection();
                setDefaultInstruments(doc.song);
                doc.song.scale = doc.defaultScale;
                for (let i = 0; i <= doc.song.channels.length; i++) {
                    doc.viewedInstrument[i] = 0;
                    doc.recentPatternInstruments[i] = [0];
                }
                doc.viewedInstrument.length = doc.song.channels.length;
            }
            else {
                this.append(new ChangeValidateTrackSelection(doc));
            }
            doc.synth.computeLatestModValues();
            doc.notifier.changed();


            this._didSomething();
            


        }
    }
    class ChangeValidateTrackSelection extends Change {
        constructor(doc) {
            super();
            const channelIndex = Math.min(doc.channel, doc.song.getChannelCount() - 1);
            const bar = Math.max(0, Math.min(doc.song.barCount - 1, doc.bar));
            const barScrollPos = Math.min(doc.bar, Math.max(doc.bar - (doc.trackVisibleBars - 1), Math.max(0, Math.min(doc.song.barCount - doc.trackVisibleBars, doc.barScrollPos))));
            const channelScrollPos = Math.min(doc.channel, Math.max(doc.channel - (doc.trackVisibleChannels - 1), Math.max(0, Math.min(doc.song.getChannelCount() - doc.trackVisibleChannels, doc.channelScrollPos))));
            if (doc.channel != channelIndex || doc.bar != bar || doc.channelScrollPos != channelScrollPos || doc.barScrollPos != barScrollPos) {
                doc.channel = channelIndex;
                doc.channelScrollPos = channelScrollPos;
                doc.bar = bar;
                doc.barScrollPos = barScrollPos;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeReplacePatterns extends ChangeGroup {
        constructor(doc, pitchChannels, noiseChannels, modChannels) {
            super();
            const song = doc.song;
            function removeExtraSparseChannels(channels, maxLength) {
                while (channels.length > maxLength) {
                    let sparsestIndex = channels.length - 1;
                    let mostZeroes = 0;
                    for (let channelIndex = 0; channelIndex < channels.length - 1; channelIndex++) {
                        let zeroes = 0;
                        for (const bar of channels[channelIndex].bars) {
                            if (bar == 0)
                                zeroes++;
                        }
                        if (zeroes >= mostZeroes) {
                            sparsestIndex = channelIndex;
                            mostZeroes = zeroes;
                        }
                    }
                    channels.splice(sparsestIndex, 1);
                }
            }
            removeExtraSparseChannels(pitchChannels, Config.pitchChannelCountMax);
            removeExtraSparseChannels(noiseChannels, Config.noiseChannelCountMax);
            removeExtraSparseChannels(modChannels, Config.modChannelCountMax);
            while (pitchChannels.length < Config.pitchChannelCountMin)
                pitchChannels.push(new Channel());
            while (noiseChannels.length < Config.noiseChannelCountMin)
                noiseChannels.push(new Channel());
            while (modChannels.length < Config.modChannelCountMin)
                modChannels.push(new Channel());
            song.barCount = 1;
            song.patternsPerChannel = 8;
            const combinedChannels = pitchChannels.concat(noiseChannels.concat(modChannels));
            for (let channelIndex = 0; channelIndex < combinedChannels.length; channelIndex++) {
                const channel = combinedChannels[channelIndex];
                song.barCount = Math.max(song.barCount, channel.bars.length);
                song.patternsPerChannel = Math.max(song.patternsPerChannel, channel.patterns.length);
                song.channels[channelIndex] = channel;
            }
            song.channels.length = combinedChannels.length;
            song.pitchChannelCount = pitchChannels.length;
            song.noiseChannelCount = noiseChannels.length;
            song.modChannelCount = modChannels.length;
            song.barCount = Math.min(Config.barCountMax, song.barCount);
            song.patternsPerChannel = Math.min(Config.barCountMax, song.patternsPerChannel);
            for (let channelIndex = 0; channelIndex < song.channels.length; channelIndex++) {
                const channel = song.channels[channelIndex];
                for (let barIndex = 0; barIndex < channel.bars.length; barIndex++) {
                    if (channel.bars[barIndex] > song.patternsPerChannel || channel.bars[barIndex] < 0) {
                        channel.bars[barIndex] = 0;
                    }
                }
                while (channel.bars.length < song.barCount) {
                    channel.bars.push(0);
                }
                channel.bars.length = song.barCount;
                if (channel.instruments.length > song.getMaxInstrumentsPerChannel()) {
                    channel.instruments.length = song.getMaxInstrumentsPerChannel();
                }
                for (const pattern of channel.patterns) {
                    discardInvalidPatternInstruments(pattern.instruments, song, channelIndex);
                }
                while (channel.patterns.length < song.patternsPerChannel) {
                    channel.patterns.push(new Pattern());
                }
                channel.patterns.length = song.patternsPerChannel;
            }
            song.loopStart = Math.max(0, Math.min(song.barCount - 1, song.loopStart));
            song.loopLength = Math.min(song.barCount - song.loopStart, song.loopLength);
            this.append(new ChangeValidateTrackSelection(doc));
            doc.notifier.changed();
            this._didSomething();
            ColorConfig.resetColors();
        }
    }
    function comparePatternNotes(a, b) {
        if (a.length != b.length)
            return false;
        for (let noteIndex = 0; noteIndex < a.length; noteIndex++) {
            const oldNote = a[noteIndex];
            const newNote = b[noteIndex];
            if (newNote.start != oldNote.start || newNote.end != oldNote.end || newNote.pitches.length != oldNote.pitches.length || newNote.pins.length != oldNote.pins.length) {
                return false;
            }
            for (let pitchIndex = 0; pitchIndex < oldNote.pitches.length; pitchIndex++) {
                if (newNote.pitches[pitchIndex] != oldNote.pitches[pitchIndex]) {
                    return false;
                }
            }
            for (let pinIndex = 0; pinIndex < oldNote.pins.length; pinIndex++) {
                if (newNote.pins[pinIndex].interval != oldNote.pins[pinIndex].interval || newNote.pins[pinIndex].time != oldNote.pins[pinIndex].time || newNote.pins[pinIndex].size != oldNote.pins[pinIndex].size) {
                    return false;
                }
            }
        }
        return true;
    }
    function removeDuplicatePatterns(channels) {
        for (const channel of channels) {
            const newPatterns = [];
            for (let bar = 0; bar < channel.bars.length; bar++) {
                if (channel.bars[bar] == 0)
                    continue;
                const oldPattern = channel.patterns[channel.bars[bar] - 1];
                let foundMatchingPattern = false;
                for (let newPatternIndex = 0; newPatternIndex < newPatterns.length; newPatternIndex++) {
                    const newPattern = newPatterns[newPatternIndex];
                    if (!patternsContainSameInstruments(oldPattern.instruments, newPattern.instruments) || newPattern.notes.length != oldPattern.notes.length) {
                        continue;
                    }
                    if (comparePatternNotes(oldPattern.notes, newPattern.notes)) {
                        foundMatchingPattern = true;
                        channel.bars[bar] = newPatternIndex + 1;
                        break;
                    }
                }
                if (!foundMatchingPattern) {
                    newPatterns.push(oldPattern);
                    channel.bars[bar] = newPatterns.length;
                }
            }
            for (let patternIndex = 0; patternIndex < newPatterns.length; patternIndex++) {
                channel.patterns[patternIndex] = newPatterns[patternIndex];
            }
            channel.patterns.length = newPatterns.length;
        }
    }
    class ChangeTempo extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.tempo = Math.max(Config.tempoMin, Math.min(Config.tempoMax, Math.round(newValue)));
            doc.synth.unsetMod(Config.modulators.dictionary["tempo"].index);
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEchoDelay extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.echoDelay = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["echo delay"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEchoSustain extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.echoSustain = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["echo"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeChorus extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.chorus = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeReverb extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.reverb = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["reverb"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeNoteAdded extends UndoableChange {
        constructor(doc, pattern, note, index, deletion = false) {
            super(deletion);
            this._doc = doc;
            this._pattern = pattern;
            this._note = note;
            this._index = index;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._pattern.notes.splice(this._index, 0, this._note);
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._pattern.notes.splice(this._index, 1);
            this._doc.notifier.changed();
        }
    }
    class ChangeNoteLength extends ChangePins {
        constructor(doc, note, truncStart, truncEnd) {
            super(doc, note);
            const continuesLastPattern = ((this._oldStart < 0 || note.continuesLastPattern) && truncStart == 0);
            truncStart -= this._oldStart;
            truncEnd -= this._oldStart;
            let setStart = false;
            let prevSize = this._oldPins[0].size;
            let prevInterval = this._oldPins[0].interval;
            let pushLastPin = true;
            let i;
            for (i = 0; i < this._oldPins.length; i++) {
                const oldPin = this._oldPins[i];
                if (oldPin.time < truncStart) {
                    prevSize = oldPin.size;
                    prevInterval = oldPin.interval;
                }
                else {
                    if (oldPin.time > truncStart && !setStart) {
                        this._newPins.push(makeNotePin(prevInterval, truncStart, prevSize));
                        setStart = true;
                    }
                    if (oldPin.time <= truncEnd) {
                        this._newPins.push(makeNotePin(oldPin.interval, oldPin.time, oldPin.size));
                        if (oldPin.time == truncEnd) {
                            pushLastPin = false;
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            if (pushLastPin)
                this._newPins.push(makeNotePin(this._oldPins[i].interval, truncEnd, this._oldPins[i].size));
            this._finishSetup(continuesLastPattern);
        }
    }
    class ChangeNoteTruncate extends ChangeSequence {
        constructor(doc, pattern, start, end, skipNote = null, force = false) {
            super();
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (note == skipNote && skipNote != null) {
                    i++;
                }
                else if (note.end <= start) {
                    i++;
                }
                else if (note.start >= end) {
                    if (!doc.song.getChannelIsMod(doc.channel)) {
                        break;
                    }
                    else {
                        i++;
                    }
                }
                else if (note.start < start && note.end > end) {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0])) {
                        const copy = note.clone();
                        this.append(new ChangeNoteLength(doc, note, note.start, start));
                        i++;
                        this.append(new ChangeNoteAdded(doc, pattern, copy, i, false));
                        this.append(new ChangeNoteLength(doc, copy, end, copy.end));
                    }
                    i++;
                }
                else if (note.start < start) {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0]))
                        this.append(new ChangeNoteLength(doc, note, note.start, start));
                    i++;
                }
                else if (note.end > end) {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0]))
                        this.append(new ChangeNoteLength(doc, note, end, note.end));
                    i++;
                }
                else {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0]))
                        this.append(new ChangeNoteAdded(doc, pattern, note, i, true));
                    else
                        i++;
                }
            }
        }
    }
    class ChangeSplitNotesAtSelection extends ChangeSequence {
        constructor(doc, pattern) {
            super();
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (note.start < doc.selection.patternSelectionStart && doc.selection.patternSelectionStart < note.end) {
                    const copy = note.clone();
                    this.append(new ChangeNoteLength(doc, note, note.start, doc.selection.patternSelectionStart));
                    i++;
                    this.append(new ChangeNoteAdded(doc, pattern, copy, i, false));
                    this.append(new ChangeNoteLength(doc, copy, doc.selection.patternSelectionStart, copy.end));
                }
                else if (note.start < doc.selection.patternSelectionEnd && doc.selection.patternSelectionEnd < note.end) {
                    const copy = note.clone();
                    this.append(new ChangeNoteLength(doc, note, note.start, doc.selection.patternSelectionEnd));
                    i++;
                    this.append(new ChangeNoteAdded(doc, pattern, copy, i, false));
                    this.append(new ChangeNoteLength(doc, copy, doc.selection.patternSelectionEnd, copy.end));
                    i++;
                }
                else {
                    i++;
                }
            }
        }
    }
    class ChangeTransposeNote extends UndoableChange {
        constructor(doc, channelIndex, note, upward, ignoreScale = false, octave = false) {
            super(false);
            this._doc = doc;
            this._note = note;
            this._oldPins = note.pins;
            this._newPins = [];
            this._oldPitches = note.pitches;
            this._newPitches = [];
            const isNoise = doc.song.getChannelIsNoise(channelIndex);
            if (isNoise != doc.song.getChannelIsNoise(doc.channel))
                return;
            if (doc.song.getChannelIsMod(doc.channel))
                return;
            const maxPitch = (isNoise ? Config.drumCount - 1 : Config.maxPitch);
            for (let i = 0; i < this._oldPitches.length; i++) {
                let pitch = this._oldPitches[i];
                if (octave && !isNoise) {
                    if (upward) {
                        pitch = Math.min(maxPitch, pitch + 12);
                    }
                    else {
                        pitch = Math.max(0, pitch - 12);
                    }
                }
                else {
                    if (upward) {
                        for (let j = pitch + 1; j <= maxPitch; j++) {
                            if (isNoise || ignoreScale || Config.scales[doc.song.scale].flags[j % 12]) {
                                pitch = j;
                                break;
                            }
                        }
                    }
                    else {
                        for (let j = pitch - 1; j >= 0; j--) {
                            if (isNoise || ignoreScale || Config.scales[doc.song.scale].flags[j % 12]) {
                                pitch = j;
                                break;
                            }
                        }
                    }
                }
                let foundMatch = false;
                for (let j = 0; j < this._newPitches.length; j++) {
                    if (this._newPitches[j] == pitch) {
                        foundMatch = true;
                        break;
                    }
                }
                if (!foundMatch)
                    this._newPitches.push(pitch);
            }
            let min = 0;
            let max = maxPitch;
            for (let i = 1; i < this._newPitches.length; i++) {
                const diff = this._newPitches[0] - this._newPitches[i];
                if (min < diff)
                    min = diff;
                if (max > diff + maxPitch)
                    max = diff + maxPitch;
            }
            for (const oldPin of this._oldPins) {
                let interval = oldPin.interval + this._oldPitches[0];
                if (interval < min)
                    interval = min;
                if (interval > max)
                    interval = max;
                if (octave && !isNoise) {
                    if (upward) {
                        interval = Math.min(max, interval + 12);
                    }
                    else {
                        interval = Math.max(min, interval - 12);
                    }
                }
                else {
                    if (upward) {
                        for (let i = interval + 1; i <= max; i++) {
                            if (isNoise || ignoreScale || Config.scales[doc.song.scale].flags[i % 12]) {
                                interval = i;
                                break;
                            }
                        }
                    }
                    else {
                        for (let i = interval - 1; i >= min; i--) {
                            if (isNoise || ignoreScale || Config.scales[doc.song.scale].flags[i % 12]) {
                                interval = i;
                                break;
                            }
                        }
                    }
                }
                interval -= this._newPitches[0];
                this._newPins.push(makeNotePin(interval, oldPin.time, oldPin.size));
            }
            if (this._newPins[0].interval != 0)
                throw new Error("wrong pin start interval");
            for (let i = 1; i < this._newPins.length - 1;) {
                if (this._newPins[i - 1].interval == this._newPins[i].interval &&
                    this._newPins[i].interval == this._newPins[i + 1].interval &&
                    this._newPins[i - 1].size == this._newPins[i].size &&
                    this._newPins[i].size == this._newPins[i + 1].size) {
                    this._newPins.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._note.pins = this._newPins;
            this._note.pitches = this._newPitches;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pins = this._oldPins;
            this._note.pitches = this._oldPitches;
            this._doc.notifier.changed();
        }
    }
    class ChangeTranspose extends ChangeSequence {
        constructor(doc, channelIndex, pattern, upward, ignoreScale = false, octave = false) {
            super();
            if (doc.selection.patternSelectionActive) {
                this.append(new ChangeSplitNotesAtSelection(doc, pattern));
            }
            for (const note of pattern.notes) {
                if (doc.selection.patternSelectionActive && (note.end <= doc.selection.patternSelectionStart || note.start >= doc.selection.patternSelectionEnd)) {
                    continue;
                }
                this.append(new ChangeTransposeNote(doc, channelIndex, note, upward, ignoreScale, octave));
            }
        }
    }
    class ChangeTrackSelection extends Change {
        constructor(doc, newX0, newX1, newY0, newY1) {
            super();
            doc.selection.boxSelectionX0 = newX0;
            doc.selection.boxSelectionX1 = newX1;
            doc.selection.boxSelectionY0 = newY0;
            doc.selection.boxSelectionY1 = newY1;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangePatternSelection extends UndoableChange {
        constructor(doc, newStart, newEnd) {
            super(false);
            this._doc = doc;
            this._oldStart = doc.selection.patternSelectionStart;
            this._oldEnd = doc.selection.patternSelectionEnd;
            this._oldActive = doc.selection.patternSelectionActive;
            this._newStart = newStart;
            this._newEnd = newEnd;
            this._newActive = newStart < newEnd;
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._doc.selection.patternSelectionStart = this._newStart;
            this._doc.selection.patternSelectionEnd = this._newEnd;
            this._doc.selection.patternSelectionActive = this._newActive;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._doc.selection.patternSelectionStart = this._oldStart;
            this._doc.selection.patternSelectionEnd = this._oldEnd;
            this._doc.selection.patternSelectionActive = this._oldActive;
            this._doc.notifier.changed();
        }
    }
    class ChangeDragSelectedNotes extends ChangeSequence {
        constructor(doc, channelIndex, pattern, parts, transpose) {
            super();
            if (parts == 0 && transpose == 0)
                return;
            if (doc.selection.patternSelectionActive) {
                this.append(new ChangeSplitNotesAtSelection(doc, pattern));
            }
            const oldStart = doc.selection.patternSelectionStart;
            const oldEnd = doc.selection.patternSelectionEnd;
            const newStart = Math.max(0, Math.min(doc.song.beatsPerBar * Config.partsPerBeat, oldStart + parts));
            const newEnd = Math.max(0, Math.min(doc.song.beatsPerBar * Config.partsPerBeat, oldEnd + parts));
            if (newStart == newEnd) {
                this.append(new ChangeNoteTruncate(doc, pattern, oldStart, oldEnd, null, true));
            }
            else if (parts < 0) {
                this.append(new ChangeNoteTruncate(doc, pattern, newStart, Math.min(oldStart, newEnd), null, true));
            }
            else {
                this.append(new ChangeNoteTruncate(doc, pattern, Math.max(oldEnd, newStart), newEnd, null, true));
            }
            this.append(new ChangePatternSelection(doc, newStart, newEnd));
            const draggedNotes = [];
            let noteInsertionIndex = 0;
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (note.end <= oldStart || note.start >= oldEnd) {
                    i++;
                    if (note.end <= newStart)
                        noteInsertionIndex = i;
                }
                else {
                    draggedNotes.push(note.clone());
                    this.append(new ChangeNoteAdded(doc, pattern, note, i, true));
                }
            }
            for (const note of draggedNotes) {
                note.start += parts;
                note.end += parts;
                if (note.end <= newStart)
                    continue;
                if (note.start >= newEnd)
                    continue;
                this.append(new ChangeNoteAdded(doc, pattern, note, noteInsertionIndex++, false));
                this.append(new ChangeNoteLength(doc, note, Math.max(note.start, newStart), Math.min(newEnd, note.end)));
                for (let i = 0; i < Math.abs(transpose); i++) {
                    this.append(new ChangeTransposeNote(doc, channelIndex, note, transpose > 0, doc.notesOutsideScale));
                }
            }
        }
    }
    class ChangeDuplicateSelectedReusedPatterns extends ChangeGroup {
        constructor(doc, barStart, barWidth, channelStart, channelHeight) {
            super();
            for (let channelIndex = channelStart; channelIndex < channelStart + channelHeight; channelIndex++) {
                const reusablePatterns = {};
                for (let bar = barStart; bar < barStart + barWidth; bar++) {
                    const currentPatternIndex = doc.song.channels[channelIndex].bars[bar];
                    if (currentPatternIndex == 0)
                        continue;
                    if (reusablePatterns[String(currentPatternIndex)] == undefined) {
                        let isUsedElsewhere = false;
                        for (let bar2 = 0; bar2 < doc.song.barCount; bar2++) {
                            if (bar2 < barStart || bar2 >= barStart + barWidth) {
                                if (doc.song.channels[channelIndex].bars[bar2] == currentPatternIndex) {
                                    isUsedElsewhere = true;
                                    break;
                                }
                            }
                        }
                        if (isUsedElsewhere) {
                            const copiedPattern = doc.song.getPattern(channelIndex, bar);
                            this.append(new ChangePatternNumbers(doc, 0, bar, channelIndex, 1, 1));
                            this.append(new ChangeEnsurePatternExists(doc, channelIndex, bar));
                            const newPattern = doc.song.getPattern(channelIndex, bar);
                            if (newPattern == null)
                                throw new Error();
                            this.append(new ChangePaste(doc, newPattern, copiedPattern.notes, 0, Config.partsPerBeat * doc.song.beatsPerBar, Config.partsPerBeat * doc.song.beatsPerBar));
                            newPattern.instruments.length = 0;
                            newPattern.instruments.push(...copiedPattern.instruments);
                            reusablePatterns[String(currentPatternIndex)] = doc.song.channels[channelIndex].bars[bar];
                        }
                        else {
                            reusablePatterns[String(currentPatternIndex)] = currentPatternIndex;
                        }
                    }
                    this.append(new ChangePatternNumbers(doc, reusablePatterns[String(currentPatternIndex)], bar, channelIndex, 1, 1));
                }
            }
        }
    }
    class ChangePatternScale extends Change {
        constructor(doc, pattern, scaleMap) {
            super();
            if (doc.selection.patternSelectionActive) {
                new ChangeSplitNotesAtSelection(doc, pattern);
            }
            const maxPitch = Config.maxPitch;
            for (const note of pattern.notes) {
                if (doc.selection.patternSelectionActive && (note.end <= doc.selection.patternSelectionStart || note.start >= doc.selection.patternSelectionEnd)) {
                    continue;
                }
                const newPitches = [];
                const newPins = [];
                for (let i = 0; i < note.pitches.length; i++) {
                    const pitch = note.pitches[i];
                    const transformedPitch = scaleMap[pitch % 12] + (pitch - (pitch % 12));
                    if (newPitches.indexOf(transformedPitch) == -1) {
                        newPitches.push(transformedPitch);
                    }
                }
                let min = 0;
                let max = maxPitch;
                for (let i = 1; i < newPitches.length; i++) {
                    const diff = newPitches[0] - newPitches[i];
                    if (min < diff)
                        min = diff;
                    if (max > diff + maxPitch)
                        max = diff + maxPitch;
                }
                for (const oldPin of note.pins) {
                    let interval = oldPin.interval + note.pitches[0];
                    if (interval < min)
                        interval = min;
                    if (interval > max)
                        interval = max;
                    const transformedInterval = scaleMap[interval % 12] + (interval - (interval % 12));
                    newPins.push(makeNotePin(transformedInterval - newPitches[0], oldPin.time, oldPin.size));
                }
                if (newPins[0].interval != 0)
                    throw new Error("wrong pin start interval");
                for (let i = 1; i < newPins.length - 1;) {
                    if (newPins[i - 1].interval == newPins[i].interval &&
                        newPins[i].interval == newPins[i + 1].interval &&
                        newPins[i - 1].size == newPins[i].size &&
                        newPins[i].size == newPins[i + 1].size) {
                        newPins.splice(i, 1);
                    }
                    else {
                        i++;
                    }
                }
                note.pitches = newPitches;
                note.pins = newPins;
            }
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangeVolume extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].volume = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSongTitle extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            if (newValue.length > 30) {
                newValue = newValue.substring(0, 30);
            }
            doc.song.title = newValue;
            document.title = newValue + " - " + EditorConfig.versionDisplayName;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeChannelName extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            if (newValue.length > 15) {
                newValue = newValue.substring(0, 15);
            }
            doc.song.channels[doc.muteEditorChannel].name = newValue;
            doc.recalcChannelNames = true;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePan extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].pan = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["pan"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeShift extends Change {
    constructor(doc, oldValue, newValue) {
        super();
        doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].pitchShift = newValue;
        doc.synth.unsetMod(Config.modulators.dictionary["pan"].index, doc.channel, doc.getCurrentInstrument());
        doc.notifier.changed();
        if (oldValue != newValue)
            this._didSomething();
    }
}
    class ChangePanDelay extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].panDelay = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSizeBend extends UndoableChange {
        constructor(doc, note, bendPart, bendSize, bendInterval, uniformSize) {
            super(false);
            this._doc = doc;
            this._note = note;
            this._oldPins = note.pins;
            this._newPins = [];
            let inserted = false;
            for (const pin of note.pins) {
                if (pin.time < bendPart) {
                    if (uniformSize) {
                        this._newPins.push(makeNotePin(pin.interval, pin.time, bendSize));
                    }
                    else {
                        this._newPins.push(pin);
                    }
                }
                else if (pin.time == bendPart) {
                    this._newPins.push(makeNotePin(bendInterval, bendPart, bendSize));
                    inserted = true;
                }
                else {
                    if (!uniformSize && !inserted) {
                        this._newPins.push(makeNotePin(bendInterval, bendPart, bendSize));
                        inserted = true;
                    }
                    if (uniformSize) {
                        this._newPins.push(makeNotePin(pin.interval, pin.time, bendSize));
                    }
                    else {
                        this._newPins.push(pin);
                    }
                }
            }
            removeRedundantPins(this._newPins);
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._note.pins = this._newPins;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pins = this._oldPins;
            this._doc.notifier.changed();
        }
    }
    class ChangeChipWave extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.chipWave != newValue) {
                instrument.chipWave = newValue;
                instrument.chipwaveselected=instrument.chipWave
                
                instrument.preset = instrument.type;
                doc.notifier.changed();
                
if (!editor._instrumentName.value || editor._instrumentName.value.trim() === "") {
    const select = editor._chipWaveSelect;
    const selectedIndex = select.selectedIndex;
    const selectedOption = select.options[selectedIndex];

    if (selectedOption) {
        const selectedLabel = selectedOption.text;
        editor._instrumentName.value = selectedLabel;
        editor._doc.song.channels[editor._doc.channel].name = selectedLabel;
    }
}

                
                this._didSomething();
            }
        }
    }
    class ChangeChipWaveUseAdvancedLoopControls extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.isUsingAdvancedLoopControls != newValue) {
			instrument.isUsingAdvancedLoopControls = newValue;
			instrument.chipWaveLoopStart = 0;
			instrument.chipWaveLoopEnd = Config.chipWaves[instrument.chipWave].samples.length - 1;
			instrument.chipWaveLoopMode = 0;
			instrument.chipWavePlayBackwards = false;
			instrument.chipWaveStartOffset = 0;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
class ChangeChipWaveLoopMode extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.chipWaveLoopMode != newValue) {
			instrument.isUsingAdvancedLoopControls = true;
			instrument.chipWaveLoopMode = newValue;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
class ChangeChipWaveLoopStart extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.chipWaveLoopStart != newValue) {
			instrument.isUsingAdvancedLoopControls = true;
			instrument.chipWaveLoopStart = newValue;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
class ChangeChipWaveLoopEnd extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.chipWaveLoopEnd != newValue) {
			instrument.isUsingAdvancedLoopControls = true;
			instrument.chipWaveLoopEnd = newValue;
			instrument.chipWaveLoopStart = Math.max(0, Math.min(newValue - 1, instrument.chipWaveLoopStart));
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
class ChangeChipWaveStartOffset extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.chipWaveStartOffset != newValue) {
			instrument.isUsingAdvancedLoopControls = true;
			instrument.chipWaveStartOffset = newValue;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
class ChangeChipWavePlayBackwards extends Change {
	constructor(doc, newValue) {
		super();
		const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
		if (instrument.chipWavePlayBackwards != newValue) {
			instrument.isUsingAdvancedLoopControls = true;
			instrument.chipWavePlayBackwards = newValue;
			instrument.preset = instrument.type;
			doc.notifier.changed();
			this._didSomething();
		}
	}
}
    class ChangeNoiseWave extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.chipNoise != newValue) {
                instrument.chipNoise = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
     
    class ChangeAddEnvelope extends Change {
        constructor(doc) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.addEnvelope(0, 0, 0);



            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
            
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].envelopessave = instrument.envelopes
        }
    }
    class ChangeRemoveEnvelope extends Change {
        constructor(doc, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.envelopeCount--;
            for (let i = index; i < instrument.envelopeCount; i++) {
                instrument.envelopes[i].target = instrument.envelopes[i + 1].target;
                instrument.envelopes[i].index = instrument.envelopes[i + 1].index;
                instrument.envelopes[i].envelope = instrument.envelopes[i + 1].envelope;
            }
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].envelopessave = instrument.envelopes
        }
    }
    class ChangeSetEnvelopeTarget extends Change {
        constructor(doc, envelopeIndex, target, targetIndex) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            
 
            
            const oldTarget = instrument.envelopes[envelopeIndex].target;
            const oldIndex = instrument.envelopes[envelopeIndex].index;
            if (oldTarget != target || oldIndex != targetIndex) {
                instrument.envelopes[envelopeIndex].target = target;
                instrument.envelopes[envelopeIndex].index = targetIndex;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].envelopessave = instrument.envelopes
        }
    }
    class ChangeSetEnvelopeType extends Change {
        constructor(doc, envelopeIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            
            
            const oldValue = instrument.envelopes[envelopeIndex].envelope;
            if (oldValue != newValue) {
                instrument.envelopes[envelopeIndex].envelope = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
            
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].envelopessave = instrument.envelopes
        }
    }

    const { div, input, button, h2, select, option, canvas: canvas$1, span ,br} = HTML; 
    class BeatsPerBarPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._beatsStepper = input({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._conversionStrategySelect = select({ style: "width: 100%;" }, option({ value: "splice" }, "Splice beats at end of bars."), option({ value: "stretch" }, "Stretch notes to fit in bars."), option({ value: "overflow" }, "Overflow notes across bars."));
            this._cancelButton = button({ class: "cancelButton" });
            this._okayButton = button({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div({ class: "prompt noSelection", style: "width: 250px;" }, h2("Beats Per Bar"), div({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div({ style: "text-align: right;" }, "Beats per bar:", br(), span({ style: "font-size: smaller; color: ${ColorConfig.secondaryText};" }, "(Multiples of 3 or 4 are recommended)")), this._beatsStepper), div({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div({ class: "selectContainer", style: "width: 100%;" }, this._conversionStrategySelect)), div({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._beatsStepper.removeEventListener("keypress", BeatsPerBarPrompt._validateKey);
                this._beatsStepper.removeEventListener("blur", BeatsPerBarPrompt._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("beatCountStrategy", this._conversionStrategySelect.value);
                this._doc.prompt = null;
                this._doc.record(new ChangeBeatsPerBar(this._doc, BeatsPerBarPrompt._validate(this._beatsStepper), this._conversionStrategySelect.value), true);
            };
            this._beatsStepper.value = this._doc.song.beatsPerBar + "";
            this._beatsStepper.min = Config.beatsPerBarMin + "";
            this._beatsStepper.max = Config.beatsPerBarMax + "";
            const lastStrategy = window.localStorage.getItem("beatCountStrategy");
            if (lastStrategy != null) {
                this._conversionStrategySelect.value = lastStrategy;
            }
            this._beatsStepper.select();
            setTimeout(() => this._beatsStepper.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._beatsStepper.addEventListener("keypress", BeatsPerBarPrompt._validateKey);
            this._beatsStepper.addEventListener("blur", BeatsPerBarPrompt._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        static _validateKey(event) {
            const charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 46 && charCode > 31 && (charCode < 48 || charCode > 57)) {
                event.preventDefault();
                return true;
            }
            return false;
        }
        static _validateNumber(event) {
            const input = event.target;
            input.value = String(BeatsPerBarPrompt._validate(input));
        }
        static _validate(input) {
            return Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value))));
        }
    }

    const { button: button$1, div: div$1, label, br: br$1, h2: h2$1, input: input$1 } = HTML;
    class ChannelSettingsPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._patternsStepper = input$1({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._pitchChannelStepper = input$1({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._drumChannelStepper = input$1({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._modChannelStepper = input$1({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._layeredInstrumentsBox = input$1({ style: "width: 3em; margin-left: 1em;", type: "checkbox" });
            this._patternInstrumentsBox = input$1({ style: "width: 3em; margin-left: 1em;", type: "checkbox" });
            this._cancelButton = button$1({ class: "cancelButton" });
            this._okayButton = button$1({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$1({ class: "prompt noSelection", style: "width: 250px; text-align: right;" }, h2$1("Channel Settings"), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Pitch channels:", this._pitchChannelStepper), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Drum channels:", this._drumChannelStepper), div$1({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Mod channels:", this._modChannelStepper), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Available patterns per channel:", this._patternsStepper), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Simultaneous instruments", br$1(), "per channel:", this._layeredInstrumentsBox), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Different instruments", br$1(), "per pattern:", this._patternInstrumentsBox), label({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._patternsStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._pitchChannelStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._drumChannelStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._modChannelStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._patternsStepper.removeEventListener("blur", this._validateNumber);
                this._pitchChannelStepper.removeEventListener("blur", this._validateNumber);
                this._drumChannelStepper.removeEventListener("blur", this._validateNumber);
                this._modChannelStepper.removeEventListener("blur", this._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._validateNumber = (event) => {
                const input = event.target;
                input.value = String(ChannelSettingsPrompt._validate(input));
            };
            this._saveChanges = () => {
                const group = new ChangeGroup();
                group.append(new ChangeInstrumentsFlags(this._doc, this._layeredInstrumentsBox.checked, this._patternInstrumentsBox.checked));
                group.append(new ChangePatternsPerChannel(this._doc, ChannelSettingsPrompt._validate(this._patternsStepper)));
                group.append(new ChangeChannelCount(this._doc, ChannelSettingsPrompt._validate(this._pitchChannelStepper), ChannelSettingsPrompt._validate(this._drumChannelStepper), ChannelSettingsPrompt._validate(this._modChannelStepper)));
                this._doc.prompt = null;
                this._doc.record(group, true);
            };
            this._patternsStepper.value = this._doc.song.patternsPerChannel + "";
            this._patternsStepper.min = "1";
            this._patternsStepper.max = Config.barCountMax + "";
            this._pitchChannelStepper.value = this._doc.song.pitchChannelCount + "";
            this._pitchChannelStepper.min = Config.pitchChannelCountMin + "";
            this._pitchChannelStepper.max = Config.pitchChannelCountMax + "";
            this._drumChannelStepper.value = this._doc.song.noiseChannelCount + "";
            this._drumChannelStepper.min = Config.noiseChannelCountMin + "";
            this._drumChannelStepper.max = Config.noiseChannelCountMax + "";
            this._modChannelStepper.value = this._doc.song.modChannelCount + "";
            this._modChannelStepper.min = Config.modChannelCountMin + "";
            this._modChannelStepper.max = Config.modChannelCountMax + "";
            this._layeredInstrumentsBox.checked = this._doc.song.layeredInstruments;
            this._patternInstrumentsBox.checked = this._doc.song.patternInstruments;
            this._pitchChannelStepper.select();
            setTimeout(() => this._pitchChannelStepper.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._patternsStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._pitchChannelStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._drumChannelStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._modChannelStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._patternsStepper.addEventListener("blur", this._validateNumber);
            this._pitchChannelStepper.addEventListener("blur", this._validateNumber);
            this._drumChannelStepper.addEventListener("blur", this._validateNumber);
            this._modChannelStepper.addEventListener("blur", this._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        static _validateKey(event) {
            const charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 46 && charCode > 31 && (charCode < 48 || charCode > 57)) {
                event.preventDefault();
                return true;
            }
            return false;
        }
        static _validate(input) {
            return Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value))));
        }
    }

    const { button: button$2, div: div$2, h2: h2$2 } = HTML;
    class CustomChipPromptCanvas {
        constructor(doc) {
            this._mouseX = 0;
            this._mouseY = 0;
            this._lastIndex = 0;
            this._lastAmp = 0;
            this._mouseDown = false;
            this.chipData = new Float64Array(64);
            this.startingChipData = new Float64Array(64);
            this._undoHistoryState = 0;
            this._changeQueue = [];
            this._editorWidth = 768 ;
            this._editorHeight = 294;
            this._fill = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._ticks = SVG.svg({ "pointer-events": "none" });
            this._subticks = SVG.svg({ "pointer-events": "none" });
            this._blocks = SVG.svg({ "pointer-events": "none" });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; overflow: visible;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._fill, this._ticks, this._subticks, this._blocks);
            this.container = HTML.div({ class: "", style: "height: 294px; width: 768px; padding-bottom: 1.5em;" }, this._svg);
            this._storeChange = () => {
                var sameCheck = true;
                if (this._changeQueue.length > 0) {
                    for (var i = 0; i < 64; i++) {
                        if (this._changeQueue[this._undoHistoryState][i] != this.chipData[i]) {
                            sameCheck = false;
                            i = 64;
                        }
                    }
                }
                if (sameCheck == false || this._changeQueue.length == 0) {
                    this._changeQueue.splice(0, this._undoHistoryState);
                    this._undoHistoryState = 0;
                    this._changeQueue.unshift(this.chipData.slice());
                    if (this._changeQueue.length > 32) {
                        this._changeQueue.pop();
                    }
                }
            };
            this.undo = () => {
                if (this._undoHistoryState < this._changeQueue.length - 1) {
                    this._undoHistoryState++;
                    this.chipData = this._changeQueue[this._undoHistoryState].slice();
                    new ChangeCustomWave(this._doc, this.chipData);
                    this.render();
                }
            };
            this.redo = () => {
                if (this._undoHistoryState > 0) {
                    this._undoHistoryState--;
                    this.chipData = this._changeQueue[this._undoHistoryState].slice();
                    new ChangeCustomWave(this._doc, this.chipData);
                    this.render();
                }
            };
            this._whenKeyPressed = (event) => {
                if (event.keyCode == 90) {
                    this.undo();
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    this.redo();
                    event.stopPropagation();
                }
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._lastIndex = -1;
                this._whenCursorMoved();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._lastIndex = -1;
                this._whenCursorMoved();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                this._storeChange();
                this._mouseDown = false;
            };
            this._doc = doc;
            for (let i = 0; i <= 4; i += 2) {
                this._ticks.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i * this._editorWidth / 4) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 1; i <= 8; i++) {
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i * this._editorWidth / 8) - 1, y: 0, width: 1, height: this._editorHeight }));
            }
            this._ticks.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: 0, y: (this._editorHeight / 2) - 1, width: this._editorWidth, height: 2 }));
            for (let i = 0; i < 3; i++) {
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: 0, y: i * 8 * (this._editorHeight / 49), width: this._editorWidth, height: 1 }));
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: 0, y: this._editorHeight - 1 - i * 8 * (this._editorHeight / 49), width: this._editorWidth, height: 1 }));
            }
            let col = ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote;
            for (let i = 0; i <= 64; i++) {
                let val = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].customChipWave[i];
                this.chipData[i] = val;
                this.startingChipData[i] = val;
                this._blocks.appendChild(SVG.rect({ fill: col, x: (i * this._editorWidth / 64), y: (val + 24) * (this._editorHeight / 49), width: this._editorWidth / 64, height: this._editorHeight / 49 }));
            }
            this._storeChange();
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
            this._svg.addEventListener("keydown", this._whenKeyPressed);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                const index = Math.min(63, Math.max(0, Math.floor(this._mouseX * 64 / this._editorWidth)));
                const amp = Math.min(48, Math.max(0, Math.floor(this._mouseY * 49 / this._editorHeight)));
                if (this._lastIndex != -1 && this._lastIndex != index) {
                    var lowest = index;
                    var highest = this._lastIndex;
                    var startingAmp = amp;
                    var endingAmp = this._lastAmp;
                    if (this._lastIndex < index) {
                        lowest = this._lastIndex;
                        highest = index;
                        startingAmp = this._lastAmp;
                        endingAmp = amp;
                    }
                    for (var i = lowest; i <= highest; i++) {
                        const medAmp = Math.round(startingAmp + (endingAmp - startingAmp) * ((i - lowest) / (highest - lowest)));
                        this.chipData[i] = medAmp - 24;
                        this._blocks.children[i].setAttribute("y", "" + (medAmp * (this._editorHeight / 49)));
                    }
                }
                else {
                    this.chipData[index] = amp - 24;
                    this._blocks.children[index].setAttribute("y", "" + (amp * (this._editorHeight / 49)));
                }
                new ChangeCustomWave(this._doc, this.chipData);
                this._lastIndex = index;
                this._lastAmp = amp;
            }
        }
        render() {
            for (var i = 0; i < 64; i++) {
                this._blocks.children[i].setAttribute("y", "" + ((this.chipData[i] + 24) * (this._editorHeight / 49)));
            }
        }
    }
    class CustomChipPrompt {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this.customChipCanvas = new CustomChipPromptCanvas(this._doc);
            this._playButton = button$2({ style: "width: 55%;", type: "button" });
            this._cancelButton = button$2({ class: "cancelButton" });
            this._okayButton = button$2({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$2({ class: "prompt noSelection", style: "width: 600px;" }, h2$2("Edit Custom Chip Instrument"), div$2({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center;" }, this.customChipCanvas.container), div$2({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._togglePlay = () => {
            
                if (this._doc.synth.playing) {
                    this._songEditor._pause();
                    this.updatePlayButton();
                }
                else {
                    this._doc.synth.snapToBar();
                    this._songEditor._play();
                    this.updatePlayButton();
                }
            };
            

            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
                if (event.keyCode == 90) {
                    this.customChipCanvas.undo();
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    this.customChipCanvas.redo();
                    event.stopPropagation();
                }
            };
            this._saveChanges = () => {
                this._doc.prompt = null;
                new ChangeCustomWave(this._doc, this.customChipCanvas.startingChipData);
                this._doc.record(new ChangeCustomWave(this._doc, this.customChipCanvas.chipData), true);
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this.whenKeyPressed);
            this._playButton.addEventListener("click", this._togglePlay);
            this.updatePlayButton();
            setTimeout(() => this._playButton.focus());
            this.customChipCanvas.render();
        }
        updatePlayButton() {
        	
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            } 
            
        }
    }

    class FilterEditor {
        constructor(_doc, useNoteFilter = false, larger = false) {
            this._doc = _doc;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._responsePath = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._indicators = [];
            this._subFilters = [];
            this._controlPointPath = SVG.path({ fill: "currentColor", "pointer-events": "none" });
            this._dottedLinePath = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 1, "stroke-dasharray": "3, 2", "pointer-events": "none" });
            this._highlight = SVG.circle({ fill: "white", stroke: "none", "pointer-events": "none", r: 4 });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._responsePath, this._dottedLinePath, this._highlight, this._controlPointPath);
            this.selfUndoSettings = [];
            this.selfUndoHistoryPos = 0;
            this._label = HTML.div({ style: "position: absolute; bottom: 0; left: 2px; font-size: 8px; line-height: 1; pointer-events: none;" });
            this.container = HTML.div({ class: "filterEditor", style: "height: 100%; position: relative;" }, this._svg, this._label);
            this._pointRadius = 2;
            this._useNoteFilter = false;
            this._larger = false;
            this._touchMode = false;
            this._mouseX = 0;
            this._mouseY = 0;
            this._mouseOver = false;
            this._mouseDown = false;
            this._mouseDragging = false;
            this._addingPoint = false;
            this._deletingPoint = false;
            this._addedType = 2;
            this._selectedIndex = 0;
            this._freqStart = 0;
            this._gainStart = 0;
            this._dragChange = null;
            this._subfilterIndex = 0;
            this._renderedSelectedIndex = -1;
            this._renderedPointCount = -1;
            this._renderedPointTypes = -1;
            this._renderedPointFreqs = -1;
            this._renderedPointGains = -1;
            this._whenKeyPressed = (event) => {
                if (event.keyCode == 90) {
                    this.undo();
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    this.redo();
                    event.stopPropagation();
                }
            };
            this._whenMouseOver = (event) => {
                this._mouseOver = true;
                if (!this._larger)
                    this._controlPointPath.style.setProperty("fill", "currentColor");
            };
            this._whenMouseOut = (event) => {
                this._mouseOver = false;
                this._updatePath();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._touchMode = false;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorPressed();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._touchMode = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorPressed();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (!this._mouseDown)
                    this._updateCursor();
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (this._mouseDown)
                    event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (!this._mouseDown)
                    this._updateCursor();
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (this._mouseDown && this._doc.lastChangeWas(this._dragChange) && this._dragChange != null) {
                    if (!this._addingPoint && !this._mouseDragging && !this._touchMode) {
                        if (this._selectedIndex < this._filterSettings.controlPointCount && this._selectedIndex != -1) {
                            const point = this._filterSettings.controlPoints[this._selectedIndex];
                            let change = new ChangeFilterAddPoint(this._doc, this._filterSettings, point, this._selectedIndex, this._useNoteFilter, true);
                            if (!this._larger) {
                                this._doc.record(change);
                            }
                        }
                    }
                    else if (!this._larger) {
                        this._doc.record(this._dragChange);
                    }
                    this._updatePath();
                    if (this._larger) {
                        this.selfUndoSettings.length = this.selfUndoHistoryPos + 1;
                        this.selfUndoSettings.push(JSON.stringify(this._filterSettings.toJsonObject()));
                        this.selfUndoHistoryPos++;
                    }
                }
                this._dragChange = null;
                this._mouseDragging = false;
                this._deletingPoint = false;
                this._mouseDown = false;
                this._updateCursor();
            };
            this._useNoteFilter = useNoteFilter;
            this._larger = larger;
            if (this._larger) {
                this.container.addEventListener("keydown", this._whenKeyPressed);
                this._editorWidth = 1200;
                this._editorHeight = 260;
                this._pointRadius = 14;
                this._svg.setAttribute("viewBox", "0 -20 " + this._editorWidth + " " + (this._editorHeight + 30));
                this._label.style.setProperty("font-size", "16px");
                this._label.style.setProperty("position", "");
                this._label.style.setProperty("bottom", "-16px");
                this._label.style.setProperty("min-height", "1em");
                this._dottedLinePath.style.setProperty("stroke-width", "3");
                this._dottedLinePath.style.setProperty("stroke-dasharray", "6, 4");
                this._dottedLinePath.setAttribute("color", ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
                this.container.style.setProperty("width", "85%");
                this._highlight.setAttribute("r", "20");
                this._controlPointPath.setAttribute("fill", ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
                for (let i = 0; i < Config.filterMaxPoints; i++) {
                    this._indicators[i] = SVG.text();
                    this._indicators[i].setAttribute("fill", ColorConfig.invertedText);
                    this._indicators[i].setAttribute("text-anchor", "start");
                    this._indicators[i].setAttribute("dominant-baseline", "central");
                    this._indicators[i].setAttribute("pointer-events", "none");
                    this._indicators[i].setAttribute("font-weight", "bolder");
                    this._indicators[i].textContent = "" + (i + 1);
                    this._indicators[i].style.setProperty("display", "none");
                    this._indicators[i].style.setProperty("font-size", "24px");
                    this._svg.appendChild(this._indicators[i]);
                }
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                const filterSettings = this._useNoteFilter ? instrument.noteFilter : instrument.eqFilter;
                this.selfUndoSettings.push(JSON.stringify(filterSettings.toJsonObject()));
                this._subFilters[0] = filterSettings;
                for (let i = 1; i < Config.filterMorphCount; i++) {
                    const subFilter = this._useNoteFilter ? instrument.noteSubFilters[i] : instrument.eqSubFilters[i];
                    if (subFilter != null) {
                        let parsedFilter = new FilterSettings();
                        parsedFilter.fromJsonObject(subFilter.toJsonObject());
                        this._subFilters[i] = parsedFilter;
                    }
                }
            }
            this.container.addEventListener("mousedown", this._whenMousePressed);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _xToFreq(x) {
            return Config.filterFreqRange * x / this._editorWidth - 0.5;
        }
        _freqToX(freq) {
            return this._editorWidth * (freq + 0.5) / Config.filterFreqRange;
        }
        _yToGain(y) {
            return (Config.filterGainRange - 1) * (1 - (y - .5) / (this._editorHeight - 1));
        }
        _gainToY(gain) {
            return (this._editorHeight - 1) * (1 - gain / (Config.filterGainRange - 1)) + .5;
        }
        _whenCursorPressed() {
            this._mouseDown = true;
            const sequence = new ChangeSequence();
            this._dragChange = sequence;
            this._doc.setProspectiveChange(this._dragChange);
            this._updateCursor();
            this._whenCursorMoved();
        }
        _updateCursor() {
            this._freqStart = this._xToFreq(this._mouseX);
            this._gainStart = this._yToGain(this._mouseY);
            this._addingPoint = true;
            this._selectedIndex = -1;
            let nearestDistance = Number.POSITIVE_INFINITY;
            for (let i = 0; i < this._filterSettings.controlPointCount; i++) {
                const point = this._filterSettings.controlPoints[i];
                const distance = Math.sqrt(Math.pow(this._freqToX(point.freq) - this._mouseX, 2) + Math.pow(this._gainToY(point.gain) - this._mouseY, 2));
                if ((distance <= 13 * (1 + +this._larger) || this._filterSettings.controlPointCount >= Config.filterMaxPoints) && distance < nearestDistance) {
                    nearestDistance = distance;
                    this._selectedIndex = i;
                    this._addingPoint = false;
                }
            }
            if (this._addingPoint) {
                const ratio = this._mouseX / this._editorWidth;
                if (ratio < 0.2) {
                    this._addedType = 1;
                }
                else if (ratio < 0.8) {
                    this._addedType = 2;
                }
                else {
                    this._addedType = 0;
                }
            }
        }
        _whenCursorMoved() {
            if (this._dragChange != null && this._doc.lastChangeWas(this._dragChange)) {
                this._dragChange.undo();
            }
            else {
                this._mouseDown = false;
            }
            this._dragChange = null;
            this._deletingPoint = false;
            if (this._mouseDown) {
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._doc.setProspectiveChange(this._dragChange);
                if (this._addingPoint) {
                    const gain = Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(this._yToGain(this._mouseY))));
                    const freq = this._findNearestFreqSlot(this._filterSettings, this._xToFreq(this._mouseX), -1);
                    if (freq >= 0 && freq < Config.filterFreqRange) {
                        const point = new FilterControlPoint();
                        point.type = this._addedType;
                        point.freq = freq;
                        point.gain = gain;
                        sequence.append(new ChangeFilterAddPoint(this._doc, this._filterSettings, point, this._filterSettings.controlPointCount, this._useNoteFilter));
                    }
                    else {
                        this._deletingPoint = true;
                    }
                }
                else if (this._selectedIndex >= this._filterSettings.controlPointCount || this._selectedIndex == -1) {
                    this._dragChange = null;
                    this._mouseDown = false;
                }
                else {
                    const freqDelta = this._xToFreq(this._mouseX) - this._freqStart;
                    const gainDelta = this._yToGain(this._mouseY) - this._gainStart;
                    const point = this._filterSettings.controlPoints[this._selectedIndex];
                    const gain = Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(point.gain + gainDelta)));
                    const freq = this._findNearestFreqSlot(this._filterSettings, point.freq + freqDelta, this._selectedIndex);
                    if (Math.round(freqDelta) != 0.0 || Math.round(gainDelta) != 0.0 || freq != point.freq || gain != point.gain) {
                        this._mouseDragging = true;
                    }
                    if (freq >= 0 && freq < Config.filterFreqRange) {
                        sequence.append(new ChangeFilterMovePoint(this._doc, point, point.freq, freq, point.gain, gain));
                    }
                    else {
                        sequence.append(new ChangeFilterAddPoint(this._doc, this._filterSettings, point, this._selectedIndex, this._useNoteFilter, true));
                        this._deletingPoint = true;
                    }
                }
            }
            if (this._mouseDown || this._mouseOver) {
                this._updatePath();
            }
        }
        _findNearestFreqSlot(filterSettings, targetFreq, ignoreIndex) {
            const roundedFreq = Math.round(targetFreq);
            let lowerFreq = roundedFreq;
            let upperFreq = roundedFreq;
            let tryingLower = (roundedFreq <= targetFreq);
            while (true) {
                let foundConflict = false;
                const currentFreq = tryingLower ? lowerFreq : upperFreq;
                for (let i = 0; i < filterSettings.controlPointCount; i++) {
                    if (i == ignoreIndex)
                        continue;
                    if (filterSettings.controlPoints[i].freq == currentFreq) {
                        foundConflict = true;
                        break;
                    }
                }
                if (!foundConflict)
                    return currentFreq;
                tryingLower = !tryingLower;
                if (tryingLower)
                    lowerFreq--;
                if (!tryingLower)
                    upperFreq++;
            }
        }
        static _circlePath(cx, cy, radius, reverse = false) {
            return `M ${cx - radius} ${cy} ` +
                `a ${radius} ${radius} 0 1 ${reverse ? 1 : 0} ${radius * 2} 0 ` +
                `a ${radius} ${radius} 0 1 ${reverse ? 1 : 0} ${-radius * 2} 0 `;
        }
        _updatePath() {
            this._highlight.style.display = "none";
            this._label.textContent = "";
            let controlPointPath = "";
            let dottedLinePath = "";
            for (let i = 0; i < this._filterSettings.controlPointCount; i++) {
                const point = this._filterSettings.controlPoints[i];
                const pointX = this._freqToX(point.freq);
                const pointY = this._gainToY(point.gain);
                controlPointPath += FilterEditor._circlePath(pointX, pointY, this._pointRadius);
                if (point.type == 1) {
                    dottedLinePath += "M " + 0 + " " + pointY + " L " + pointX + " " + pointY + " ";
                }
                else if (point.type == 0) {
                    dottedLinePath += "M " + this._editorWidth + " " + pointY + " L " + pointX + " " + pointY + " ";
                }
                if (this._selectedIndex == i && this._mouseOver && !this._mouseDown) {
                    this._highlight.setAttribute("cx", String(pointX));
                    this._highlight.setAttribute("cy", String(pointY));
                    this._highlight.style.display = "";
                }
                if ((this._selectedIndex == i || (this._addingPoint && this._mouseDown && i == this._filterSettings.controlPointCount - 1)) && (this._mouseOver || this._mouseDown) && !this._deletingPoint) {
                    this._label.textContent = (i + 1) + ": " + Config.filterTypeNames[point.type];
                }
                if (this._larger) {
                    this._indicators[i].style.setProperty("display", "");
                    this._indicators[i].setAttribute("x", "" + (pointX - 7));
                    this._indicators[i].setAttribute("y", "" + (pointY + 2));
                }
            }
            this._controlPointPath.setAttribute("d", controlPointPath);
            this._dottedLinePath.setAttribute("d", dottedLinePath);
            if (this._addingPoint && !this._mouseDown && this._mouseOver) {
                this._label.textContent = "+ " + Config.filterTypeNames[this._addedType];
            }
            if (this._larger) {
                for (let i = this._filterSettings.controlPointCount; i < Config.filterMaxPoints; i++) {
                    this._indicators[i].style.setProperty("display", "none");
                }
            }
            const standardSampleRate = 44800;
            const filters = [];
            for (let i = 0; i < this._filterSettings.controlPointCount; i++) {
                const point = this._filterSettings.controlPoints[i];
                const filter = new FilterCoefficients();
                point.toCoefficients(filter, standardSampleRate);
                filters.push(filter);
            }
            const response = new FrequencyResponse();
            let responsePath = "M 0 " + this._editorHeight + " ";
            for (let i = -1; i <= Config.filterFreqRange; i++) {
                const hz = FilterControlPoint.getHzFromSettingValue(i);
                const cornerRadiansPerSample = 2.0 * Math.PI * hz / standardSampleRate;
                const real = Math.cos(cornerRadiansPerSample);
                const imag = Math.sin(cornerRadiansPerSample);
                let linearGain = 1.0;
                for (const filter of filters) {
                    response.analyzeComplex(filter, real, imag);
                    linearGain *= response.magnitude();
                }
                const gainSetting = Math.log2(linearGain) / Config.filterGainStep + Config.filterGainCenter;
                const y = this._gainToY(gainSetting);
                const x = this._freqToX(i);
                responsePath += "L " + prettyNumber(x) + " " + prettyNumber(y) + " ";
            }
            responsePath += "L " + this._editorWidth + " " + this._editorHeight + " L 0 " + this._editorHeight + " z ";
            this._responsePath.setAttribute("d", responsePath);
        }
        swapToSettings(settings, useHistory = false) {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            new ChangeFilterSettings(this._doc, settings, this._filterSettings, this._useNoteFilter, this._subFilters, this._useNoteFilter ? instrument.noteSubFilters : instrument.eqSubFilters);
            this._filterSettings = settings;
            this._subFilters[this._subfilterIndex] = settings;
            if (useHistory && this._larger) {
                this.selfUndoSettings.length = this.selfUndoHistoryPos + 1;
                this.selfUndoSettings.push(JSON.stringify((this._filterSettings.toJsonObject())));
                this.selfUndoHistoryPos++;
            }
            this._updatePath();
        }
        saveSettings() {
            let firstFilter = new FilterSettings;
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            firstFilter.fromJsonObject(JSON.parse(String(this.selfUndoSettings[0])));
            this._doc.record(new ChangeFilterSettings(this._doc, this._subFilters[0], firstFilter, this._useNoteFilter, this._subFilters, this._useNoteFilter ? instrument.noteSubFilters : instrument.eqSubFilters), true);
        }
        undo() {
            if (this.selfUndoHistoryPos > 0) {
                this.selfUndoHistoryPos--;
                if (this.selfUndoSettings[this.selfUndoHistoryPos + 1] != null && this.selfUndoSettings[this.selfUndoHistoryPos + 1].startsWith("jmp")) {
                    let str = this.selfUndoSettings[this.selfUndoHistoryPos + 1];
                    let jumpIndex = +str.substring(3, str.indexOf("|"));
                    this.swapToSubfilter(this._subfilterIndex, jumpIndex);
                    return jumpIndex;
                }
                else if (this.selfUndoSettings[this.selfUndoHistoryPos].startsWith("jmp")) {
                    let savedFilter = new FilterSettings();
                    let str = this.selfUndoSettings[this.selfUndoHistoryPos];
                    savedFilter.fromJsonObject(JSON.parse(str.substring(str.indexOf(":") + 1)));
                    this.swapToSettings(savedFilter, false);
                }
                else {
                    let savedFilter = new FilterSettings();
                    savedFilter.fromJsonObject(JSON.parse(String(this.selfUndoSettings[this.selfUndoHistoryPos])));
                    this.swapToSettings(savedFilter, false);
                }
            }
            return -1;
        }
        redo() {
            if (this.selfUndoHistoryPos < this.selfUndoSettings.length - 1) {
                this.selfUndoHistoryPos++;
                if (this.selfUndoSettings[this.selfUndoHistoryPos].startsWith("jmp")) {
                    let str = this.selfUndoSettings[this.selfUndoHistoryPos];
                    let jumpIndex = +str.substring(str.indexOf("|") + 1, str.indexOf(":"));
                    this.swapToSubfilter(this._subfilterIndex, jumpIndex, false);
                    return jumpIndex;
                }
                else {
                    let savedFilter = new FilterSettings();
                    savedFilter.fromJsonObject(JSON.parse(String(this.selfUndoSettings[this.selfUndoHistoryPos])));
                    this.swapToSettings(savedFilter, false);
                }
            }
            return -1;
        }
        resetToInitial() {
            this.selfUndoHistoryPos = 1;
            this.undo();
        }
        swapSubfilterIndices(newIndex) {
            if (this._selectedIndex == -1)
                return;
            if (newIndex >= this._filterSettings.controlPointCount)
                return;
            let tmp = this._filterSettings.controlPoints[this._selectedIndex];
            this._filterSettings.controlPoints[this._selectedIndex] = this._filterSettings.controlPoints[newIndex];
            this._filterSettings.controlPoints[newIndex] = tmp;
            this.render();
        }
        swapToSubfilter(oldIndex, newIndex, useHistory = false) {
            if (oldIndex != newIndex) {
                let currFilter = new FilterSettings();
                currFilter.fromJsonObject(this._filterSettings.toJsonObject());
                this._subFilters[oldIndex] = currFilter;
                if (this._subFilters[newIndex] == undefined) {
                    let parsedFilter = new FilterSettings();
                    parsedFilter.fromJsonObject(this._subFilters[0].toJsonObject());
                    this._subFilters[newIndex] = parsedFilter;
                }
                if (useHistory) {
                    this.selfUndoSettings.length = this.selfUndoHistoryPos + 1;
                    this.selfUndoSettings.push("jmp" + oldIndex + "|" + newIndex + ":" + JSON.stringify(this._subFilters[newIndex].toJsonObject()));
                    this.selfUndoHistoryPos++;
                }
                this._subfilterIndex = newIndex;
                this.swapToSettings(this._subFilters[newIndex], false);
            }
        }
        render(activeMods = false) {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const filterSettings = this._useNoteFilter ? instrument.noteFilter : instrument.eqFilter;
            let displayMods = (activeMods && !this._larger && !this._mouseOver && !this._mouseDragging && !this._mouseDown && this._doc.synth.playing);
            if (displayMods)
                this._controlPointPath.style.setProperty("fill", `${ColorConfig.overwritingModSlider}`);
            else if (!this._larger)
                this._controlPointPath.style.setProperty("fill", "currentColor");
            if (this._filterSettings != filterSettings) {
                this._dragChange = null;
                this._mouseDown = false;
            }
            this._filterSettings = filterSettings;
            let targetSettings = filterSettings;
            if (!this._mouseDown)
                this._updateCursor();
            if (displayMods) {
                targetSettings = (this._useNoteFilter) ? instrument.tmpNoteFilterStart : instrument.tmpEqFilterStart;
                if (targetSettings == null)
                    targetSettings = (this._useNoteFilter) ? instrument.noteFilter : instrument.eqFilter;
                this._filterSettings = targetSettings;
            }
            let pointTypes = 0;
            let pointFreqs = 0;
            let pointGains = 0;
            for (let i = 0; i < targetSettings.controlPointCount; i++) {
                const point = targetSettings.controlPoints[i];
                pointTypes = pointTypes * 3 + point.type;
                pointFreqs = pointFreqs * Config.filterFreqRange + point.freq;
                pointGains = pointGains * Config.filterGainRange + point.gain;
            }
            if (this._renderedSelectedIndex != this._selectedIndex ||
                this._renderedPointCount != targetSettings.controlPointCount ||
                this._renderedPointTypes != pointTypes ||
                this._renderedPointFreqs != pointFreqs ||
                this._renderedPointGains != pointGains) {
                this._renderedSelectedIndex = this._selectedIndex;
                this._renderedPointCount = targetSettings.controlPointCount;
                this._renderedPointTypes = pointTypes;
                this._renderedPointFreqs = pointFreqs;
                this._renderedPointGains = pointGains;
                this._updatePath();
            }
            if (displayMods) {
                this._filterSettings = filterSettings;
            }
        }
    }

    const { button: button$3, div: div$3, h2: h2$3 } = HTML;
    class CustomFilterPrompt {
        constructor(_doc, _songEditor, _useNoteFilter) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._useNoteFilter = _useNoteFilter;
            this.filterData = new FilterSettings;
            this.startingFilterData = new FilterSettings;
            this._subfilterIndex = 0;
            this._playButton = button$3({ style: "width: 55%;", type: "button" });
            this._filterButtons = [];
            this._filterButtonContainer = div$3({ class: "instrument-bar", style: "justify-content: center;" });
            this._cancelButton = button$3({ class: "cancelButton" });
            this._okayButton = button$3({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._filterContainer = div$3({ style: "width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: center;" });
            this._editorTitle = div$3({}, h2$3("Edit Filter"));
            this._filterCopyButton = button$3({ style: "width:86px; margin-right: 5px;", class: "copyButton" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this._filterPasteButton = button$3({ style: "width:86px;", class: "pasteButton" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this._filterCopyPasteContainer = div$3({ style: "width: 185px;" }, this._filterCopyButton, this._filterPasteButton);
            this.container = div$3({ class: "prompt noSelection", style: "width: 600px;" }, this._editorTitle, div$3({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), this._filterButtonContainer, this._filterContainer, div$3({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this._filterCopyPasteContainer), this._cancelButton);
            this._setSubfilter = (index, useHistory = true, doSwap = true) => {
                this._filterButtons[this._subfilterIndex].classList.remove("selected-instrument");
                if (doSwap)
                    this.filterEditor.swapToSubfilter(this._subfilterIndex, index, useHistory);
                this._subfilterIndex = index;
                this._filterButtons[index].classList.add("selected-instrument");
            };
            this._copyFilterSettings = () => {
                const filterCopy = this._useNoteFilter
                    ? this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].noteFilter.toJsonObject()
                    : this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].eqFilter.toJsonObject();
                window.localStorage.setItem("filterCopy", JSON.stringify(filterCopy));
            };
            this._pasteFilterSettings = () => {
                let filterCopy = new FilterSettings();
                filterCopy.fromJsonObject(JSON.parse(String(window.localStorage.getItem("filterCopy"))));
                if (filterCopy != null) {
                    this.filterEditor.swapToSettings(filterCopy, true);
                }
            };
            this._whenKeyPressed = (event) => {
                if (event.keyCode == 90) {
                    let newIdx = this.filterEditor.undo();
                    if (newIdx >= 0) {
                        this._setSubfilter(newIdx, false, false);
                    }
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    let newIdx = this.filterEditor.redo();
                    if (newIdx >= 0) {
                        this._setSubfilter(newIdx, false, false);
                    }
                    event.stopPropagation();
                }
                if (event.keyCode >= 49 && event.keyCode <= 57) {
                    this.filterEditor.swapSubfilterIndices(event.keyCode - 49);
                    event.stopPropagation();
                }
            };
            this._togglePlay = () => {
                if (this._doc.synth.playing) {
                    this._songEditor._pause();
                    this.updatePlayButton();
                }
                else {
                    this._doc.synth.snapToBar();
                    this._songEditor._play();
                    this.updatePlayButton();
                }
            };
            this._close = () => {
                this._doc.prompt = null;
                this.filterEditor.resetToInitial();
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
                if (event.keyCode == 90) {
                    this.filterEditor.undo();
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    this.filterEditor.redo();
                    event.stopPropagation();
                }
            };
            this._saveChanges = () => {
                this._doc.prompt = null;
                this.filterEditor.saveSettings();
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._playButton.addEventListener("click", this._togglePlay);
            this._filterCopyButton.addEventListener("click", this._copyFilterSettings);
            this._filterPasteButton.addEventListener("click", this._pasteFilterSettings);
            this.updatePlayButton();
            let colors = ColorConfig.getChannelColor(this._doc.song, this._doc.channel);
            this.filterEditor = new FilterEditor(_doc, _useNoteFilter, true);
            this._filterContainer.appendChild(this.filterEditor.container);
            this._editorTitle.children[0].innerHTML = (_useNoteFilter) ? "Edit Note Filter" : "Edit EQ Filter";
            let newButton = button$3({ style: "max-width: 5em;" }, "Main");
            this._filterButtonContainer.appendChild(newButton);
            this._filterButtons.push(newButton);
            newButton.addEventListener("click", () => { this._setSubfilter(0); });
            for (let i = 1; i < Config.filterMorphCount; i++) {
                let newSubButton = button$3({ style: "max-width: 2em;" }, "" + i);
                this._filterButtons.push(newSubButton);
                this._filterButtonContainer.appendChild(newSubButton);
                newSubButton.addEventListener("click", () => { this._setSubfilter(i); });
            }
            this._filterButtons[Config.filterMorphCount - 1].classList.add("last-button");
            this._filterButtons[0].classList.add("selected-instrument");
            this._filterButtonContainer.style.setProperty("--text-color-lit", colors.primaryNote);
            this._filterButtonContainer.style.setProperty("--text-color-dim", colors.secondaryNote);
            this._filterButtonContainer.style.setProperty("--background-color-lit", colors.primaryChannel);
            this._filterButtonContainer.style.setProperty("--background-color-dim", colors.secondaryChannel);
            this._filterContainer.addEventListener("keydown", this._whenKeyPressed);
            this.filterEditor.container.addEventListener("keydown", this._whenKeyPressed);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            setTimeout(() => this._playButton.focus());
            this.filterEditor.render();
        }
        updatePlayButton() {
        	
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            }
        }
    }

    function transfer(source, length) {
        const dest = new ArrayBuffer(length);
        let nextOffset = 0;
        let leftBytes = Math.min(source.byteLength, dest.byteLength);
        const wordSizes = [8, 4, 2, 1];
        for (const wordSize of wordSizes) {
            if (leftBytes >= wordSize) {
                const done = transferWith(wordSize, source, dest, nextOffset, leftBytes);
                nextOffset = done.nextOffset;
                leftBytes = done.leftBytes;
            }
        }
        return dest;
        function transferWith(wordSize, source, dest, nextOffset, leftBytes) {
            let ViewClass = Uint8Array;
            switch (wordSize) {
                case 8:
                    ViewClass = Float64Array;
                    break;
                case 4:
                    ViewClass = Float32Array;
                    break;
                case 2:
                    ViewClass = Uint16Array;
                    break;
                case 1:
                    ViewClass = Uint8Array;
                    break;
                default:
                    ViewClass = Uint8Array;
                    break;
            }
            const view_source = new ViewClass(source, nextOffset, (leftBytes / wordSize) | 0);
            const view_dest = new ViewClass(dest, nextOffset, (leftBytes / wordSize) | 0);
            for (let i = 0; i < view_dest.length; i++) {
                view_dest[i] = view_source[i];
            }
            return {
                nextOffset: view_source.byteOffset + view_source.byteLength,
                leftBytes: leftBytes - view_dest.length * wordSize,
            };
        }
    }
    class ArrayBufferWriter {
        constructor(initialCapacity) {
            this._writeIndex = 0;
            this._fileSize = 0;
            this._arrayBuffer = new ArrayBuffer(initialCapacity);
            this._data = new DataView(this._arrayBuffer);
        }
        _addBytes(numBytes) {
            this._fileSize += numBytes;
            if (this._fileSize > this._arrayBuffer.byteLength) {
                this._arrayBuffer = transfer(this._arrayBuffer, Math.max(this._arrayBuffer.byteLength * 2, this._fileSize));
                this._data = new DataView(this._arrayBuffer);
            }
        }
        getWriteIndex() {
            return this._writeIndex;
        }
        rewriteUint32(index, value) {
            this._data.setUint32(index, value >>> 0, false);
        }
        writeUint32(value) {
            value = value >>> 0;
            this._addBytes(4);
            this._data.setUint32(this._writeIndex, value, false);
            this._writeIndex = this._fileSize;
        }
        writeUint24(value) {
            value = value >>> 0;
            this._addBytes(3);
            this._data.setUint8(this._writeIndex, (value >> 16) & 0xff);
            this._data.setUint8(this._writeIndex + 1, (value >> 8) & 0xff);
            this._data.setUint8(this._writeIndex + 2, (value) & 0xff);
            this._writeIndex = this._fileSize;
        }
        writeUint16(value) {
            value = value >>> 0;
            this._addBytes(2);
            this._data.setUint16(this._writeIndex, value, false);
            this._writeIndex = this._fileSize;
        }
        writeUint8(value) {
            value = value >>> 0;
            this._addBytes(1);
            this._data.setUint8(this._writeIndex, value);
            this._writeIndex = this._fileSize;
        }
        writeInt8(value) {
            value = value | 0;
            this._addBytes(1);
            this._data.setInt8(this._writeIndex, value);
            this._writeIndex = this._fileSize;
        }
        writeMidi7Bits(value) {
            value = value >>> 0;
            if (value >= 0x80)
                throw new Error("7 bit value contained 8th bit!");
            this._addBytes(1);
            this._data.setUint8(this._writeIndex, value);
            this._writeIndex = this._fileSize;
        }
        writeMidiVariableLength(value) {
            value = value >>> 0;
            if (value > 0x0fffffff)
                throw new Error("writeVariableLength value too big.");
            let startWriting = false;
            for (let i = 0; i < 4; i++) {
                const shift = 21 - i * 7;
                const bits = (value >>> shift) & 0x7f;
                if (bits != 0 || i == 3)
                    startWriting = true;
                if (startWriting)
                    this.writeUint8((i == 3 ? 0x00 : 0x80) | bits);
            }
        }
        writeMidiAscii(string) {
            this.writeMidiVariableLength(string.length);
            for (let i = 0; i < string.length; i++) {
                const charCode = string.charCodeAt(i);
                if (charCode > 0x7f)
                    throw new Error("Trying to write unicode character as ascii.");
                this.writeUint8(charCode);
            }
        }
        toCompactArrayBuffer() {
            return transfer(this._arrayBuffer, this._fileSize);
        }
    }

    const defaultMidiExpression = 0x7F;
    const defaultMidiPitchBend = 0x2000;
    const analogousDrumMap = {
        35: { frequency: 0, duration: 2, volume: 3 },
        36: { frequency: 0, duration: 2, volume: 3 },
        37: { frequency: 5, duration: 1, volume: 3 },
        38: { frequency: 4, duration: 2, volume: 3 },
        39: { frequency: 5, duration: 2, volume: 3 },
        40: { frequency: 4, duration: 2, volume: 3 },
        41: { frequency: 1, duration: 2, volume: 3 },
        42: { frequency: 8, duration: 1, volume: 3 },
        43: { frequency: 1, duration: 2, volume: 3 },
        44: { frequency: 8, duration: 1, volume: 2 },
        45: { frequency: 2, duration: 2, volume: 3 },
        46: { frequency: 8, duration: 4, volume: 3 },
        47: { frequency: 2, duration: 2, volume: 3 },
        48: { frequency: 3, duration: 2, volume: 3 },
        49: { frequency: 7, duration: 4, volume: 3 },
        50: { frequency: 3, duration: 2, volume: 3 },
        51: { frequency: 6, duration: 4, volume: 2 },
        52: { frequency: 7, duration: 4, volume: 3 },
        53: { frequency: 6, duration: 2, volume: 3 },
        54: { frequency: 11, duration: 2, volume: 3 },
        55: { frequency: 9, duration: 4, volume: 3 },
        56: { frequency: 7, duration: 1, volume: 2 },
        57: { frequency: 7, duration: 4, volume: 3 },
        58: { frequency: 10, duration: 2, volume: 2 },
        59: { frequency: 6, duration: 4, volume: 3 },
        69: { frequency: 10, duration: 2, volume: 3 },
        70: { frequency: 10, duration: 2, volume: 3 },
        73: { frequency: 10, duration: 1, volume: 2 },
        74: { frequency: 10, duration: 2, volume: 2 },
    };
    function midiVolumeToVolumeMult(volume) {
        return Math.pow(volume / 127, 4.0) / 0.3844015376046128;
    }
    function volumeMultToMidiVolume(volumeMult) {
        return Math.pow(volumeMult * 0.3844015376046128, 0.25) * 127;
    }
    function midiExpressionToVolumeMult(expression) {
        return Math.pow(expression / 127, 4.0);
    }
    function volumeMultToMidiExpression(volumeMult) {
        return Math.pow(volumeMult, 0.25) * 127;
    }

    const { button: button$4, div: div$4, h2: h2$4, input: input$2, select: select$1, option: option$1 } = HTML;
    function lerp(low, high, t) {
        return low + t * (high - low);
    }
function ArrayBufferToString(buffer) {
    return BinaryToString(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(buffer))));
}
function StringToArrayBuffer(string) {
    return StringToUint8Array(string).buffer;
}
function BinaryToString(binary) {
    var error;
    
    try {
        return decodeURIComponent(escape(binary));
    } catch (_error) {
        error = _error;
        if (error instanceof URIError) {
            return binary;
        } else {
            throw error;
        }
    }
}
function StringToBinary(string) {
    var chars, code, i, isUCS2, len, _i;
    len = string.length;
    chars = [];
    isUCS2 = false;
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        code = String.prototype.charCodeAt.call(string, i);
        if (code > 255) {
            isUCS2 = true;
            chars = null;
            break;
        } else {
            chars.push(code);
        }
    }
    if (isUCS2 === true) {
        return unescape(encodeURIComponent(string));
    } else {
        return String.fromCharCode.apply(null, Array.prototype.slice.apply(chars));
    }
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64data = reader.result.split(',')[1];
      resolve(base64data);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function save(blob, name, text, jsontype) {
 if (location.href.startsWith("file:///")) {
if(jsontype){
NativeJava.DownloadText((text), name);
}else{
    try {
blobToBase64(blob).then(base64data => {
  NativeJava.DownloadFile(base64data, name);
});
    } catch(e){
        alert(e)
    }
}
  } else {
        if (navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, name);
            return;
        }
        const anchor = document.createElement("a");
        if (anchor.download != undefined) {
            const url = URL.createObjectURL(blob);
            setTimeout(function () { URL.revokeObjectURL(url); }, 60000);
            anchor.href = url;
            anchor.download = name;
            setTimeout(function () { anchor.dispatchEvent(new MouseEvent("click")); }, 0);
        }
        else {
            const url = URL.createObjectURL(blob);
            setTimeout(function () { URL.revokeObjectURL(url); }, 60000);
            if (!window.open(url, "_blank"))
                window.location.href = url;
        }
    }}
    class ExportPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this.outputStarted = false;
            this._fileName = input$2({ type: "text", style: "width: 10em;", value: "BeepBox-Song", maxlength: 250, "autofocus": "autofocus" });
            this._computedSamplesLabel = div$4({ style: "width: 10em;" }, new Text("0:00"));
            this._enableIntro = input$2({ type: "checkbox" });
            this._loopDropDown = input$2({ style: "width: 2em;", type: "number", min: "1", max: "4", step: "1" });
            this._enableOutro = input$2({ type: "checkbox" });
            this._formatSelect = select$1({ style: "width: 100%;" }, option$1({ value: "wav" }, "Export to .wav file."), option$1({ value: "mp3" }, "Export to .mp3 file."), option$1({ value: "midi" }, "Export to .mid file."), option$1({ value: "json" }, "Export to .json file."), option$1({ value: "html" }, "Export to .html file."));
            this._cancelButton = button$4({ class: "cancelButton" });
            this._exportButton = button$4({ class: "exportButton", style: "width:45%;" }, "Export");
            this._outputProgressBar = div$4({ style: `width: 0%; background: ${ColorConfig.loopAccent}; height: 100%; position: absolute; z-index: 2;` });
            this._outputProgressLabel = div$4({ style: `position: relative; top: -1px; z-index: 3;` }, "0%");
            this._outputProgressContainer = div$4({ style: `height: 12px; background: ${ColorConfig.uiWidgetBackground}; display: block; position: relative; z-index: 1;` }, this._outputProgressBar, this._outputProgressLabel);
            this.container = div$4({ class: "prompt noSelection", style: "width: 200px;" }, h2$4("Export Options"), div$4({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "File name:", this._fileName), div$4({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "Length:", this._computedSamplesLabel), div$4({ style: "display: table; width: 100%;" }, div$4({ style: "display: table-row;" }, div$4({ style: "display: table-cell;" }, "Intro:"), div$4({ style: "display: table-cell;" }, "Loop Count:"), div$4({ style: "display: table-cell;" }, "Outro:")), div$4({ style: "display: table-row;" }, div$4({ style: "display: table-cell; vertical-align: middle;" }, this._enableIntro), div$4({ style: "display: table-cell; vertical-align: middle;" }, this._loopDropDown), div$4({ style: "display: table-cell; vertical-align: middle;" }, this._enableOutro))), div$4({ class: "selectContainer", style: "width: 100%;" }, this._formatSelect), div$4({ style: "text-align: left;" }, "Exporting can be slow. Reloading the page or clicking the X will cancel it. Please be patient."), this._outputProgressContainer, div$4({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._exportButton), this._cancelButton);
            this._close = () => {
                if (this.synth != null)
                    this.synth.renderingSong = false;
                this.outputStarted = false;
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._fileName.removeEventListener("input", ExportPrompt._validateFileName);
                this._loopDropDown.removeEventListener("blur", ExportPrompt._validateNumber);
                this._exportButton.removeEventListener("click", this._export);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._export();
                }
            };
            this._export = () => {
                if (this.outputStarted == true)
                    return;
                window.localStorage.setItem("exportFormat", this._formatSelect.value);
                switch (this._formatSelect.value) {
                    case "wav":
                        this.outputStarted = true;
                        this._exportTo("wav");
                        break;
                    case "mp3":
                        this.outputStarted = true;
                        this._exportTo("mp3");
                        break;
                    case "midi":
                        this.outputStarted = true;
                        this._exportToMidi();
                        break;
                    case "json":
                        this.outputStarted = true;
                        this._exportToJson();
                        break;
                    case "html":
                        this._exportToHtml();
                        break;
                    default:
                        throw new Error("Unhandled file export type.");
                }
            };
            this._loopDropDown.value = "1";
            if (this._doc.song.loopStart == 0) {
                this._enableIntro.checked = false;
                this._enableIntro.disabled = true;
            }
            else {
                this._enableIntro.checked = true;
                this._enableIntro.disabled = false;
            }
            if (this._doc.song.loopStart + this._doc.song.loopLength == this._doc.song.barCount) {
                this._enableOutro.checked = false;
                this._enableOutro.disabled = true;
            }
            else {
                this._enableOutro.checked = true;
                this._enableOutro.disabled = false;
            }
            const lastExportFormat = window.localStorage.getItem("exportFormat");
            if (lastExportFormat != null) {
                this._formatSelect.value = lastExportFormat;
            }
            this._fileName.select();
            setTimeout(() => this._fileName.focus());
            this._fileName.addEventListener("input", ExportPrompt._validateFileName);
            this._loopDropDown.addEventListener("blur", ExportPrompt._validateNumber);
            this._exportButton.addEventListener("click", this._export);
            this._cancelButton.addEventListener("click", this._close);
            this._enableOutro.addEventListener("click", () => { this._computedSamplesLabel.firstChild.textContent = this.samplesToTime(this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1)); });
            this._enableIntro.addEventListener("click", () => { this._computedSamplesLabel.firstChild.textContent = this.samplesToTime(this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1)); });
            this._loopDropDown.addEventListener("change", () => { this._computedSamplesLabel.firstChild.textContent = this.samplesToTime(this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1)); });
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._fileName.value = _doc.song.title;
            ExportPrompt._validateFileName(null, this._fileName);
            this._computedSamplesLabel.firstChild.textContent = this.samplesToTime(this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1));
        }
        samplesToTime(samples) {
            const rawSeconds = Math.round(samples / this._doc.synth.samplesPerSecond);
            const seconds = rawSeconds % 60;
            const minutes = Math.floor(rawSeconds / 60);
            return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
        }
        changeFileName(newValue) {
            this._fileName.value = newValue;
        }
        static _validateFileName(event, use) {
            let input;
            if (event != null) {
                input = event.target;
            }
            else if (use != undefined) {
                input = use;
            }
            else {
                return;
            }
            const deleteChars = /[\+\*\$\?\|\{\}\\\/<>#%!`&'"=:@]/gi;
            if (deleteChars.test(input.value)) {
                let cursorPos = input.selectionStart;
                input.value = input.value.replace(deleteChars, "");
                cursorPos--;
                input.setSelectionRange(cursorPos, cursorPos);
            }
        }
        static _validateNumber(event) {
            const input = event.target;
            input.value = Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value)))) + "";
        }
        _synthesize() {
            if (this.outputStarted == false) {
                return;
            }
            const samplesPerChunk = this.synth.samplesPerSecond * 5;
            const currentFrame = this.currentChunk * samplesPerChunk;
            const samplesInChunk = Math.min(samplesPerChunk, this.sampleFrames - currentFrame);
            const tempSamplesL = new Float32Array(samplesInChunk);
            const tempSamplesR = new Float32Array(samplesInChunk);
            this.synth.renderingSong = true;
            this.synth.synthesize(tempSamplesL, tempSamplesR, samplesInChunk);
            this.recordedSamplesL.set(tempSamplesL, currentFrame);
            this.recordedSamplesR.set(tempSamplesR, currentFrame);
            this._outputProgressBar.style.setProperty("width", Math.round((this.currentChunk + 1) / this.totalChunks * 100.0) + "%");
            this._outputProgressLabel.innerText = Math.round((this.currentChunk + 1) / this.totalChunks * 100.0) + "%";
            this.currentChunk++;
            if (this.currentChunk >= this.totalChunks) {
                this.synth.renderingSong = false;
                this._outputProgressLabel.innerText = "Encoding...";
                if (this.thenExportTo == "wav") {
                    this._exportToWavFinish();
                }
                else if (this.thenExportTo == "mp3") {
                    this._exportToMp3Finish();
                }
                else {
                    throw new Error("Unrecognized file export type chosen!");
                }
            }
            else {
                setTimeout(() => { this._synthesize(); });
            }
        }
        _exportTo(type) {
            this.thenExportTo = type;
            this.currentChunk = 0;
            this.synth = new Synth(this._doc.song);
            if (type == "wav") {
                this.synth.samplesPerSecond = 48000;
            }
            else if (type == "mp3") {
                this.synth.samplesPerSecond = 44100;
            }
            else {
                throw new Error("Unrecognized file export type chosen!");
            }
            this._outputProgressBar.style.setProperty("width", "0%");
            this._outputProgressLabel.innerText = "0%";
            this.synth.loopRepeatCount = Number(this._loopDropDown.value) - 1;
            if (!this._enableIntro.checked) {
                for (let introIter = 0; introIter < this._doc.song.loopStart; introIter++) {
                    this.synth.goToNextBar();
                }
            }
            this.synth.warmUpSynthesizer(this._doc.song);
            this.synth.computeLatestModValues();
            this.sampleFrames = this.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, this.synth.loopRepeatCount);
            this.totalChunks = Math.ceil(this.sampleFrames / (this.synth.samplesPerSecond * 5));
            this.recordedSamplesL = new Float32Array(this.sampleFrames);
            this.recordedSamplesR = new Float32Array(this.sampleFrames);
            setTimeout(() => { this._synthesize(); });
        }
        _exportToWavFinish() {
            const sampleFrames = this.recordedSamplesL.length;
            const sampleRate = this.synth.samplesPerSecond;
            const wavChannelCount = 2;
            const bytesPerSample = 2;
            const bitsPerSample = 8 * bytesPerSample;
            const sampleCount = wavChannelCount * sampleFrames;
            const totalFileSize = 44 + sampleCount * bytesPerSample;
            let index = 0;
            const arrayBuffer = new ArrayBuffer(totalFileSize);
            const data = new DataView(arrayBuffer);
            data.setUint32(index, 0x52494646, false);
            index += 4;
            data.setUint32(index, 36 + sampleCount * bytesPerSample, true);
            index += 4;
            data.setUint32(index, 0x57415645, false);
            index += 4;
            data.setUint32(index, 0x666D7420, false);
            index += 4;
            data.setUint32(index, 0x00000010, true);
            index += 4;
            data.setUint16(index, 0x0001, true);
            index += 2;
            data.setUint16(index, wavChannelCount, true);
            index += 2;
            data.setUint32(index, sampleRate, true);
            index += 4;
            data.setUint32(index, sampleRate * bytesPerSample * wavChannelCount, true);
            index += 4;
            data.setUint16(index, bytesPerSample * wavChannelCount, true);
            index += 2;
            data.setUint16(index, bitsPerSample, true);
            index += 2;
            data.setUint32(index, 0x64617461, false);
            index += 4;
            data.setUint32(index, sampleCount * bytesPerSample, true);
            index += 4;
            {
                const range = (1 << (bitsPerSample - 1)) - 1;
                for (let i = 0; i < sampleFrames; i++) {
                    let valL = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesL[i])) * range);
                    let valR = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesR[i])) * range);
                    {
                        data.setInt16(index, valL, true);
                        index += 2;
                        data.setInt16(index, valR, true);
                        index += 2;
                    }
                }
            }
            
            const blob = new Blob([arrayBuffer], { type: "audio/wav" });
            save(blob, this._fileName.value.trim() + ".wav", [arrayBuffer] );
            this._close();
        }
        _exportToMp3Finish() {
            const whenEncoderIsAvailable = () => {
                const lamejs = window["lamejs"];
                const channelCount = 2;
                const kbps = 192;
                const sampleBlockSize = 1152;
                const mp3encoder = new lamejs.Mp3Encoder(channelCount, this.synth.samplesPerSecond, kbps);
                const mp3Data = [];
                const left = new Int16Array(this.recordedSamplesL.length);
                const right = new Int16Array(this.recordedSamplesR.length);
                const range = (1 << 15) - 1;
                for (let i = 0; i < this.recordedSamplesL.length; i++) {
                    left[i] = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesL[i])) * range);
                    right[i] = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesR[i])) * range);
                }
                for (let i = 0; i < left.length; i += sampleBlockSize) {
                    const leftChunk = left.subarray(i, i + sampleBlockSize);
                    const rightChunk = right.subarray(i, i + sampleBlockSize);
                    const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                    if (mp3buf.length > 0)
                        mp3Data.push(mp3buf);
                }
                const mp3buf = mp3encoder.flush();
                if (mp3buf.length > 0)
                    mp3Data.push(mp3buf);
                const blob = new Blob(mp3Data, { type: "audio/mp3" });
                save(blob, this._fileName.value.trim() + ".mp3", mp3Data);
                this._close();
            };
            if ("lamejs" in window) {
                whenEncoderIsAvailable();
            }
            else {
                var script = document.createElement("script");
                script.src = "./lame.min.js";
                script.onload = whenEncoderIsAvailable;
                document.head.appendChild(script);
            }
        }
        _exportToMidi() {
            const song = this._doc.song;
            const midiTicksPerBeepBoxTick = 2;
            const midiTicksPerBeat = midiTicksPerBeepBoxTick * Config.ticksPerPart * Config.partsPerBeat;
            const midiTicksPerPart = midiTicksPerBeepBoxTick * Config.ticksPerPart;
            const secondsPerMinute = 60;
            const microsecondsPerMinute = secondsPerMinute * 1000000;
            const beatsPerMinute = song.getBeatsPerMinute();
            const microsecondsPerBeat = Math.round(microsecondsPerMinute / beatsPerMinute);
            const midiTicksPerBar = midiTicksPerBeat * song.beatsPerBar;
            const pitchBendRange = 24;
            const defaultNoteVelocity = 90;
            const unrolledBars = [];
            if (this._enableIntro.checked) {
                for (let bar = 0; bar < song.loopStart; bar++) {
                    unrolledBars.push(bar);
                }
            }
            for (let loopIndex = 0; loopIndex < Number(this._loopDropDown.value); loopIndex++) {
                for (let bar = song.loopStart; bar < song.loopStart + song.loopLength; bar++) {
                    unrolledBars.push(bar);
                }
            }
            if (this._enableOutro.checked) {
                for (let bar = song.loopStart + song.loopLength; bar < song.barCount; bar++) {
                    unrolledBars.push(bar);
                }
            }
            const tracks = [{ isMeta: true, channel: -1, midiChannel: -1, isNoise: false, isDrumset: false }];
            let midiChannelCounter = 0;
            let foundADrumset = false;
            for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                if (!foundADrumset && this._doc.song.channels[channel].instruments[0].type == 4) {
                    tracks.push({ isMeta: false, channel: channel, midiChannel: 9, isNoise: true, isDrumset: true });
                    foundADrumset = true;
                }
                else {
                    if (midiChannelCounter >= 16)
                        continue;
                    tracks.push({ isMeta: false, channel: channel, midiChannel: midiChannelCounter++, isNoise: this._doc.song.getChannelIsNoise(channel), isDrumset: false });
                    if (midiChannelCounter == 9)
                        midiChannelCounter++;
                }
            }
            const writer = new ArrayBufferWriter(1024);
            writer.writeUint32(1297377380);
            writer.writeUint32(6);
            writer.writeUint16(1);
            writer.writeUint16(tracks.length);
            writer.writeUint16(midiTicksPerBeat);
            for (const track of tracks) {
                writer.writeUint32(1297379947);
                const { isMeta, channel, midiChannel, isNoise, isDrumset } = track;
                const trackStartIndex = writer.getWriteIndex();
                writer.writeUint32(0);
                let prevTime = 0;
                let barStartTime = 0;
                const writeEventTime = function (time) {
                    if (time < prevTime)
                        throw new Error("Midi event time cannot go backwards.");
                    writer.writeMidiVariableLength(time - prevTime);
                    prevTime = time;
                };
                const writeControlEvent = function (message, value) {
                    if (!(value >= 0 && value <= 0x7F))
                        throw new Error("Midi control event value out of range: " + value);
                    writer.writeUint8(176 | midiChannel);
                    writer.writeMidi7Bits(message);
                    writer.writeMidi7Bits(value | 0);
                };
                if (isMeta) {
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(1);
                    writer.writeMidiAscii("Composed with jummbus.bitbucket.io");
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(81);
                    writer.writeMidiVariableLength(3);
                    writer.writeUint24(microsecondsPerBeat);
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(88);
                    writer.writeMidiVariableLength(4);
                    writer.writeUint8(song.beatsPerBar);
                    writer.writeUint8(2);
                    writer.writeUint8(24);
                    writer.writeUint8(8);
                    const isMinor = Config.scales[song.scale].flags[3] && !Config.scales[song.scale].flags[4];
                    const key = song.key;
                    let numSharps = key;
                    if ((key & 1) == 1)
                        numSharps += 6;
                    if (isMinor)
                        numSharps += 9;
                    while (numSharps > 6)
                        numSharps -= 12;
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(89);
                    writer.writeMidiVariableLength(2);
                    writer.writeInt8(numSharps);
                    writer.writeUint8(isMinor ? 1 : 0);
                    if (this._enableIntro.checked)
                        barStartTime += midiTicksPerBar * song.loopStart;
                    writeEventTime(barStartTime);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(6);
                    writer.writeMidiAscii("Loop Start");
                    for (let loopIndex = 0; loopIndex < parseInt(this._loopDropDown.value); loopIndex++) {
                        barStartTime += midiTicksPerBar * song.loopLength;
                        writeEventTime(barStartTime);
                        writer.writeUint8(255);
                        writer.writeMidi7Bits(6);
                        writer.writeMidiAscii(loopIndex < Number(this._loopDropDown.value) - 1 ? "Loop Repeat" : "Loop End");
                    }
                    if (this._enableOutro.checked)
                        barStartTime += midiTicksPerBar * (song.barCount - song.loopStart - song.loopLength);
                    if (barStartTime != midiTicksPerBar * unrolledBars.length)
                        throw new Error("Miscalculated number of bars.");
                }
                else {
                    let channelName = isNoise
                        ? "noise channel " + channel
                        : "pitch channel " + channel;
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(3);
                    writer.writeMidiAscii(channelName);
                    writeEventTime(0);
                    writeControlEvent(101, 0);
                    writeEventTime(0);
                    writeControlEvent(100, 0);
                    writeEventTime(0);
                    writeControlEvent(6, pitchBendRange);
                    writeEventTime(0);
                    writeControlEvent(38, 0);
                    writeEventTime(0);
                    writeControlEvent(101, 127);
                    writeEventTime(0);
                    writeControlEvent(100, 127);
                    let prevInstrumentIndex = -1;
                    function writeInstrumentSettings(instrumentIndex) {
                        const instrument = song.channels[channel].instruments[instrumentIndex];
                        const preset = EditorConfig.valueToPreset(instrument.preset);
                        if (prevInstrumentIndex != instrumentIndex) {
                            prevInstrumentIndex = instrumentIndex;
                            writeEventTime(barStartTime);
                            writer.writeUint8(255);
                            writer.writeMidi7Bits(4);
                            writer.writeMidiAscii("Instrument " + (instrumentIndex + 1));
                            if (!isDrumset) {
                                let instrumentProgram = 81;
                                if (preset != null && preset.midiProgram != undefined) {
                                    instrumentProgram = preset.midiProgram;
                                }
                                else if (instrument.type == 4) {
                                    instrumentProgram = 116;
                                }
                                else {
                                    if (instrument.type == 2 || instrument.type == 3) {
                                        if (isNoise) {
                                            instrumentProgram = 116;
                                        }
                                        else {
                                            instrumentProgram = 75;
                                        }
                                    }
                                    else if (instrument.type == 0) {
                                        if (ExportPrompt.midiChipInstruments.length > instrument.chipWave) {
                                            instrumentProgram = ExportPrompt.midiChipInstruments[instrument.chipWave];
                                        }
                                    }
                                    else if (instrument.type == 6 || instrument.type == 1 || instrument.type == 5) {
                                        instrumentProgram = 81;
                                    }
                                    else if (instrument.type == 7) {
                                        instrumentProgram = 0x19;
                                    }
                                    else if (instrument.type == 8) {
                                        instrumentProgram = 81;
                                    }
                                    else {
                                        throw new Error("Unrecognized instrument type.");
                                    }
                                }
                                writeEventTime(barStartTime);
                                writer.writeUint8(192 | midiChannel);
                                writer.writeMidi7Bits(instrumentProgram);
                            }
                            writeEventTime(barStartTime);
                            let instrumentVolume = volumeMultToMidiVolume(Synth.instrumentVolumeToVolumeMult(instrument.volume));
                            writeControlEvent(7, Math.min(0x7f, Math.round(instrumentVolume)));
                            writeEventTime(barStartTime);
                            let instrumentPan = (instrument.pan / Config.panCenter - 1) * 0x3f + 0x40;
                            writeControlEvent(10, Math.min(0x7f, Math.round(instrumentPan)));
                        }
                    }
                    if (song.getPattern(channel, 0) == null) {
                        writeInstrumentSettings(0);
                    }
                    let prevPitchBend = defaultMidiPitchBend;
                    let prevExpression = defaultMidiExpression;
                    let shouldResetExpressionAndPitchBend = false;
                    const channelRoot = isNoise ? Config.spectrumBasePitch : Config.keys[song.key].basePitch;
                    const intervalScale = isNoise ? Config.noiseInterval : 1;
                    for (const bar of unrolledBars) {
                        const pattern = song.getPattern(channel, bar);
                        if (pattern != null) {
                            const instrumentIndex = pattern.instruments[0];
                            const instrument = song.channels[channel].instruments[instrumentIndex];
                            const preset = EditorConfig.valueToPreset(instrument.preset);
                            writeInstrumentSettings(instrumentIndex);
                            let usesArpeggio = instrument.getChord().arpeggiates;
                            let polyphony = usesArpeggio ? 1 : Config.maxChordSize;
                            if (instrument.getChord().customInterval) {
                                if (instrument.type == 0 || instrument.type == 5) {
                                    polyphony = 2;
                                    usesArpeggio = true;
                                }
                                else if (instrument.type == 1) {
                                    polyphony = Config.operatorCount;
                                }
                                else {
                                    console.error("Unrecognized instrument type for harmonizing arpeggio: " + instrument.type);
                                }
                            }
                            for (let noteIndex = 0; noteIndex < pattern.notes.length; noteIndex++) {
                                const note = pattern.notes[noteIndex];
                                const noteStartTime = barStartTime + note.start * midiTicksPerPart;
                                let pinTime = noteStartTime;
                                let pinSize = note.pins[0].size;
                                let pinInterval = note.pins[0].interval;
                                const prevPitches = [-1, -1, -1, -1];
                                const nextPitches = [-1, -1, -1, -1];
                                const toneCount = Math.min(polyphony, note.pitches.length);
                                const velocity = isDrumset ? Math.max(1, Math.round(defaultNoteVelocity * note.pins[0].size / Config.noteSizeMax)) : defaultNoteVelocity;
                                let mainInterval = note.pickMainInterval();
                                let pitchOffset = mainInterval * intervalScale;
                                if (!isDrumset) {
                                    let maxPitchOffset = pitchBendRange;
                                    let minPitchOffset = -pitchBendRange;
                                    for (let pinIndex = 1; pinIndex < note.pins.length; pinIndex++) {
                                        const interval = note.pins[pinIndex].interval * intervalScale;
                                        maxPitchOffset = Math.min(maxPitchOffset, interval + pitchBendRange);
                                        minPitchOffset = Math.max(minPitchOffset, interval - pitchBendRange);
                                    }
                                    pitchOffset = Math.min(maxPitchOffset, Math.max(minPitchOffset, pitchOffset));
                                }
                                for (let pinIndex = 1; pinIndex < note.pins.length; pinIndex++) {
                                    const nextPinTime = noteStartTime + note.pins[pinIndex].time * midiTicksPerPart;
                                    const nextPinSize = note.pins[pinIndex].size;
                                    const nextPinInterval = note.pins[pinIndex].interval;
                                    const length = nextPinTime - pinTime;
                                    for (let midiTick = 0; midiTick < length; midiTick++) {
                                        const midiTickTime = pinTime + midiTick;
                                        const linearSize = lerp(pinSize, nextPinSize, midiTick / length);
                                        const linearInterval = lerp(pinInterval, nextPinInterval, midiTick / length);
                                        const interval = linearInterval * intervalScale - pitchOffset;
                                        const pitchBend = Math.max(0, Math.min(0x3fff, Math.round(0x2000 * (1.0 + interval / pitchBendRange))));
                                        const expression = Math.min(0x7f, Math.round(volumeMultToMidiExpression(Synth.noteSizeToVolumeMult(linearSize))));
                                        if (pitchBend != prevPitchBend) {
                                            writeEventTime(midiTickTime);
                                            writer.writeUint8(224 | midiChannel);
                                            writer.writeMidi7Bits(pitchBend & 0x7f);
                                            writer.writeMidi7Bits((pitchBend >> 7) & 0x7f);
                                            prevPitchBend = pitchBend;
                                        }
                                        if (expression != prevExpression && !isDrumset) {
                                            writeEventTime(midiTickTime);
                                            writeControlEvent(11, expression);
                                            prevExpression = expression;
                                        }
                                        const noteStarting = midiTickTime == noteStartTime;
                                        for (let toneIndex = 0; toneIndex < toneCount; toneIndex++) {
                                            let nextPitch = note.pitches[toneIndex];
                                            if (isDrumset) {
                                                nextPitch += mainInterval;
                                                const drumsetMap = [
                                                    36,
                                                    41,
                                                    45,
                                                    48,
                                                    40,
                                                    39,
                                                    59,
                                                    49,
                                                    46,
                                                    55,
                                                    69,
                                                    54,
                                                ];
                                                if (nextPitch < 0 || nextPitch >= drumsetMap.length)
                                                    throw new Error("Could not find corresponding drumset pitch. " + nextPitch);
                                                nextPitch = drumsetMap[nextPitch];
                                            }
                                            else {
                                                if (usesArpeggio && note.pitches.length > toneIndex + 1 && toneIndex == toneCount - 1) {
                                                    const midiTicksSinceBeat = (midiTickTime - barStartTime) % midiTicksPerBeat;
                                                    const midiTicksPerArpeggio = Config.ticksPerArpeggio * midiTicksPerPart / Config.ticksPerPart;
                                                    const arpeggio = Math.floor(midiTicksSinceBeat / midiTicksPerArpeggio);
                                                    nextPitch = note.pitches[toneIndex + getArpeggioPitchIndex(note.pitches.length - toneIndex, instrument.fastTwoNoteArp, arpeggio)];
                                                }
                                                nextPitch = channelRoot + nextPitch * intervalScale + pitchOffset;
                                                if (preset != null && preset.midiSubharmonicOctaves != undefined) {
                                                    nextPitch += 12 * preset.midiSubharmonicOctaves;
                                                }
                                                else if (isNoise) {
                                                    nextPitch += 12 * (+EditorConfig.presetCategories.dictionary["Drum Presets"].presets.dictionary["taiko drum"].midiSubharmonicOctaves);
                                                }
                                                if (isNoise)
                                                    nextPitch *= 2;
                                            }
                                            nextPitch = Math.max(0, Math.min(127, nextPitch));
                                            nextPitches[toneIndex] = nextPitch;
                                            if (!noteStarting && prevPitches[toneIndex] != nextPitches[toneIndex]) {
                                                writeEventTime(midiTickTime);
                                                writer.writeUint8(128 | midiChannel);
                                                writer.writeMidi7Bits(prevPitches[toneIndex]);
                                                writer.writeMidi7Bits(velocity);
                                            }
                                        }
                                        for (let toneIndex = 0; toneIndex < toneCount; toneIndex++) {
                                            if (noteStarting || prevPitches[toneIndex] != nextPitches[toneIndex]) {
                                                writeEventTime(midiTickTime);
                                                writer.writeUint8(144 | midiChannel);
                                                writer.writeMidi7Bits(nextPitches[toneIndex]);
                                                writer.writeMidi7Bits(velocity);
                                                prevPitches[toneIndex] = nextPitches[toneIndex];
                                            }
                                        }
                                    }
                                    pinTime = nextPinTime;
                                    pinSize = nextPinSize;
                                    pinInterval = nextPinInterval;
                                }
                                const noteEndTime = barStartTime + note.end * midiTicksPerPart;
                                for (let toneIndex = 0; toneIndex < toneCount; toneIndex++) {
                                    writeEventTime(noteEndTime);
                                    writer.writeUint8(128 | midiChannel);
                                    writer.writeMidi7Bits(prevPitches[toneIndex]);
                                    writer.writeMidi7Bits(velocity);
                                }
                                shouldResetExpressionAndPitchBend = true;
                            }
                        }
                        else {
                            if (shouldResetExpressionAndPitchBend) {
                                shouldResetExpressionAndPitchBend = false;
                                if (prevExpression != defaultMidiExpression) {
                                    prevExpression = defaultMidiExpression;
                                    writeEventTime(barStartTime);
                                    writeControlEvent(11, prevExpression);
                                }
                                if (prevPitchBend != defaultMidiPitchBend) {
                                    prevPitchBend = defaultMidiPitchBend;
                                    writeEventTime(barStartTime);
                                    writer.writeUint8(224 | midiChannel);
                                    writer.writeMidi7Bits(prevPitchBend & 0x7f);
                                    writer.writeMidi7Bits((prevPitchBend >> 7) & 0x7f);
                                }
                            }
                        }
                        barStartTime += midiTicksPerBar;
                    }
                }
                writeEventTime(barStartTime);
                writer.writeUint8(255);
                writer.writeMidi7Bits(47);
                writer.writeMidiVariableLength(0x00);
                writer.rewriteUint32(trackStartIndex, writer.getWriteIndex() - trackStartIndex - 4);
            }
            const blob = new Blob([writer.toCompactArrayBuffer()], { type: "audio/midi" });
            save(blob, this._fileName.value.trim() + ".mid", writer.toCompactArrayBuffer());
            this._close();
        }
        _exportToJson() {
        	editor._pause();
        	this._doc.song.title = this._fileName.value.trim()
            const jsonObject = this._doc.song.toJsonObject(this._enableIntro.checked, Number(this._loopDropDown.value), this._enableOutro.checked);
            const jsonString = JSON.stringify(jsonObject, null, '\t');
            const blob = new Blob([jsonString], { type: "application/json" });
            save(blob, this._fileName.value.trim() + ".json",jsonString,true);
             
            this._close();
        }
        _exportToHtml() {
            const fileContents = `\
<!DOCTYPE html><meta charset="utf-8">

You should be redirected to the song at:<br /><br />

<a id="destination" href="${new URL("#" + this._doc.song.toBase64String(), location.href).href}"></a>

<style>
	:root {
		color: white;
		background: black;
		font-family:
		sans-serif;
	}
	a {
		color: #98f;
	}
	a[href]::before {
		content: attr(href);
	}
</style>

<script>
	location.assign(document.querySelector("a#destination").href);
</script>
`;
            const blob = new Blob([fileContents], { type: "text/html" });
            save(blob, this._fileName.value.trim() + ".html");
            this._close();
        }
    }
    ExportPrompt.midiChipInstruments = [
        0x4A,
        0x47,
        0x50,
        0x46,
        0x44,
        0x51,
        0x51,
        0x51,
        0x51,
    ];

    class Layout {
        static setLayout(layout) {
            this._styleElement.textContent = this._layoutMap[layout];
        }
    }
    Layout._layoutMap = {
        "small": "",
        
        "tall3": `\
        /* tall layout */
        @media (min-width: 711px) {
        #beepboxEditorContainer {
        max-width: initial;
        height: 100vh;
        }
        .beepboxEditor {
        width: 100%;
        
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 2fr);
        grid-template-rows: 1fr;
        grid-template-areas: "track-area settings-area pattern-area";
        }
        .beepboxEditor .pattern-area {
        width: 100%;
        margin:0px;
        height: 100%;
        }
        .beepboxEditor .track-area {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        }
        .beepboxEditor .trackAndMuteContainer {
        width: 100%;
        min-height: 0;
        flex: 0;
        overflow: auto;
        flex-basis: initial;
        flex-grow: 0;
        max-height: 97.5vh;
        }
        .beepboxEditor .instrument-settings-area > .editor-controls {
        position: absolute;
        width: 100%;
        }
        
        .beepboxEditor .settings-area {
        width: 192px;
        position: relative;
        overflow-y: auto;
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto auto minmax(0, 1fr);
        grid-template-areas:
        "version-area"
        "play-pause-area"
        "menu-area"
        "song-settings-area"
        "instrument-settings-area";
        }
        .beepboxEditor .version-area {
        position: sticky;
        top: 0;
        z-index: 1;
        background: ${ColorConfig.editorBackground};
        }
        .beepboxEditor .play-pause-area {
        position: sticky;
        top: 22px;
        z-index: 1;
        background: ${ColorConfig.editorBackground};
        }
        .beepboxEditor .menu-area {
        position: sticky;
        top: 82px;
        z-index: 1;
        background: ${ColorConfig.editorBackground};
        }
        
        .beepboxEditor .barScrollBar {
        display: none;
        }
        .beepboxEditor .trackContainer {
        overflow: visible;
        }
        .beepboxEditor .trackAndMuteContainer {
        scrollbar-width: auto;
        scrollbar-color: ${ColorConfig.uiWidgetBackground} ${ColorConfig.editorBackground};
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
        width: 20px;
        height: 20px;
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
        background: ${ColorConfig.editorBackground};
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
        background-color: ${ColorConfig.uiWidgetBackground};
        border: 3px solid ${ColorConfig.editorBackground};
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
        background-color: ${ColorConfig.editorBackground};
        }
        }
        `,
        
        
        "tall2": `\
        /* tall layout */
        @media (min-width: 711px) {
        #beepboxEditorContainer {
        max-width: initial;
        height: 100vh;
        }
        .beepboxEditor {
        width: 100%;
        
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) 192px;
        grid-template-rows: 1fr;
        grid-template-areas: "pattern-area track-area settings-area";
        }
        .beepboxEditor .pattern-area {
        width: 100%;
        height: 100%;
        }
        .beepboxEditor .track-area {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        }
        .beepboxEditor .trackAndMuteContainer {
        width: 100%;
        min-height: 0;
        flex: 0;
        overflow: auto;
        flex-basis: initial;
        flex-grow: 0;
        max-height: 97.5vh;
        }
        .beepboxEditor .instrument-settings-area > .editor-controls {
        position: absolute;
        width: 100%;
        }
        
        .beepboxEditor .settings-area {
        width: 192px;
        position: relative;
        overflow-y: auto;
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto auto minmax(0, 1fr);
        grid-template-areas:
        "version-area"
        "play-pause-area"
        "menu-area"
        "song-settings-area"
        "instrument-settings-area";
        }
        .beepboxEditor .version-area {
        position: sticky;
        top: 0;
        z-index: 1;
        background: ${ColorConfig.editorBackground};
        }
        .beepboxEditor .play-pause-area {
        position: sticky;
        top: 22px;
        z-index: 1;
        background: ${ColorConfig.editorBackground};
        }
        .beepboxEditor .menu-area {
        position: sticky;
        top: 82px;
        z-index: 1;
        background: ${ColorConfig.editorBackground};
        }
        
        .beepboxEditor .barScrollBar {
        display: none;
        }
        .beepboxEditor .trackContainer {
        overflow: visible;
        }
        .beepboxEditor .trackAndMuteContainer {
        scrollbar-width: auto;
        scrollbar-color: ${ColorConfig.uiWidgetBackground} ${ColorConfig.editorBackground};
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
        width: 20px;
        height: 20px;
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
        background: ${ColorConfig.editorBackground};
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
        background-color: ${ColorConfig.uiWidgetBackground};
        border: 3px solid ${ColorConfig.editorBackground};
        }
        .beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
        background-color: ${ColorConfig.editorBackground};
        }
        }
        `,
        
        
        
        "long": `\

			/* long layout */
			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
				}
				.beepboxEditor {
					width: 100%;
					 
					grid-template-columns: minmax(0, 1fr) 390px; /* minmax(0, 1fr) min-content; Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */
					grid-template-rows: minmax(481px, 1fr) minmax(0, min-content);
					grid-template-areas: "pattern-area settings-area" "track-area track-area";
				}
				
				
 				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					display: flex;
					flex-direction: column;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 1;
					overflow: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				.beepboxEditor .song-settings-area {
					overflow-y: auto;
				}
				
				.beepboxEditor .settings-area {
					width: 390px;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
					grid-template-rows: auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"instrument-settings-area version-area"
						"instrument-settings-area play-pause-area"
						"instrument-settings-area menu-area"
						"instrument-settings-area song-settings-area";
				}
				
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor.selectRow {
					height: 2em;
				}
				.beepboxEditor .operatorRow {
					heiht: 2em;
				}
				.beepboxEditor .trackAndMuteContainer {
					max-height: 446px;
				}

				.beepboxEditor .trackContainer {
					overflow: visible;
				}
				.beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
					scrollbar-color: ${ColorConfig.uiWidgetBackground} ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,
        "tall": `\
			/* tall layout */
			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
				}
				.beepboxEditor {
					width: 100%;
					 
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) 192px;
					grid-template-rows: 1fr;
					grid-template-areas: "track-area pattern-area settings-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					height: 100%;
					display: flex;
					flex-direction: column;
					justify-content: center;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 0;
					overflow: auto;
					flex-basis: initial;
					flex-grow: 0;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				
				.beepboxEditor .settings-area {
					width: 192px;
					position: relative;
					overflow-y: auto;
					grid-template-columns: minmax(0, 1fr);
					grid-template-rows: auto auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"version-area"
						"play-pause-area"
						"menu-area"
						"song-settings-area"
						"instrument-settings-area";
				}
				.beepboxEditor .version-area {
					position: sticky;
					top: 0;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .play-pause-area {
					position: sticky;
					top: 22px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .menu-area {
					position: sticky;
					top: 82px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor .trackContainer {
					overflow: visible;
				}
				.beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
					scrollbar-color: ${ColorConfig.uiWidgetBackground} ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,

		
		
        "wide": `\
			/* wide (JB) layout */
			@media (min-width: 1001px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
				}
				.beepboxEditor {
					width: 100%;
					 
					grid-template-columns: 512px minmax(0, 1fr) 30em;
					grid-template-rows: minmax(481px, 1fr) min-content;
					grid-template-areas: "track-area pattern-area settings-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					height: 100%;
					max-height: 100%
				}
				.beepboxEditor .editor-widget-column {
					flex: 0;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					flex: 0;
					flex-basis: initial;
					flex-grow: 0;
					overflow-y: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				
				.beepboxEditor .song-settings-area {
					overflow-y: auto;
				}
				
				.beepboxEditor .settings-area {
					width: 30em;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
					grid-template-rows: auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"instrument-settings-area version-area"
						"instrument-settings-area play-pause-area"
						"instrument-settings-area menu-area"
						"instrument-settings-area song-settings-area";
				}
				.beepboxEditor .version-area {
					position: sticky;
					top: 0;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .play-pause-area {
					position: sticky;
					top: 22px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .menu-area {
					position: sticky;
					top: 82px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				
				.beepboxEditor .trackContainer {
					overflow: visible;
				}
			}
		`,
    };
     
    Layout._styleElement = document.head.appendChild(HTML.style({ type: "text/css" }));

    class HarmonicsEditor {
        constructor(_doc) {
            this._doc = _doc;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._octaves = SVG.svg({ "pointer-events": "none" });
            this._fifths = SVG.svg({ "pointer-events": "none" });
            this._curve = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 2, "pointer-events": "none" });
            this._lastControlPoints = [];
            this._lastControlPointContainer = SVG.svg({ "pointer-events": "none" });
            this._svg = SVG.svg({ style: "background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;", width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._octaves, this._fifths, this._curve, this._lastControlPointContainer);
            this.container = HTML.div({ class: "harmonics", style: "height: 100%;" }, this._svg);
            this._mouseX = 0;
            this._mouseY = 0;
            this._freqPrev = 0;
            this._ampPrev = 0;
            this._mouseDown = false;
            this._change = null;
            this._renderedPath = "";
            this._renderedFifths = true;
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (this._mouseDown) {
                    this._doc.record(this._change);
                    this._change = null;
                }
                this._mouseDown = false;
            };
            for (let i = 1; i <= Config.harmonicsControlPoints; i = i * 2) {
                this._octaves.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i - 0.5) * (this._editorWidth - 8) / (Config.harmonicsControlPoints - 1) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 3; i <= Config.harmonicsControlPoints; i = i * 2) {
                this._fifths.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i - 0.5) * (this._editorWidth - 8) / (Config.harmonicsControlPoints - 1) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 0; i < 4; i++) {
                const rect = SVG.rect({ fill: "currentColor", x: (this._editorWidth - i * 2 - 1), y: 0, width: 1, height: this._editorHeight });
                this._lastControlPoints.push(rect);
                this._lastControlPointContainer.appendChild(rect);
            }
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _xToFreq(x) {
            return (Config.harmonicsControlPoints - 1) * x / (this._editorWidth - 8) - 0.5;
        }
        _yToAmp(y) {
            return Config.harmonicsMax * (1 - y / this._editorHeight);
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                const freq = this._xToFreq(this._mouseX);
                const amp = this._yToAmp(this._mouseY);
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                const harmonicsWave = instrument.harmonicsWave;
                if (freq != this._freqPrev) {
                    const slope = (amp - this._ampPrev) / (freq - this._freqPrev);
                    const offset = this._ampPrev - this._freqPrev * slope;
                    const lowerFreq = Math.ceil(Math.min(this._freqPrev, freq));
                    const upperFreq = Math.floor(Math.max(this._freqPrev, freq));
                    for (let i = lowerFreq; i <= upperFreq; i++) {
                        if (i < 0 || i >= Config.harmonicsControlPoints)
                            continue;
                        harmonicsWave.harmonics[i] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(i * slope + offset)));
                    }
                }
                harmonicsWave.harmonics[Math.max(0, Math.min(Config.harmonicsControlPoints - 1, Math.round(freq)))] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(amp)));
                this._freqPrev = freq;
                this._ampPrev = amp;
                this._change = new ChangeHarmonics(this._doc, instrument, harmonicsWave);
                this._doc.setProspectiveChange(this._change);
            }
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const harmonicsWave = instrument.harmonicsWave;
            const controlPointToHeight = (point) => {
                return (1 - (point / Config.harmonicsMax)) * this._editorHeight;
            };
            let bottom = prettyNumber(this._editorHeight);
            let path = "";
            for (let i = 0; i < Config.harmonicsControlPoints - 1; i++) {
                if (harmonicsWave.harmonics[i] == 0)
                    continue;
                let xPos = prettyNumber((i + 0.5) * (this._editorWidth - 8) / (Config.harmonicsControlPoints - 1));
                path += "M " + xPos + " " + bottom + " ";
                path += "L " + xPos + " " + prettyNumber(controlPointToHeight(harmonicsWave.harmonics[i])) + " ";
            }
            const lastHeight = controlPointToHeight(harmonicsWave.harmonics[Config.harmonicsControlPoints - 1]);
            for (let i = 0; i < 4; i++) {
                const rect = this._lastControlPoints[i];
                rect.setAttribute("y", prettyNumber(lastHeight));
                rect.setAttribute("height", prettyNumber(this._editorHeight - lastHeight));
            }
            if (this._renderedPath != path) {
                this._renderedPath = path;
                this._curve.setAttribute("d", path);
            }
            if (this._renderedFifths != this._doc.showFifth) {
                this._renderedFifths = this._doc.showFifth;
                this._fifths.style.display = this._doc.showFifth ? "" : "none";
            }
        }
    }

    const { span: span$1 } = HTML;
    class InputBox {
        constructor(input, _doc, _getChange) {
            this.input = input;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._value = "";
            this._oldValue = "";
            this._whenInput = () => {
                const continuingProspectiveChange = this._doc.lastChangeWas(this._change);
                if (!continuingProspectiveChange)
                    this._oldValue = this._value;
                this._change = this._getChange(this._oldValue, this.input.value);
                this._doc.setProspectiveChange(this._change);
            };
            this._whenChange = () => {
                this._doc.record(this._change);
                this._change = null;
            };
            input.addEventListener("input", this._whenInput);
            input.addEventListener("change", this._whenChange);
        }
        updateValue(value) {
            this._value = value;
            this.input.value = String(value);
        }
    }
    class Slider {
        constructor(input, _doc, _getChange, midTick) {
            this.input = input;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._value = 0; 
            this._oldValue = 0;
            this._whenInput = () => { 
            	 
                const continuingProspectiveChange = this._doc.lastChangeWas(this._change);
                if (!continuingProspectiveChange)
                    this._oldValue = this._value;
                if (this._getChange != null) {
                    this._change = this._getChange(this._oldValue, parseInt(this.input.value));
                    this._doc.setProspectiveChange(this._change);
                }
            };
            this._whenChange = () => {
                if (this._getChange != null) {
                    this._doc.record(this._change);
                    this._change = null;
                }
            };
            this.container = (midTick) ? span$1({ class: "midTick", style: "position: sticky; width: 61.5%;" }, input) : span$1({ style: "position: sticky;" }, input);
            input.addEventListener("input", this._whenInput);
            input.addEventListener("change", this._whenChange);
        }
        updateValue(value) {
            this._value = value;
            this.input.value = String(value);
        }
    }

    class ArrayBufferReader {
        constructor(data) {
            this._readIndex = 0;
            this._data = data;
        }
        getReadIndex() {
            return this._readIndex;
        }
        readUint32() {
            if (this._readIndex + 4 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getUint32(this._readIndex, false);
            this._readIndex += 4;
            return result;
        }
        readUint24() {
            return (this.readUint8() << 16) | (this.readUint8() << 8) | (this.readUint8());
        }
        readUint16() {
            if (this._readIndex + 2 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getUint16(this._readIndex, false);
            this._readIndex += 2;
            return result;
        }
        readUint8() {
            if (this._readIndex + 1 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getUint8(this._readIndex);
            this._readIndex++;
            return result;
        }
        readInt8() {
            if (this._readIndex + 1 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getInt8(this._readIndex);
            this._readIndex++;
            return result;
        }
        peakUint8() {
            if (this._readIndex + 1 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            return this._data.getUint8(this._readIndex);
        }
        readMidi7Bits() {
            const result = this.readUint8();
            if (result >= 0x80)
                console.log("7 bit value contained 8th bit! value " + result + ", index " + this._readIndex);
            return result & 0x7f;
        }
        readMidiVariableLength() {
            let result = 0;
            for (let i = 0; i < 4; i++) {
                const nextByte = this.readUint8();
                result += nextByte & 0x7f;
                if (nextByte & 0x80) {
                    result = result << 7;
                }
                else {
                    break;
                }
            }
            return result;
        }
        skipBytes(length) {
            this._readIndex += length;
        }
        hasMore() {
            return this._data.byteLength > this._readIndex;
        }
        getReaderForNextBytes(length) {
            if (this._readIndex + length > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = new ArrayBufferReader(new DataView(this._data.buffer, this._data.byteOffset + this._readIndex, length));
            this.skipBytes(length);
            return result;
        }
    }

    const { button: button$5, p, div: div$5, h2: h2$5, input: input$3 } = HTML;
    class ImportPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._fileInput = input$3({ type: "file", accept: ".json,application/json,.mid,.midi,audio/midi,audio/x-midi" });
            this._cancelButton = button$5({ class: "cancelButton" });
            this.container = div$5({ class: "prompt noSelection", style: "width: 300px;" }, h2$5("Import"), p({ style: "text-align: left; margin: 0.5em 0;" }, "BeepBox songs can be exported and re-imported as .json files. You could also use other means to make .json files for BeepBox as long as they follow the same structure."), p({ style: "text-align: left; margin: 0.5em 0;" }, "BeepBox can also (crudely) import .mid files. There are many tools available for creating .mid files. Shorter and simpler songs are more likely to work well."), this._fileInput, this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._fileInput.removeEventListener("change", this._whenFileSelected);
                this._cancelButton.removeEventListener("click", this._close);
            };
            this._whenFileSelected = () => {
                const file = this._fileInput.files[0];
                if (!file)
                    return;
                const extension = file.name.slice((file.name.lastIndexOf(".") - 1 >>> 0) + 2);
                if (extension == "json") {
                    const reader = new FileReader();
reader.addEventListener("load", (event) => {
                        this._doc.prompt = null;
let registerWaves=[]
let OBJeR=JSON.parse(reader.result)

for (let channel of OBJeR.channels) {
	for (let instrument of channel.instruments) {
if (instrument.wave) {
const keys = Object.values(Config.chipWaves).map(item => item.name);
const index = keys.indexOf(instrument.wave);
if(index!==-1){ instrument.envelopessave = index}
	registerWaves.push(index)
}}}


                        
                        this._doc.goBackToStart();
                        this._doc.record(new ChangeSong(this._doc, reader.result), true, true);

// avoiding base64 limitations maded by a creator of beepbox lmfao now Infinity amount of samples ♾️   v1. beta code  
let waveIndex = 0;
for (let channel of this._doc.song.channels) {
	for (let instrument of channel.instruments) {
		//console.log(JSON.stringify(instrument))
		
		if (registerWaves[waveIndex] !== undefined && registerWaves[waveIndex] !== -1) {
    	instrument.chipwaveselected = registerWaves[waveIndex];
    } else if (instrument.chipWave !== undefined && instrument.chipWave !== null) {
			instrument.chipwaveselected = instrument.chipWave
		} else {
			instrument.chipwaveselected = 0;
		}
		waveIndex++;
	}
}
for (let channel of this._doc.song.channels) {
for (let instrument of channel.instruments) {
if (instrument.envelopes) {
instrument.envelopessave = instrument.envelopes
}}
}

                    });
                    reader.readAsText(file);
                }
                else if (extension == "midi" || extension == "mid") {
                    const reader = new FileReader();
                    reader.addEventListener("load", (event) => {
                        this._doc.prompt = null;
                        
/*for (let channel of this.channels) {
	for (let instrument of channel.instruments) {
		if (instrument.envelopes) {
			instrument.envelopessave = instrument.envelopes
		}
	}
}*/
                        
                        this._doc.goBackToStart();
                        this._parseMidiFile(reader.result);
// avoiding base64 limitations maded by a creator of beepbox lmfao now Infinity amount of samples ♾️   v1. beta code  
for (let channel of this._doc.song.channels) {
	for (let instrument of channel.instruments) {
		if (instrument.chipWave !== undefined && instrument.chipWave !== null) {
			instrument.chipwaveselected = instrument.chipWave
		} else {
			instrument.chipwaveselected = 0;
		}
	}
}

/* prototype 
for (let channel of this._doc.song.channels) {
	for (let instrument of channel.instruments) {
		alert(JSON.stringify(instrument))
		if (instrument.wave !== undefined && instrument.wave !== null) {
			// const index = Config.chipWaves.indexOf(instrument.wave);
			instrument.chipwaveselected = instrument.chipWave //(index !== -1) ? index : 0;
		} else {
			instrument.chipwaveselected = 0;
		}
	}
}*/
                    });
                    reader.readAsArrayBuffer(file);
                }
                else {
                    console.error("Unrecognized file extension.");
                    this._close();
                }
            };
            this._fileInput.select();
            setTimeout(() => this._fileInput.focus());
            this._fileInput.addEventListener("change", this._whenFileSelected);
            this._cancelButton.addEventListener("click", this._close);
        }
        _parseMidiFile(buffer) {
            const reader = new ArrayBufferReader(new DataView(buffer));
            let headerReader = null;
            const tracks = [];
            while (reader.hasMore()) {
                const chunkType = reader.readUint32();
                const chunkLength = reader.readUint32();
                if (chunkType == 1297377380) {
                    if (headerReader == null) {
                        headerReader = reader.getReaderForNextBytes(chunkLength);
                    }
                    else {
                        console.error("This MIDI file has more than one header chunk.");
                    }
                }
                else if (chunkType == 1297379947) {
                    const trackReader = reader.getReaderForNextBytes(chunkLength);
                    if (trackReader.hasMore()) {
                        tracks.push({
                            reader: trackReader,
                            nextEventMidiTick: trackReader.readMidiVariableLength(),
                            ended: false,
                            runningStatus: -1,
                        });
                    }
                }
                else {
                    reader.skipBytes(chunkLength);
                }
            }
            if (headerReader == null) {
                console.error("No header chunk found in this MIDI file.");
                this._close();
                return;
            }
            const fileFormat = headerReader.readUint16();
            headerReader.readUint16();
            const midiTicksPerBeat = headerReader.readUint16();
            let currentIndependentTrackIndex = 0;
            const currentTrackIndices = [];
            const independentTracks = (fileFormat == 2);
            if (independentTracks) {
                currentTrackIndices.push(currentIndependentTrackIndex);
            }
            else {
                for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
                    currentTrackIndices.push(trackIndex);
                }
            }
            const channelRPNMSB = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
            const channelRPNLSB = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
            const pitchBendRangeMSB = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];
            const pitchBendRangeLSB = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            const currentInstrumentProgram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            const currentInstrumentVolumes = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100];
            const currentInstrumentPans = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];
            const noteEvents = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            const pitchBendEvents = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            const noteSizeEvents = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            let microsecondsPerBeat = 500000;
            let beatsPerBar = 8;
            let numSharps = 0;
            let isMinor = false;
            let currentMidiTick = 0;
            while (true) {
                let nextEventMidiTick = Number.MAX_VALUE;
                let anyTrackHasMore = false;
                for (const trackIndex of currentTrackIndices) {
                    const track = tracks[trackIndex];
                    while (!track.ended && track.nextEventMidiTick == currentMidiTick) {
                        const peakStatus = track.reader.peakUint8();
                        const eventStatus = (peakStatus & 0x80) ? track.reader.readUint8() : track.runningStatus;
                        const eventType = eventStatus & 0xF0;
                        const eventChannel = eventStatus & 0x0F;
                        if (eventType != 240) {
                            track.runningStatus = eventStatus;
                        }
                        let foundTrackEndEvent = false;
                        switch (eventType) {
                            case 128:
                                {
                                    const pitch = track.reader.readMidi7Bits();
                                    track.reader.readMidi7Bits();
                                    noteEvents[eventChannel].push({ midiTick: currentMidiTick, pitch: pitch, velocity: 0.0, program: -1, instrumentVolume: -1, instrumentPan: -1, on: false });
                                }
                                break;
                            case 144:
                                {
                                    const pitch = track.reader.readMidi7Bits();
                                    const velocity = track.reader.readMidi7Bits();
                                    if (velocity == 0) {
                                        noteEvents[eventChannel].push({ midiTick: currentMidiTick, pitch: pitch, velocity: 0.0, program: -1, instrumentVolume: -1, instrumentPan: -1, on: false });
                                    }
                                    else {
                                        const volume = Math.max(0, Math.min(Config.volumeRange - 1, Math.round(Synth.volumeMultToInstrumentVolume(midiVolumeToVolumeMult(currentInstrumentVolumes[eventChannel])))));
                                        const pan = Math.max(0, Math.min(Config.panMax, Math.round(((currentInstrumentPans[eventChannel] - 64) / 63 + 1) * Config.panCenter)));
                                        noteEvents[eventChannel].push({
                                            midiTick: currentMidiTick,
                                            pitch: pitch,
                                            velocity: Math.max(0.0, Math.min(1.0, (velocity + 14) / 90.0)),
                                            program: currentInstrumentProgram[eventChannel],
                                            instrumentVolume: volume,
                                            instrumentPan: pan,
                                            on: true,
                                        });
                                    }
                                }
                                break;
                            case 160:
                                {
                                    track.reader.readMidi7Bits();
                                    track.reader.readMidi7Bits();
                                }
                                break;
                            case 176:
                                {
                                    const message = track.reader.readMidi7Bits();
                                    const value = track.reader.readMidi7Bits();
                                    switch (message) {
                                        case 6:
                                            {
                                                if (channelRPNMSB[eventChannel] == 0 && channelRPNLSB[eventChannel] == 0) {
                                                    pitchBendRangeMSB[eventChannel] = value;
                                                }
                                            }
                                            break;
                                        case 7:
                                            {
                                                currentInstrumentVolumes[eventChannel] = value;
                                            }
                                            break;
                                        case 10:
                                            {
                                                currentInstrumentPans[eventChannel] = value;
                                            }
                                            break;
                                        case 11:
                                            {
                                                noteSizeEvents[eventChannel].push({ midiTick: currentMidiTick, size: Synth.volumeMultToNoteSize(midiExpressionToVolumeMult(value)) });
                                            }
                                            break;
                                        case 38:
                                            {
                                                if (channelRPNMSB[eventChannel] == 0 && channelRPNLSB[eventChannel] == 0) {
                                                    pitchBendRangeLSB[eventChannel] = value;
                                                }
                                            }
                                            break;
                                        case 100:
                                            {
                                                channelRPNLSB[eventChannel] = value;
                                            }
                                            break;
                                        case 101:
                                            {
                                                channelRPNMSB[eventChannel] = value;
                                            }
                                            break;
                                    }
                                }
                                break;
                            case 192:
                                {
                                    const program = track.reader.readMidi7Bits();
                                    currentInstrumentProgram[eventChannel] = program;
                                }
                                break;
                            case 208:
                                {
                                    track.reader.readMidi7Bits();
                                }
                                break;
                            case 224:
                                {
                                    const lsb = track.reader.readMidi7Bits();
                                    const msb = track.reader.readMidi7Bits();
                                    const pitchBend = (((msb << 7) | lsb) / 0x2000) - 1.0;
                                    const pitchBendRange = pitchBendRangeMSB[eventChannel] + pitchBendRangeLSB[eventChannel] * 0.01;
                                    const interval = pitchBend * pitchBendRange;
                                    pitchBendEvents[eventChannel].push({ midiTick: currentMidiTick, interval: interval });
                                }
                                break;
                            case 240:
                                {
                                    if (eventStatus == 255) {
                                        const message = track.reader.readMidi7Bits();
                                        const length = track.reader.readMidiVariableLength();
                                        if (message == 47) {
                                            foundTrackEndEvent = true;
                                            track.reader.skipBytes(length);
                                        }
                                        else if (message == 81) {
                                            microsecondsPerBeat = track.reader.readUint24();
                                            track.reader.skipBytes(length - 3);
                                        }
                                        else if (message == 88) {
                                            const numerator = track.reader.readUint8();
                                            let denominatorExponent = track.reader.readUint8();
                                            track.reader.readUint8();
                                            track.reader.readUint8();
                                            track.reader.skipBytes(length - 4);
                                            beatsPerBar = numerator * 4;
                                            while ((beatsPerBar & 1) == 0 && (denominatorExponent > 0 || beatsPerBar > Config.beatsPerBarMax) && beatsPerBar >= Config.beatsPerBarMin * 2) {
                                                beatsPerBar = beatsPerBar >> 1;
                                                denominatorExponent = denominatorExponent - 1;
                                            }
                                            beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, beatsPerBar));
                                        }
                                        else if (message == 89) {
                                            numSharps = track.reader.readInt8();
                                            isMinor = track.reader.readUint8() == 1;
                                            track.reader.skipBytes(length - 2);
                                        }
                                        else {
                                            track.reader.skipBytes(length);
                                        }
                                    }
                                    else if (eventStatus == 0xF0 || eventStatus == 0xF7) {
                                        const length = track.reader.readMidiVariableLength();
                                        track.reader.skipBytes(length);
                                    }
                                    else {
                                        console.error("Unrecognized event status: " + eventStatus);
                                        this._close();
                                        return;
                                    }
                                }
                                break;
                            default: {
                                console.error("Unrecognized event type: " + eventType);
                                this._close();
                                return;
                            }
                        }
                        if (!foundTrackEndEvent && track.reader.hasMore()) {
                            track.nextEventMidiTick = currentMidiTick + track.reader.readMidiVariableLength();
                        }
                        else {
                            track.ended = true;
                            if (independentTracks) {
                                currentIndependentTrackIndex++;
                                if (currentIndependentTrackIndex < tracks.length) {
                                    currentTrackIndices[0] = currentIndependentTrackIndex;
                                    tracks[currentIndependentTrackIndex].nextEventMidiTick += currentMidiTick;
                                    nextEventMidiTick = Math.min(nextEventMidiTick, tracks[currentIndependentTrackIndex].nextEventMidiTick);
                                    anyTrackHasMore = true;
                                }
                            }
                        }
                    }
                    if (!track.ended) {
                        anyTrackHasMore = true;
                        nextEventMidiTick = Math.min(nextEventMidiTick, track.nextEventMidiTick);
                    }
                }
                if (anyTrackHasMore) {
                    currentMidiTick = nextEventMidiTick;
                }
                else {
                    break;
                }
            }
            const microsecondsPerMinute = 60 * 1000 * 1000;
            const beatsPerMinute = Math.max(Config.tempoMin, Math.min(Config.tempoMax, Math.round(microsecondsPerMinute / microsecondsPerBeat)));
            const midiTicksPerPart = midiTicksPerBeat / Config.partsPerBeat;
            const partsPerBar = Config.partsPerBeat * beatsPerBar;
            const songTotalBars = Math.ceil(currentMidiTick / midiTicksPerPart / partsPerBar);
            function quantizeMidiTickToPart(midiTick) {
                return Math.round(midiTick / midiTicksPerPart);
            }
            let key = numSharps;
            if (isMinor)
                key += 3;
            if ((key & 1) == 1)
                key += 6;
            while (key < 0)
                key += 12;
            key = key % 12;
            const pitchChannels = [];
            const noiseChannels = [];
            const modChannels = [];
            for (let midiChannel = 0; midiChannel < 16; midiChannel++) {
                if (noteEvents[midiChannel].length == 0)
                    continue;
                const channel = new Channel();
                const channelPresetValue = EditorConfig.midiProgramToPresetValue(noteEvents[midiChannel][0].program);
                const channelPreset = (channelPresetValue == null) ? null : EditorConfig.valueToPreset(channelPresetValue);
                const isDrumsetChannel = (midiChannel == 9);
                const isNoiseChannel = isDrumsetChannel || (channelPreset != null && channelPreset.isNoise == true);
                const isModChannel = (channelPreset != null && channelPreset.isMod == true);
                const channelBasePitch = isNoiseChannel ? Config.spectrumBasePitch : Config.keys[key].basePitch;
                const intervalScale = isNoiseChannel ? Config.noiseInterval : 1;
                const midiIntervalScale = isNoiseChannel ? 0.5 : 1;
                const channelMaxPitch = isNoiseChannel ? Config.drumCount - 1 : Config.maxPitch;
                if (isNoiseChannel) {
                    if (isDrumsetChannel) {
                        noiseChannels.unshift(channel);
                    }
                    else {
                        noiseChannels.push(channel);
                    }
                }
                else if (isModChannel) {
                    modChannels.push(channel);
                }
                else {
                    pitchChannels.push(channel);
                }
                let currentVelocity = 1.0;
                let currentProgram = 0;
                let currentInstrumentVolume = 0;
                let currentInstrumentPan = Config.panCenter;
                if (isDrumsetChannel) {
                    const heldPitches = [];
                    let currentBar = -1;
                    let pattern = null;
                    let prevEventPart = 0;
                    let setInstrumentVolume = false;
                    const presetValue = EditorConfig.nameToPresetValue("standard drumset");
                    const preset = EditorConfig.valueToPreset(presetValue);
                    const instrument = new Instrument(false, false);
                    instrument.fromJsonObject(preset.settings, false, false, false, false, 1);
                    instrument.preset = presetValue;
                    channel.instruments.push(instrument);
                    for (let noteEventIndex = 0; noteEventIndex <= noteEvents[midiChannel].length; noteEventIndex++) {
                        const noMoreNotes = noteEventIndex == noteEvents[midiChannel].length;
                        const noteEvent = noMoreNotes ? null : noteEvents[midiChannel][noteEventIndex];
                        const nextEventPart = noteEvent == null ? Number.MAX_SAFE_INTEGER : quantizeMidiTickToPart(noteEvent.midiTick);
                        if (heldPitches.length > 0 && nextEventPart > prevEventPart && (noteEvent == null || noteEvent.on)) {
                            const bar = Math.floor(prevEventPart / partsPerBar);
                            const barStartPart = bar * partsPerBar;
                            if (currentBar != bar || pattern == null) {
                                currentBar++;
                                while (currentBar < bar) {
                                    channel.bars[currentBar] = 0;
                                    currentBar++;
                                }
                                pattern = new Pattern();
                                channel.patterns.push(pattern);
                                channel.bars[currentBar] = channel.patterns.length;
                                pattern.instruments[0] = 0;
                                pattern.instruments.length = 1;
                            }
                            if (!setInstrumentVolume || instrument.volume > currentInstrumentVolume) {
                                instrument.volume = currentInstrumentVolume;
                                instrument.pan = currentInstrumentPan;
                                instrument.panDelay = 0;
                                setInstrumentVolume = true;
                            }
                            const drumFreqs = [];
                            let minDuration = channelMaxPitch;
                            let maxDuration = 0;
                            let noteSize = 1;
                            for (const pitch of heldPitches) {
                                const drum = analogousDrumMap[pitch];
                                if (drumFreqs.indexOf(drum.frequency) == -1) {
                                    drumFreqs.push(drum.frequency);
                                }
                                noteSize = Math.max(noteSize, Math.round(drum.volume * currentVelocity));
                                minDuration = Math.min(minDuration, drum.duration);
                                maxDuration = Math.max(maxDuration, drum.duration);
                            }
                            const duration = Math.min(maxDuration, Math.max(minDuration, 2));
                            const noteStartPart = prevEventPart - barStartPart;
                            const noteEndPart = Math.min(partsPerBar, Math.min(nextEventPart - barStartPart, noteStartPart + duration * 6));
                            const note = new Note(-1, noteStartPart, noteEndPart, noteSize, true);
                            note.pitches.length = 0;
                            for (let pitchIndex = 0; pitchIndex < Math.min(Config.maxChordSize, drumFreqs.length); pitchIndex++) {
                                const heldPitch = drumFreqs[pitchIndex + Math.max(0, drumFreqs.length - Config.maxChordSize)];
                                if (note.pitches.indexOf(heldPitch) == -1) {
                                    note.pitches.push(heldPitch);
                                }
                            }
                            pattern.notes.push(note);
                            heldPitches.length = 0;
                        }
                        if (noteEvent != null && noteEvent.on && analogousDrumMap[noteEvent.pitch] != undefined) {
                            heldPitches.push(noteEvent.pitch);
                            prevEventPart = nextEventPart;
                            currentVelocity = noteEvent.velocity;
                            currentInstrumentVolume = noteEvent.instrumentVolume;
                            currentInstrumentPan = noteEvent.instrumentPan;
                        }
                    }
                }
                else {
                    let currentMidiInterval = 0.0;
                    let currentMidiNoteSize = Config.noteSizeMax;
                    let pitchBendEventIndex = 0;
                    let noteSizeEventIndex = 0;
                    function updateCurrentMidiInterval(midiTick) {
                        while (pitchBendEventIndex < pitchBendEvents[midiChannel].length && pitchBendEvents[midiChannel][pitchBendEventIndex].midiTick <= midiTick) {
                            currentMidiInterval = pitchBendEvents[midiChannel][pitchBendEventIndex].interval;
                            pitchBendEventIndex++;
                        }
                    }
                    function updateCurrentMidiNoteSize(midiTick) {
                        while (noteSizeEventIndex < noteSizeEvents[midiChannel].length && noteSizeEvents[midiChannel][noteSizeEventIndex].midiTick <= midiTick) {
                            currentMidiNoteSize = noteSizeEvents[midiChannel][noteSizeEventIndex].size;
                            noteSizeEventIndex++;
                        }
                    }
                    const instrumentByProgram = [];
                    const heldPitches = [];
                    let currentBar = -1;
                    let pattern = null;
                    let prevEventMidiTick = 0;
                    let prevEventPart = 0;
                    let pitchSum = 0;
                    let pitchCount = 0;
                    for (let noteEvent of noteEvents[midiChannel]) {
                        const nextEventMidiTick = noteEvent.midiTick;
                        const nextEventPart = quantizeMidiTickToPart(nextEventMidiTick);
                        if (heldPitches.length > 0 && nextEventPart > prevEventPart) {
                            const startBar = Math.floor(prevEventPart / partsPerBar);
                            const endBar = Math.ceil(nextEventPart / partsPerBar);
                            let createdNote = false;
                            for (let bar = startBar; bar < endBar; bar++) {
                                const barStartPart = bar * partsPerBar;
                                const barStartMidiTick = bar * beatsPerBar * midiTicksPerBeat;
                                const barEndMidiTick = (bar + 1) * beatsPerBar * midiTicksPerBeat;
                                const noteStartPart = Math.max(0, prevEventPart - barStartPart);
                                const noteEndPart = Math.min(partsPerBar, nextEventPart - barStartPart);
                                const noteStartMidiTick = Math.max(barStartMidiTick, prevEventMidiTick);
                                const noteEndMidiTick = Math.min(barEndMidiTick, nextEventMidiTick);
                                if (noteStartPart < noteEndPart) {
                                    const presetValue = EditorConfig.midiProgramToPresetValue(currentProgram);
                                    const preset = (presetValue == null) ? null : EditorConfig.valueToPreset(presetValue);
                                    if (currentBar != bar || pattern == null) {
                                        currentBar++;
                                        while (currentBar < bar) {
                                            channel.bars[currentBar] = 0;
                                            currentBar++;
                                        }
                                        pattern = new Pattern();
                                        channel.patterns.push(pattern);
                                        channel.bars[currentBar] = channel.patterns.length;
                                        if (instrumentByProgram[currentProgram] == undefined) {
                                            const instrument = new Instrument(isNoiseChannel, isModChannel);
                                            instrumentByProgram[currentProgram] = instrument;
                                            if (presetValue != null && preset != null && (preset.isNoise == true) == isNoiseChannel) {
                                                instrument.fromJsonObject(preset.settings, isNoiseChannel, isModChannel, false, false, 1);
                                                instrument.preset = presetValue;
                                            }
                                            else {
                                                instrument.setTypeAndReset(isModChannel ? 9 : (isNoiseChannel ? 2 : 0), isNoiseChannel, isModChannel);
                                                instrument.chord = 0;
                                            }
                                            instrument.volume = currentInstrumentVolume;
                                            instrument.pan = currentInstrumentPan;
                                            instrument.panDelay = 0;
                                            channel.instruments.push(instrument);
                                        }
                                        pattern.instruments[0] = channel.instruments.indexOf(instrumentByProgram[currentProgram]);
                                        pattern.instruments.length = 1;
                                    }
                                    if (instrumentByProgram[currentProgram] != undefined) {
                                        instrumentByProgram[currentProgram].volume = Math.min(instrumentByProgram[currentProgram].volume, currentInstrumentVolume);
                                        instrumentByProgram[currentProgram].pan = Math.min(instrumentByProgram[currentProgram].pan, currentInstrumentPan);
                                    }
                                    const note = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, false);
                                    note.pins.length = 0;
                                    note.continuesLastPattern = (createdNote && noteStartPart == 0);
                                    createdNote = true;
                                    updateCurrentMidiInterval(noteStartMidiTick);
                                    updateCurrentMidiNoteSize(noteStartMidiTick);
                                    const shiftedHeldPitch = heldPitches[0] * midiIntervalScale - channelBasePitch;
                                    const initialBeepBoxPitch = Math.round((shiftedHeldPitch + currentMidiInterval) / intervalScale);
                                    const heldPitchOffset = Math.round(currentMidiInterval - channelBasePitch);
                                    let firstPin = makeNotePin(0, 0, Math.round(currentVelocity * currentMidiNoteSize));
                                    note.pins.push(firstPin);
                                    const potentialPins = [
                                        { part: 0, pitch: initialBeepBoxPitch, size: firstPin.size, keyPitch: false, keySize: false }
                                    ];
                                    let prevPinIndex = 0;
                                    let prevPartPitch = (shiftedHeldPitch + currentMidiInterval) / intervalScale;
                                    let prevPartSize = currentVelocity * currentMidiNoteSize;
                                    for (let part = noteStartPart + 1; part <= noteEndPart; part++) {
                                        const midiTick = Math.max(noteStartMidiTick, Math.min(noteEndMidiTick - 1, Math.round(midiTicksPerPart * (part + barStartPart))));
                                        const noteRelativePart = part - noteStartPart;
                                        const lastPart = (part == noteEndPart);
                                        updateCurrentMidiInterval(midiTick);
                                        updateCurrentMidiNoteSize(midiTick);
                                        const partPitch = (currentMidiInterval + shiftedHeldPitch) / intervalScale;
                                        const partSize = currentVelocity * currentMidiNoteSize;
                                        const nearestPitch = Math.round(partPitch);
                                        const pitchIsNearInteger = Math.abs(partPitch - nearestPitch) < 0.01;
                                        const pitchCrossedInteger = (Math.abs(prevPartPitch - Math.round(prevPartPitch)) < 0.01)
                                            ? Math.abs(partPitch - prevPartPitch) >= 1.0
                                            : Math.floor(partPitch) != Math.floor(prevPartPitch);
                                        const keyPitch = pitchIsNearInteger || pitchCrossedInteger;
                                        const nearestSize = Math.round(partSize);
                                        const sizeIsNearInteger = Math.abs(partSize - nearestSize) < 0.01;
                                        const sizeCrossedInteger = (Math.abs(prevPartSize - Math.round(prevPartSize)))
                                            ? Math.abs(partSize - prevPartSize) >= 1.0
                                            : Math.floor(partSize) != Math.floor(prevPartSize);
                                        const keySize = sizeIsNearInteger || sizeCrossedInteger;
                                        prevPartPitch = partPitch;
                                        prevPartSize = partSize;
                                        if (keyPitch || keySize || lastPart) {
                                            const currentPin = { part: noteRelativePart, pitch: nearestPitch, size: nearestSize, keyPitch: keyPitch || lastPart, keySize: keySize || lastPart };
                                            const prevPin = potentialPins[prevPinIndex];
                                            let addPin = false;
                                            let addPinAtIndex = Number.MAX_VALUE;
                                            if (currentPin.keyPitch) {
                                                const slope = (currentPin.pitch - prevPin.pitch) / (currentPin.part - prevPin.part);
                                                let furthestIntervalDistance = Math.abs(slope);
                                                let addIntervalPin = false;
                                                let addIntervalPinAtIndex = Number.MAX_VALUE;
                                                for (let potentialIndex = prevPinIndex + 1; potentialIndex < potentialPins.length; potentialIndex++) {
                                                    const potentialPin = potentialPins[potentialIndex];
                                                    if (potentialPin.keyPitch) {
                                                        const interpolatedInterval = prevPin.pitch + slope * (potentialPin.part - prevPin.part);
                                                        const distance = Math.abs(interpolatedInterval - potentialPin.pitch);
                                                        if (furthestIntervalDistance < distance) {
                                                            furthestIntervalDistance = distance;
                                                            addIntervalPin = true;
                                                            addIntervalPinAtIndex = potentialIndex;
                                                        }
                                                    }
                                                }
                                                if (addIntervalPin) {
                                                    addPin = true;
                                                    addPinAtIndex = Math.min(addPinAtIndex, addIntervalPinAtIndex);
                                                }
                                            }
                                            if (currentPin.keySize) {
                                                const slope = (currentPin.size - prevPin.size) / (currentPin.part - prevPin.part);
                                                let furthestSizeDistance = Math.abs(slope);
                                                let addSizePin = false;
                                                let addSizePinAtIndex = Number.MAX_VALUE;
                                                for (let potentialIndex = prevPinIndex + 1; potentialIndex < potentialPins.length; potentialIndex++) {
                                                    const potentialPin = potentialPins[potentialIndex];
                                                    if (potentialPin.keySize) {
                                                        const interpolatedSize = prevPin.size + slope * (potentialPin.part - prevPin.part);
                                                        const distance = Math.abs(interpolatedSize - potentialPin.size);
                                                        if (furthestSizeDistance < distance) {
                                                            furthestSizeDistance = distance;
                                                            addSizePin = true;
                                                            addSizePinAtIndex = potentialIndex;
                                                        }
                                                    }
                                                }
                                                if (addSizePin) {
                                                    addPin = true;
                                                    addPinAtIndex = Math.min(addPinAtIndex, addSizePinAtIndex);
                                                }
                                            }
                                            if (addPin) {
                                                const toBePinned = potentialPins[addPinAtIndex];
                                                note.pins.push(makeNotePin(toBePinned.pitch - initialBeepBoxPitch, toBePinned.part, toBePinned.size));
                                                prevPinIndex = addPinAtIndex;
                                            }
                                            potentialPins.push(currentPin);
                                        }
                                    }
                                    const lastToBePinned = potentialPins[potentialPins.length - 1];
                                    note.pins.push(makeNotePin(lastToBePinned.pitch - initialBeepBoxPitch, lastToBePinned.part, lastToBePinned.size));
                                    let maxPitch = channelMaxPitch;
                                    let minPitch = 0;
                                    for (const notePin of note.pins) {
                                        maxPitch = Math.min(maxPitch, channelMaxPitch - notePin.interval);
                                        minPitch = Math.min(minPitch, -notePin.interval);
                                    }
                                    note.pitches.length = 0;
                                    for (let pitchIndex = 0; pitchIndex < Math.min(Config.maxChordSize, heldPitches.length); pitchIndex++) {
                                        let heldPitch = heldPitches[pitchIndex + Math.max(0, heldPitches.length - Config.maxChordSize)] * midiIntervalScale;
                                        if (preset != null && preset.midiSubharmonicOctaves != undefined) {
                                            heldPitch -= 12 * preset.midiSubharmonicOctaves;
                                        }
                                        const shiftedPitch = Math.max(minPitch, Math.min(maxPitch, Math.round((heldPitch + heldPitchOffset) / intervalScale)));
                                        if (note.pitches.indexOf(shiftedPitch) == -1) {
                                            note.pitches.push(shiftedPitch);
                                            const weight = note.end - note.start;
                                            pitchSum += shiftedPitch * weight;
                                            pitchCount += weight;
                                        }
                                    }
                                    pattern.notes.push(note);
                                }
                            }
                        }
                        if (heldPitches.indexOf(noteEvent.pitch) != -1) {
                            heldPitches.splice(heldPitches.indexOf(noteEvent.pitch), 1);
                        }
                        if (noteEvent.on) {
                            heldPitches.push(noteEvent.pitch);
                            currentVelocity = noteEvent.velocity;
                            currentProgram = noteEvent.program;
                            currentInstrumentVolume = noteEvent.instrumentVolume;
                            currentInstrumentPan = noteEvent.instrumentPan;
                        }
                        prevEventMidiTick = nextEventMidiTick;
                        prevEventPart = nextEventPart;
                    }
                    const averagePitch = pitchSum / pitchCount;
                    channel.octave = (isNoiseChannel || isModChannel) ? 0 : Math.max(0, Math.min(Config.pitchOctaves - 1, Math.floor((averagePitch / 12))));
                }
                while (channel.bars.length < songTotalBars) {
                    channel.bars.push(0);
                }
            }
            function compactChannels(channels, maxLength) {
                while (channels.length > maxLength) {
                    let bestChannelIndexA = channels.length - 2;
                    let bestChannelIndexB = channels.length - 1;
                    let fewestConflicts = Number.MAX_VALUE;
                    let fewestGaps = Number.MAX_VALUE;
                    for (let channelIndexA = 0; channelIndexA < channels.length - 1; channelIndexA++) {
                        for (let channelIndexB = channelIndexA + 1; channelIndexB < channels.length; channelIndexB++) {
                            const channelA = channels[channelIndexA];
                            const channelB = channels[channelIndexB];
                            let conflicts = 0;
                            let gaps = 0;
                            for (let barIndex = 0; barIndex < channelA.bars.length && barIndex < channelB.bars.length; barIndex++) {
                                if (channelA.bars[barIndex] != 0 && channelB.bars[barIndex] != 0)
                                    conflicts++;
                                if (channelA.bars[barIndex] == 0 && channelB.bars[barIndex] == 0)
                                    gaps++;
                            }
                            if (conflicts <= fewestConflicts) {
                                if (conflicts < fewestConflicts || gaps < fewestGaps) {
                                    bestChannelIndexA = channelIndexA;
                                    bestChannelIndexB = channelIndexB;
                                    fewestConflicts = conflicts;
                                    fewestGaps = gaps;
                                }
                            }
                        }
                    }
                    const channelA = channels[bestChannelIndexA];
                    const channelB = channels[bestChannelIndexB];
                    const channelAInstrumentCount = channelA.instruments.length;
                    const channelAPatternCount = channelA.patterns.length;
                    for (const instrument of channelB.instruments) {
                        channelA.instruments.push(instrument);
                    }
                    for (const pattern of channelB.patterns) {
                        pattern.instruments[0] += channelAInstrumentCount;
                        channelA.patterns.push(pattern);
                    }
                    for (let barIndex = 0; barIndex < channelA.bars.length && barIndex < channelB.bars.length; barIndex++) {
                        if (channelA.bars[barIndex] == 0 && channelB.bars[barIndex] != 0) {
                            channelA.bars[barIndex] = channelB.bars[barIndex] + channelAPatternCount;
                        }
                    }
                    channels.splice(bestChannelIndexB, 1);
                }
            }
            compactChannels(pitchChannels, Config.pitchChannelCountMax);
            compactChannels(noiseChannels, Config.noiseChannelCountMax);
            compactChannels(modChannels, Config.modChannelCountMax);
            class ChangeImportMidi extends ChangeGroup {
                constructor(doc) {
                    super();
                    const song = doc.song;
                    song.tempo = beatsPerMinute;
                    song.beatsPerBar = beatsPerBar;
                    song.key = key;
                    song.scale = 11;
                    song.rhythm = 1;
                    song.layeredInstruments = false;
                    song.patternInstruments = pitchChannels.some(channel => channel.instruments.length > 1) || noiseChannels.some(channel => channel.instruments.length > 1);
                    removeDuplicatePatterns(pitchChannels);
                    removeDuplicatePatterns(noiseChannels);
                    removeDuplicatePatterns(modChannels);
                    this.append(new ChangeReplacePatterns(doc, pitchChannels, noiseChannels, modChannels));
                    song.loopStart = 0;
                    song.loopLength = song.barCount;
                    this._didSomething();
                    doc.notifier.changed();
                }
            }
            this._doc.goBackToStart();
            for (const channel of this._doc.song.channels)
                channel.muted = false;
            this._doc.prompt = null;
            this._doc.record(new ChangeImportMidi(this._doc), true, true);
        }
    }

    const { button: button$6, label: label$1, div: div$6, form, h2: h2$6, input: input$4 } = HTML;
    class LayoutPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._fileInput = input$4({ type: "file", accept: ".json,application/json,.mid,.midi,audio/midi,audio/x-midi" });
            this._okayButton = button$6({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._cancelButton = button$6({ class: "cancelButton" });
            this._form = form({ style: "display: flex; gap: 10px;" }, label$1({ class: "layout-option" }, input$4({ type: "radio", name: "layout", value: "small" }), SVG(`\
					<svg viewBox="-4 -1 28 22">
						<rect x="0" y="0" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="11" height="10" fill="currentColor"/>
						<rect x="14" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="2" y="13" width="11" height="5" fill="currentColor"/>
					</svg>
				`), div$6("Small")), label$1({ class: "layout-option" }, input$4({ type: "radio", name: "layout", value: "long" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="12" height="10" fill="currentColor"/>
						<rect x="15" y="2" width="4" height="10" fill="currentColor"/>
						<rect x="20" y="2" width="4" height="10" fill="currentColor"/>
						<rect x="2" y="13" width="22" height="5" fill="currentColor"/>
					</svg>
				`), div$6("Long")), 
				
				
				 
				label$1({ class: "layout-option" }, input$4({ type: "radio", name: "layout", value: "tall2" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="11" y="2" width="8" height="16" fill="currentColor"/>
						<rect x="20" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="2" y="2" width="8" height="16" fill="currentColor"/>
					</svg>
				`), div$6("Tall Left")),
				

					
				label$1({ class: "layout-option" }, input$4({ type: "radio", name: "layout", value: "tall" }), SVG(`\
										<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1" />
						<rect x="7" y="2" width="12" height="16" fill="currentColor" />
						<rect x="20" y="2" width="4" height="16" fill="currentColor" />
						<rect x="2" y="2" width="4" height="16" fill="currentColor" />
					</svg>
				`), div$6("Tall Center")), 
				
				
				label$1({ class: "layout-option" }, input$4({ type: "radio", name: "layout", value: "tall3" }), SVG(`\
										<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1" />
						<rect x="7" y="2" width="8" height="16" fill="currentColor" />
						<rect x="16" y="2" width="8" height="16" fill="currentColor" />
						<rect x="2" y="2" width="4" height="16" fill="currentColor" />
					</svg>
				`), div$6("Tall Right")),
				
				label$1({ class: "layout-option" }, input$4({ type: "radio", name: "layout", value: "wide" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="18" y="2" width="2.5" height="16" fill="currentColor"/>
						<rect x="21.5" y="2" width="2.5" height="16" fill="currentColor"/>
						<rect x="7" y="2" width="10" height="16" fill="currentColor"/>
					</svg>
				`), div$6("Wide (JB)")));
            this.container = div$6({ class: "prompt noSelection", style: "width: 300px;" }, h2$6("Layout"), this._form, div$6({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._confirm);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._confirm();
                }
            };
            this._confirm = () => {
                this._doc.layout = this._form.elements["layout"].value;
                this._doc.savePreferences();
                Layout.setLayout(this._doc.layout);
                this._close();
            };
            this._fileInput.select();
            setTimeout(() => this._fileInput.focus());
            this._okayButton.addEventListener("click", this._confirm);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._form.elements["layout"].value = this._doc.layout;
        }
    }

    class EnvelopeEditor {
        constructor(_doc, _extraSettingsDropdown, _openPrompt) {
            this._doc = _doc;
            this.container = HTML.div({ class: "envelopeEditor" });
            this._rows = [];
            this._extraSettingsDropdown = _extraSettingsDropdown;
            this._targetSelects = [];
            this._envelopeSelects = [];
            this._deleteButtons = [];
            this._renderedEnvelopeCount = 0;
            this._renderedEqFilterCount = -1;
            this._renderedNoteFilterCount = -1;
            this._renderedEffects = 0;
            this._onChange = (event) => {
                const targetSelectIndex = this._targetSelects.indexOf(event.target);
                const envelopeSelectIndex = this._envelopeSelects.indexOf(event.target);
                if (targetSelectIndex != -1) {
                    const combinedValue = parseInt(this._targetSelects[targetSelectIndex].value);
                    const target = combinedValue % Config.instrumentAutomationTargets.length;
                    const index = (combinedValue / Config.instrumentAutomationTargets.length) >>> 0;
                    this._doc.record(new ChangeSetEnvelopeTarget(this._doc, targetSelectIndex, target, index));
                }
                else if (envelopeSelectIndex != -1) {
                    this._doc.record(new ChangeSetEnvelopeType(this._doc, envelopeSelectIndex, this._envelopeSelects[envelopeSelectIndex].selectedIndex));
                }
            };
            this._onClick = (event) => {
                const index = this._deleteButtons.indexOf(event.target);
                if (index != -1) {
                    this._doc.record(new ChangeRemoveEnvelope(this._doc, index));
                }
            };
            this.container.addEventListener("change", this._onChange);
            this.container.addEventListener("click", this._onClick);
        }
        _makeOption(target, index) {
            let displayName = Config.instrumentAutomationTargets[target].displayName;
            if (Config.instrumentAutomationTargets[target].maxCount > 1) {
                if (displayName.indexOf("#") != -1) {
                    displayName = displayName.replace("#", String(index + 1));
                }
                else {
                    displayName += " " + (index + 1);
                }
            }
            return HTML.option({ value: target + index * Config.instrumentAutomationTargets.length }, displayName);
        }
        _updateTargetOptionVisibility(menu, instrument) {
            for (let optionIndex = 0; optionIndex < menu.childElementCount; optionIndex++) {
                const option = menu.children[optionIndex];
                const combinedValue = parseInt(option.value);
                const target = combinedValue % Config.instrumentAutomationTargets.length;
                const index = (combinedValue / Config.instrumentAutomationTargets.length) >>> 0;
                option.hidden = !instrument.supportsEnvelopeTarget(target, index);
            }
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            if (!this._doc.alwaysShowSettings && instrument.preset != instrument.type)
                return;
            for (let envelopeIndex = this._rows.length; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                const targetSelect = HTML.select();
                for (let target = 0; target < Config.instrumentAutomationTargets.length; target++) {
                    const interleaved = (Config.instrumentAutomationTargets[target].interleave);
                    for (let index = 0; index < Config.instrumentAutomationTargets[target].maxCount; index++) {
                        targetSelect.appendChild(this._makeOption(target, index));
                        if (interleaved) {
                            targetSelect.appendChild(this._makeOption(target + 1, index));
                        }
                    }
                    if (interleaved)
                        target++;
                }
                const envelopeSelect = HTML.select();
                for (let envelope = 0; envelope < Config.envelopes.length; envelope++) {
                    envelopeSelect.appendChild(HTML.option({ value: envelope }, Config.envelopes[envelope].name));
                }
                const deleteButton = HTML.button({ type: "button", class: "delete-envelope" });
                
                
                 
                
                
                
                const row = HTML.div({ class: "envelope-row" }, HTML.div({ class: "selectContainer", style: "width: 0; flex: 1;" }, targetSelect), HTML.div({ class: "selectContainer", style: "width: 0; flex: 0.7;" }, envelopeSelect), deleteButton);
                
                
                
                
                this.container.appendChild(row);
                this._rows[envelopeIndex] = row;
                this._targetSelects[envelopeIndex] = targetSelect;
                this._envelopeSelects[envelopeIndex] = envelopeSelect;
                this._deleteButtons[envelopeIndex] = deleteButton;
            }
            for (let envelopeIndex = this._renderedEnvelopeCount; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                this._rows[envelopeIndex].style.display = "";
                this._updateTargetOptionVisibility(this._targetSelects[envelopeIndex], instrument);
            }
            for (let envelopeIndex = instrument.envelopeCount; envelopeIndex < this._renderedEnvelopeCount; envelopeIndex++) {
                this._rows[envelopeIndex].style.display = "none";
            }
            let useControlPointCount = instrument.noteFilter.controlPointCount;
            if (instrument.noteFilterType)
                useControlPointCount = 1;
            if (this._renderedEqFilterCount != instrument.eqFilter.controlPointCount ||
                this._renderedNoteFilterCount != useControlPointCount ||
                this._renderedInstrumentType != instrument.type ||
                this._renderedEffects != instrument.effects) {
                for (let envelopeIndex = 0; envelopeIndex < this._renderedEnvelopeCount; envelopeIndex++) {
                    this._updateTargetOptionVisibility(this._targetSelects[envelopeIndex], instrument);
                }
            }
            for (let envelopeIndex = 0; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                this._targetSelects[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].target + instrument.envelopes[envelopeIndex].index * Config.instrumentAutomationTargets.length);
                this._envelopeSelects[envelopeIndex].selectedIndex = instrument.envelopes[envelopeIndex].envelope;
            }
            this._renderedEnvelopeCount = instrument.envelopeCount;
            this._renderedEqFilterCount = instrument.eqFilter.controlPointCount;
            this._renderedNoteFilterCount = useControlPointCount;
            this._renderedInstrumentType = instrument.type;
            this._renderedEffects = instrument.effects;
        }
    }

    class FadeInOutEditor {
        constructor(_doc) {
            this._doc = _doc;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._fadeCurve = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._dottedLinePath = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 1, "stroke-dasharray": "3, 2", "pointer-events": "none" });
            this._controlCurve = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 2, "pointer-events": "none" });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._fadeCurve, this._dottedLinePath, this._controlCurve);
            this.container = HTML.div({ class: "fadeInOut", style: "height: 100%;" }, this._svg);
            this._mouseX = 0;
            this._mouseXStart = 0;
            this._mouseDown = false;
            this._mouseDragging = false;
            this._draggingFadeIn = false;
            this._dragChange = null;
            this._renderedFadeIn = -1;
            this._renderedFadeOut = -1;
            this._whenMousePressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left);
                this._whenCursorPressed();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left);
                this._whenCursorPressed();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (this._mouseDown && this._doc.lastChangeWas(this._dragChange) && this._dragChange != null) {
                    if (!this._mouseDragging) {
                        const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                        if (this._draggingFadeIn) {
                            this._doc.record(new ChangeFadeInOut(this._doc, this._xToFadeIn(this._mouseX), instrument.fadeOut));
                        }
                        else {
                            this._doc.record(new ChangeFadeInOut(this._doc, instrument.fadeIn, this._xToFadeOut(this._mouseX)));
                        }
                    }
                    else {
                        this._doc.record(this._dragChange);
                    }
                }
                this._dragChange = null;
                this._mouseDragging = false;
                this._mouseDown = false;
            };
            const dottedLineX = this._fadeOutToX(Config.fadeOutNeutral);
            this._dottedLinePath.setAttribute("d", `M ${dottedLineX} 0 L ${dottedLineX} ${this._editorHeight}`);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _fadeInToX(fadeIn) {
            return 1.0 + (this._editorWidth - 2.0) * 0.4 * fadeIn / (Config.fadeInRange - 1);
        }
        _xToFadeIn(x) {
            return clamp(0, Config.fadeInRange, Math.round((x - 1.0) * (Config.fadeInRange - 1) / (0.4 * this._editorWidth - 2.0)));
        }
        _fadeOutToX(fadeOut) {
            return 1.0 + (this._editorWidth - 2.0) * (0.5 + 0.5 * fadeOut / (Config.fadeOutTicks.length - 1));
        }
        _xToFadeOut(x) {
            return clamp(0, Config.fadeOutTicks.length, Math.round((Config.fadeOutTicks.length - 1) * ((x - 1.0) / (this._editorWidth - 2.0) - 0.5) / 0.5));
        }
        _whenCursorPressed() {
            if (isNaN(this._mouseX))
                this._mouseX = 0;
            this._mouseXStart = this._mouseX;
            this._mouseDown = true;
            this._mouseDragging = false;
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const fadeInX = this._fadeInToX(instrument.fadeIn);
            const fadeOutX = this._fadeOutToX(instrument.fadeOut);
            this._draggingFadeIn = this._mouseXStart < (fadeInX + fadeOutX) / 2.0;
            this._dragChange = new ChangeSequence();
            this._doc.setProspectiveChange(this._dragChange);
        }
        _whenCursorMoved() {
            if (this._dragChange != null && this._doc.lastChangeWas(this._dragChange)) {
                this._dragChange.undo();
            }
            else {
                this._mouseDown = false;
            }
            this._dragChange = null;
            if (this._mouseDown) {
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._doc.setProspectiveChange(this._dragChange);
                if (Math.abs(this._mouseX - this._mouseXStart) > 4.0) {
                    this._mouseDragging = true;
                }
                if (this._mouseDragging) {
                    const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                    if (this._draggingFadeIn) {
                        sequence.append(new ChangeFadeInOut(this._doc, this._xToFadeIn(this._fadeInToX(instrument.fadeIn) + this._mouseX - this._mouseXStart), instrument.fadeOut));
                    }
                    else {
                        sequence.append(new ChangeFadeInOut(this._doc, instrument.fadeIn, this._xToFadeOut(this._fadeOutToX(instrument.fadeOut) + this._mouseX - this._mouseXStart)));
                    }
                }
            }
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            if (this._renderedFadeIn == instrument.fadeIn && this._renderedFadeOut == instrument.fadeOut) {
                return;
            }
            const fadeInX = this._fadeInToX(instrument.fadeIn);
            const fadeOutX = this._fadeOutToX(instrument.fadeOut);
            this._controlCurve.setAttribute("d", `M ${fadeInX} 0 L ${fadeInX} ${this._editorHeight} M ${fadeOutX} 0 L ${fadeOutX} ${this._editorHeight}`);
            const dottedLineX = this._fadeOutToX(Config.fadeOutNeutral);
            let fadePath = "";
            fadePath += `M 0 ${this._editorHeight} `;
            fadePath += `L ${fadeInX} 0 `;
            if (Synth.fadeOutSettingToTicks(instrument.fadeOut) > 0) {
                fadePath += `L ${dottedLineX} 0 `;
                fadePath += `L ${fadeOutX} ${this._editorHeight} `;
            }
            else {
                fadePath += `L ${fadeOutX} 0 `;
                fadePath += `L ${dottedLineX} ${this._editorHeight} `;
            }
            fadePath += "z";
            this._fadeCurve.setAttribute("d", fadePath);
        }
    }

    const { button: button$7, div: div$7, h2: h2$7, input: input$5 } = HTML;
    class LimiterCanvas {
        constructor(lim) {
            this._editorWidth = 200;
            this._editorHeight = 52;
            this._fill = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._ticks = SVG.svg({ "pointer-events": "none" });
            this._subticks = SVG.svg({ "pointer-events": "none" });
            this._boostCurve = SVG.path({ fill: "none", stroke: ColorConfig.textSelection, "stroke-width": 2, "pointer-events": "none" });
            this._boostDot = SVG.circle({ fill: ColorConfig.textSelection, stroke: "none", r: "3" });
            this._midCurve = SVG.path({ fill: "none", stroke: ColorConfig.primaryText, "stroke-width": 2, "pointer-events": "none" });
            this._limitCurve = SVG.path({ fill: "none", stroke: ColorConfig.linkAccent, "stroke-width": 2, "pointer-events": "none" });
            this._limitDot = SVG.circle({ fill: ColorConfig.linkAccent, stroke: "none", r: "3" });
            this._label0 = SVG.text({ x: "-1.5%", y: "148.5%", "pointer-events": "none", "font-size": "7pt", fill: "var(--secondary-text)" }, "0");
            this._label1 = SVG.text({ x: "48.2%", y: "148.5%", "pointer-events": "none", "font-size": "7pt", fill: "var(--secondary-text)" }, "1");
            this._label2 = SVG.text({ x: "98.2%", y: "148.5%", "pointer-events": "none", "font-size": "7pt", fill: "var(--secondary-text)" }, "2");
            this._inLabel = SVG.text({ x: "-5%", y: "113.5%", "pointer-events": "none", "font-size": "6pt", fill: "var(--secondary-text)" }, "In");
            this._outLabel = SVG.text({ x: "-9%", y: "131%", "pointer-events": "none", "font-size": "6pt", fill: "var(--secondary-text)" }, "Out");
            this._xAxisLabel = SVG.text({ x: "42%", y: "172%", "pointer-events": "none", "font-size": "7pt", fill: "var(--primary-text)" }, "Volume");
            this._yAxisLabel = SVG.text({ x: "55.2%", y: "160%", "pointer-events": "none", "font-size": "7pt", transform: "rotate(-90 30,120)", fill: "var(--primary-text)" }, "Gain");
            this._inVolumeBg = SVG.rect({ "pointer-events": "none", width: "100%", height: "6px", x: "0%", y: "105%", fill: ColorConfig.uiWidgetBackground });
            this._outVolumeBg = SVG.rect({ "pointer-events": "none", width: "100%", height: "6px", x: "0%", y: "120%", fill: ColorConfig.uiWidgetBackground });
            this._inVolumeBar = SVG.rect({ "pointer-events": "none", height: "6px", x: "0%", y: "105%", fill: "url('#volumeGrad')" });
            this._inVolumeCap = SVG.rect({ "pointer-events": "none", width: "2px", height: "6px", y: "105%", fill: ColorConfig.uiWidgetFocus });
            this._outVolumeBar = SVG.rect({ "pointer-events": "none", height: "6px", x: "0%", y: "120%", fill: "url('#volumeGrad')" });
            this._outVolumeCap = SVG.rect({ "pointer-events": "none", width: "2px", height: "6px", y: "120%", fill: ColorConfig.uiWidgetFocus });
            this._stop1 = SVG.stop({ "stop-color": "lime", offset: "30%" });
            this._stop2 = SVG.stop({ "stop-color": "orange", offset: "45%" });
            this._stop3 = SVG.stop({ "stop-color": "red", offset: "50%" });
            this._gradient = SVG.linearGradient({ id: "volumeGrad", gradientUnits: "userSpaceOnUse" }, this._stop1, this._stop2, this._stop3);
            this._defs = SVG.defs({}, this._gradient);
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; overflow: visible;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._defs, this._fill, this._ticks, this._subticks, this._boostCurve, this._midCurve, this._limitCurve, this._boostDot, this._limitDot, this._label0, this._label1, this._label2, this._inLabel, this._outLabel, this._xAxisLabel, this._yAxisLabel, this._inVolumeBg, this._outVolumeBg, this._inVolumeBar, this._outVolumeBar, this._inVolumeCap, this._outVolumeCap);
            this.container = HTML.div({ class: "", style: "height: 4em; width: 80%; padding-bottom: 1.5em;" }, this._svg);
            for (let i = 0; i <= 2; i++) {
                this._ticks.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i * this._editorWidth / 2) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 1; i <= 3; i += 2) {
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i * this._editorWidth / 4) - 1, y: 0, width: 1, height: this._editorHeight }));
            }
            this._limiterPrompt = lim;
        }
        animateVolume(inVolumeCap, historicInCap, outVolumeCap, historicOutCap) {
            this._inVolumeBar.setAttribute("width", "" + Math.min(this._editorWidth, inVolumeCap * (this._editorWidth / 2.0)));
            this._inVolumeCap.setAttribute("x", "" + Math.min(this._editorWidth, historicInCap * (this._editorWidth / 2.0)));
            this._outVolumeBar.setAttribute("width", "" + Math.min(this._editorWidth, outVolumeCap * (this._editorWidth / 2.0)));
            this._outVolumeCap.setAttribute("x", "" + Math.min(this._editorWidth, historicOutCap * (this._editorWidth / 2.0)));
        }
        render() {
            const controlPointToHeight = (point) => {
                return Math.max(0, (1 - (point / 5)) * (this._editorHeight - 1) + 1);
            };
            let lastValue = 0;
            let currentSubpathIdx = 0;
            let lastSubpathIdx = -1;
            let path = "";
            let subPaths = ["", "", ""];
            for (let i = 0; i < 64; i++) {
                let limiterRatio = +this._limiterPrompt.limitRatioSlider.value;
                limiterRatio = (limiterRatio < 10 ? limiterRatio / 10 : (limiterRatio - 9));
                let compressorRatio = +this._limiterPrompt.compressionRatioSlider.value;
                compressorRatio = (compressorRatio < 10 ? compressorRatio / 10 : (1 + (compressorRatio - 10) / 60));
                let limiterThreshold = +this._limiterPrompt.limitThresholdSlider.value;
                let compressorThreshold = +this._limiterPrompt.compressionThresholdSlider.value;
                let useVol = i * 2.0 / 64.0;
                let nextValue = 1 / 1.05;
                if (useVol >= limiterThreshold) {
                    nextValue = 1 / (1.05 * (useVol + 1 - limiterThreshold) * limiterRatio + (1 - limiterRatio));
                }
                else if (useVol < compressorThreshold) {
                    nextValue = 1 / (((useVol + 1 - compressorThreshold) * 0.8 + 0.25) * compressorRatio + 1.05 * (1 - compressorRatio));
                }
                if (i == 0) {
                    path += "M 0 " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                }
                if (currentSubpathIdx > lastSubpathIdx) {
                    if (lastSubpathIdx >= 0) {
                        subPaths[lastSubpathIdx] += "L " + prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                    }
                    subPaths[currentSubpathIdx] += "M " + prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                    if (currentSubpathIdx == 1 || (lastSubpathIdx == 0 && currentSubpathIdx == 2)) {
                        this._boostDot.setAttribute("cx", prettyNumber(i * this._editorWidth / 64));
                        this._boostDot.setAttribute("cy", prettyNumber(controlPointToHeight(nextValue)));
                    }
                    if (currentSubpathIdx == 2) {
                        this._limitDot.setAttribute("cx", prettyNumber(i * this._editorWidth / 64));
                        this._limitDot.setAttribute("cy", prettyNumber(controlPointToHeight(nextValue)));
                    }
                    lastSubpathIdx = currentSubpathIdx;
                }
                if (lastValue != 0 || nextValue != 0) {
                    path += "L ";
                    subPaths[currentSubpathIdx] += "L ";
                }
                else {
                    path += "M ";
                    subPaths[currentSubpathIdx] += "M ";
                }
                path += prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                subPaths[currentSubpathIdx] += prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                lastValue = nextValue;
                if (currentSubpathIdx == 0 && (i >= compressorThreshold * 32 - 2)) {
                    currentSubpathIdx++;
                }
                if (currentSubpathIdx == 1 && (i >= limiterThreshold * 32 - 2)) {
                    currentSubpathIdx++;
                }
            }
            const lastHeight = controlPointToHeight(lastValue);
            if (lastValue > 0) {
                path += "L " + (this._editorWidth - 1) + " " + prettyNumber(lastHeight) + " ";
                subPaths[currentSubpathIdx] += "L " + (this._editorWidth - 1) + " " + prettyNumber(lastHeight) + " ";
            }
            this._boostCurve.setAttribute("d", subPaths[0]);
            this._midCurve.setAttribute("d", subPaths[1]);
            this._limitCurve.setAttribute("d", subPaths[2]);
            this._fill.setAttribute("d", path + "L " + this._editorWidth + " " + prettyNumber(lastHeight) + " L " + this._editorWidth + " " + prettyNumber(this._editorHeight) + " L 0 " + prettyNumber(this._editorHeight) + " z ");
        }
    }
    class LimiterPrompt {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this.limiterCanvas = new LimiterCanvas(this);
            this._playButton = button$7({ style: "width: 55%;", type: "button" });
            this.limitDecaySlider = input$5({ title: "limit decay", style: `width: 5em; flex-grow: 1; margin: 0;`, type: "range", min: "1", max: "30", value: "4", step: "1" });
            this.limitRiseSlider = input$5({ title: "limit rise", style: `width: 5em; flex-grow: 1; margin: 0;`, type: "range", min: "2000", max: "10000", value: "4000", step: "250" });
            this.compressionThresholdSlider = input$5({ title: "compressor threshold", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "1.1", value: "1", step: "0.05" });
            this.limitThresholdSlider = input$5({ title: "limiter threshold", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "2", value: "1", step: "0.05" });
            this.compressionRatioSlider = input$5({ title: "compressor ratio", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "20", value: "10", step: "1" });
            this.limitRatioSlider = input$5({ title: "limiter ratio", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "20", value: "10", step: "1" });
            this.masterGainSlider = input$5({ title: "master gain", style: `width: 5em; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "10", value: "1", step: "0.02" });
            this.inVolumeHistoricTimer = 0.0;
            this.inVolumeHistoricCap = 0.0;
            this.outVolumeHistoricTimer = 0.0;
            this.outVolumeHistoricCap = 0.0;
            this._cancelButton = button$7({ class: "cancelButton" });
            this._okayButton = button$7({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._resetButton = button$7({ style: "width:45%;" }, "Reset");
            this.container = div$7({ class: "prompt noSelection", style: "width: 250px;" }, h2$7("Limiter Options"), div$7({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), div$7({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center;" }, this.limiterCanvas.container), div$7({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; margin-top: 1.5em; justify-content: flex-end;" }, div$7({ style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${ColorConfig.primaryText};` }, ""), div$7({ style: `text-align: center; width: 33%; margin-right: 4.5%; color: ${ColorConfig.textSelection};` }, "Boost"), div$7({ style: `text-align: center; width: 33%; margin-right: 0%; color: ${ColorConfig.linkAccent};` }, "Cutoff")), div$7({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; margin-top: 0.5em; justify-content: flex-end;" }, div$7({ style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${ColorConfig.primaryText};` }, "Threshold:"), div$7({ style: `width: 33%; margin-right: 4.5%;` }, this.compressionThresholdSlider), div$7({ style: `width: 33%; margin-right: 0%;` }, this.limitThresholdSlider)), div$7({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$7({ style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${ColorConfig.primaryText};` }, "Ratio:"), div$7({ style: `width: 33%; margin-right: 4.5%;` }, this.compressionRatioSlider), div$7({ style: `width: 33%; margin-right: 0%;` }, this.limitRatioSlider)), div$7({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$7({ style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${ColorConfig.primaryText};` }, "Limit Decay:"), this.limitDecaySlider), div$7({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$7({ style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${ColorConfig.primaryText};` }, "Limit Rise:"), this.limitRiseSlider), div$7({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$7({ style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${ColorConfig.primaryText};` }, "Master Gain:"), this.masterGainSlider), div$7({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this._resetButton), this._cancelButton);
            this._volumeUpdate = () => {
                this.inVolumeHistoricTimer--;
                if (this.inVolumeHistoricTimer <= 0) {
                    this.inVolumeHistoricCap -= 0.03;
                }
                if (this._doc.song.inVolumeCap > this.inVolumeHistoricCap) {
                    this.inVolumeHistoricCap = this._doc.song.inVolumeCap;
                    this.inVolumeHistoricTimer = 50;
                }
                this.outVolumeHistoricTimer--;
                if (this.outVolumeHistoricTimer <= 0) {
                    this.outVolumeHistoricCap -= 0.03;
                }
                if (this._doc.song.outVolumeCap > this.outVolumeHistoricCap) {
                    this.outVolumeHistoricCap = this._doc.song.outVolumeCap;
                    this.outVolumeHistoricTimer = 50;
                }
                this.limiterCanvas.animateVolume(this._doc.song.inVolumeCap, this.inVolumeHistoricCap, this._doc.song.outVolumeCap, this.outVolumeHistoricCap);
                window.requestAnimationFrame(this._volumeUpdate);
            };
            this._togglePlay = () => {
                if (this._doc.synth.playing) {
                    this._songEditor._pause();
                    
                    this.updatePlayButton();
                }
                else {
                    this._doc.synth.snapToBar();
                    this._songEditor._play();
                    this.updatePlayButton();
                }
            };
            this._whenInput = () => {
                if (+this.limitThresholdSlider.value < +this.compressionThresholdSlider.value) {
                    this.limitThresholdSlider.removeEventListener("input", this._whenInputFavorLimitThreshold);
                    this.limitThresholdSlider.value = this.compressionThresholdSlider.value;
                    this.limitThresholdSlider.addEventListener("input", this._whenInputFavorLimitThreshold);
                }
                this.limiterCanvas.render();
                this._updateLimiter();
            };
            this._whenInputFavorLimitThreshold = () => {
                if (+this.limitThresholdSlider.value < +this.compressionThresholdSlider.value) {
                    this.compressionThresholdSlider.removeEventListener("input", this._whenInput);
                    this.compressionThresholdSlider.value = this.limitThresholdSlider.value;
                    this.compressionThresholdSlider.addEventListener("input", this._whenInput);
                }
                this.limiterCanvas.render();
                this._updateLimiter();
            };
            this._close = () => {
                this.limitRatioSlider.value = "" + this.startingLimitRatio;
                this.compressionRatioSlider.value = "" + this.startingCompressionRatio;
                this.limitThresholdSlider.value = "" + this.startingLimitThreshold;
                this.compressionThresholdSlider.value = "" + this.startingCompressionThreshold;
                this.limitDecaySlider.value = "" + this.startingLimitDecay;
                this.limitRiseSlider.value = "" + this.startingLimitRise;
                this.masterGainSlider.value = "" + this.startingMasterGain;
                this._updateLimiter();
                this._doc.prompt = null;
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._resetButton.removeEventListener("click", this._resetDefaults);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this.limitDecaySlider.removeEventListener("input", this._whenInput);
                this.limitRiseSlider.removeEventListener("input", this._whenInput);
                this.limitThresholdSlider.removeEventListener("input", this._whenInputFavorLimitThreshold);
                this.limitRatioSlider.removeEventListener("input", this._whenInput);
                this.compressionRatioSlider.removeEventListener("input", this._whenInput);
                this.compressionThresholdSlider.removeEventListener("input", this._whenInput);
                this.masterGainSlider.removeEventListener("input", this._whenInput);
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
            };
            this._resetDefaults = () => {
                if (this.limitRatioSlider.value != "10" || this.limitRiseSlider.value != "4000" || this.limitDecaySlider.value != "4" || this.limitThresholdSlider.value != "1" || this.compressionRatioSlider.value != "10" || this.compressionThresholdSlider.value != "1" || this.masterGainSlider.value != "1") {
                    this.limitRatioSlider.value = "10";
                    this.limitRiseSlider.value = "4000";
                    this.limitDecaySlider.value = "4";
                    this.limitThresholdSlider.value = "1";
                    this.compressionRatioSlider.value = "10";
                    this.compressionThresholdSlider.value = "1";
                    this.masterGainSlider.value = "1";
                    this._whenInput();
                }
            };
            this._updateLimiter = () => {
                this._doc.record(new ChangeLimiterSettings(this._doc, (+this.limitRatioSlider.value < 10 ? +this.limitRatioSlider.value / 10 : (+this.limitRatioSlider.value - 9)), (+this.compressionRatioSlider.value < 10 ? +this.compressionRatioSlider.value / 10 : (1 + (+this.compressionRatioSlider.value - 10) / 60)), +this.limitThresholdSlider.value, +this.compressionThresholdSlider.value, +this.limitRiseSlider.value, +this.limitDecaySlider.value, +this.masterGainSlider.value), true);
            };
            this._saveChanges = () => {
                this._updateLimiter();
                this._doc.prompt = null;
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._resetButton.addEventListener("click", this._resetDefaults);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this.whenKeyPressed);
            this.limitRatioSlider.value = "" + (this._doc.song.limitRatio < 1 ? this._doc.song.limitRatio * 10 : 9 + this._doc.song.limitRatio);
            this.compressionRatioSlider.value = "" + (this._doc.song.compressionRatio < 1 ? this._doc.song.compressionRatio * 10 : 10 + (this._doc.song.compressionRatio - 1) * 60);
            this.limitThresholdSlider.value = "" + this._doc.song.limitThreshold;
            this.compressionThresholdSlider.value = "" + this._doc.song.compressionThreshold;
            this.limitDecaySlider.value = "" + this._doc.song.limitDecay;
            this.limitRiseSlider.value = "" + this._doc.song.limitRise;
            this.masterGainSlider.value = "" + this._doc.song.masterGain;
            this.startingLimitRatio = +this.limitRatioSlider.value;
            this.startingCompressionRatio = +this.compressionRatioSlider.value;
            this.startingLimitThreshold = +this.limitThresholdSlider.value;
            this.startingCompressionThreshold = +this.compressionThresholdSlider.value;
            this.startingLimitDecay = +this.limitDecaySlider.value;
            this.startingLimitRise = +this.limitRiseSlider.value;
            this.startingMasterGain = +this.masterGainSlider.value;
            this.limitDecaySlider.addEventListener("input", this._whenInput);
            this.limitRiseSlider.addEventListener("input", this._whenInput);
            this.limitRatioSlider.addEventListener("input", this._whenInput);
            this.limitThresholdSlider.addEventListener("input", this._whenInputFavorLimitThreshold);
            this.compressionRatioSlider.addEventListener("input", this._whenInput);
            this.compressionThresholdSlider.addEventListener("input", this._whenInput);
            this.masterGainSlider.addEventListener("input", this._whenInput);
            this._playButton.addEventListener("click", this._togglePlay);
            window.requestAnimationFrame(this._volumeUpdate);
            this.updatePlayButton();
            setTimeout(() => this._playButton.focus());
            this.limiterCanvas.render();
        }
        updatePlayButton() {
        	
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
                
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            }
        }
    }

    class LoopEditor {
        constructor(_doc) {
            this._doc = _doc;
            this._editorHeight = 20;
            this._startMode = 0;
            this._endMode = 1;
            this._bothMode = 2;
            this._loop = SVG.path({ fill: "none", stroke: ColorConfig.loopAccent, "stroke-width": 4 });
            this._highlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._svg = SVG.svg({ style: `touch-action: pan-y; position: absolute;`, height: this._editorHeight }, this._loop, this._highlight);
            this.container = HTML.div({ class: "loopEditor" }, this._svg);
            this._barWidth = 32;
            this._change = null;
            this._cursor = { startBar: -1, mode: -1 };
            this._mouseX = 0;
            this._clientStartX = 0;
            this._clientStartY = 0;
            this._startedScrolling = false;
            this._draggingHorizontally = false;
            this._mouseDown = false;
            this._mouseOver = false;
            this._renderedLoopStart = -1;
            this._renderedLoopStop = -1;
            this._renderedBarCount = 0;
            this._renderedBarWidth = -1;
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._updatePreview();
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
                this._updatePreview();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
                this._updateCursorStatus();
                this._updatePreview();
                this._whenMouseMoved(event);
            };
            this._whenTouchPressed = (event) => {
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = event.touches[0].clientX - boundingRect.left;
                this._updateCursorStatus();
                this._updatePreview();
                this._clientStartX = event.touches[0].clientX;
                this._clientStartY = event.touches[0].clientY;
                this._draggingHorizontally = false;
                this._startedScrolling = false;
            };
            this._whenMouseMoved = (event) => {
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = event.touches[0].clientX - boundingRect.left;
                if (!this._draggingHorizontally && !this._startedScrolling) {
                    if (Math.abs(event.touches[0].clientY - this._clientStartY) > 10) {
                        this._startedScrolling = true;
                    }
                    else if (Math.abs(event.touches[0].clientX - this._clientStartX) > 10) {
                        this._draggingHorizontally = true;
                    }
                }
                if (this._draggingHorizontally) {
                    this._whenCursorMoved();
                    event.preventDefault();
                }
            };
            this._whenTouchReleased = (event) => {
                event.preventDefault();
                if (!this._startedScrolling) {
                    this._whenCursorMoved();
                    this._mouseOver = false;
                    this._whenCursorReleased(event);
                    this._updatePreview();
                }
                this._mouseDown = false;
            };
            this._whenCursorReleased = (event) => {
                if (this._change != null)
                    this._doc.record(this._change);
                this._change = null;
                this._mouseDown = false;
                this._updateCursorStatus();
                this._render();
            };
            this._documentChanged = () => {
                this._render();
            };
            this._updateCursorStatus();
            this._render();
            this._doc.notifier.watch(this._documentChanged);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenTouchReleased);
            this.container.addEventListener("touchcancel", this._whenTouchReleased);
        }
        _updateCursorStatus() {
            const bar = this._mouseX / this._barWidth;
            this._cursor.startBar = bar;
            if (bar > this._doc.song.loopStart - 0.25 && bar < this._doc.song.loopStart + this._doc.song.loopLength + 0.25) {
                if (bar - this._doc.song.loopStart < this._doc.song.loopLength * 0.5) {
                    this._cursor.mode = this._startMode;
                }
                else {
                    this._cursor.mode = this._endMode;
                }
            }
            else {
                this._cursor.mode = this._bothMode;
            }
        }
        _findEndPoints(middle) {
            let start = Math.round(middle - this._doc.song.loopLength / 2);
            let end = start + this._doc.song.loopLength;
            if (start < 0) {
                end -= start;
                start = 0;
            }
            if (end > this._doc.song.barCount) {
                start -= end - this._doc.song.barCount;
                end = this._doc.song.barCount;
            }
            return { start: start, length: end - start };
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                let oldStart = this._doc.song.loopStart;
                let oldEnd = this._doc.song.loopStart + this._doc.song.loopLength;
                if (this._change != null && this._doc.lastChangeWas(this._change)) {
                    oldStart = this._change.oldStart;
                    oldEnd = oldStart + this._change.oldLength;
                }
                const bar = this._mouseX / this._barWidth;
                let start;
                let end;
                let temp;
                if (this._cursor.mode == this._startMode) {
                    start = oldStart + Math.round(bar - this._cursor.startBar);
                    end = oldEnd;
                    if (start < 0)
                        start = 0;
                    if (start >= this._doc.song.barCount)
                        start = this._doc.song.barCount;
                    if (start == end) {
                        start = end - 1;
                    }
                    else if (start > end) {
                        temp = start;
                        start = end;
                        end = temp;
                    }
                    this._change = new ChangeLoop(this._doc, oldStart, oldEnd - oldStart, start, end - start);
                }
                else if (this._cursor.mode == this._endMode) {
                    start = oldStart;
                    end = oldEnd + Math.round(bar - this._cursor.startBar);
                    if (end < 0)
                        end = 0;
                    if (end >= this._doc.song.barCount)
                        end = this._doc.song.barCount;
                    if (end == start) {
                        end = start + 1;
                    }
                    else if (end < start) {
                        temp = start;
                        start = end;
                        end = temp;
                    }
                    this._change = new ChangeLoop(this._doc, oldStart, oldEnd - oldStart, start, end - start);
                }
                else if (this._cursor.mode == this._bothMode) {
                    const endPoints = this._findEndPoints(bar);
                    this._change = new ChangeLoop(this._doc, oldStart, oldEnd - oldStart, endPoints.start, endPoints.length);
                }
                this._doc.synth.jumpIntoLoop();
                if (this._doc.autoFollow) {
                    new ChangeChannelBar(this._doc, this._doc.channel, Math.floor(this._doc.synth.playhead), true);
                }
                this._doc.setProspectiveChange(this._change);
            }
            else {
                this._updateCursorStatus();
                this._updatePreview();
            }
        }
        _updatePreview() {
            const showHighlight = this._mouseOver && !this._mouseDown;
            this._highlight.style.visibility = showHighlight ? "visible" : "hidden";
            if (showHighlight) {
                const radius = this._editorHeight / 2;
                let highlightStart = (this._doc.song.loopStart) * this._barWidth;
                let highlightStop = (this._doc.song.loopStart + this._doc.song.loopLength) * this._barWidth;
                if (this._cursor.mode == this._startMode) {
                    highlightStop = (this._doc.song.loopStart) * this._barWidth + radius * 2;
                }
                else if (this._cursor.mode == this._endMode) {
                    highlightStart = (this._doc.song.loopStart + this._doc.song.loopLength) * this._barWidth - radius * 2;
                }
                else {
                    const endPoints = this._findEndPoints(this._cursor.startBar);
                    highlightStart = (endPoints.start) * this._barWidth;
                    highlightStop = (endPoints.start + endPoints.length) * this._barWidth;
                }
                this._highlight.setAttribute("d", `M ${highlightStart + radius} ${4} ` +
                    `L ${highlightStop - radius} ${4} ` +
                    `A ${radius - 4} ${radius - 4} ${0} ${0} ${1} ${highlightStop - radius} ${this._editorHeight - 4} ` +
                    `L ${highlightStart + radius} ${this._editorHeight - 4} ` +
                    `A ${radius - 4} ${radius - 4} ${0} ${0} ${1} ${highlightStart + radius} ${4} ` +
                    `z`);
            }
        }
        _render() {
            this._barWidth = this._doc.getBarWidth();
            const radius = this._editorHeight / 2;
            const loopStart = (this._doc.song.loopStart) * this._barWidth;
            const loopStop = (this._doc.song.loopStart + this._doc.song.loopLength) * this._barWidth;
            if (this._renderedBarCount != this._doc.song.barCount || this._renderedBarWidth != this._barWidth) {
                this._renderedBarCount = this._doc.song.barCount;
                this._renderedBarWidth = this._barWidth;
                const editorWidth = this._barWidth * this._doc.song.barCount;
                this.container.style.width = editorWidth + "px";
                this._svg.setAttribute("width", editorWidth + "");
            }
            if (this._renderedLoopStart != loopStart || this._renderedLoopStop != loopStop) {
                this._renderedLoopStart = loopStart;
                this._renderedLoopStop = loopStop;
                this._loop.setAttribute("d", `M ${loopStart + radius} ${2} ` +
                    `L ${loopStop - radius} ${2} ` +
                    `A ${radius - 2} ${radius - 2} ${0} ${0} ${1} ${loopStop - radius} ${this._editorHeight - 2} ` +
                    `L ${loopStart + radius} ${this._editorHeight - 2} ` +
                    `A ${radius - 2} ${radius - 2} ${0} ${0} ${1} ${loopStart + radius} ${2} ` +
                    `z`);
            }
            this._updatePreview();
        }
    }

    const { button: button$8, div: div$8, span: span$2, h2: h2$8, input: input$6, br: br$2, select: select$2, option: option$2 } = HTML;
    class MoveNotesSidewaysPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._beatsStepper = input$6({ style: "width: 3em; margin-left: 1em;", type: "number", step: "0.01", value: "0" });
            this._conversionStrategySelect = select$2({ style: "width: 100%;" }, option$2({ value: "overflow" }, "Overflow notes across bars."), option$2({ value: "wrapAround" }, "Wrap notes around within bars."));
            this._cancelButton = button$8({ class: "cancelButton" });
            this._okayButton = button$8({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$8({ class: "prompt noSelection", style: "width: 250px;" }, h2$8("Move Notes Sideways"), div$8({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$8({ style: "text-align: right;" }, "Beats to move:", br$2(), span$2({ style: `font-size: smaller; color: ${ColorConfig.secondaryText};` }, "(Negative is left, positive is right)")), this._beatsStepper), div$8({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$8({ class: "selectContainer", style: "width: 100%;" }, this._conversionStrategySelect)), div$8({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._beatsStepper.removeEventListener("blur", MoveNotesSidewaysPrompt._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("moveNotesSidewaysStrategy", this._conversionStrategySelect.value);
                this._doc.prompt = null;
                this._doc.record(new ChangeMoveNotesSideways(this._doc, +this._beatsStepper.value, this._conversionStrategySelect.value), true);
            };
            this._beatsStepper.min = (-this._doc.song.beatsPerBar) + "";
            this._beatsStepper.max = this._doc.song.beatsPerBar + "";
            const lastStrategy = window.localStorage.getItem("moveNotesSidewaysStrategy");
            if (lastStrategy != null) {
                this._conversionStrategySelect.value = lastStrategy;
            }
            this._beatsStepper.select();
            setTimeout(() => this._beatsStepper.focus(), 100);
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._beatsStepper.addEventListener("blur", MoveNotesSidewaysPrompt._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        static _validateNumber(event) {
            const input = event.target;
            let value = +input.value;
            value = Math.round(value * Config.partsPerBeat) / Config.partsPerBeat;
            value = Math.round(value * 100) / 100;
            input.value = Math.max(+input.min, Math.min(+input.max, value)) + "";
        }
    }

    class MuteEditor {
        constructor(_doc, _editor) {
            this._doc = _doc;
            this._editor = _editor;
            this._cornerFiller = HTML.div({ style: `background: ${ColorConfig.editorBackground}; position: sticky; bottom: 0; left: 0; width: 32px; height: 30px;` });
            this._buttons = [];
            this._channelCounts = [];
            this._channelNameDisplay = HTML.div({ style: `background-color: ${ColorConfig.uiWidgetFocus}; white-space:nowrap; display: none; transform:translate(20px); width: auto; pointer-events: none; position: absolute; border-radius: 0.2em; z-index: 2;`, "color": ColorConfig.primaryText }, "");
            this._channelNameInput = new InputBox(HTML.input({ style: `color: ${ColorConfig.primaryText}; background-color: ${ColorConfig.uiWidgetFocus}; margin-top: -2px; display: none; width: 6em; position: absolute; border-radius: 0.2em; z-index: 2;`, "color": ColorConfig.primaryText }, ""), this._doc, (oldValue, newValue) => new ChangeChannelName(this._doc, oldValue, newValue));
            this._channelDropDown = HTML.select({ style: "width: 0px; left: 19px; height: 19px; position:absolute; opacity:0" }, HTML.option({ value: "rename" }, "Rename..."), HTML.option({ value: "chnUp" }, "Move Channel Up"), HTML.option({ value: "chnDown" }, "Move Channel Down"), HTML.option({ value: "chnMute" }, "Mute Channel"), HTML.option({ value: "chnSolo" }, "Solo Channel"), HTML.option({ value: "chnInsert" }, "Insert Channel Below"), HTML.option({ value: "chnDelete" }, "Delete This Channel"));
            this.container = HTML.div({ class: "muteEditor", style: "position: sticky; padding-top: " + Config.barEditorHeight + "px;" }, this._channelNameDisplay, this._channelNameInput.input, this._channelDropDown);
            this._editorHeight = 128;
            this._renderedChannelCount = 0;
            this._renderedPitchChannels = 0;
            this._renderedNoiseChannels = 0;
            this._renderedModChannels = 0;
            this._renderedChannelHeight = -1;
            this._channelDropDownChannel = 0;
            this._channelDropDownOpen = false;
            this._channelDropDownLastState = false;
            this._channelNameInputWhenInput = () => {
                let newValue = this._channelNameInput.input.value;
                if (newValue.length > 15) {
                    this._channelNameInput.input.value = newValue.substring(0, 15);
                }
            };
            this._channelNameInputClicked = (event) => {
                event.stopPropagation();
            };
            this._channelNameInputHide = () => {
                this._channelNameInput.input.style.setProperty("display", "none");
                this._channelNameDisplay.style.setProperty("display", "none");
            };
            this._channelDropDownClick = (event) => {
                this._channelDropDownOpen = !this._channelDropDownLastState;
                this._channelDropDownGetOpenedPosition(event);
            };
            this._channelDropDownBlur = () => {
                this._channelDropDownOpen = false;
                this._channelNameDisplay.style.setProperty("display", "none");
            };
            this._channelDropDownGetOpenedPosition = (event) => {
                this._channelDropDownLastState = this._channelDropDownOpen;
                this._channelDropDownChannel = Math.floor(Math.min(this._renderedChannelCount, Math.max(0, parseInt(this._channelDropDown.style.getPropertyValue("top")) / this._renderedChannelHeight)));
                this._doc.muteEditorChannel = this._channelDropDownChannel;
                this._channelNameDisplay.style.setProperty("display", "");
                if ((this._channelDropDownChannel < this._doc.song.pitchChannelCount && this._doc.song.pitchChannelCount == Config.pitchChannelCountMax)
                    || (this._channelDropDownChannel >= this._doc.song.pitchChannelCount && this._channelDropDownChannel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount && this._doc.song.noiseChannelCount == Config.noiseChannelCountMax)
                    || (this._channelDropDownChannel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount && this._doc.song.modChannelCount == Config.modChannelCountMax)) {
                    this._channelDropDown.options[5].disabled = true;
                }
                else {
                    this._channelDropDown.options[5].disabled = false;
                }
                if (this._channelDropDownChannel == 0 || this._channelDropDownChannel == this._doc.song.pitchChannelCount || this._channelDropDownChannel == this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                    this._channelDropDown.options[1].disabled = true;
                }
                else {
                    this._channelDropDown.options[1].disabled = false;
                }
                if (this._channelDropDownChannel == this._doc.song.pitchChannelCount - 1 || this._channelDropDownChannel == this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount - 1 || this._channelDropDownChannel == this._doc.song.getChannelCount() - 1) {
                    this._channelDropDown.options[2].disabled = true;
                }
                else {
                    this._channelDropDown.options[2].disabled = false;
                }
                if (this._doc.song.pitchChannelCount == 1 && this._channelDropDownChannel == 0) {
                    this._channelDropDown.options[6].disabled = true;
                }
                else {
                    this._channelDropDown.options[6].disabled = false;
                }
            };
            this._channelDropDownHandler = (event) => {
                this._channelNameDisplay.style.setProperty("display", "none");
                this._channelDropDown.style.setProperty("display", "none");
                this._channelDropDownOpen = false;
                event.stopPropagation();
                switch (this._channelDropDown.value) {
                    case "rename":
                        this._channelNameInput.input.style.setProperty("display", "");
                        this._channelNameInput.input.style.setProperty("transform", this._channelNameDisplay.style.getPropertyValue("transform"));
                        if (this._channelNameDisplay.textContent != null) {
                            this._channelNameInput.input.value = this._channelNameDisplay.textContent;
                        }
                        else {
                            this._channelNameInput.input.value = "";
                        }
                        this._channelNameInput.input.select();
                        break;
                    case "chnUp":
                        this._doc.record(new ChangeChannelOrder(this._doc, this._channelDropDownChannel, this._channelDropDownChannel, -1));
                        break;
                    case "chnDown":
                        this._doc.record(new ChangeChannelOrder(this._doc, this._channelDropDownChannel, this._channelDropDownChannel, 1));
                        break;
                    case "chnMute":
                        this._doc.song.channels[this._channelDropDownChannel].muted = !this._doc.song.channels[this._channelDropDownChannel].muted;
                        this.render();
                        break;
                    case "chnSolo": {
                        let shouldSolo = false;
                        for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                            if (this._doc.song.channels[channel].muted == (channel == this._channelDropDownChannel)) {
                                shouldSolo = true;
                                channel = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount;
                            }
                        }
                        if (shouldSolo) {
                            for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                                this._doc.song.channels[channel].muted = (channel != this._channelDropDownChannel);
                            }
                        }
                        else {
                            for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                                this._doc.song.channels[channel].muted = false;
                            }
                        }
                        this.render();
                        break;
                    }
                    case "chnInsert": {
                        this._doc.channel = this._channelDropDownChannel;
                        this._doc.selection.resetBoxSelection();
                        this._doc.selection.insertChannel();
                        break;
                    }
                    case "chnDelete": {
                        this._doc.record(new ChangeRemoveChannel(this._doc, this._channelDropDownChannel, this._channelDropDownChannel));
                        break;
                    }
                }
                if (this._channelDropDown.value != "rename")
                    this._editor.refocusStage();
                this._channelDropDown.selectedIndex = -1;
            };
            this._onClick = (event) => {
                const index = this._buttons.indexOf(event.target);
                if (index == -1)
                    return;
                let xPos = event.clientX - this._buttons[0].getBoundingClientRect().left;
                if (xPos < 21.0) {
                    this._doc.song.channels[index].muted = !this._doc.song.channels[index].muted;
                }
                this._doc.notifier.changed();
            };
            this._onMouseMove = (event) => {
                const index = this._buttons.indexOf(event.target);
                if (index == -1) {
                    if (!this._channelDropDownOpen && event.target != this._channelNameDisplay && event.target != this._channelDropDown) {
                        this._channelNameDisplay.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("width", "0px");
                    }
                    return;
                }
                let xPos = event.clientX - this._buttons[0].getBoundingClientRect().left;
                if (xPos >= 21.0) {
                    if (!this._channelDropDownOpen) {
                        this._channelDropDown.style.setProperty("display", "");
                        var height = this._doc.getChannelHeight();
                        this._channelNameDisplay.style.setProperty("transform", "translate(20px, " + (height / 4 + height * index) + "px)");
                        if (this._doc.song.channels[index].name != "") {
                            this._channelNameDisplay.textContent = this._doc.song.channels[index].name;
                            this._channelNameDisplay.style.setProperty("display", "");
                        }
                        else {
                            if (index < this._doc.song.pitchChannelCount) {
                                this._channelNameDisplay.textContent = "Pitch " + (index + 1);
                            }
                            else if (index < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                                this._channelNameDisplay.textContent = "Noise " + (index - this._doc.song.pitchChannelCount + 1);
                            }
                            else {
                                this._channelNameDisplay.textContent = "Mod " + (index - this._doc.song.pitchChannelCount - this._doc.song.noiseChannelCount + 1);
                            }
                            this._channelNameDisplay.style.setProperty("display", "none");
                        }
                        this._channelDropDown.style.top = (Config.barEditorHeight + 2 + index * this._renderedChannelHeight) + "px";
                        this._channelDropDown.style.setProperty("width", "15px");
                    }
                }
                else {
                    if (!this._channelDropDownOpen) {
                        this._channelNameDisplay.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("width", "0px");
                    }
                }
            };
            this._onMouseLeave = (event) => {
                if (!this._channelDropDownOpen) {
                    this._channelNameDisplay.style.setProperty("display", "none");
                    this._channelDropDown.style.setProperty("width", "0px");
                }
            };
            this.container.addEventListener("click", this._onClick);
            this.container.addEventListener("mousemove", this._onMouseMove);
            this.container.addEventListener("mouseleave", this._onMouseLeave);
            this._channelDropDown.selectedIndex = -1;
            this._channelDropDown.addEventListener("change", this._channelDropDownHandler);
            this._channelDropDown.addEventListener("mousedown", this._channelDropDownGetOpenedPosition);
            this._channelDropDown.addEventListener("blur", this._channelDropDownBlur);
            this._channelDropDown.addEventListener("click", this._channelDropDownClick);
            this._channelNameInput.input.addEventListener("change", this._channelNameInputHide);
            this._channelNameInput.input.addEventListener("blur", this._channelNameInputHide);
            this._channelNameInput.input.addEventListener("mousedown", this._channelNameInputClicked);
            this._channelNameInput.input.addEventListener("input", this._channelNameInputWhenInput);
        }
        onKeyUp(event) {
            switch (event.keyCode) {
                case 27:
                    this._channelDropDownOpen = false;
                    this._channelNameDisplay.style.setProperty("display", "none");
                    break;
                case 13:
                    this._channelDropDownOpen = false;
                    this._channelNameDisplay.style.setProperty("display", "none");
                    break;
            }
        }
        render() {
            if (!this._doc.enableChannelMuting)
                return;
            const channelHeight = this._doc.getChannelHeight();
            if (this._renderedChannelCount != this._doc.song.getChannelCount()) {
                for (let y = this._renderedChannelCount; y < this._doc.song.getChannelCount(); y++) {
                    const channelCountText = HTML.div({ class: "noSelection muteButtonText", style: "display: table-cell; vertical-align: middle; text-align: center; -webkit-user-select: none; -webkit-touch-callout: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none; width: 12px; height: 20px; transform: translate(0px, 1px);" });
                    const muteButton = HTML.div({ class: "mute-button", title: "Mute (M), Mute All (⇧M), Solo (S), Exclude (⇧S)", style: `display: block; pointer-events: none; width: 16px; height: 20px; transform: translate(2px, 1px);` });
                    const muteContainer = HTML.div({ style: "align-items: center; height: 20px; margin: 0px; display: table; flex-direction: row; justify-content: space-between;" }, [
                        muteButton,
                        channelCountText,
                    ]);
                    this.container.appendChild(muteContainer);
                    this._buttons[y] = muteContainer;
                    this._channelCounts[y] = channelCountText;
                }
                for (let y = this._doc.song.getChannelCount(); y < this._renderedChannelCount; y++) {
                    this.container.removeChild(this._buttons[y]);
                }
                this._buttons.length = this._doc.song.getChannelCount();
                this.container.appendChild(this._cornerFiller);
            }
            for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                if (this._doc.song.channels[y].muted) {
                    this._buttons[y].children[0].classList.add("muted");
                    if (y < this._doc.song.pitchChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgPitchDim;
                    else if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgNoiseDim;
                    else
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgModDim;
                }
                else {
                    this._buttons[y].children[0].classList.remove("muted");
                    if (y < this._doc.song.pitchChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgPitch;
                    else if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgNoise;
                    else
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgMod;
                }
            }
            if (this._renderedChannelHeight != channelHeight || this._renderedChannelCount != this._doc.song.getChannelCount()) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    this._buttons[y].style.marginTop = ((channelHeight - 20) / 2) + "px";
                    this._buttons[y].style.marginBottom = ((channelHeight - 20) / 2) + "px";
                }
            }
            if (this._renderedModChannels != this._doc.song.modChannelCount || this._renderedChannelCount != this._doc.song.getChannelCount()) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        this._buttons[y].children[0].classList.remove("modMute");
                    }
                    else {
                        this._buttons[y].children[0].classList.add("modMute");
                    }
                }
            }
            if (this._renderedModChannels != this._doc.song.modChannelCount || this._renderedPitchChannels != this._doc.song.pitchChannelCount || this._renderedNoiseChannels != this._doc.song.noiseChannelCount) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    if (y < this._doc.song.pitchChannelCount) {
                        let val = (y + 1);
                        this._channelCounts[y].textContent = val + "";
                        this._channelCounts[y].style.fontSize = (val >= 10) ? "xx-small" : "inherit";
                    }
                    else if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        let val = (y - this._doc.song.pitchChannelCount + 1);
                        this._channelCounts[y].textContent = val + "";
                        this._channelCounts[y].style.fontSize = (val >= 10) ? "xx-small" : "inherit";
                    }
                    else {
                        let val = (y - this._doc.song.pitchChannelCount - this._doc.song.noiseChannelCount + 1);
                        this._channelCounts[y].textContent = val + "";
                        this._channelCounts[y].style.fontSize = (val >= 10) ? "xx-small" : "inherit";
                    }
                }
                this._renderedPitchChannels = this._doc.song.pitchChannelCount;
                this._renderedNoiseChannels = this._doc.song.noiseChannelCount;
                this._renderedModChannels = this._doc.song.modChannelCount;
            }
            if (this._renderedChannelHeight != channelHeight || this._renderedChannelCount != this._doc.song.getChannelCount()) {
                this._renderedChannelHeight = channelHeight;
                this._renderedChannelCount = this._doc.song.getChannelCount();
                this._editorHeight = Config.barEditorHeight + this._doc.song.getChannelCount() * channelHeight;
                this._channelNameDisplay.style.setProperty("display", "none");
                this.container.style.height = (this._editorHeight + 16) + "px";
                if (this._renderedChannelHeight < 27) {
                    this._channelNameDisplay.style.setProperty("margin-top", "-2px");
                    this._channelDropDown.style.setProperty("margin-top", "-4px");
                    this._channelNameInput.input.style.setProperty("margin-top", "-4px");
                }
                else if (this._renderedChannelHeight < 30) {
                    this._channelNameDisplay.style.setProperty("margin-top", "-1px");
                    this._channelDropDown.style.setProperty("margin-top", "-3px");
                    this._channelNameInput.input.style.setProperty("margin-top", "-3px");
                }
                else {
                    this._channelNameDisplay.style.setProperty("margin-top", "0px");
                    this._channelDropDown.style.setProperty("margin-top", "0px");
                    this._channelNameInput.input.style.setProperty("margin-top", "-2px");
                }
            }
        }
    }

    class OctaveScrollBar {
        constructor(_doc, _piano) {
            this._doc = _doc;
            this._piano = _piano;
            this._editorWidth = 20;
            this._editorHeight = 481;
            this._notchHeight = 4.0;
            this._octaveCount = Config.pitchOctaves;
            this._octaveHeight = (this._editorHeight - this._notchHeight) / this._octaveCount;
            this._handle = SVG.rect({ fill: ColorConfig.uiWidgetBackground, x: 2, y: 0, width: this._editorWidth - 4 });
            this._handleHighlight = SVG.rect({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": 2, "pointer-events": "none", x: 1, y: 0, width: this._editorWidth - 2 });
            this._upHighlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._downHighlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._svg = SVG.svg({ style: "background-color: ${ColorConfig.editorBackground}; touch-action: pan-x; position: absolute;", width: this._editorWidth, height: "100%", viewBox: "0 0 20 " + this._editorHeight, preserveAspectRatio: "none" });
            this.container = HTML.div({ id: "octaveScrollBarContainer", style: "width: 20px; height: 100%; overflow: hidden; position: relative; flex-shrink: 0;" }, this._svg);
            this._mouseY = 0;
            this._mouseDown = false;
            this._mouseOver = false;
            this._dragging = false;
            this._renderedBarBottom = -1;
            this._renderedVisibleOctaveCount = -1;
            this._change = null;
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._updatePreview();
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
                this._updatePreview();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel))
                    return;
                this._updatePreview();
                if (this._mouseY >= this._barBottom - this._barHeight && this._mouseY <= this._barBottom) {
                    this._dragging = true;
                    this._change = null;
                    this._dragStart = this._mouseY;
                }
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel))
                    return;
                this._updatePreview();
                if (this._mouseY >= this._barBottom - this._barHeight && this._mouseY <= this._barBottom) {
                    this._dragging = true;
                    this._change = null;
                    this._dragStart = this._mouseY;
                }
            };
            this._whenMouseMoved = (event) => {
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (!this._doc.song.getChannelIsNoise(this._doc.channel) && !this._doc.song.getChannelIsMod(this._doc.channel) && this._mouseDown) {
                    if (this._dragging) {
                        if (this._change != null)
                            this._doc.record(this._change);
                    }
                    else {
                        const visibleOctaveCount = this._doc.getVisibleOctaveCount();
                        const scrollableOctaves = Config.pitchOctaves - visibleOctaveCount;
                        const canReplaceLastChange = this._doc.lastChangeWas(this._change);
                        const oldValue = canReplaceLastChange ? this._change.oldValue : this._doc.song.channels[this._doc.channel].octave;
                        const currentOctave = this._doc.getBaseVisibleOctave(this._doc.channel);
                        if (this._mouseY < this._barBottom - this._barHeight * 0.5) {
                            if (currentOctave < scrollableOctaves) {
                                this._change = new ChangeOctave(this._doc, oldValue, Math.floor(currentOctave + 1 + visibleOctaveCount * 0.5));
                                this._doc.record(this._change, canReplaceLastChange);
                            }
                        }
                        else {
                            if (currentOctave > 0) {
                                this._change = new ChangeOctave(this._doc, oldValue, Math.floor(currentOctave - 1 + visibleOctaveCount * 0.5));
                                this._doc.record(this._change, canReplaceLastChange);
                            }
                        }
                    }
                }
                this._mouseDown = false;
                this._dragging = false;
                this._updatePreview();
            };
            this._documentChanged = () => {
                this._barBottom = this._editorHeight - (this._octaveHeight * this._doc.getBaseVisibleOctave(this._doc.channel));
                this._svg.style.visibility = (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel)) ? "hidden" : "visible";
                const visibleOctaveCount = this._doc.getVisibleOctaveCount();
                if (this._renderedBarBottom != this._barBottom || this._renderedVisibleOctaveCount != visibleOctaveCount) {
                    this._renderedBarBottom = this._barBottom;
                    this._renderedVisibleOctaveCount = visibleOctaveCount;
                    this._barHeight = (this._octaveHeight * visibleOctaveCount + this._notchHeight);
                    this._handle.setAttribute("height", String(this._barHeight));
                    this._handleHighlight.setAttribute("height", String(this._barHeight));
                    this._handle.setAttribute("y", String(this._barBottom - this._barHeight));
                    this._handleHighlight.setAttribute("y", String(this._barBottom - this._barHeight));
                    this._piano.forceRender();
                }
                this._updatePreview();
            };
            this._doc.notifier.watch(this._documentChanged);
            this._documentChanged();
            this._svg.appendChild(this._handle);
            for (let i = 0; i <= this._octaveCount; i++) {
                this._svg.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: 0, y: i * this._octaveHeight, width: this._editorWidth, height: this._notchHeight }));
            }
            this._svg.appendChild(this._handleHighlight);
            this._svg.appendChild(this._upHighlight);
            this._svg.appendChild(this._downHighlight);
            const center = this._editorWidth * 0.5;
            const base = 20;
            const tip = 9;
            const arrowWidth = 6;
            this._upHighlight.setAttribute("d", `M ${center} ${tip} L ${center + arrowWidth} ${base} L ${center - arrowWidth} ${base} z`);
            this._downHighlight.setAttribute("d", `M ${center} ${this._editorHeight - tip} L ${center + arrowWidth} ${this._editorHeight - base} L ${center - arrowWidth} ${this._editorHeight - base} z`);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _whenCursorMoved() {
            if (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel))
                return;
            if (this._dragging) {
                const visibleOctaveCount = this._doc.getVisibleOctaveCount();
                const scrollableOctaves = Config.pitchOctaves - visibleOctaveCount;
                const continuingProspectiveChange = this._doc.lastChangeWas(this._change);
                const oldValue = continuingProspectiveChange ? this._change.oldValue : this._doc.song.channels[this._doc.channel].octave;
                const currentOctave = this._doc.getBaseVisibleOctave(this._doc.channel);
                let octave = currentOctave;
                while (this._mouseY - this._dragStart < -this._octaveHeight * 0.5) {
                    if (octave < scrollableOctaves) {
                        octave++;
                        this._dragStart -= this._octaveHeight;
                    }
                    else {
                        break;
                    }
                }
                while (this._mouseY - this._dragStart > this._octaveHeight * 0.5) {
                    if (octave > 0) {
                        octave--;
                        this._dragStart += this._octaveHeight;
                    }
                    else {
                        break;
                    }
                }
                this._change = new ChangeOctave(this._doc, oldValue, Math.floor(octave + visibleOctaveCount * 0.5));
                this._doc.setProspectiveChange(this._change);
            }
            if (this._mouseOver)
                this._updatePreview();
        }
        _updatePreview() {
            const showHighlight = this._mouseOver && !this._mouseDown;
            let showUpHighlight = false;
            let showDownHighlight = false;
            let showHandleHighlight = false;
            if (showHighlight) {
                if (this._mouseY < this._barBottom - this._barHeight) {
                    showUpHighlight = true;
                }
                else if (this._mouseY > this._barBottom) {
                    showDownHighlight = true;
                }
                else {
                    showHandleHighlight = true;
                }
            }
            this._upHighlight.style.visibility = showUpHighlight ? "inherit" : "hidden";
            this._downHighlight.style.visibility = showDownHighlight ? "inherit" : "hidden";
            this._handleHighlight.style.visibility = showHandleHighlight ? "inherit" : "hidden";
        }
    }

    function makeEmptyReplacementElement(node) {
        const clone = node.cloneNode(false);
        node.parentNode.replaceChild(clone, node);
        return clone;
    }
    class PatternCursor {
        constructor() {
            this.valid = false;
            this.prevNote = null;
            this.curNote = null;
            this.nextNote = null;
            this.pitch = 0;
            this.pitchIndex = -1;
            this.curIndex = 0;
            this.start = 0;
            this.end = 0;
            this.part = 0;
            this.exactPart = 0;
            this.nearPinIndex = 0;
            this.pins = [];
        }
    }
    class PatternEditor {
        constructor(_doc, _interactive, _barOffset) {
            this._doc = _doc;
            this._interactive = _interactive;
            this._barOffset = _barOffset;
            this.controlMode = false;
            this.shiftMode = false;
            this._svgNoteBackground = SVG.pattern({ id: "patternEditorNoteBackground" + this._barOffset, x: "0", y: "0", patternUnits: "userSpaceOnUse" });
            this._svgDrumBackground = SVG.pattern({ id: "patternEditorDrumBackground" + this._barOffset, x: "0", y: "0", patternUnits: "userSpaceOnUse" });
            this._svgModBackground = SVG.pattern({ id: "patternEditorModBackground" + this._barOffset, x: "0", y: "0", patternUnits: "userSpaceOnUse" });
            this._svgBackground = SVG.rect({ x: "0", y: "0", "pointer-events": "none", fill: "url(#patternEditorNoteBackground" + this._barOffset + ")" });
            this._svgNoteContainer = SVG.svg();
            this._svgPlayhead = SVG.rect({ x: "0", y: "0", width: "4", fill: ColorConfig.playhead, "pointer-events": "none" });
            this._selectionRect = SVG.rect({ class: "dashed-line dash-move", fill: ColorConfig.boxSelectionFill, stroke: ColorConfig.hoverPreview, "stroke-width": 2, "stroke-dasharray": "5, 3", "fill-opacity": "0.4", "pointer-events": "none", visibility: "hidden" });
            this._svgPreview = SVG.path({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": "2", "pointer-events": "none" });
            this.modDragValueLabel = HTML.div({ width: "90", "text-anchor": "start", contenteditable: "true", style: "display: flex, justify-content: center; align-items:center; position:absolute; pointer-events: none;", "dominant-baseline": "central", });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.patternBackground? ColorConfig.patternBackground : ColorConfig.editorBackground}; touch-action: none; position: absolute;`, width: "100%", height: "100%" }, SVG.defs(this._svgNoteBackground, this._svgDrumBackground, this._svgModBackground), this._svgBackground, this._selectionRect, this._svgNoteContainer, this._svgPreview, this._svgPlayhead);
            this.container = HTML.div({ style: "height: 100%; overflow:hidden; position: relative; flex-grow: 1;" }, this._svg, this.modDragValueLabel);
            this._defaultModBorder = 34;
            this._backgroundPitchRows = [];
            this._backgroundDrumRow = SVG.rect();
            this._backgroundModRow = SVG.rect();
            this._modDragValueLabelLeft = 0;
            this._modDragValueLabelTop = 0;
            this._modDragValueLabelWidth = 0;
            this.editingModLabel = false;
            this._modDragStartValue = 0;
            this._modDragLowerBound = 0;
            this._modDragUpperBound = 6;
            this._pitchHeight = -1;
            this._mouseX = 0;
            this._mouseY = 0;
            this._mouseDown = false;
            this._mouseOver = false;
            this._mouseDragging = false;
            this._mouseHorizontal = false;
            this._usingTouch = false;
            this._copiedPinChannels = [];
            this._mouseXStart = 0;
            this._mouseYStart = 0;
            this._touchTime = 0;
            this._shiftHeld = false;
            this._dragConfirmed = false;
            this._draggingStartOfSelection = false;
            this._draggingEndOfSelection = false;
            this._draggingSelectionContents = false;
            this._dragTime = 0;
            this._dragPitch = 0;
            this._dragSize = 0;
            this._dragVisible = false;
            this._dragChange = null;
            this._changePatternSelection = null;
            this._lastChangeWasPatternSelection = false;
            this._cursor = new PatternCursor();
            this._stashCursorPinVols = [];
            this._pattern = null;
            this._playheadX = 0.0;
            this._octaveOffset = 0;
            this._renderedWidth = -1;
            this._renderedHeight = -1;
            this._renderedBeatWidth = -1;
            this._renderedPitchHeight = -1;
            this._renderedFifths = false;
            this._renderedDrums = false;
            this._renderedMod = false;
            this._renderedRhythm = -1;
            this._renderedPitchChannelCount = -1;
            this._renderedNoiseChannelCount = -1;
            this._renderedModChannelCount = -1;
            this._followPlayheadBar = -1;
            this._validateModDragLabelInput = (event) => {
                const label = event.target;
                let converted = Number(label.innerText);
                if (!isNaN(converted) && converted >= 0 && converted < this._modDragLowerBound)
                    return;
                if (label.innerText != "" && label.innerText != "-") {
                    if (isNaN(converted)) {
                        converted = this._modDragLowerBound;
                        label.innerText = "" + this._modDragLowerBound;
                    }
                    let presValue = Math.floor(Math.max(Number(this._modDragLowerBound), Math.min(Number(this._modDragUpperBound), converted)));
                    if (label.innerText != presValue + "")
                        label.innerText = presValue + "";
                    let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                    this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * (this._modDragNote.start + this._modDragPin.time) - 4 - xOffset * 4), 2));
                    this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                    const sequence = new ChangeSequence();
                    this._dragChange = sequence;
                    this._doc.setProspectiveChange(this._dragChange);
                    sequence.append(new ChangeSizeBend(this._doc, this._modDragNote, this._modDragPin.time, presValue - Config.modulators[this._modDragSetting].convertRealFactor, this._modDragPin.interval, this.shiftMode));
                }
            };
            this.resetCopiedPins = () => {
                const maxDivision = this._getMaxDivision();
                let cap = this._doc.song.getVolumeCap(false);
                this._copiedPinChannels.length = this._doc.song.getChannelCount();
                this._stashCursorPinVols.length = this._doc.song.getChannelCount();
                for (let i = 0; i < this._doc.song.pitchChannelCount; i++) {
                    this._copiedPinChannels[i] = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, cap)];
                    this._stashCursorPinVols[i] = [cap, cap];
                }
                for (let i = this._doc.song.pitchChannelCount; i < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; i++) {
                    this._copiedPinChannels[i] = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, 0)];
                    this._stashCursorPinVols[i] = [cap, 0];
                }
                for (let i = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; i < this._doc.song.getChannelCount(); i++) {
                    this._copiedPinChannels[i] = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, 0)];
                    this._stashCursorPinVols[i] = [cap, 0];
                }
            };
            
            this._animatePlayhead = (timestamp) => {
                if (this._usingTouch && !this.shiftMode && !this._mouseDragging && this._mouseDown && performance.now() > this._touchTime + 1000 && this._cursor.valid && this._doc.lastChangeWas(this._dragChange)) {
                    this._dragChange.undo();
                    this._shiftHeld = true;
                    this._dragConfirmed = false;
                    this._whenCursorPressed();
                    this._doc.notifier.notifyWatchers();
                }
                const playheadBar = Math.floor(this._doc.synth.playhead);
                if (this._doc.synth.playing && ((this._pattern != null && this._doc.song.getPattern(this._doc.channel, Math.floor(this._doc.synth.playhead)) == this._pattern) || Math.floor(this._doc.synth.playhead) == this._doc.bar + this._barOffset)) {
                    this._svgPlayhead.setAttribute("visibility", "visible");
                    const modPlayhead = this._doc.synth.playhead - playheadBar;
                    if (Math.abs(modPlayhead - this._playheadX) > 0.1) {
                        this._playheadX = modPlayhead;
                    }
                    else {
                        this._playheadX += (modPlayhead - this._playheadX) * 0.2;
                    }
                    this._svgPlayhead.setAttribute("x", "" + prettyNumber(this._playheadX * this._editorWidth - 2));
                }
                else {
                    this._svgPlayhead.setAttribute("visibility", "hidden");
                }
                if (this._doc.synth.playing && this._doc.autoFollow && this._followPlayheadBar != playheadBar) {
                    new ChangeChannelBar(this._doc, this._doc.channel, playheadBar);
                    this._doc.notifier.notifyWatchers();
                }
this._followPlayheadBar = playheadBar;

                window.requestAnimationFrame(this._animatePlayhead);
            };
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._usingTouch = false;
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._usingTouch = false;
                this._shiftHeld = event.shiftKey;
                this._dragConfirmed = false;
                this._whenCursorPressed();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._usingTouch = true;
                this._shiftHeld = event.shiftKey;
                this._dragConfirmed = false;
                this._touchTime = performance.now();
                this._whenCursorPressed();
            };
            this._whenMouseMoved = (event) => {
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._usingTouch = false;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                    
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (!this._cursor.valid)
                    return;
                const continuousState = this._doc.lastChangeWas(this._dragChange);
                if (this._mouseDown && continuousState && this._dragChange != null) {
                    if (this._draggingSelectionContents) {
                        this._doc.record(this._dragChange);
                        this._dragChange = null;
                        if (this._pattern != null && this._doc.song.getChannelIsMod(this._doc.channel))
                            this._pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                    }
                    else if (this._draggingStartOfSelection || this._draggingEndOfSelection || this._shiftHeld) {
                        this._setPatternSelection(this._dragChange);
                        this._dragChange = null;
                    }
                    else if (this._mouseDragging || this._cursor.curNote == null || !this._dragChange.isNoop() || this._draggingStartOfSelection || this._draggingEndOfSelection || this._draggingSelectionContents || this._shiftHeld) {
                        this._doc.record(this._dragChange);
                        this._dragChange = null;
                        if (this._pattern != null && this._doc.song.getChannelIsMod(this._doc.channel))
                            this._pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                    }
                    else {
                        if (this._pattern == null)
                            throw new Error();
                        const sequence = new ChangeSequence();
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        if (this._cursor.pitchIndex == -1) {
                            if (this._cursor.curNote.pitches.length == Config.maxChordSize) {
                                sequence.append(new ChangePitchAdded(this._doc, this._cursor.curNote, this._cursor.curNote.pitches[0], 0, true));
                            }
                            sequence.append(new ChangePitchAdded(this._doc, this._cursor.curNote, this._cursor.pitch, this._cursor.curNote.pitches.length));
                            this._copyPins(this._cursor.curNote);
                            if (this._doc.enableNotePreview && !this._doc.synth.playing) {
                                const duration = Math.min(Config.partsPerBeat, this._cursor.end - this._cursor.start);
                                this._doc.synth.liveInputDuration = duration;
                                this._doc.synth.liveInputPitches = this._cursor.curNote.pitches.concat();
                                this._doc.synth.liveInputStarted = true;
                            }
                        }
                        else {
                            if (this._cursor.curNote.pitches.length == 1) {
                                sequence.append(new ChangeNoteAdded(this._doc, this._pattern, this._cursor.curNote, this._cursor.curIndex, true));
                            }
                            else {
                                sequence.append(new ChangePitchAdded(this._doc, this._cursor.curNote, this._cursor.pitch, this._cursor.curNote.pitches.indexOf(this._cursor.pitch), true));
                            }
                        }
                        this._doc.record(sequence);
                    }
                }
                this._mouseDown = false;
                this._mouseDragging = false;
                this._draggingStartOfSelection = false;
                this._draggingEndOfSelection = false;
                this._draggingSelectionContents = false;
                this._lastChangeWasPatternSelection = false;
                this.modDragValueLabel.setAttribute("fill", ColorConfig.secondaryText);
                this._updateCursorStatus();
                this._updatePreview();
            };
            for (let i = 0; i < Config.pitchesPerOctave; i++) {
                const rectangle = SVG.rect();
                rectangle.setAttribute("x", "1");
                rectangle.setAttribute("fill", (i == 0) ? ColorConfig.tonic : ColorConfig.pitchBackground);
                this._svgNoteBackground.appendChild(rectangle);
                this._backgroundPitchRows[i] = rectangle;
            }
            this._backgroundDrumRow.setAttribute("x", "1");
            this._backgroundDrumRow.setAttribute("y", "1");
            this._backgroundDrumRow.setAttribute("fill", ColorConfig.pitchBackground);
            this._svgDrumBackground.appendChild(this._backgroundDrumRow);
            this._backgroundModRow.setAttribute("fill", ColorConfig.pitchBackground);
            this._svgModBackground.appendChild(this._backgroundModRow);
            if (this._interactive) {
                this._updateCursorStatus();
                this._updatePreview();
                window.requestAnimationFrame(this._animatePlayhead);
                this._svg.addEventListener("mousedown", this._whenMousePressed);
                document.addEventListener("mousemove", this._whenMouseMoved);
                document.addEventListener("mouseup", this._whenCursorReleased);
                this._svg.addEventListener("mouseover", this._whenMouseOver);
                this._svg.addEventListener("mouseout", this._whenMouseOut);
                this._svg.addEventListener("touchstart", this._whenTouchPressed);
                this._svg.addEventListener("touchmove", this._whenTouchMoved);
                this._svg.addEventListener("touchend", this._whenCursorReleased);
                this._svg.addEventListener("touchcancel", this._whenCursorReleased);
                this.modDragValueLabel.addEventListener("input", this._validateModDragLabelInput);
            }
            else {
                this._svgPlayhead.style.display = "none";
                this._svg.appendChild(SVG.rect({ x: 0, y: 0, width: 10000, height: 10000, fill: ColorConfig.editorBackground, style: "opacity: 0.5;" }));
            }
            this.resetCopiedPins();
        }
_redrawNotePatterns() {
	this._svgNoteContainer = makeEmptyReplacementElement(this._svgNoteContainer);
	if (this._doc.showChannel) {
		if (!this._doc.song.getChannelIsMod(this._doc.channel)) {
			let noteFlashColor = "#ffffff77";
			if (this._doc.notesFlashWhenPlayed)
				noteFlashColor = ColorConfig.getComputed("--note-flash-secondary");
			for (let channel = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount - 1; channel >= 0; channel--) {
				if (channel == this._doc.channel)
					continue;
				if (this._doc.song.getChannelIsNoise(channel) != this._doc.song.getChannelIsNoise(this._doc.channel))
					continue;
				const pattern2 = this._doc.song.getPattern(channel, this._doc.bar + this._barOffset);
				if (pattern2 == null)
					continue;
				const octaveOffset = this._doc.getBaseVisibleOctave(channel) * Config.pitchesPerOctave;
				for (const note of pattern2.notes) {
					for (const pitch of note.pitches) {
						let notePath = SVG.path();
						notePath.setAttribute("fill", ColorConfig.getChannelColor(this._doc.song, channel).secondaryNote);
						notePath.setAttribute("pointer-events", "none");
						this._drawNote(notePath, pitch, note.start, note.pins, this._pitchHeight * 0.19, false, octaveOffset);
						this._svgNoteContainer.appendChild(notePath);
						if (this._doc.notesFlashWhenPlayed) {
							notePath = SVG.path();
							notePath.setAttribute("fill", noteFlashColor);
							notePath.setAttribute("pointer-events", "none");
							this._drawNote(notePath, pitch, note.start, note.pins, this._pitchHeight * 0.19, false, octaveOffset);
							this._svgNoteContainer.appendChild(notePath);
							notePath.classList.add('note-flash');
							notePath.style.opacity = "0";
							notePath.setAttribute('note-start', String(note.start));
							notePath.setAttribute('note-end', String(note.end));
						}
					}
				}
			}
		}
	}
	if (this._pattern != null) {
		const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)];
		const chord = instrument.getChord();
		const transition = instrument.getTransition();
		const displayNumberedChords = chord.customInterval || chord.arpeggiates || chord.strumParts > 0 || transition.slides;
		let noteFlashColor = "#ffffff";
		if (this._doc.notesFlashWhenPlayed)
			noteFlashColor = ColorConfig.getComputed("--note-flash");
		for (const note of this._pattern.notes) {
			let disabled = false;
			if (this._doc.song.getChannelIsMod(this._doc.channel)) {
				const modIndex = instrument.modulators[Config.modCount - 1 - note.pitches[0]];
				if ((modIndex == Config.modulators.dictionary["none"].index) ||
					instrument.invalidModulators[Config.modCount - 1 - note.pitches[0]])
					disabled = true;
			}
			for (let i = 0; i < note.pitches.length; i++) {
				const pitch = note.pitches[i];
				let notePath = SVG.path();
				let colorPrimary = (disabled ? ColorConfig.disabledNotePrimary : ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
				let colorSecondary = (disabled ? ColorConfig.disabledNoteSecondary : ColorConfig.getChannelColor(this._doc.song, this._doc.channel).secondaryNote);
				notePath.setAttribute("fill", colorSecondary);
				notePath.setAttribute("pointer-events", "none");
				this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, false, this._octaveOffset);
				this._svgNoteContainer.appendChild(notePath);
				notePath = SVG.path();
				notePath.setAttribute("fill", colorPrimary);
				notePath.setAttribute("pointer-events", "none");
				this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
				this._svgNoteContainer.appendChild(notePath);
				if (this._doc.notesFlashWhenPlayed && !disabled) {
					notePath = SVG.path();
					notePath.setAttribute("fill", noteFlashColor);
					notePath.setAttribute("pointer-events", "none");
					this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
					this._svgNoteContainer.appendChild(notePath);
					notePath.classList.add('note-flash');
					notePath.style.opacity = "0";
					notePath.setAttribute('note-start', String(note.start));
					notePath.setAttribute('note-end', String(note.end));
				}
				let indicatorOffset = 2;
				if (note.continuesLastPattern) {
					const arrowHeight = Math.min(this._pitchHeight, 20);
					let arrowPath;
					arrowPath = "M " + prettyNumber(this._partWidth * note.start + indicatorOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.1 * arrowHeight);
					arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.1 * arrowHeight);
					arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.1 * arrowHeight);
					arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.3 * arrowHeight);
					arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 12) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset));
					arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.3 * arrowHeight);
					arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.1 * arrowHeight);
					const arrow = SVG.path();
					arrow.setAttribute("d", arrowPath);
					arrow.setAttribute("fill", ColorConfig.invertedText);
					this._svgNoteContainer.appendChild(arrow);
					indicatorOffset += 12;
				}
				if (note.pitches.length > 1) {
					if (displayNumberedChords) {
						const oscillatorLabel = SVG.text();
						oscillatorLabel.setAttribute("x", "" + prettyNumber(this._partWidth * note.start + indicatorOffset));
						oscillatorLabel.setAttribute("y", "" + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset)));
						oscillatorLabel.setAttribute("width", "30");
						oscillatorLabel.setAttribute("fill", ColorConfig.invertedText);
						oscillatorLabel.setAttribute("text-anchor", "start");
						oscillatorLabel.setAttribute("dominant-baseline", "central");
						oscillatorLabel.setAttribute("pointer-events", "none");
						oscillatorLabel.textContent = "" + (i + 1);
						this._svgNoteContainer.appendChild(oscillatorLabel);
					}
				}
			}
			if (this._doc.song.getChannelIsMod(this._doc.channel) && this._mouseDragging && !this._mouseHorizontal && note == this._cursor.curNote) {
				this.modDragValueLabel.style.setProperty("display", "");
				this.modDragValueLabel.style.setProperty("pointer-events", "none");
				this.modDragValueLabel.setAttribute("contenteditable", "false");
				this.modDragValueLabel.style.setProperty("color", "#FFFFFF");
				let setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[Config.modCount - 1 - note.pitches[0]];
				let presValue = this._dragSize + Config.modulators[setting].convertRealFactor;
				let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
				this._modDragValueLabelWidth = 8 + xOffset * 8;
				this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * this._dragTime - 4 - xOffset * 4), 2));
				this._modDragValueLabelTop = +prettyNumber(this._pitchToPixelHeight(note.pitches[0] - this._octaveOffset) - 17 - (this._pitchHeight - this._pitchBorder) / 2);
				this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
				this.modDragValueLabel.style.setProperty("top", "" + this._modDragValueLabelTop + "px");
				this.modDragValueLabel.textContent = "" + presValue;
			}
		}
	}
	this._doc.currentPatternIsDirty = false;
}
        _getMaxDivision() {
            const rhythmStepsPerBeat = Config.rhythms[this._doc.song.rhythm].stepsPerBeat;
            if (rhythmStepsPerBeat % 4 == 0) {
                return Config.partsPerBeat / 2;
            }
            else if (rhythmStepsPerBeat % 3 == 0) {
                return Config.partsPerBeat / 3;
            }
            else if (rhythmStepsPerBeat % 2 == 0) {
                return Config.partsPerBeat / 2;
            }
            return Config.partsPerBeat;
        }
        _getMinDivision() {
            return Config.partsPerBeat / Config.rhythms[this._doc.song.rhythm].stepsPerBeat;
        }
        _snapToMinDivision(input) {
            const minDivision = this._getMinDivision();
            return Math.floor(input / minDivision) * minDivision;
        }
        _updateCursorStatus() {
            this._cursor = new PatternCursor();
            if (this._mouseX < 0 || this._mouseX > this._editorWidth || this._mouseY < 0 || this._mouseY > this._editorHeight || this._pitchHeight <= 0)
                return;
            const minDivision = this._getMinDivision();
            this._cursor.exactPart = this._mouseX / this._partWidth;
            this._cursor.part =
                Math.floor(Math.max(0, Math.min(this._doc.song.beatsPerBar * Config.partsPerBeat - minDivision, this._cursor.exactPart))
                    / minDivision) * minDivision;
            let foundNote = false;
            if (this._pattern != null) {
                for (const note of this._pattern.notes) {
                    if (note.end <= this._cursor.exactPart) {
                        if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                            if (note.pitches[0] == Math.floor(this._findMousePitch(this._mouseY))) {
                                this._cursor.prevNote = note;
                            }
                            if (!foundNote)
                                this._cursor.curIndex++;
                        }
                        else {
                            this._cursor.prevNote = note;
                            this._cursor.curIndex++;
                        }
                    }
                    else if (note.start <= this._cursor.exactPart && note.end > this._cursor.exactPart) {
                        if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                            if (note.pitches[0] == Math.floor(this._findMousePitch(this._mouseY))) {
                                this._cursor.curNote = note;
                                foundNote = true;
                            }
                            else if (!foundNote || (this._cursor.curNote != null && note.start < this._cursor.curNote.start))
                                this._cursor.curIndex++;
                        }
                        else {
                            this._cursor.curNote = note;
                        }
                    }
                    else if (note.start > this._cursor.exactPart) {
                        if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                            if (note.pitches[0] == Math.floor(this._findMousePitch(this._mouseY))) {
                                this._cursor.nextNote = note;
                                break;
                            }
                        }
                        else {
                            this._cursor.nextNote = note;
                            break;
                        }
                    }
                }
                if (this._doc.song.getChannelIsMod(this._doc.channel) && !this.editingModLabel) {
                    if (this._pattern.notes[this._cursor.curIndex] != null && this._cursor.curNote != null) {
                        let pinIdx = 0;
                        while (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx].time < this._cursor.exactPart && pinIdx < this._cursor.curNote.pins.length) {
                            pinIdx++;
                        }
                        if (pinIdx > 0) {
                            if (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx].time - this._cursor.exactPart > this._cursor.exactPart - (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx - 1].time)) {
                                pinIdx--;
                            }
                        }
                        this.modDragValueLabel.style.setProperty("color", "#666688");
                        this.modDragValueLabel.style.setProperty("display", "");
                        const mod = Math.max(0, Config.modCount - 1 - this._cursor.curNote.pitches[0]);
                        let setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[mod];
                        let presValue = this._cursor.curNote.pins[pinIdx].size + Config.modulators[setting].convertRealFactor;
                        let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                        this._modDragValueLabelWidth = 8 + xOffset * 8;
                        this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx].time) - 4 - xOffset * 4), 2));
                        this._modDragValueLabelTop = +prettyNumber(this._pitchToPixelHeight(this._cursor.curNote.pitches[0] - this._octaveOffset) - 17 - (this._pitchHeight - this._pitchBorder) / 2);
                        this._modDragStartValue = this._cursor.curNote.pins[pinIdx].size;
                        this._modDragNote = this._cursor.curNote;
                        this._modDragPin = this._cursor.curNote.pins[pinIdx];
                        this._modDragLowerBound = Config.modulators[setting].convertRealFactor;
                        this._modDragUpperBound = Config.modulators[setting].convertRealFactor + Config.modulators[setting].maxRawVol;
                        this._modDragSetting = setting;
                        this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                        this.modDragValueLabel.style.setProperty("top", "" + this._modDragValueLabelTop + "px");
                        this.modDragValueLabel.textContent = "" + presValue;
                    }
                    else {
                        this.modDragValueLabel.style.setProperty("display", "none");
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                    }
                }
                else if (!this.editingModLabel) {
                    this.modDragValueLabel.style.setProperty("display", "none");
                    this.modDragValueLabel.style.setProperty("pointer-events", "none");
                    this.modDragValueLabel.setAttribute("contenteditable", "false");
                }
            }
            else {
                this.modDragValueLabel.style.setProperty("display", "none");
                this.modDragValueLabel.style.setProperty("pointer-events", "none");
                this.modDragValueLabel.setAttribute("contenteditable", "false");
            }
            let mousePitch = this._findMousePitch(this._mouseY);
            if (this._cursor.curNote != null) {
                this._cursor.start = this._cursor.curNote.start;
                this._cursor.end = this._cursor.curNote.end;
                this._cursor.pins = this._cursor.curNote.pins;
                let interval = 0;
                let error = 0;
                let prevPin;
                let nextPin = this._cursor.curNote.pins[0];
                for (let j = 1; j < this._cursor.curNote.pins.length; j++) {
                    prevPin = nextPin;
                    nextPin = this._cursor.curNote.pins[j];
                    const leftSide = this._partWidth * (this._cursor.curNote.start + prevPin.time);
                    const rightSide = this._partWidth * (this._cursor.curNote.start + nextPin.time);
                    if (this._mouseX > rightSide)
                        continue;
                    if (this._mouseX < leftSide)
                        throw new Error();
                    const intervalRatio = (this._mouseX - leftSide) / (rightSide - leftSide);
                    const arc = Math.sqrt(1.0 / Math.sqrt(4.0) - Math.pow(intervalRatio - 0.5, 2.0)) - 0.5;
                    const bendHeight = Math.abs(nextPin.interval - prevPin.interval);
                    interval = prevPin.interval * (1.0 - intervalRatio) + nextPin.interval * intervalRatio;
                    error = arc * bendHeight + 0.95;
                    break;
                }
                let minInterval = Number.MAX_VALUE;
                let maxInterval = -Number.MAX_VALUE;
                let bestDistance = Number.MAX_VALUE;
                for (const pin of this._cursor.curNote.pins) {
                    if (minInterval > pin.interval)
                        minInterval = pin.interval;
                    if (maxInterval < pin.interval)
                        maxInterval = pin.interval;
                    const pinDistance = Math.abs(this._cursor.curNote.start + pin.time - this._mouseX / this._partWidth);
                    if (bestDistance > pinDistance) {
                        bestDistance = pinDistance;
                        this._cursor.nearPinIndex = this._cursor.curNote.pins.indexOf(pin);
                    }
                }
                mousePitch -= interval;
                const maxPitch = this._doc.song.getChannelIsNoise(this._doc.channel) ? Config.drumCount - 1 :
                    this._doc.song.getChannelIsMod(this._doc.channel) ? Config.modCount - 1 : Config.maxPitch;
                this._cursor.pitch = this._snapToPitch(mousePitch, -minInterval, maxPitch - maxInterval);
                if (!this._doc.song.getChannelIsNoise(this._doc.channel) && !this._doc.song.getChannelIsMod(this._doc.channel)) {
                    let nearest = error;
                    for (let i = 0; i < this._cursor.curNote.pitches.length; i++) {
                        const distance = Math.abs(this._cursor.curNote.pitches[i] - mousePitch + 0.5);
                        if (distance > nearest)
                            continue;
                        nearest = distance;
                        this._cursor.pitch = this._cursor.curNote.pitches[i];
                    }
                }
                for (let i = 0; i < this._cursor.curNote.pitches.length; i++) {
                    if (this._cursor.curNote.pitches[i] == this._cursor.pitch) {
                        this._cursor.pitchIndex = i;
                        break;
                    }
                }
            }
            else {
                const maxPitch = this._doc.song.getChannelIsNoise(this._doc.channel) ? Config.drumCount - 1 :
                    this._doc.song.getChannelIsMod(this._doc.channel) ? Config.modCount : Config.maxPitch;
                this._cursor.pitch = this._snapToPitch(mousePitch, 0, maxPitch);
                const defaultLength = this._copiedPins[this._copiedPins.length - 1].time;
                const fullBeats = Math.floor(this._cursor.part / Config.partsPerBeat);
                const maxDivision = this._getMaxDivision();
                const modMouse = this._cursor.part % Config.partsPerBeat;
                if (defaultLength == 1) {
                    this._cursor.start = this._cursor.part;
                }
                else if (defaultLength > Config.partsPerBeat) {
                    this._cursor.start = fullBeats * Config.partsPerBeat;
                }
                else if (defaultLength == Config.partsPerBeat) {
                    this._cursor.start = fullBeats * Config.partsPerBeat;
                    if (maxDivision < Config.partsPerBeat && modMouse > maxDivision) {
                        this._cursor.start += Math.floor(modMouse / maxDivision) * maxDivision;
                    }
                }
                else {
                    this._cursor.start = fullBeats * Config.partsPerBeat;
                    let division = Config.partsPerBeat % defaultLength == 0 ? defaultLength : Math.min(defaultLength, maxDivision);
                    while (division < maxDivision && Config.partsPerBeat % division != 0) {
                        division++;
                    }
                    this._cursor.start += Math.floor(modMouse / division) * division;
                }
                this._cursor.end = this._cursor.start + defaultLength;
                let forceStart = 0;
                let forceEnd = this._doc.song.beatsPerBar * Config.partsPerBeat;
                if (this._cursor.prevNote != null) {
                    forceStart = this._cursor.prevNote.end;
                }
                if (this._cursor.nextNote != null) {
                    forceEnd = this._cursor.nextNote.start;
                }
                if (this._cursor.start < forceStart) {
                    this._cursor.start = forceStart;
                    this._cursor.end = this._cursor.start + defaultLength;
                    if (this._cursor.end > forceEnd) {
                        this._cursor.end = forceEnd;
                    }
                }
                else if (this._cursor.end > forceEnd) {
                    this._cursor.end = forceEnd;
                    this._cursor.start = this._cursor.end - defaultLength;
                    if (this._cursor.start < forceStart) {
                        this._cursor.start = forceStart;
                    }
                }
                if (this._cursor.end - this._cursor.start == defaultLength) {
                    this._copiedPins = this._copiedPinChannels[this._doc.channel];
                    this._cursor.pins = this._copiedPins;
                }
                else {
                    this._cursor.pins = [];
                    for (const oldPin of this._copiedPins) {
                        if (oldPin.time <= this._cursor.end - this._cursor.start) {
                            this._cursor.pins.push(makeNotePin(0, oldPin.time, oldPin.size));
                            if (oldPin.time == this._cursor.end - this._cursor.start)
                                break;
                        }
                        else {
                            this._cursor.pins.push(makeNotePin(0, this._cursor.end - this._cursor.start, oldPin.size));
                            break;
                        }
                    }
                }
                if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                    this._cursor.pitch = Math.max(0, Math.min(Config.modCount - 1, this._cursor.pitch));
                    if (this._stashCursorPinVols != null && this._stashCursorPinVols[this._doc.channel] != null) {
                        for (let pin = 0; pin < this._cursor.pins.length; pin++) {
                            this._cursor.pins[pin].size = this._stashCursorPinVols[this._doc.channel][pin];
                        }
                    }
                    let maxHeight = this._doc.song.getVolumeCap(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), this._cursor.pitch);
                    let maxFoundHeight = 0;
                    for (const pin of this._cursor.pins) {
                        if (pin.size > maxFoundHeight) {
                            maxFoundHeight = pin.size;
                        }
                    }
                    if (maxFoundHeight > maxHeight) {
                        for (const pin of this._cursor.pins) {
                            pin.size = Math.round(pin.size * (maxHeight / maxFoundHeight));
                        }
                    }
                }
            }
            this._cursor.valid = true;
        }
        _cursorIsInSelection() {
            return this._cursor.valid && this._doc.selection.patternSelectionActive && this._doc.selection.patternSelectionStart <= this._cursor.exactPart && this._cursor.exactPart <= this._doc.selection.patternSelectionEnd;
        }
        _cursorAtStartOfSelection() {
            return this._cursor.valid && this._doc.selection.patternSelectionActive && this._cursor.pitchIndex == -1 && this._doc.selection.patternSelectionStart - 3 <= this._cursor.exactPart && this._cursor.exactPart <= this._doc.selection.patternSelectionStart + 1.25;
        }
        _cursorAtEndOfSelection() {
            return this._cursor.valid && this._doc.selection.patternSelectionActive && this._cursor.pitchIndex == -1 && this._doc.selection.patternSelectionEnd - 1.25 <= this._cursor.exactPart && this._cursor.exactPart <= this._doc.selection.patternSelectionEnd + 3;
        }
        _findMousePitch(pixelY) {
            return Math.max(0, Math.min(this._pitchCount - 1, this._pitchCount - (pixelY / this._pitchHeight))) + this._octaveOffset;
        }
        _snapToPitch(guess, min, max) {
            if (guess < min)
                guess = min;
            if (guess > max)
                guess = max;
            const scale = this._doc.notesOutsideScale ? Config.scales.dictionary["Free"].flags : Config.scales[this._doc.song.scale].flags;
            if (scale[Math.floor(guess) % Config.pitchesPerOctave] || this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel)) {
                return Math.floor(guess);
            }
            else {
                let topPitch = Math.floor(guess) + 1;
                let bottomPitch = Math.floor(guess) - 1;
                while (!scale[topPitch % Config.pitchesPerOctave]) {
                    topPitch++;
                }
                while (!scale[(bottomPitch) % Config.pitchesPerOctave]) {
                    bottomPitch--;
                }
                if (topPitch > max) {
                    if (bottomPitch < min) {
                        return min;
                    }
                    else {
                        return bottomPitch;
                    }
                }
                else if (bottomPitch < min) {
                    return topPitch;
                }
                let topRange = topPitch;
                let bottomRange = bottomPitch + 1;
                if (topPitch % Config.pitchesPerOctave == 0 || topPitch % Config.pitchesPerOctave == 7) {
                    topRange -= 0.5;
                }
                if (bottomPitch % Config.pitchesPerOctave == 0 || bottomPitch % Config.pitchesPerOctave == 7) {
                    bottomRange += 0.5;
                }
                return guess - bottomRange > topRange - guess ? topPitch : bottomPitch;
            }
        }
        _copyPins(note) {
            this._copiedPins = [];
            for (const oldPin of note.pins) {
                this._copiedPins.push(makeNotePin(0, oldPin.time, oldPin.size));
            }
            for (let i = 1; i < this._copiedPins.length - 1;) {
                if (this._copiedPins[i - 1].size == this._copiedPins[i].size &&
                    this._copiedPins[i].size == this._copiedPins[i + 1].size) {
                    this._copiedPins.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            this._copiedPinChannels[this._doc.channel] = this._copiedPins;
            this._stashCursorPinVols[this._doc.channel] = [];
            for (let pin = 0; pin < this._copiedPins.length; pin++) {
                this._stashCursorPinVols[this._doc.channel].push(this._copiedPins[pin].size);
            }
        }
        movePlayheadToMouse() {
            if (this._mouseOver) {
                this._doc.synth.playhead = this._doc.bar + this._barOffset + (this._mouseX / this._editorWidth);
                return true;
            }
            return false;
        }
        stopEditingModLabel(discardChanges) {
            if (this.editingModLabel) {
                this.editingModLabel = false;
                this.modDragValueLabel.style.setProperty("pointer-events", "none");
                if (window.getSelection) {
                    let sel = window.getSelection();
                    if (sel != null)
                        sel.removeAllRanges();
                }
                if (discardChanges) {
                    this._modDragPin.size = this._modDragStartValue;
                    let presValue = this._modDragStartValue + Config.modulators[this._modDragSetting].convertRealFactor;
                    let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                    this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * (this._modDragNote.start + this._modDragPin.time) - 4 - xOffset * 4), 2));
                    this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                    const sequence = new ChangeSequence();
                    this._dragChange = sequence;
                    this._doc.setProspectiveChange(this._dragChange);
                    sequence.append(new ChangeSizeBend(this._doc, this._modDragNote, this._modDragPin.time, this._modDragStartValue, this._modDragPin.interval, this.shiftMode));
                    this._dragChange = null;
                }
                const continuousState = this._doc.lastChangeWas(this._dragChange);
                if (continuousState) {
                    if (this._dragChange != null) {
                        this._doc.record(this._dragChange);
                        this._dragChange = null;
                    }
                }
            }
        }
        _whenCursorPressed() {
            if (this._doc.song.getChannelIsMod(this._doc.channel) && this.modDragValueLabel.style.getPropertyValue("display") != "none" &&
                this._mouseX > +this._modDragValueLabelLeft - 6 &&
                this._mouseX < +this._modDragValueLabelLeft + this._modDragValueLabelWidth + 6 &&
                this._mouseY > +this._modDragValueLabelTop - 8 &&
                this._mouseY < +this._modDragValueLabelTop + 11) {
                this.modDragValueLabel.style.setProperty("pointer-events", "fill");
                this.modDragValueLabel.setAttribute("contenteditable", "true");
                if (window.getSelection) {
                    let sel = window.getSelection();
                    if (sel != null)
                        sel.selectAllChildren(this.modDragValueLabel);
                }
                window.setTimeout(() => { this.modDragValueLabel.focus(); });
                this.editingModLabel = true;
            }
            else {
                this.stopEditingModLabel(false);
                if (this._doc.enableNotePreview)
                    this._doc.synth.maintainLiveInput();
                this._mouseDown = true;
                this._mouseXStart = this._mouseX;
                this._mouseYStart = this._mouseY;
                this._updateCursorStatus();
                this._updatePreview();
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._lastChangeWasPatternSelection = this._doc.lastChangeWas(this._changePatternSelection);
                this._doc.setProspectiveChange(this._dragChange);
                if (this._cursorAtStartOfSelection()) {
                    this._draggingStartOfSelection = true;
                }
                else if (this._cursorAtEndOfSelection()) {
                    this._draggingEndOfSelection = true;
                }
                else if (this._shiftHeld) {
                    if ((this._doc.selection.patternSelectionActive && this._cursor.pitchIndex == -1) || this._cursorIsInSelection()) {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                    }
                    else {
                        if (this._cursor.curNote != null) {
                            sequence.append(new ChangePatternSelection(this._doc, this._cursor.curNote.start, this._cursor.curNote.end));
                        }
                        else {
                            const start = Math.max(0, Math.min((this._doc.song.beatsPerBar - 1) * Config.partsPerBeat, Math.floor(this._cursor.exactPart / Config.partsPerBeat) * Config.partsPerBeat));
                            const end = start + Config.partsPerBeat;
                            sequence.append(new ChangePatternSelection(this._doc, start, end));
                        }
                    }
                }
                else if (this._cursorIsInSelection()) {
                    this._draggingSelectionContents = true;
                }
                else if (this._cursor.valid && this._cursor.curNote == null) {
                    sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                    const note = new Note(this._cursor.pitch, this._cursor.start, this._cursor.end, Config.noteSizeMax, this._doc.song.getChannelIsNoise(this._doc.channel));
                    note.pins = [];
                    for (const oldPin of this._cursor.pins) {
                        note.pins.push(makeNotePin(0, oldPin.time, oldPin.size));
                    }
                    sequence.append(new ChangeEnsurePatternExists(this._doc, this._doc.channel, this._doc.bar));
                    const pattern = this._doc.getCurrentPattern(this._barOffset);
                    if (pattern == null)
                        throw new Error();
                    sequence.append(new ChangeNoteAdded(this._doc, pattern, note, this._cursor.curIndex));
                    if (this._doc.enableNotePreview && !this._doc.synth.playing) {
                        const duration = Math.min(Config.partsPerBeat, this._cursor.end - this._cursor.start);
                        this._doc.synth.liveInputDuration = duration;
                        this._doc.synth.liveInputPitches = [this._cursor.pitch];
                        this._doc.synth.liveInputStarted = true;
                    }
                }
                this._updateSelection();
            }
        }
        _whenCursorMoved() {
            if (this._doc.enableNotePreview && this._mouseOver)
                this._doc.synth.maintainLiveInput();
            const continuousState = this._doc.lastChangeWas(this._dragChange);
            if (!this._mouseDragging && this._mouseDown && this._cursor.valid && continuousState) {
                const dx = this._mouseX - this._mouseXStart;
                const dy = this._mouseY - this._mouseYStart;
                if (Math.sqrt(dx * dx + dy * dy) > 5) {
                    this._mouseDragging = true;
                    this._mouseHorizontal = Math.abs(dx) >= Math.abs(dy);
                }
            }
            
            if (this._shiftHeld && this._mouseHorizontal && Math.abs(this._mouseXStart - this._mouseX) > 5) {
                this._dragConfirmed = true;
            }
            if (this._mouseDragging && this._mouseDown && this._cursor.valid && continuousState) {
                this._dragChange.undo();
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._doc.setProspectiveChange(this._dragChange);
                const minDivision = this._getMinDivision();
                const currentPart = this._snapToMinDivision(this._mouseX / this._partWidth);
                if (this._draggingStartOfSelection) {
                	
                    sequence.append(new ChangePatternSelection(this._doc, Math.max(0, Math.min(this._doc.song.beatsPerBar * Config.partsPerBeat, currentPart)), this._doc.selection.patternSelectionEnd));
                    this._updateSelection();
                }
                else if (this._draggingEndOfSelection) {
                    sequence.append(new ChangePatternSelection(this._doc, this._doc.selection.patternSelectionStart, Math.max(0, Math.min(this._doc.song.beatsPerBar * Config.partsPerBeat, currentPart))));
                    this._updateSelection();
                }
                else if (this._draggingSelectionContents) {
                    const pattern = this._doc.getCurrentPattern(this._barOffset);
                    
                    if (this._mouseDragging && pattern != null) {
                        this._dragChange.undo();
                        const sequence = new ChangeSequence();
                        this._dragChange = sequence;
                        this._doc.setProspectiveChange(this._dragChange);
                        const notesInScale = Config.scales[this._doc.song.scale].flags.filter(x => x).length;
                        const pitchRatio = this._doc.song.getChannelIsNoise(this._doc.channel) ? 1 : 12 / notesInScale;
                        const draggedParts = Math.round((this._mouseX - this._mouseXStart) / (this._partWidth * minDivision)) * minDivision;
                        const draggedTranspose = Math.round((this._mouseYStart - this._mouseY) / (this._pitchHeight * pitchRatio));
                        sequence.append(new ChangeDragSelectedNotes(this._doc, this._doc.channel, pattern, draggedParts, draggedTranspose));
                    }
                }
                else if (this._shiftHeld && this._dragConfirmed) {
                    if (this._mouseDragging) {
                        let start = Math.max(0, Math.min((this._doc.song.beatsPerBar - 1) * Config.partsPerBeat, Math.floor(this._cursor.exactPart / Config.partsPerBeat) * Config.partsPerBeat));
                        let end = start + Config.partsPerBeat;
                        if (this._cursor.curNote != null) {
                            start = Math.max(start, this._cursor.curNote.start);
                            end = Math.min(end, this._cursor.curNote.end);
                        }
                         
                        if (currentPart < start) {
                            start = 0;
                            const pattern = this._doc.getCurrentPattern(this._barOffset);
                            if (pattern != null) {
                                for (let i = 0; i < pattern.notes.length; i++) {
                                    if (pattern.notes[i].start <= currentPart) {
                                        start = pattern.notes[i].start;
                                    }
                                    if (pattern.notes[i].end <= currentPart) {
                                        start = pattern.notes[i].end;
                                    }
                                }
                            }
                            for (let beat = 0; beat <= this._doc.song.beatsPerBar; beat++) {
                                const part = beat * Config.partsPerBeat;
                                if (start <= part && part <= currentPart) {
                                    start = part;
                                }
                            }
                        }
                        if (currentPart > end) {
                            end = Config.partsPerBeat * this._doc.song.beatsPerBar;
                            const pattern = this._doc.getCurrentPattern(this._barOffset);
                            if (pattern != null) {
                                for (let i = 0; i < pattern.notes.length; i++) {
                                    if (pattern.notes[i].start >= currentPart) {
                                        end = pattern.notes[i].start;
                                        break;
                                    }
                                    if (pattern.notes[i].end >= currentPart) {
                                        end = pattern.notes[i].end;
                                        break;
                                    }
                                }
                            }
                            for (let beat = 0; beat <= this._doc.song.beatsPerBar; beat++) {
                                const part = beat * Config.partsPerBeat;
                                if (currentPart < part && part < end) {
                                    end = part;
                                }
                            }
                        }
                        sequence.append(new ChangePatternSelection(this._doc, start, end));
                        this._updateSelection();
                    }
                }
                else {
                    if (this._cursor.curNote == null) {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        let backwards;
                        let directLength;
                        if (currentPart < this._cursor.start) {
                            backwards = true;
                            directLength = this._cursor.start - currentPart;
                        }
                        else {
                            backwards = false;
                            directLength = currentPart - this._cursor.start + minDivision;
                        }
                        let defaultLength = minDivision;
                        for (let i = minDivision; i <= this._doc.song.beatsPerBar * Config.partsPerBeat; i += minDivision) {
                            if (minDivision == 1) {
                                if (i < 5) ;
                                else if (i <= Config.partsPerBeat / 2.0) {
                                    if (i % 3 != 0 && i % 4 != 0) {
                                        continue;
                                    }
                                }
                                else if (i <= Config.partsPerBeat * 1.5) {
                                    if (i % 6 != 0 && i % 8 != 0) {
                                        continue;
                                    }
                                }
                                else if (i % Config.partsPerBeat != 0) {
                                    continue;
                                }
                            }
                            else {
                                if (i >= 5 * minDivision &&
                                    i % Config.partsPerBeat != 0 &&
                                    i != Config.partsPerBeat * 3.0 / 4.0 &&
                                    i != Config.partsPerBeat * 3.0 / 2.0 &&
                                    i != Config.partsPerBeat * 4.0 / 3.0) {
                                    continue;
                                }
                            }
                            const blessedLength = i;
                            if (blessedLength == directLength) {
                                defaultLength = blessedLength;
                                break;
                            }
                            if (blessedLength < directLength) {
                                defaultLength = blessedLength;
                            }
                            if (blessedLength > directLength) {
                                if (defaultLength < directLength - minDivision) {
                                    defaultLength = blessedLength;
                                }
                                break;
                            }
                        }
                        let start;
                        let end;
                        if (backwards) {
                            end = this._cursor.start;
                            start = end - defaultLength;
                        }
                        else {
                            start = this._cursor.start;
                            end = start + defaultLength;
                        }
                        const continuesLastPattern = (start < 0 && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount);
                        if (start < 0)
                            start = 0;
                        if (end > this._doc.song.beatsPerBar * Config.partsPerBeat)
                            end = this._doc.song.beatsPerBar * Config.partsPerBeat;
                        if (start < end) {
                            sequence.append(new ChangeEnsurePatternExists(this._doc, this._doc.channel, this._doc.bar));
                            const pattern = this._doc.getCurrentPattern(this._barOffset);
                            if (pattern == null)
                                throw new Error();
                            sequence.append(new ChangeNoteTruncate(this._doc, pattern, start, end, new Note(this._cursor.pitch, 0, 0, 0)));
                            let i;
                            for (i = 0; i < pattern.notes.length; i++) {
                                if (pattern.notes[i].start >= end)
                                    break;
                            }
                            const theNote = new Note(this._cursor.pitch, start, end, this._doc.song.getNewNoteVolume(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), this._cursor.pitch), this._doc.song.getChannelIsNoise(this._doc.channel));
                            theNote.continuesLastPattern = continuesLastPattern;
                            sequence.append(new ChangeNoteAdded(this._doc, pattern, theNote, i));
                            this._copyPins(theNote);
                            this._dragTime = backwards ? start : end;
                            this._dragPitch = this._cursor.pitch;
                            this._dragSize = theNote.pins[backwards ? 0 : 1].size;
                            this._dragVisible = true;
                        }
                        let prevPattern = this._pattern;
                        this._pattern = this._doc.getCurrentPattern(this._barOffset);
                        if (this._pattern != null && this._doc.song.getChannelIsMod(this._doc.channel) && this._interactive && prevPattern != this._pattern) {
                            this._pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                        }
                    }
                    else if (this._mouseHorizontal) {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        const shift = (this._mouseX - this._mouseXStart) / this._partWidth;
                        const shiftedPin = this._cursor.curNote.pins[this._cursor.nearPinIndex];
                        let shiftedTime = Math.round((this._cursor.curNote.start + shiftedPin.time + shift) / minDivision) * minDivision;
                        const continuesLastPattern = (shiftedTime < 0.0 && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount);
                        if (shiftedTime < 0)
                            shiftedTime = 0;
                        if (shiftedTime > this._doc.song.beatsPerBar * Config.partsPerBeat)
                            shiftedTime = this._doc.song.beatsPerBar * Config.partsPerBeat;
                        if (this._pattern == null)
                            throw new Error();
                        if (shiftedTime <= this._cursor.curNote.start && this._cursor.nearPinIndex == this._cursor.curNote.pins.length - 1 ||
                            shiftedTime >= this._cursor.curNote.end && this._cursor.nearPinIndex == 0) {
                            sequence.append(new ChangeNoteAdded(this._doc, this._pattern, this._cursor.curNote, this._cursor.curIndex, true));
                            this._dragVisible = false;
                        }
                        else {
                            const start = Math.min(this._cursor.curNote.start, shiftedTime);
                            const end = Math.max(this._cursor.curNote.end, shiftedTime);
                            this._dragTime = shiftedTime;
                            this._dragPitch = this._cursor.curNote.pitches[this._cursor.pitchIndex == -1 ? 0 : this._cursor.pitchIndex] + this._cursor.curNote.pins[this._cursor.nearPinIndex].interval;
                            this._dragSize = this._cursor.curNote.pins[this._cursor.nearPinIndex].size;
                            this._dragVisible = true;
                            sequence.append(new ChangeNoteTruncate(this._doc, this._pattern, start, end, this._cursor.curNote));
                            sequence.append(new ChangePinTime(this._doc, this._cursor.curNote, this._cursor.nearPinIndex, shiftedTime, continuesLastPattern));
                            this._copyPins(this._cursor.curNote);
                        }
                    }
                    else if (this._cursor.pitchIndex == -1 || this._doc.song.getChannelIsMod(this._doc.channel)) {
                    	 
                        if (!this._mouseDragging)
                            sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        const bendPart = Math.max(this._cursor.curNote.start, Math.min(this._cursor.curNote.end, Math.round(this._mouseX / (this._partWidth * minDivision)) * minDivision)) - this._cursor.curNote.start;
                        let prevPin;
                        let nextPin = this._cursor.curNote.pins[0];
                        let bendSize = 0;
                        let bendInterval = 0;
                        let cap = this._doc.song.getVolumeCap(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), this._cursor.pitch);
                         
                        let dragFactorSlow = 25.0 / Math.pow(cap, 0.4);
                        let dragFactorFast = 22.0 / Math.pow(cap, 0.5);
                        let dragSign = (this._mouseYStart > this._mouseY ? 1 : -1);
                        
                        let dragCounts = Math.min(Math.abs(this._mouseYStart - this._mouseY) / dragFactorSlow, 8) + Math.max(0, Math.abs(this._mouseYStart - this._mouseY) / dragFactorFast - 8);
                        if(this._doc.song.getChannelIsMod(this._doc.channel)){
  dragFactorSlow = 60.0 / Math.pow(cap, 0.3);
  dragFactorFast = 57.0 / Math.pow(cap, 0.5);
                       	dragCounts = Math.min(Math.abs(this._mouseYStart - this._mouseY) / dragFactorSlow, 8) + Math.max(0, Math.abs(this._mouseYStart - this._mouseY) / dragFactorFast - 8);
                        }
                        
                        
                        if (dragCounts > 0) {
                            this._shiftHeld = false;
                        }
                        for (let i = 1; i < this._cursor.curNote.pins.length; i++) {
                            prevPin = nextPin;
                            nextPin = this._cursor.curNote.pins[i];
                            if (bendPart > nextPin.time)
                                continue;
                            if (bendPart < prevPin.time)
                                throw new Error();
                            const sizeRatio = (bendPart - prevPin.time) / (nextPin.time - prevPin.time);
                            bendSize = Math.round(prevPin.size * (1.0 - sizeRatio) + nextPin.size * sizeRatio + dragSign * dragCounts);
                            if (!this.controlMode && !this._doc.alwaysFineNoteVol && !this._doc.song.getChannelIsMod(this._doc.channel)) {
                                bendSize = Math.floor(bendSize / 2) * 2;
                            }
                            if (bendSize < 0)
                                bendSize = 0;
                            if (bendSize > cap)
                                bendSize = cap;
                            bendInterval = this._snapToPitch(prevPin.interval * (1.0 - sizeRatio) + nextPin.interval * sizeRatio + this._cursor.curNote.pitches[0], 0, Config.maxPitch) - this._cursor.curNote.pitches[0];
                            break;
                        }
                        if (this._doc.song.getChannelIsMod(this._doc.channel) && this.controlMode) {
                            if (bendPart >= this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1].time) {
                                if (this._cursor.curNote.start + this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1].time < this._doc.song.beatsPerBar * Config.partsPerBeat) {
                                    for (const note of this._pattern.notes) {
                                        if (note.start == this._cursor.curNote.start + this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1].time && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                            sequence.append(new ChangeSizeBend(this._doc, note, note.pins[0].time, bendSize, bendInterval, this.shiftMode));
                                        }
                                    }
                                }
                                else {
                                    const nextPattern = this._doc.getCurrentPattern(1);
                                    if (nextPattern != null && nextPattern.instruments[0] == this._pattern.instruments[0]) {
                                        for (const note of nextPattern.notes) {
                                            if (note.start == 0 && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                                sequence.append(new ChangeSizeBend(this._doc, note, note.pins[0].time, bendSize, bendInterval, this.shiftMode));
                                            }
                                        }
                                    }
                                }
                            }
                            else if (bendPart <= this._cursor.curNote.pins[0].time) {
                                if (this._cursor.curNote.start > 0) {
                                    for (const note of this._pattern.notes) {
                                        if (note.end == this._cursor.curNote.start && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                            sequence.append(new ChangeSizeBend(this._doc, note, note.pins[note.pins.length - 1].time, bendSize, bendInterval, this.shiftMode));
                                        }
                                    }
                                }
                                else {
                                    const prevPattern = this._doc.getCurrentPattern(-1);
                                    if (prevPattern != null && prevPattern.instruments[0] == this._pattern.instruments[0]) {
                                        for (const note of prevPattern.notes) {
                                            if (note.end == this._doc.song.beatsPerBar * Config.partsPerBeat && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                                sequence.append(new ChangeSizeBend(this._doc, note, note.pins[note.pins.length - 1].time, bendSize, bendInterval, this.shiftMode));
                                            }
                                        }
                                    }
                                }
                            }
                        }
this._dragTime = this._cursor.curNote.start + bendPart;
this._dragPitch = this._cursor.curNote.pitches[this._cursor.pitchIndex == -1 ? 0 : this._cursor.pitchIndex] + bendInterval;
this._dragSize = bendSize;
this._dragVisible = true;
if (this._doc.increaseAllPins) {
    let targetPin = null;
    for (let i = 1; i < this._cursor.curNote.pins.length; i++) {
        if (bendPart <= this._cursor.curNote.pins[i].time) {
            targetPin = this._cursor.curNote.pins[i];
            break;
        }
    }
    if (!targetPin) targetPin = this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1];
// Lol Delta ∆
    const delta = bendSize - targetPin.size;
    for (const pin of this._cursor.curNote.pins) {
        let newSize = pin.size + delta;
        if (newSize < 0) newSize = 0;
        if (newSize > cap) newSize = cap;
        sequence.append(new ChangeSizeBend(
            this._doc,
            this._cursor.curNote,
            pin.time,
            newSize,
            pin.interval,
            this.shiftMode
        ));
    }
} else {
    sequence.append(new ChangeSizeBend(
        this._doc,
        this._cursor.curNote,
        bendPart,
        bendSize,
        bendInterval,
        this.shiftMode
    ));
}
this._copyPins(this._cursor.curNote);

                    }
                    else {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        this._dragSize = this._cursor.curNote.pins[this._cursor.nearPinIndex].size;
                        if (this._pattern == null)
                            throw new Error();
                        let bendStart;
                        let bendEnd;
                        if (this._mouseX >= this._mouseXStart) {
                            bendStart = Math.max(this._cursor.curNote.start, this._cursor.part);
                            bendEnd = currentPart + minDivision;
                        }
                        else {
                            bendStart = Math.min(this._cursor.curNote.end, this._cursor.part + minDivision);
                            bendEnd = currentPart;
                        }
                        if (bendEnd < 0)
                            bendEnd = 0;
                        if (bendEnd > this._doc.song.beatsPerBar * Config.partsPerBeat)
                            bendEnd = this._doc.song.beatsPerBar * Config.partsPerBeat;
                        if (bendEnd > this._cursor.curNote.end) {
                            sequence.append(new ChangeNoteTruncate(this._doc, this._pattern, this._cursor.curNote.start, bendEnd, this._cursor.curNote));
                        }
                        if (bendEnd < this._cursor.curNote.start) {
                            sequence.append(new ChangeNoteTruncate(this._doc, this._pattern, bendEnd, this._cursor.curNote.end, this._cursor.curNote));
                        }
                        let minPitch = Number.MAX_VALUE;
                        let maxPitch = -Number.MAX_VALUE;
                        for (const pitch of this._cursor.curNote.pitches) {
                            if (minPitch > pitch)
                                minPitch = pitch;
                            if (maxPitch < pitch)
                                maxPitch = pitch;
                        }
                        minPitch -= this._cursor.curNote.pitches[this._cursor.pitchIndex];
                        maxPitch -= this._cursor.curNote.pitches[this._cursor.pitchIndex];
                        if (!this._doc.song.getChannelIsMod(this._doc.channel)) {
                            const bendTo = this._snapToPitch(this._findMousePitch(this._mouseY), -minPitch, (this._doc.song.getChannelIsNoise(this._doc.channel) ? Config.drumCount - 1 : Config.maxPitch) - maxPitch);
                            sequence.append(new ChangePitchBend(this._doc, this._cursor.curNote, bendStart, bendEnd, bendTo, this._cursor.pitchIndex));
                            this._dragPitch = bendTo;
                        }
                        else {
                            const bendTo = this._snapToPitch(this._dragPitch, -minPitch, Config.modCount - 1);
                           
                            sequence.append(new ChangePitchBend(this._doc, this._cursor.curNote, bendStart, bendEnd, bendTo, this._cursor.pitchIndex));
                            this._dragPitch = bendTo;
                        }
                        this._copyPins(this._cursor.curNote);
                        this._dragTime = bendEnd;
                        this._dragVisible = true;
                    }
                }
            }
            if (!(this._mouseDown && this._cursor.valid && continuousState)) {
                this._updateCursorStatus();
                this._updatePreview();
            }
        }
        _setPatternSelection(change) {
            this._changePatternSelection = change;
            this._doc.record(this._changePatternSelection, this._lastChangeWasPatternSelection);
        }
        _updatePreview() {
            if (this._usingTouch) {
                if (!this._mouseDown || !this._cursor.valid || !this._mouseDragging || !this._dragVisible || this._shiftHeld || this._draggingStartOfSelection || this._draggingEndOfSelection || this._draggingSelectionContents) {
                    this._svgPreview.setAttribute("visibility", "hidden");
                    if (!this.editingModLabel ) {
                        this.modDragValueLabel.style.setProperty("display", "none");
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                    }
                }
                else {
this._svgPreview.setAttribute("visibility", "visible");
this._svgPreview.style.opacity = "0.8";
const x = this._partWidth * this._dragTime;
const radius = (this._pitchHeight - this._pitchBorder) / 2;
const cap = this._doc.song.getVolumeCap(
    this._doc.song.getChannelIsMod(this._doc.channel),
    this._doc.channel,
    this._doc.getCurrentInstrument(this._barOffset),
    this._cursor.pitch
);

if (this._doc.differentMod && this._doc.song.getChannelIsMod(this._doc.channel) ) {
    const yStart = this._pitchToPixelHeight(this._dragPitch - this._octaveOffset) + radius +10;
    const yEnd = yStart - (radius * (this._dragSize / cap)) -20;
    let pathString = "";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart);
    pathString += " L " + prettyNumber(x) + " " + prettyNumber(yEnd);
    this._svgPreview.setAttribute("d", pathString);
} else {
    const yStart = this._pitchToPixelHeight(this._dragPitch - this._octaveOffset);
    const height = 60;
    let pathString = "";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
    pathString += "L " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap) - height) + " ";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
    pathString += "L " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap) + height) + " ";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
    pathString += "L " + prettyNumber(x + 80) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
    pathString += "L " + prettyNumber(x + 80) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
    pathString += "L " + prettyNumber(x - 80) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
    pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
    pathString += "L " + prettyNumber(x - 80) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
    this._svgPreview.setAttribute("d", pathString);
}


                }
            }
            else {
                if (!this._mouseOver || this._mouseDown || !this._cursor.valid) {
                    this._svgPreview.setAttribute("visibility", "hidden");
                    if (!this.editingModLabel ) { 
                        this.modDragValueLabel.style.setProperty("display", "none");
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                    }
                }
                else {
                    this._svgPreview.setAttribute("visibility", "visible");
                    if (this._cursorAtStartOfSelection()) {
                        const center = this._partWidth * this._doc.selection.patternSelectionStart;
                        const left = prettyNumber(center - 4);
                        const right = prettyNumber(center + 4);
                        const bottom = this._pitchToPixelHeight(-0.5);
                        this._svgPreview.setAttribute("d", "M " + left + " 0 L " + left + " " + bottom + " L " + right + " " + bottom + " L " + right + " 0 z");
                    }
                    else if (this._cursorAtEndOfSelection()) {
                        const center = this._partWidth * this._doc.selection.patternSelectionEnd;
                        const left = prettyNumber(center - 4);
                        const right = prettyNumber(center + 4);
                        const bottom = this._pitchToPixelHeight(-0.5);
                        this._svgPreview.setAttribute("d", "M " + left + " 0 L " + left + " " + bottom + " L " + right + " " + bottom + " L " + right + " 0 z");
                    }
                    else if (this._cursorIsInSelection()) {
                        const left = prettyNumber(this._partWidth * this._doc.selection.patternSelectionStart - 2);
                        const right = prettyNumber(this._partWidth * this._doc.selection.patternSelectionEnd + 2);
                        const bottom = this._pitchToPixelHeight(-0.5);
                        this._svgPreview.setAttribute("d", "M " + left + " 0 L " + left + " " + bottom + " L " + right + " " + bottom + " L " + right + " 0 z");
                    }
                    else {
                        this._drawNote(this._svgPreview, this._cursor.pitch, this._cursor.start, this._cursor.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
                    }
                }
            }
        }
        _updateSelection() {
            if (this._doc.selection.patternSelectionActive) {
                this._selectionRect.setAttribute("visibility", "visible");
                this._selectionRect.setAttribute("x", String(this._partWidth * this._doc.selection.patternSelectionStart));
                this._selectionRect.setAttribute("width", String(this._partWidth * (this._doc.selection.patternSelectionEnd - this._doc.selection.patternSelectionStart)));
            }
            else {
                this._selectionRect.setAttribute("visibility", "hidden");
            }
        }
        render() {
            const nextPattern = this._doc.getCurrentPattern(this._barOffset);
            if (this._pattern != nextPattern && this._pattern != null) {
                if (this._doc.song.getChannelIsMod(this._doc.channel) && this._interactive && nextPattern != null) {
                    nextPattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                }
                this._dragChange = null;
                this._whenCursorReleased(null);
            }
            this._pattern = nextPattern;
            this._editorWidth = this.container.clientWidth;
            this._editorHeight = this.container.clientHeight;
            this._partWidth = this._editorWidth / (this._doc.song.beatsPerBar * Config.partsPerBeat);
            this._octaveOffset = this._doc.song.channels[this._doc.channel].octave * Config.pitchesPerOctave;
            if (this._doc.song.getChannelIsNoise(this._doc.channel)) {
                this._pitchBorder = 0;
                this._pitchCount = Config.drumCount;
            }
            else if (this._doc.song.getChannelIsMod(this._doc.channel)) {
            	 
                this._pitchBorder = this._defaultModBorder;
                this._pitchCount = Config.modCount;
                if (this._pattern != null) {
                    for (const note of this._pattern.notes) {
                        let pitch = note.pitches[0];
                        let maxHeight = this._doc.song.getVolumeCap(true, this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), pitch);
                        let maxFoundHeight = 0;
                        for (const pin of note.pins) {
                            if (pin.size > maxFoundHeight) {
                                maxFoundHeight = pin.size;
                            }
                        }
                        if (maxFoundHeight > maxHeight) {
                            for (const pin of note.pins) {
                                pin.size = Math.round(pin.size * (maxHeight / maxFoundHeight));
                            }
                        }
                    }
                }
            }
            else {
                this._pitchBorder = 0;
                this._pitchCount = this._doc.getVisiblePitchCount();
            }
            this._pitchHeight = this._editorHeight / this._pitchCount;
            this._octaveOffset = this._doc.getBaseVisibleOctave(this._doc.channel) * Config.pitchesPerOctave;
            if (this._renderedRhythm != this._doc.song.rhythm ||
                this._renderedPitchChannelCount != this._doc.song.pitchChannelCount ||
                this._renderedNoiseChannelCount != this._doc.song.noiseChannelCount ||
                this._renderedModChannelCount != this._doc.song.modChannelCount) {
                this._renderedRhythm = this._doc.song.rhythm;
                this._renderedPitchChannelCount = this._doc.song.pitchChannelCount;
                this._renderedNoiseChannelCount = this._doc.song.noiseChannelCount;
                this._renderedModChannelCount = this._doc.song.modChannelCount;
                this.resetCopiedPins();
            }
            this._copiedPins = this._copiedPinChannels[this._doc.channel];
            if (this._renderedWidth != this._editorWidth || this._renderedHeight != this._editorHeight) {
                this._renderedWidth = this._editorWidth
                this._renderedHeight = this._editorHeight;
                this._svgBackground.setAttribute("width", "" + this._editorWidth);
                this._svgBackground.setAttribute("height", "" + this._editorHeight);
                this._svgPlayhead.setAttribute("height", "" + this._editorHeight);
                this._selectionRect.setAttribute("y", "0");
                this._selectionRect.setAttribute("height", "" + this._editorHeight);
            }
            const beatWidth = this._editorWidth / this._doc.song.beatsPerBar;
            if (this._renderedBeatWidth != beatWidth || this._renderedPitchHeight != this._pitchHeight) {
                this._renderedBeatWidth = beatWidth;
                this._renderedPitchHeight = this._pitchHeight;
                this._svgNoteBackground.setAttribute("width", "" + beatWidth); 
                this._svgNoteBackground.setAttribute("height", "" + (this._pitchHeight * Config.pitchesPerOctave));
                this._svgDrumBackground.setAttribute("width", "" + beatWidth);
                this._svgDrumBackground.setAttribute("height", "" + this._pitchHeight);
                this._svgModBackground.setAttribute("width", "" + beatWidth);
                this._svgModBackground.setAttribute("height", "" + (this._pitchHeight));
                this._svgModBackground.setAttribute("y", "" + (this._pitchBorder / 2));
                this._backgroundDrumRow.setAttribute("width", "" + (beatWidth - 2));
                this._backgroundDrumRow.setAttribute("height", "" + (this._pitchHeight - 2));
                if (this._pitchHeight > this._pitchBorder) {
                    this._backgroundModRow.setAttribute("width", "" + (beatWidth - 2));
                    this._backgroundModRow.setAttribute("height", "" + (this._pitchHeight - this._pitchBorder));
                }
                for (let j = 0; j < Config.pitchesPerOctave; j++) {
                    const rectangle = this._backgroundPitchRows[j];
                    const y = (Config.pitchesPerOctave - j) % Config.pitchesPerOctave;
                    rectangle.setAttribute("width", "" + (beatWidth - 2));
                    rectangle.setAttribute("y", "" + (y * this._pitchHeight + 1));
                    rectangle.setAttribute("height", "" + (this._pitchHeight - 2));
                }
            }
            this._svgNoteContainer = makeEmptyReplacementElement(this._svgNoteContainer);
            if (this._interactive) {
                if (!this._mouseDown)
                    this._updateCursorStatus();
                this._updatePreview();
                this._updateSelection();
            }
            if (this._renderedFifths != this._doc.showFifth) {
                this._renderedFifths = this._doc.showFifth;
                this._backgroundPitchRows[7].setAttribute("fill", this._doc.showFifth ? ColorConfig.fifthNote : ColorConfig.pitchBackground);
            }
            for (let j = 0; j < Config.pitchesPerOctave; j++) {
                this._backgroundPitchRows[j].style.visibility = Config.scales[this._doc.song.scale].flags[j] ? "visible" : "hidden";
            }
            if (this._doc.song.getChannelIsNoise(this._doc.channel)) {
                if (!this._renderedDrums) {
                    this._renderedDrums = true;
                    this._renderedMod = false;
                    this._svgBackground.setAttribute("fill", "url(#patternEditorDrumBackground" + this._barOffset + ")");
                }
            }
            else if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                if (!this._renderedMod) {
                    this._renderedDrums = false;
                    this._renderedMod = true;
                    this._svgBackground.setAttribute("fill", "url(#patternEditorModBackground" + this._barOffset + ")");
                }
            }
            else {
                if (this._renderedDrums || this._renderedMod) {
                    this._renderedDrums = false;
                    this._renderedMod = false;
                    this._svgBackground.setAttribute("fill", "url(#patternEditorNoteBackground" + this._barOffset + ")");
                }
            }
            if (this._doc.showChannels) {
                if (!this._doc.song.getChannelIsMod(this._doc.channel)) {
                    for (let channel = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount - 1; channel >= 0; channel--) {
                        if (channel == this._doc.channel)
                            continue;
                        if (this._doc.song.getChannelIsNoise(channel) != this._doc.song.getChannelIsNoise(this._doc.channel))
                            continue;
                        const pattern2 = this._doc.song.getPattern(channel, this._doc.bar + this._barOffset);
                        if (pattern2 == null)
                            continue;
                        const octaveOffset = this._doc.getBaseVisibleOctave(channel) * Config.pitchesPerOctave;
                        for (const note of pattern2.notes) {
                            for (const pitch of note.pitches) {
                                const notePath = SVG.path();
                                notePath.setAttribute("fill", ColorConfig.getChannelColor(this._doc.song, channel).secondaryNote);
                                notePath.setAttribute("pointer-events", "none");
                                this._drawNote(notePath, pitch, note.start, note.pins, this._pitchHeight * 0.19, false, octaveOffset);
                                this._svgNoteContainer.appendChild(notePath);
                            }
                        }
                    }
                }
            }
            if (this._pattern != null) {
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)];
                const chord = instrument.getChord();
                const transition = instrument.getTransition();
                const displayNumberedChords = chord.customInterval || chord.arpeggiates || chord.strumParts > 0 || transition.slides;
                for (const note of this._pattern.notes) {
                    let disabled = false;
                    if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                        const modIndex = instrument.modulators[Config.modCount - 1 - note.pitches[0]];
                        if ((modIndex == Config.modulators.dictionary["none"].index)
                            || instrument.invalidModulators[Config.modCount - 1 - note.pitches[0]])
                            disabled = true;
                    }
                    for (let i = 0; i < note.pitches.length; i++) {
                        const pitch = note.pitches[i];
                        let notePath = SVG.path();
                        let colorPrimary = (disabled ? ColorConfig.disabledNotePrimary : ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
                        let colorSecondary = (disabled ? ColorConfig.disabledNoteSecondary : ColorConfig.getChannelColor(this._doc.song, this._doc.channel).secondaryNote);
                        notePath.setAttribute("fill", colorSecondary);
                        notePath.setAttribute("pointer-events", "none");
                        this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, false, this._octaveOffset);
                        this._svgNoteContainer.appendChild(notePath);
                        notePath = SVG.path();
                        notePath.setAttribute("fill", colorPrimary);
                        notePath.setAttribute("pointer-events", "none")
                        
                        
 
// drawing NOTE VOLUME
if (this._doc.song.getChannelIsMod(this._doc.channel) && this._doc.differentMod) {
    this._drawNote2(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
} else {
    this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
}
 
this._svgNoteContainer.appendChild(notePath);
if (this._doc.song.getChannelIsMod(this._doc.channel) && this._doc.differentMod) {
    for (let p = 0; p < note.pins.length; p++) {
        const pin = note.pins[p];
        if (p === 0 || pin.size !== note.pins[p - 1].size) {
            const cap = this._doc.song.getVolumeCap(
                true,
                this._doc.channel,
                this._doc.getCurrentInstrument(this._barOffset),
                pitch
            );
            let x = this._partWidth * (note.start + pin.time);
            const topY = this._pitchToPixelHeight(pitch + pin.interval - this._octaveOffset)
                        - ((this._pitchHeight - this._pitchBorder) / 2 + 1) * (pin.size / cap);
            const y = topY - 10; 
            if (p === 0) x += 10; 
            if (p === note.pins.length - 1) x -= 10;

            const textEl = document.createElementNS(svgNS, "text");
            textEl.setAttribute("x", prettyNumber(x));
            textEl.setAttribute("y", prettyNumber(y));
            textEl.setAttribute("fill", "white");
            textEl.setAttribute("font-size", "5");
            textEl.setAttribute("text-anchor", "middle");
           const setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[Config.modCount - 1 - note.pitches[0]];

if(Config.modulators[setting].divider && (Config.modulators[setting].valueRealAdd || (!isNaN(Config.modulators[setting].valueRealAdd )&& Config.modulators[setting].valueRealAdd==0 ) ) ){
textEl.textContent = (( (pin.size + Config.modulators[setting].convertRealFactor + Config.modulators[setting].valueRealAdd ) / Config.modulators[setting].divider ) - 0.2 ).toFixed(1);
}else if ( Config.modulators[setting].valueRealAdd) {
 textEl.textContent = ((pin.size + Config.modulators[setting].convertRealFactor + Config.modulators[setting].valueRealAdd) );
}else if (Config.modulators[setting].divider) {
 function floorTo1(num) {
  return Math.floor(num * 10) / 10;
}
 textEl.textContent = floorTo1(
   (pin.size + Config.modulators[setting].convertRealFactor) / Config.modulators[setting].divider
 );
}else  {
 textEl.textContent = ((pin.size + Config.modulators[setting].convertRealFactor ));
}
            this._svgNoteContainer.appendChild(textEl);
        }
    }
}


                        let indicatorOffset = 2;
                        if (note.continuesLastPattern) {
                            const arrowHeight = Math.min(this._pitchHeight, 20);
                            let arrowPath;
                            arrowPath = "M " + prettyNumber(this._partWidth * note.start + indicatorOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.3 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 12) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset));
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.3 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.1 * arrowHeight);
                            const arrow = SVG.path();
                            arrow.setAttribute("d", arrowPath);
                            arrow.setAttribute("fill", ColorConfig.invertedText);
                            this._svgNoteContainer.appendChild(arrow);
                            indicatorOffset += 12;
                        }
                        if (note.pitches.length > 1) {
                            if (displayNumberedChords) {
                                const oscillatorLabel = SVG.text();
                                oscillatorLabel.setAttribute("x", "" + prettyNumber(this._partWidth * note.start + indicatorOffset));
                                oscillatorLabel.setAttribute("y", "" + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset)));
                                oscillatorLabel.setAttribute("width", "30");
                                oscillatorLabel.setAttribute("fill", ColorConfig.invertedText);
                                oscillatorLabel.setAttribute("text-anchor", "start");
                                oscillatorLabel.setAttribute("dominant-baseline", "central");
                                oscillatorLabel.setAttribute("pointer-events", "none");
                                oscillatorLabel.textContent = "" + (i + 1);
                                this._svgNoteContainer.appendChild(oscillatorLabel);
                            }
                        }
                    }
                    if (this._doc.song.getChannelIsMod(this._doc.channel) && this._mouseDragging && !this._mouseHorizontal && note == this._cursor.curNote) {
                        this.modDragValueLabel.style.setProperty("display", "");
                        
                        if( this._doc.differentMod){
                        	this.modDragValueLabel.style.setProperty("display", "none");
                        }
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                        this.modDragValueLabel.style.setProperty("color", "#FFFFFF");
                        let setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[Config.modCount - 1 - note.pitches[0]];
                        let presValue = this._dragSize + Config.modulators[setting].convertRealFactor;
                        let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                        
                        this._modDragValueLabelWidth = 8 + xOffset * 8;
                        this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * this._dragTime - 4 - xOffset * 4), 2));
                        this._modDragValueLabelTop = +prettyNumber(this._pitchToPixelHeight(note.pitches[0] - this._octaveOffset) - 17 - (this._pitchHeight - this._pitchBorder) / 2);
                        this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                        this.modDragValueLabel.style.setProperty("top", "" + this._modDragValueLabelTop + "px");
                         
if(Config.modulators[setting].divider && (Config.modulators[setting].valueRealAdd || (!isNaN(Config.modulators[setting].valueRealAdd )&& Config.modulators[setting].valueRealAdd==0 ) ) ){
 this.modDragValueLabel.textContent = (((presValue + Config.modulators[setting].valueRealAdd) / Config.modulators[setting].divider) - 0.2).toFixed(1);
} else if (Config.modulators[setting].valueRealAdd) {
 this.modDragValueLabel.textContent =((presValue+ Config.modulators[setting].valueRealAdd));
}else if (Config.modulators[setting].divider) {
 function floorTo1(num) {
 return Math.floor(num * 10) / 10;
}
this.modDragValueLabel.textContent = floorTo1(
 (pin.size + Config.modulators[setting].convertRealFactor) / Config.modulators[setting].divider
);
}else {
 this.modDragValueLabel.textContent = presValue
}
                        
                    }
                }
            }
        }
        
        _drawNote2(svgElement, pitch, start, pins, radius, showSize, offset) {
    const totalWidth = this._partWidth * (pins[pins.length - 1].time + pins[0].time);
    const endOffset = 0.5 * Math.min(2, totalWidth - 1);
    let nextPin = pins[0];
    let cap = this._doc.song.getVolumeCap(true, this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), pitch);
    const getY = (interval, size) => {
        const bottom = this._pitchToPixelHeight(pitch + interval - offset) + radius;
        const height = radius * (showSize ? size*1.8 / cap : 1.0);
        return bottom - height;
    };
    let pathString = "M " + prettyNumber(this._partWidth * (start + nextPin.time) + endOffset) + " " + prettyNumber(getY(nextPin.interval, nextPin.size)) + " ";
    let linePathString = "M " + prettyNumber(this._partWidth * (start + nextPin.time)) + " " + prettyNumber(getY(nextPin.interval, nextPin.size)) + " ";
    for (let i = 1; i < pins.length; i++) {
        let prevPin = nextPin;
        nextPin = pins[i];
        let prevSide = this._partWidth * (start + prevPin.time) + (i == 1 ? endOffset : 0);
        let nextSide = this._partWidth * (start + nextPin.time) - (i == pins.length - 1 ? endOffset : 0);
        let prevY = getY(prevPin.interval, prevPin.size);
        let nextY = getY(nextPin.interval, nextPin.size);
        pathString += "L " + prettyNumber(prevSide) + " " + prettyNumber(prevY) + " ";
        pathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextY) + " ";
        linePathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextY) + " ";
    }
    for (let i = pins.length - 1; i >= 0; i--) {
        const pin = pins[i];
        let x = this._partWidth * (start + pin.time);
        let bottomY = this._pitchToPixelHeight(pitch + pin.interval - offset) + radius;
        pathString += "L " + prettyNumber(x) + " " + prettyNumber(bottomY) + " ";
    }
    pathString += "z";
    svgElement.setAttribute("d", pathString);
    let lineEl = document.createElementNS(svgNS, "path");
    lineEl.setAttribute("d", linePathString);
    lineEl.setAttribute("stroke", "rgba(255,255,255,0.5)");
    lineEl.setAttribute("stroke-width", "1");
    lineEl.setAttribute("fill", "none");
    this._svgNoteContainer.appendChild(lineEl);

}

        
        
        _drawNote(svgElement, pitch, start, pins, radius, showSize, offset) {
            const totalWidth = this._partWidth * (pins[pins.length - 1].time + pins[0].time);
            const endOffset = 0.5 * Math.min(2, totalWidth - 1);
            let nextPin = pins[0];
            
            // volume size
            let cap = this._doc.song.getVolumeCap(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), pitch);
            
 

            
            let pathString = "M " + prettyNumber(this._partWidth * (start + nextPin.time) + endOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - offset) + radius * (showSize ? nextPin.size / cap : 1.0)) + " ";
            for (let i = 1; i < pins.length; i++) {
                let prevPin = nextPin;
                nextPin = pins[i];
                let prevSide = this._partWidth * (start + prevPin.time) + (i == 1 ? endOffset : 0);
                let nextSide = this._partWidth * (start + nextPin.time) - (i == pins.length - 1 ? endOffset : 0);
                let prevHeight = this._pitchToPixelHeight(pitch + prevPin.interval - offset);
                let nextHeight = this._pitchToPixelHeight(pitch + nextPin.interval - offset);
                let prevSize = showSize ? prevPin.size / cap : 1.0;
                let nextSize = showSize ? nextPin.size / cap : 1.0;
                pathString += "L " + prettyNumber(prevSide) + " " + prettyNumber(prevHeight - radius * prevSize) + " ";
                if (prevPin.interval > nextPin.interval)
                    pathString += "L " + prettyNumber(prevSide + 1) + " " + prettyNumber(prevHeight - radius * prevSize) + " ";
                if (prevPin.interval < nextPin.interval)
                    pathString += "L " + prettyNumber(nextSide - 1) + " " + prettyNumber(nextHeight - radius * nextSize) + " ";
                pathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextHeight - radius * nextSize) + " ";
            }
            for (let i = pins.length - 2; i >= 0; i--) {
                let prevPin = nextPin;
                nextPin = pins[i];
                let prevSide = this._partWidth * (start + prevPin.time) - (i == pins.length - 2 ? endOffset : 0);
                let nextSide = this._partWidth * (start + nextPin.time) + (i == 0 ? endOffset : 0);
                let prevHeight = this._pitchToPixelHeight(pitch + prevPin.interval - offset);
                let nextHeight = this._pitchToPixelHeight(pitch + nextPin.interval - offset) 
                
                
                
                
                let prevSize = showSize ? prevPin.size / cap : 1.0;
                let nextSize = showSize ? nextPin.size / cap : 1.0;
                pathString += "L " + prettyNumber(prevSide) + " " + prettyNumber(prevHeight + radius * prevSize) + " ";
                if (prevPin.interval < nextPin.interval)
                    pathString += "L " + prettyNumber(prevSide - 1) + " " + prettyNumber(prevHeight + radius * prevSize) + " ";
                if (prevPin.interval > nextPin.interval)
                    pathString += "L " + prettyNumber(nextSide + 1) + " " + prettyNumber(nextHeight + radius * nextSize) + " ";
                pathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextHeight + radius * nextSize) + " ";
            }
            pathString += "z";
            svgElement.setAttribute("d", pathString);
        }
        _pitchToPixelHeight(pitch) {
            return this._pitchHeight * (this._pitchCount - (pitch) - 0.5);
        }
    }
 class Piano {
    forceRender() {
        this._renderedScale = -1;
        this._documentChanged();
    }
    static getBassCutoffPitch(doc) {
        const octaveOffset = doc.getBaseVisibleOctave(doc.channel);
        return octaveOffset * Config.pitchesPerOctave + Math.floor(doc.getVisiblePitchCount() / (Config.pitchesPerOctave * 2)) * Config.pitchesPerOctave;
    }
    constructor(_doc) {
        this._doc = _doc;
        this._pianoContainer = HTML.div({ style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;" });
        this._drumContainer = HTML.div({ style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;" });
        this._modContainer = HTML.div({ style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;" });
        this._preview = HTML.div({ style: `width: 100%; height: 40px; border: 2px solid ${ColorConfig.primaryText}; position: absolute; box-sizing: border-box; pointer-events: none;` });
        this.container = HTML.div({ style: "width: 32px; height: 100%; overflow: hidden; position: relative; flex-shrink: 0; touch-action: none;" }, this._pianoContainer, this._drumContainer, this._modContainer, this._preview);
        this._editorHeight = 481;
        this._pianoKeys = [];
        this._pianoLabels = [];
        this._modFirstLabels = [];
        this._modSecondLabels = [];
        this._modCountLabels = [];
        this._modCountRects = [];
        this._mouseY = 0;
        this._mouseDown = false;
        this._mouseOver = false;
        this._playedPitch = -1;
        this._renderedScale = -1;
        this._renderedDrums = false;
        this._renderedMod = false;
        this._renderedKey = -1;
        this._renderedPitchCount = -1;
        this._renderedLiveInputPitches = [];
        this._whenMouseOver = (event) => {
            if (this._mouseOver)
                return;
            this._mouseOver = true;
            this._updatePreview();
        };
        this._whenMouseOut = (event) => {
            if (!this._mouseOver)
                return;
            this._mouseOver = false;
            this._updatePreview();
        };
        this._whenMousePressed = (event) => {
            event.preventDefault();
            this._doc.synth.maintainLiveInput();
            this._mouseDown = true;
            const boundingRect = this.container.getBoundingClientRect();
            this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
            if (isNaN(this._mouseY))
                this._mouseY = 0;
            this._updateCursorPitch();
            this._playLiveInput();
            this._updatePreview();
        };
        this._whenMouseMoved = (event) => {
            if (this._mouseDown || this._mouseOver)
                this._doc.synth.maintainLiveInput();
            const boundingRect = this.container.getBoundingClientRect();
            this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
            if (isNaN(this._mouseY))
                this._mouseY = 0;
            this._updateCursorPitch();
            if (this._mouseDown)
                this._playLiveInput();
            this._updatePreview();
        };
        this._whenMouseReleased = (event) => {
            if (this._mouseDown)
                this._releaseLiveInput();
            this._mouseDown = false;
            this._updatePreview();
        };
        this._whenTouchPressed = (event) => {
            event.preventDefault();
            this._doc.synth.maintainLiveInput();
            this._mouseDown = true;
            const boundingRect = this.container.getBoundingClientRect();
            this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
            if (isNaN(this._mouseY))
                this._mouseY = 0;
            this._updateCursorPitch();
            this._playLiveInput();
        };
        this._whenTouchMoved = (event) => {
            event.preventDefault();
            this._doc.synth.maintainLiveInput();
            const boundingRect = this.container.getBoundingClientRect();
            this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
            if (isNaN(this._mouseY))
                this._mouseY = 0;
            this._updateCursorPitch();
            if (this._mouseDown)
                this._playLiveInput();
        };
        this._whenTouchReleased = (event) => {
            event.preventDefault();
            this._mouseDown = false;
            this._releaseLiveInput();
        };
        this._onAnimationFrame = () => {
            window.requestAnimationFrame(this._onAnimationFrame);
            let liveInputChanged = false;
            let liveInputPitchCount = !this._doc.performance.pitchesAreTemporary() ? this._doc.synth.liveInputPitches.length : 0;
            liveInputPitchCount += !this._doc.performance.bassPitchesAreTemporary() ? this._doc.synth.liveBassInputPitches.length : 0;
            if (this._renderedLiveInputPitches.length != liveInputPitchCount) {
                liveInputChanged = true;
            }
            for (let i = 0; i < this._doc.synth.liveInputPitches.length; i++) {
                if (this._renderedLiveInputPitches[i] != this._doc.synth.liveInputPitches[i]) {
                    this._renderedLiveInputPitches[i] = this._doc.synth.liveInputPitches[i];
                    liveInputChanged = true;
                }
            }
            for (let i = this._doc.synth.liveInputPitches.length; i < liveInputPitchCount; i++) {
                if (this._renderedLiveInputPitches[i] != this._doc.synth.liveBassInputPitches[i - this._doc.synth.liveInputPitches.length]) {
                    this._renderedLiveInputPitches[i] = this._doc.synth.liveBassInputPitches[i - this._doc.synth.liveInputPitches.length];
                    liveInputChanged = true;
                }
            }
            this._renderedLiveInputPitches.length = liveInputPitchCount;
            if (liveInputChanged) {
                this._updatePreview();
            }
        };
        this._documentChanged = () => {
            const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
            const isMod = this._doc.song.getChannelIsMod(this._doc.channel);
            this._pitchCount = isMod ? Config.modCount : (isDrum ? Config.drumCount : this._doc.getVisiblePitchCount());
            this._pitchHeight = this._editorHeight / this._pitchCount;
            this._updateCursorPitch();
            if (this._mouseDown)
                this._playLiveInput();
            if (!this._doc.showLetters)
                return;
if (this._renderedScale == this._doc.song.scale && this._renderedKey == this._doc.song.key && this._renderedDrums == isDrum && this._renderedMod == isMod && this._renderedPitchCount == this._pitchCount)
                	return;
            this._renderedScale = this._doc.song.scale;
            this._renderedKey = this._doc.song.key;
            this._renderedDrums = isDrum;
            this._renderedMod = isMod;
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._pianoContainer.style.display = (isDrum || isMod) ? "none" : "flex";
            this._drumContainer.style.display = isDrum ? "flex" : "none";
            this._modContainer.style.display = isMod ? "flex" : "none";
            if (!isDrum && !isMod) {
                if (this._renderedPitchCount != this._pitchCount) {
                    this._pianoContainer.innerHTML = "";
                    for (let i = 0; i < this._pitchCount; i++) {
                        const pianoLabel = HTML.div({ class: "piano-label", style: "font-weight: bold; -webkit-text-stroke-width: 0; font-size: 11px; font-family: sans-serif; position: absolute; padding-left: 15px; white-space: nowrap;" });
                        const pianoKey = HTML.div({ class: "piano-button", style: "background: gray;" }, pianoLabel);
                        this._pianoContainer.appendChild(pianoKey);
                        this._pianoLabels[i] = pianoLabel;
                        this._pianoKeys[i] = pianoKey;
                    }
                    this._pianoLabels.length = this._pitchCount;
                    this._pianoKeys.length = this._pitchCount;
                    this._renderedPitchCount = this._pitchCount;
                }
                for (let j = 0; j < this._pitchCount; j++) {
                    const pitchNameIndex = (j + Config.keys[this._doc.song.key].basePitch) % Config.pitchesPerOctave;
                    const isWhiteKey = Config.keys[pitchNameIndex].isWhiteKey;
                    this._pianoKeys[j].style.background = isWhiteKey ? ColorConfig.whitePianoKey : ColorConfig.blackPianoKey;
                    let scale =  Config.scales[this._doc.song.scale].flags;
                    if (!scale[j % Config.pitchesPerOctave]) {
                        this._pianoKeys[j].classList.add("disabled");
                        this._pianoLabels[j].style.display = "none";
                    }
                    else {
	this._pianoKeys[j].classList.remove("disabled");
	this._pianoLabels[j].style.display = "";
	let text;
	if (Config.keys[pitchNameIndex].isWhiteKey) {
		text = Config.keys[pitchNameIndex].name;
	}
	else {
		const shiftDir = Config.blackKeyNameParents[j % Config.pitchesPerOctave];
		text = Config.keys[(pitchNameIndex + Config.pitchesPerOctave + shiftDir) % Config.pitchesPerOctave].name;
		if (shiftDir == 1) {
			text += "♭";
		}
		else if (shiftDir == -1) {
			text += "♯";
		}
	}
	const label = this._pianoLabels[j];
	if ((j % 12) == 0) {
		text += Math.floor(j / 12) + this._doc.getBaseVisibleOctave(this._doc.channel);
		label.style.transform = "translate(-5px, 0px)";
	}
	else {
		label.style.transform = "translate(0px, 0px)";
	}
	const root22 = document.documentElement;
	const rawColor = getComputedStyle(root22).getPropertyValue('--white-piano-key-color').trim();
	
	if (rawColor !== '') {
		label.style.color = isWhiteKey ? ColorConfig.whitePianoKeyColor : ColorConfig.blackPianoKeyColor;
	} else {
		label.style.color = Config.keys[pitchNameIndex].isWhiteKey ? "black" : "white";
	}
	label.textContent = text;
}
                }
            }
            else if (isMod) {
                let firstRow = "";
                let secondRow = "";
                let useFirstColor = ColorConfig.modLabelPrimaryText;
                let useSecondColor = ColorConfig.modLabelSecondaryText;
                for (let j = 0; j < Config.modCount; j++) {
                    let usingSecondRow = true;
                    let usingMod = true;
                    let instrumentVal = instrument.modInstruments[Config.modCount - j - 1] + 1;
                    let channelVal = instrument.modChannels[Config.modCount - j - 1] + 1;
                    let modulator = instrument.modulators[Config.modCount - j - 1];
                    let status = 1 + +(channelVal - 1 >= this._doc.song.pitchChannelCount);
                    if (instrument.modChannels[Config.modCount - j - 1] == -2)
                        status = 0;
                    else if (instrument.modChannels[Config.modCount - j - 1] == -1)
                        status = 3;
                    let instrumentsLength = this._doc.song.channels[Math.max(0, channelVal - 1)].instruments.length;
                    switch (status) {
                        case 0:
                            firstRow = "Mod";
                            usingSecondRow = false;
                            useSecondColor = ColorConfig.modLabelSecondaryText;
                            usingMod = false;
                            break;
                        case 1:
                            if (this._doc.song.channels[channelVal - 1].name == "") {
                                if (instrumentsLength > 1) {
                                    if (channelVal >= 10 || instrumentVal >= 10) {
                                        firstRow = "P" + channelVal;
                                        if (instrumentVal - 1 == instrumentsLength) {
                                            firstRow += " All";
                                        }
                                        else if (instrumentVal - 1 > instrumentsLength) {
                                            firstRow += " Act";
                                        }
                                        else {
                                            firstRow += " I" + instrumentVal;
                                        }
                                    }
                                    else {
                                        firstRow = "Pitch" + channelVal;
                                        if (instrumentVal - 1 == instrumentsLength) {
                                            firstRow += " All";
                                        }
                                        else if (instrumentVal - 1 > instrumentsLength) {
                                            firstRow += " Act";
                                        }
                                        else {
                                            firstRow += " Ins" + instrumentVal;
                                        }
                                    }
                                }
                                else {
                                    firstRow = "Pitch " + channelVal;
                                }
                            }
                            else {
                                let insText;
                                if (instrumentVal - 1 == instrumentsLength) {
                                    insText = " All";
                                }
                                else if (instrumentVal - 1 > instrumentsLength) {
                                    insText = " Act";
                                }
                                else {
                                    insText = " I" + instrumentVal;
                                }
                                if (instrumentsLength > 1) {
                                    firstRow = "P" + channelVal + " " + this._doc.song.channels[channelVal - 1].name + insText;
                                }
                                else {
                                    firstRow = "P" + channelVal + " " + this._doc.song.channels[channelVal - 1].name;
                                }
                            }
                            break;
                        case 2:
                            const absoluteChannelVal = instrument.modChannels[Config.modCount - j - 1];
                            const relativeChannelVal = absoluteChannelVal - this._doc.song.pitchChannelCount;
                            if (this._doc.song.channels[absoluteChannelVal].name == "") {
                                if (instrumentsLength > 1) {
                                    if ((relativeChannelVal + 1) >= 10 || instrumentVal >= 10) {
                                        firstRow = "N" + (relativeChannelVal + 1);
                                        if (instrumentVal - 1 == instrumentsLength) {
                                            firstRow += " All";
                                        }
                                        else if (instrumentVal - 1 > instrumentsLength) {
                                            firstRow += " Act";
                                        }
                                        else {
                                            firstRow += " I" + instrumentVal;
                                        }
                                    }
                                    else {
                                        firstRow = "Noise" + (relativeChannelVal + 1);
                                        if (instrumentVal - 1 == instrumentsLength) {
                                            firstRow += " All";
                                        }
                                        else if (instrumentVal - 1 > instrumentsLength) {
                                            firstRow += " Act";
                                        }
                                        else {
                                            firstRow += " Ins" + instrumentVal;
                                        }
                                    }
                                }
                                else {
                                    firstRow = "Noise " + (relativeChannelVal + 1);
                                }
                            }
                            else {
                                if (instrumentsLength > 1) {
                                    let insText;
                                    if (instrumentVal - 1 == instrumentsLength) {
                                        insText = " All";
                                    }
                                    else if (instrumentVal - 1 > instrumentsLength) {
                                        insText = " Act";
                                    }
                                    else {
                                        insText = " I" + instrumentVal;
                                    }
                                    firstRow = "N" + (relativeChannelVal + 1) + " " + this._doc.song.channels[absoluteChannelVal].name + insText;
                                }
                                else {
                                    firstRow = "N" + (relativeChannelVal + 1) + " " + this._doc.song.channels[absoluteChannelVal].name;
                                }
                            }
                            break;
                        case 3:
                            firstRow = "Song";
                            break;
                    }
                    if (usingSecondRow) {
                        secondRow = Config.modulators[modulator].pianoName;
                        if (modulator == Config.modulators.dictionary["none"].index) {
                            useSecondColor = ColorConfig.modLabelSecondaryText;
                            usingMod = false;
                        }
                        else if (modulator == Config.modulators.dictionary["eq filter"].index || modulator == Config.modulators.dictionary["note filter"].index) {
                            var text = " Morph";
                            var filterVal = instrument.modFilterTypes[Config.modCount - j - 1];
                            if (filterVal > 0 && (filterVal % 2)) {
                                text = " Dot" + Math.ceil(filterVal / 2) + "X";
                            }
                            else if (filterVal > 0) {
                                text = " Dot" + Math.ceil(filterVal / 2) + "Y";
                            }
                            secondRow += text;
                        }
                    }
                    const firstLabel = this._modFirstLabels[j];
                    const secondLabel = this._modSecondLabels[j];
                    const modCountLabel = this._modCountLabels[j];
                    const modCountRect = this._modCountRects[j];
                    firstLabel.style.fill = useFirstColor;
                    firstLabel.textContent = firstRow;
                    secondLabel.style.fill = useSecondColor;
                    secondLabel.textContent = usingSecondRow ? secondRow : "Not set";
                    modCountLabel.textContent = "" + (Config.modCount - j);
                    modCountRect.style.fill = usingMod ? ColorConfig.indicatorPrimary : ColorConfig.modLabelSecondaryText;
                    if (this._doc.song.channels[Math.max(0, instrument.modChannels[Config.modCount - j - 1])].name != "") {
                        let scaleFactor = "1";
                        let height = firstLabel.parentElement.parentElement.getBoundingClientRect().height;
                        let length = firstLabel.getComputedTextLength();
                        let squeeze = 0;
                        if (length > height - 8) {
                            scaleFactor = "0.65";
                            squeeze = 2;
                        }
                        else if (length > height - 24) {
                            scaleFactor = "0.8";
                            squeeze = 1;
                        }
                        firstLabel.style.transform = "rotate(-90deg) translate(" + (-20 - squeeze - Math.round(Math.max(0, (height - 80) / 2))) + "px, 39px) scale(" + scaleFactor + ", 1)";
                        while (scaleFactor == "0.65" && firstLabel.getComputedTextLength() > height + 8) {
                            var offset = 4 + (instrumentVal >= 10 ? 1 : 0);
                            firstLabel.textContent = firstLabel.textContent.substr(0, firstLabel.textContent.length - offset) + firstLabel.textContent.substr(firstLabel.textContent.length - offset + 1);
                        }
                    }
                    else {
                        let height = firstLabel.parentElement.parentElement.getBoundingClientRect().height;
                        firstLabel.style.transform = "rotate(-90deg) translate(" + (-20 - Math.round(Math.max(0, (height - 80) / 2))) + "px, 39px) scale(1, 1)";
                    }
                }
            }
            this._updatePreview();
        };
        for (let i = 0; i < Config.drumCount; i++) {
            const scale = (1.0 - (i / Config.drumCount) * 0.35) * 100;
            this._drumContainer.appendChild(HTML.div({ class: "drum-button", style: `background-size: ${scale}% ${scale}%;` }));
        }
        for (let i = 0; i < Config.modCount; i++) {
            const firstRowText = SVG.text({ class: "modulator-label", "text-anchor": "left", fill: ColorConfig.modLabelPrimaryText, style: "font-weight: bold; align-self: flex-start; transform-origin: center; transform: rotate(-90deg) translate(-19px, 39px); font-size: 11px; font-family: sans-serif;" });
            const secondRowText = SVG.text({ class: "modulator-label", "text-anchor": "left", fill: ColorConfig.modLabelPrimaryText, style: "font-weight: bold; align-self: flex-end; transform-origin: center; transform: rotate(-90deg) translate(-26px, 42px); font-size: 11px; font-family: sans-serif;" });
            const countText = SVG.text({ class: "modulator-inverse-label", fill: ColorConfig.modLabelPrimary, style: "font-weight: bold; align-self: flex-start; transform-origin: center; transform: rotate(-90deg) translate(4px, 13px); font-size: 11px; font-family: sans-serif;" });
            const countRect = SVG.rect({ width: "12px", height: "9px", fill: ColorConfig.indicatorPrimary, style: "pointer-events: none; transform: translate(4px, 4px);" });
            const firstRowSVG = SVG.svg({ viewBox: "0 0 16 66", width: "16px", style: "pointer-events: none; flex-grow: 1;" }, [
                firstRowText,
            ]);
            const countSVG = SVG.svg({ viewBox: "0 0 16 14", width: "16px", style: "pointer-events: none;" }, [
                countRect,
                countText,
            ]);
            const secondRowSVG = SVG.svg({ viewBox: "0 0 16 80", width: "16px", style: "pointer-events: none;" }, [
                secondRowText,
            ]);
            const flexRow1 = HTML.div({ style: "display: flex; flex-direction: column; justify-content: space-between; pointer-events: none;" }, [
                countSVG,
                firstRowSVG,
            ]);
            const flexRow2 = HTML.div({ style: "display: flex; flex-direction: column-reverse; justify-content: space-between; pointer-events: none;" }, [
                secondRowSVG,
            ]);
            const flexContainer = HTML.div({ style: "display: flex; flex-direction: row; justify-content: space-between; padding: 0px; width: 32px; height: 100%; overflow: hidden; pointer-events: none;" }, [
                flexRow1,
                flexRow2,
            ]);
            const modKey = HTML.div({ class: "modulator-button", style: "background: " + ColorConfig.modLabelPrimary + ";" }, flexContainer);
            this._modContainer.appendChild(modKey);
            this._modFirstLabels.push(firstRowText);
            this._modSecondLabels.push(secondRowText);
            this._modCountLabels.push(countText);
            this._modCountRects.push(countRect);
        }
        this.container.addEventListener("mousedown", this._whenMousePressed);
        document.addEventListener("mousemove", this._whenMouseMoved);
        document.addEventListener("mouseup", this._whenMouseReleased);
        this.container.addEventListener("mouseover", this._whenMouseOver);
        this.container.addEventListener("mouseout", this._whenMouseOut);
        this.container.addEventListener("touchstart", this._whenTouchPressed);
        this.container.addEventListener("touchmove", this._whenTouchMoved);
        this.container.addEventListener("touchend", this._whenTouchReleased);
        this.container.addEventListener("touchcancel", this._whenTouchReleased);
        this._doc.notifier.watch(this._documentChanged);
        this._documentChanged();
        window.requestAnimationFrame(this._onAnimationFrame);
    }
    _updateCursorPitch() {
        const scale =   Config.scales[this._doc.song.scale].flags;
        const mousePitch = Math.max(0, Math.min(this._pitchCount - 1, this._pitchCount - (this._mouseY / this._pitchHeight)));
        if (scale[Math.floor(mousePitch) % Config.pitchesPerOctave] || this._doc.song.getChannelIsNoise(this._doc.channel)) {
            this._cursorPitch = Math.floor(mousePitch);
        }
        else {
            let topPitch = Math.floor(mousePitch) + 1;
            let bottomPitch = Math.floor(mousePitch) - 1;
            while (!scale[topPitch % Config.pitchesPerOctave]) {
                topPitch++;
            }
            while (!scale[(bottomPitch) % Config.pitchesPerOctave]) {
                bottomPitch--;
            }
            let topRange = topPitch;
            let bottomRange = bottomPitch + 1;
            if (topPitch % Config.pitchesPerOctave == 0 || topPitch % Config.pitchesPerOctave == 7) {
                topRange -= 0.5;
            }
            if (bottomPitch % Config.pitchesPerOctave == 0 || bottomPitch % Config.pitchesPerOctave == 7) {
                bottomRange += 0.5;
            }
            this._cursorPitch = mousePitch - bottomRange > topRange - mousePitch ? topPitch : bottomPitch;
        }
    }
    _playLiveInput() {
        const octaveOffset = this._doc.getBaseVisibleOctave(this._doc.channel) * Config.pitchesPerOctave;
        const currentPitch = this._cursorPitch + octaveOffset;
        if (this._playedPitch == currentPitch)
            return;
        this._doc.performance.removePerformedPitch(this._playedPitch);
        this._playedPitch = currentPitch;
        this._doc.performance.addPerformedPitch(currentPitch);
    }
    _releaseLiveInput() {
        this._doc.performance.removePerformedPitch(this._playedPitch);
        this._playedPitch = -1;
    }
    _updatePreview() {
        this._preview.style.visibility = (!this._mouseOver || this._mouseDown) ? "hidden" : "visible";
        if (this._mouseOver && !this._mouseDown) {
            const boundingRect = this.container.getBoundingClientRect();
            const pitchHeight = this._pitchHeight / (this._editorHeight / (boundingRect.bottom - boundingRect.top));
            this._preview.style.left = "0px";
            this._preview.style.top = pitchHeight * (this._pitchCount - this._cursorPitch - 1) + "px";
            this._preview.style.height = pitchHeight + "px";
        }
        const octaveOffset = this._doc.getBaseVisibleOctave(this._doc.channel) * Config.pitchesPerOctave;
        const container = this._doc.song.getChannelIsNoise(this._doc.channel) ? this._drumContainer : this._pianoContainer;
        const children = container.children;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (this._renderedLiveInputPitches.indexOf(i + octaveOffset) == -1) {
                child.classList.remove("pressed");
            }
            else {
                child.classList.add("pressed");
            }
        }
    }
    static getPitchName(pitchNameIndex, scaleIndex, baseVisibleOctave) {
        let text;
        if (Config.keys[pitchNameIndex].isWhiteKey) {
            text = Config.keys[pitchNameIndex].name;
        }
        else {
            const shiftDir = Config.blackKeyNameParents[scaleIndex % Config.pitchesPerOctave];
            text = Config.keys[(pitchNameIndex + Config.pitchesPerOctave + shiftDir) % Config.pitchesPerOctave].name;
            if (shiftDir == 1) {
                text += "♭";
            }
            else if (shiftDir == -1) {
                text += "♯";
            }
        }
        if (scaleIndex % 12 == 0) {
            text += Math.floor(scaleIndex / 12) + baseVisibleOctave;
        }
        return text;
    }
}


 class VisualLoopControlsHandle {
        constructor(value, canvasWidth, canvasHeight, viewportX0, viewportX1, validator, whenValueChanges, whenMouseUpHappens, shapeFunction) {
            this._handleWidth = 40;
            this._mouseDown = false;
            this._handleDragOffset = null;
            this.canvas = null;
            this._context = null;
            this.update = (newValue) => {
                this._value = this._validator(newValue);
            };
            this.render = () => {
                const cnv = this.canvas;
                const ctx = this._context;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const v = this._value;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                const bw = this._handleWidth;
                const bh = h;
                const bx = Math.floor((v - vx0) * w / (vx1 - vx0)) - bw / 2;
                const by = 0;
                this._shapeFunction(cnv, ctx, bx, by, bw, bh);
            };
            this.updateViewport = (x0, x1) => {
                this._viewportX0 = x0;
                this._viewportX1 = x1;
            };
            this._whenMouseMoves = (event) => {
                if (!this._mouseDown)
                    return;
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenMouseIsDown = (event) => {
                this._mouseDown = true;
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                const bw = this._handleWidth;
                const bx0 = ((this._value - vx0) * w / (vx1 - vx0)) - bw / 2;
                const bx1 = bx0 + bw;
                if (mx >= bx0 && mx <= bx1) {
                    this._handleDragOffset = (mx - (bx0 + bw / 2)) * (vx1 - vx0) / w;
                }
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenMouseIsUp = (event) => {
                if (!this._mouseDown)
                    return;
                this._mouseDown = false;
                this._handleDragOffset = null;
                this._whenMouseUpHappens();
            };
            this._whenTouchMoves = (event) => {
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenTouchIsDown = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                const bw = this._handleWidth;
                const bx0 = ((this._value - vx0) * w / (vx1 - vx0)) - bw / 2;
                const bx1 = bx0 + bw;
                if (mx >= bx0 && mx <= bx1) {
                    this._handleDragOffset = (mx - (bx0 + bw / 2)) * (vx1 - vx0) / w;
                }
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenTouchIsUp = (event) => {
                event.preventDefault();
                this._mouseDown = false;
                this._handleDragOffset = null;
                this._whenMouseUpHappens();
            };
            this.cleanUp = () => {
                window.removeEventListener("mousemove", this._whenMouseMoves);
                this.canvas.removeEventListener("mousedown", this._whenMouseIsDown);
                window.removeEventListener("mouseup", this._whenMouseIsUp);
                this.canvas.removeEventListener("touchstart", this._whenTouchIsDown);
                this.canvas.removeEventListener("touchmove", this._whenTouchMoves);
                this.canvas.removeEventListener("touchend", this._whenTouchIsUp);
                this.canvas.removeEventListener("touchcancel", this._whenTouchIsUp);
            };
            this._value = value;
            this._validator = validator;
            this._whenValueChanges = whenValueChanges;
            this._whenMouseUpHappens = whenMouseUpHappens;
            this._shapeFunction = shapeFunction == null ? defaultShapeFunction : shapeFunction;
            this._viewportX0 = viewportX0;
            this._viewportX1 = viewportX1;
            this._canvasWidth = canvasWidth;
            this._canvasHeight = canvasHeight;
            this.canvas = canvas$1({ width: this._canvasWidth, height: this._canvasHeight, style: "cursor: default; position: static; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; outline: 1px solid var(--ui-widget-background); box-sizing: border-box; width: 100%;" });
            this._context = this.canvas.getContext("2d");
            window.addEventListener("mousemove", this._whenMouseMoves);
            this.canvas.addEventListener("mousedown", this._whenMouseIsDown);
            window.addEventListener("mouseup", this._whenMouseIsUp);
            this.canvas.addEventListener("touchstart", this._whenTouchIsDown);
            this.canvas.addEventListener("touchmove", this._whenTouchMoves);
            this.canvas.addEventListener("touchend", this._whenTouchIsUp);
            this.canvas.addEventListener("touchcancel", this._whenTouchIsUp);
        }
    }
    class VisualLoopControlsPrompt {
        constructor(_doc, _songEditor) {
            this._waveformCanvasWidth = 500;
            this._waveformCanvasHeight = 200;
            this._handleCanvasHeight = 20;
            this._instrument = null;
            this._waveformData = null;
            this._waveformDataLength = null;
            this._initialChipWaveLoopMode = null;
            this._initialChipWaveStartOffset = null;
            this._initialChipWaveLoopStart = null;
            this._initialChipWaveLoopEnd = null;
            this._initialChipWavePlayBackwards = null;
            this._chipWaveLoopMode = 0;
            this._chipWaveStartOffset = 0;
            this._chipWaveLoopStart = 0;
            this._chipWaveLoopEnd = 0;
            this._chipWavePlayBackwards = false;
            this._waveformViewportX0 = 0;
            this._waveformViewportX1 = 1;
            this._waveformViewportY0 = -1.01;
            this._waveformViewportY1 = 1.01;
            this._waveformViewportWidth = 1;
            this._waveformViewportOffset = 0;
            this._waveformViewportMaxOffset = 0;
            this._overlayIsMouseDown = false;
            this._overlaySelectionX0 = null;
            this._overlaySelectionX1 = null;
            this._startOffsetValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.floor(v)));
            };
            this._loopStartValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.min(this._chipWaveLoopEnd - 2, Math.floor(v))));
            };
            this._loopEndValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.max(this._chipWaveLoopStart + 2, Math.floor(v))));
            };
            this._startOffsetHandle = new VisualLoopControlsHandle(this._chipWaveStartOffset, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._startOffsetValidator, (v) => {
                this._chipWaveStartOffset = v;
                this._instrument.chipWaveStartOffset = this._chipWaveStartOffset;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const th = h / 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y);
                ctx.lineTo(x + w, y + h - th);
                ctx.lineTo(x + w / 2, y + h);
                ctx.lineTo(x, y + h - th);
                ctx.fill();
            });
            this._loopStartHandle = new VisualLoopControlsHandle(this._chipWaveLoopStart, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._loopStartValidator, (v) => {
                this._chipWaveLoopStart = v;
                this._instrument.chipWaveLoopStart = this._chipWaveLoopStart;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const tw = w / 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w - tw, y);
                ctx.lineTo(x + w, y + h / 2);
                ctx.lineTo(x + w - tw, y + h);
                ctx.lineTo(x, y + h);
                ctx.fill();
            });
            this._loopEndHandle = new VisualLoopControlsHandle(this._chipWaveLoopEnd, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._loopEndValidator, (v) => {
                this._chipWaveLoopEnd = v;
                this._instrument.chipWaveLoopEnd = this._chipWaveLoopEnd;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const tw = w / 4;
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(x + w, y + h);
                ctx.lineTo(x + tw, y + h);
                ctx.lineTo(x, y + h / 2);
                ctx.lineTo(x + tw, y);
                ctx.fill();
            });
            this._chipWaveIsUnavailable = true;
            this._waveformCanvas = canvas$1({ width: this._waveformCanvasWidth, height: this._waveformCanvasHeight, style: "cursor: default; position: static; width: 100%;" });
            this._waveformContext = null;
            this._overlayCanvas = canvas$1({ width: this._waveformCanvasWidth, height: this._waveformCanvasHeight, style: "cursor: default; position: absolute; top: 0; left: 0; width: 100%;" });
            this._overlayContext = null;
            this._waveformContainer = div$4({ style: `position: relative; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; width: 100%; outline: 1px solid ${ColorConfig.uiWidgetBackground};` }, this._waveformCanvas, this._overlayCanvas);
            this._viewportOffsetSlider = input$3({ style: "width: 100%; flex-grow: 1; margin: 0;", type: "range", min: "0", max: "1", value: "0", step: "0.00001" });
            this._zoomInButton = button$4({ type: "button", title: "Zoom In", style: "height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "20", height: "20", viewBox: "-10 -10 20 20", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.circle({ cx: -1, cy: -1, r: 6, "stroke-width": 2, stroke: ColorConfig.primaryText, fill: "none" }), SVG.path({ stroke: ColorConfig.primaryText, "stroke-width": 2, d: "M 3 3 L 7 7 M -1 -4 L -1 2 M -4 -1 L 2 -1", fill: "none" })));
            this._zoomOutButton = button$4({ type: "button", title: "Zoom Out", style: "height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "20", height: "20", viewBox: "-10 -10 20 20", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.circle({ cx: -1, cy: -1, r: 6, "stroke-width": 2, stroke: ColorConfig.primaryText, fill: "none" }), SVG.path({ stroke: ColorConfig.primaryText, "stroke-width": 2, d: "M 3 3 L 7 7 M -4 -1 L 2 -1", fill: "none" })));
            this._zoom100Button = button$4({ type: "button", title: "Zoom 100%", style: "height: var(--button-size); margin-left: 0.5em;" }, "100%");
            this._loopModeSelect = select$3({ style: "width: 100%; flex-grow: 1; margin-left: 0.5em;" }, option$3({ value: 0 }, "Loop"), option$3({ value: 1 }, "Ping-Pong"), option$3({ value: 2 }, "Play Once"), option$3({ value: 3 }, "Play Loop Once"));
            this._startOffsetStepper = input$3({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveStartOffset, min: "0", step: "1" });
            this._loopStartStepper = input$3({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveLoopStart, min: "0", step: "1" });
            this._loopEndStepper = input$3({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveLoopEnd, min: "0", step: "1" });
            this._playBackwardsBox = input$3({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: auto; margin-right: auto;" });
            this._playSongButton = button$4({ style: "width: 55%;", type: "button" });
            this._cancelButton = button$4({ class: "cancelButton" });
            this._okayButton = button$4({ class: "okayButton", style: "width: 25%;" }, "Okay");
            this._sampleIsLoadingMessage = div$4({ style: "margin-bottom: 0.5em; display: none;" }, "Sample is loading");
            this._loopControlsContainer = div$4(div$4({ style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$4({ style: `width: 100%; margin-bottom: 0.5em; text-align: center; color: ${ColorConfig.secondaryText};` }, "You can also zoom by dragging horizontally on the waveform.")), this._startOffsetHandle.canvas, this._waveformContainer, this._loopStartHandle.canvas, this._loopEndHandle.canvas, div$4({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, this._viewportOffsetSlider, this._zoomInButton, this._zoomOutButton, this._zoom100Button), div$4({ style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right: color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop Mode"), this._loopModeSelect), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Offset"), this._startOffsetStepper), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop Start"), this._loopStartStepper), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop End"), this._loopEndStepper), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Backwards"), this._playBackwardsBox), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em; justify-content: center;" }, this._playSongButton)));
            this.container = div$4({ class: "prompt noSelection", style: "width: 500px;" }, div$4(h2$3({ style: "margin-bottom: 0.5em;" }, "Loop Controls"), this._sampleIsLoadingMessage, this._loopControlsContainer, div$4({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton)), this._cancelButton);
            this.gotMouseUp = false;
            this._waveformSampleLookup = (x) => {
                const n = this._waveformDataLength;
                if (x >= 0 && x < n) {
                    return this._waveformData[Math.floor(x)];
                }
                else {
                    return 0;
                }
            };
            this._waveformSamplesLookup = (x0, x1) => {
                const n = this._waveformDataLength;
                const a = Math.max(0, Math.min(n, Math.ceil(x0)));
                const b = Math.max(0, Math.min(n, Math.ceil(x1)));
                if (a >= b)
                    return [0, 0];
                let y0 = this._waveformData[a];
                let y1 = y0;
                for (let i = a + 1; i < b; i++) {
                    const v = this._waveformData[i];
                    y0 = Math.min(y0, v);
                    y1 = Math.max(y1, v);
                }
                return [y0, y1];
            };
            this.cleanUp = () => {
                this._startOffsetHandle.cleanUp();
                this._loopStartHandle.cleanUp();
                this._loopEndHandle.cleanUp();
                this.container.removeEventListener("keydown", this._whenKeyPressed);
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._viewportOffsetSlider.removeEventListener("input", this._whenViewportOffsetSliderChanges);
                this._zoomInButton.removeEventListener("click", this._whenZoomInClicked);
                this._zoomOutButton.removeEventListener("click", this._whenZoomOutClicked);
                this._zoom100Button.removeEventListener("click", this._whenZoom100Clicked);
                this._loopModeSelect.removeEventListener("change", this._whenLoopModeSelectChanges);
                this._startOffsetStepper.removeEventListener("change", this._whenStartOffsetStepperChanges);
                this._loopStartStepper.removeEventListener("change", this._whenLoopStartStepperChanges);
                this._loopEndStepper.removeEventListener("change", this._whenLoopEndStepperChanges);
                this._playBackwardsBox.removeEventListener("input", this._whenPlayBackwardsBoxChanges);
                this._playSongButton.removeEventListener("click", this._togglePlaySong);
                this._overlayCanvas.removeEventListener("mousemove", this._whenOverlayMouseMoves);
                this._overlayCanvas.removeEventListener("mousedown", this._whenOverlayMouseIsDown);
                this._overlayCanvas.removeEventListener("mouseup", this._whenOverlayMouseIsUp);
                this._overlayCanvas.removeEventListener("touchstart", this._whenOverlayTouchIsDown);
                this._overlayCanvas.removeEventListener("touchmove", this._whenOverlayTouchMoves);
                this._overlayCanvas.removeEventListener("touchend", this._whenOverlayTouchIsUp);
                this._overlayCanvas.removeEventListener("touchcancel", this._whenOverlayTouchIsUp);
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this._saveChanges = () => {
                if (!this._chipWaveIsUnavailable) {
                    this._doc.prompt = null;
                    this._instrument.chipWaveLoopMode = this._initialChipWaveLoopMode;
                    this._instrument.chipWaveStartOffset = this._initialChipWaveStartOffset;
                    this._instrument.chipWaveLoopStart = this._initialChipWaveLoopStart;
                    this._instrument.chipWaveLoopEnd = this._initialChipWaveLoopEnd;
                    this._instrument.chipWavePlayBackwards = this._initialChipWavePlayBackwards;
                    const group = new ChangeGroup();
                    group.append(new ChangeChipWaveLoopMode(this._doc, this._chipWaveLoopMode));
                    group.append(new ChangeChipWaveStartOffset(this._doc, this._chipWaveStartOffset));
                    group.append(new ChangeChipWaveLoopStart(this._doc, this._chipWaveLoopStart));
                    group.append(new ChangeChipWaveLoopEnd(this._doc, this._chipWaveLoopEnd));
                    group.append(new ChangeChipWavePlayBackwards(this._doc, this._chipWavePlayBackwards));
                    this._doc.record(group, true);
                }
                else {
                    this._doc.prompt = null;
                    this._doc.undo();
                }
            };
            this._togglePlaySong = () => {
if (this._doc.synth.playing) {
	this._songEditor._pause();
	this.updatePlayButton();
}
else {
	this._doc.synth.snapToBar();
	this._songEditor._play();
	this.updatePlayButton();
}
                this._updatePlaySongButton();
            };
            this._renderWaveform = () => {
                if (this._chipWaveIsUnavailable)
                    return;
                const cnv = this._waveformCanvas;
                const ctx = this._waveformContext;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const vy0 = this._waveformViewportY0;
                const vy1 = this._waveformViewportY1;
                const sampleWidth = (vx1 - vx0) / w;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                ctx.fillRect(0, h / 2, w, 1);
                const waveformColor = ColorConfig.getComputed("--primary-text");
                if (sampleWidth < 1) {
                    ctx.strokeStyle = waveformColor;
                    ctx.lineWidth = 1;
                    let firstMove = true;
                    ctx.beginPath();
                    for (let cx = 0; cx < w; cx++) {
                        const wx = vx0 + cx * sampleWidth;
                        const wy = this._waveformSampleLookup(wx);
                        const cy = h - (wy - vy0) * h / (vy1 - vy0);
                        if (firstMove) {
                            ctx.moveTo(cx, cy);
                            firstMove = false;
                        }
                        else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    ctx.stroke();
                }
                else {
                    ctx.fillStyle = waveformColor;
                    let pcy0 = null;
                    let pcy1 = null;
                    for (let cx = 0; cx < w; cx++) {
                        const wx = vx0 + cx * sampleWidth;
                        const [wy0, wy1] = this._waveformSamplesLookup(wx - sampleWidth / 2, wx + sampleWidth / 2);
                        const cy0 = Math.max(-1, Math.min(h, h - (wy1 - vy0) * h / (vy1 - vy0)));
                        const cy1 = Math.max(-1, Math.min(h, h - (wy0 - vy0) * h / (vy1 - vy0)));
                        const cy0i = Math.floor(cy0);
                        const cy1i = Math.max(Math.ceil(cy1), cy0i + 1);
                        const ocy0 = pcy1 == null ? cy0i : Math.min(cy0i, pcy1);
                        const ocy1 = pcy0 == null ? cy1i : Math.max(cy1i, pcy0);
                        const bh = Math.max(1, ocy1 - ocy0);
                        ctx.fillRect(cx, ocy0, 1, bh);
                        pcy0 = ocy0;
                        pcy1 = ocy1;
                    }
                }
            };
            this._renderOverlay = () => {
                const cnv = this._overlayCanvas;
                const ctx = this._overlayContext;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const so = this._chipWaveStartOffset;
                const ls = this._chipWaveLoopStart;
                const le = this._chipWaveLoopEnd;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                const obx = Math.floor((so - vx0) * w / (vx1 - vx0));
                const oby = 0;
                const obw = 1;
                const obh = h;
                ctx.fillRect(obx, oby, obw, obh);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                ctx.globalAlpha = 0.5;
                const lbx0 = Math.floor((ls - vx0) * w / (vx1 - vx0));
                const lbx1 = Math.floor((le - vx0) * w / (vx1 - vx0));
                const lbx = lbx0;
                const lby = 0;
                const lbw = lbx1 - lbx0;
                const lbh = h;
                ctx.fillRect(lbx, lby, lbw, lbh);
                ctx.globalAlpha = 1;
                if (this._overlaySelectionX0 != null && this._overlaySelectionX1 != null) {
                    ctx.fillStyle = ColorConfig.getComputed("--box-selection-fill");
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(this._overlaySelectionX0, 0, this._overlaySelectionX1 - this._overlaySelectionX0, h);
                    ctx.globalAlpha = 1;
                }
            };
            this._reconfigureLoopControls = () => {
                this._loopModeSelect.value = "" + this._chipWaveLoopMode;
                this._startOffsetStepper.value = "" + this._chipWaveStartOffset;
                this._loopStartStepper.value = "" + this._chipWaveLoopStart;
                this._loopEndStepper.value = "" + this._chipWaveLoopEnd;
                this._playBackwardsBox.checked = this._chipWavePlayBackwards;
            };
            this._whenViewportOffsetSliderChanges = (event) => {
                const rawOffset = Math.max(0, Math.min(1, +event.target.value));
                const newViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, rawOffset * this._waveformViewportMaxOffset));
                this._waveformViewportOffset = Math.min(this._waveformViewportMaxOffset, newViewportOffset);
                this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoomInClicked = (event) => {
                const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, this._waveformViewportWidth / 2));
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                const centerX = this._waveformViewportX0 + (this._waveformCanvasWidth / 2) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX - (this._waveformCanvasWidth / 2) * this._waveformViewportWidth / this._waveformCanvasWidth));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoomOutClicked = (event) => {
                const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, this._waveformViewportWidth * 2));
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                const centerX = this._waveformViewportX0 + (this._waveformCanvasWidth / 2) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX - (this._waveformCanvas.width / 2) * this._waveformViewportWidth / this._waveformCanvasWidth));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                if (this._waveformViewportWidth === this._waveformDataLength) {
                    this._viewportOffsetSlider.value = "0";
                }
                else {
                    this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                }
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoom100Clicked = (event) => {
                const newViewportWidth = this._waveformDataLength;
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, 0));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                if (this._waveformViewportWidth === this._waveformDataLength) {
                    this._viewportOffsetSlider.value = "0";
                }
                else {
                    this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                }
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenLoopModeSelectChanges = (event) => {
                const element = event.target;
                const newValue = +element.value;
                this._chipWaveLoopMode = newValue;
                this._instrument.chipWaveLoopMode = this._chipWaveLoopMode;
            };
            this._whenStartOffsetStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._startOffsetValidator(+element.value);
                this._chipWaveStartOffset = newValue;
                this._instrument.chipWaveStartOffset = this._chipWaveStartOffset;
                element.value = "" + newValue;
                this._startOffsetHandle.update(newValue);
                this._startOffsetHandle.render();
                this._renderOverlay();
            };
            this._whenLoopStartStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._loopStartValidator(+element.value);
                this._chipWaveLoopStart = newValue;
                this._instrument.chipWaveLoopStart = this._chipWaveLoopStart;
                element.value = "" + newValue;
                this._loopStartHandle.update(newValue);
                this._loopStartHandle.render();
                this._renderOverlay();
            };
            this._whenLoopEndStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._loopEndValidator(+element.value);
                this._chipWaveLoopEnd = newValue;
                this._instrument.chipWaveLoopEnd = this._chipWaveLoopEnd;
                element.value = "" + newValue;
                this._loopEndHandle.update(newValue);
                this._loopEndHandle.render();
                this._renderOverlay();
            };
            this._whenPlayBackwardsBoxChanges = (event) => {
                const element = event.target;
                const newValue = element.checked;
                this._chipWavePlayBackwards = newValue;
                this._instrument.chipWavePlayBackwards = this._chipWavePlayBackwards;
            };
            this._whenOverlayMouseMoves = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayMouseIsDown = (event) => {
                this._overlayIsMouseDown = true;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX0 = mx;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayMouseIsUp = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
                this._overlayIsMouseDown = false;
                const w = this._overlayCanvas.width;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._overlaySelectionX0 = Math.max(0, Math.min(w, this._overlaySelectionX0));
                this._overlaySelectionX1 = Math.max(0, Math.min(w, this._overlaySelectionX1));
                if (this._overlaySelectionX0 > this._overlaySelectionX1) {
                    const t = this._overlaySelectionX0;
                    this._overlaySelectionX0 = this._overlaySelectionX1;
                    this._overlaySelectionX1 = t;
                }
                let zoomAreaIsTooSmall = false;
                if (this._overlaySelectionX1 - this._overlaySelectionX0 > 2) {
                    const wosx0 = vx0 + this._overlaySelectionX0 * (vx1 - vx0) / w;
                    const wosx1 = vx0 + this._overlaySelectionX1 * (vx1 - vx0) / w;
                    const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, wosx1 - wosx0));
                    this._waveformViewportWidth = newViewportWidth;
                    this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                    const centerX = vx0 + (this._overlaySelectionX0) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                    this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX));
                    this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                    this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                    if (this._waveformViewportWidth === this._waveformDataLength) {
                        this._viewportOffsetSlider.value = "0";
                    }
                    else {
                        this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                    }
                }
                else {
                    zoomAreaIsTooSmall = true;
                }
                this._overlaySelectionX0 = null;
                this._overlaySelectionX1 = null;
                if (!zoomAreaIsTooSmall) {
                    this._propagateViewportUpdate();
                    this._render();
                }
                this._renderOverlay();
            };
            this._whenOverlayTouchIsDown = (event) => {
                event.preventDefault();
                this._overlayIsMouseDown = true;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                this._overlaySelectionX0 = mx;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayTouchMoves = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                event.preventDefault();
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayTouchIsUp = (event) => {
                event.preventDefault();
                if (!this._overlayIsMouseDown)
                    return;
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
                this._overlayIsMouseDown = false;
                const w = this._overlayCanvas.width;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                this._overlaySelectionX0 = Math.max(0, Math.min(w, this._overlaySelectionX0));
                this._overlaySelectionX1 = Math.max(0, Math.min(w, this._overlaySelectionX1));
                if (this._overlaySelectionX0 > this._overlaySelectionX1) {
                    const t = this._overlaySelectionX0;
                    this._overlaySelectionX0 = this._overlaySelectionX1;
                    this._overlaySelectionX1 = t;
                }
                let zoomAreaIsTooSmall = false;
                if (this._overlaySelectionX1 - this._overlaySelectionX0 > 2) {
                    const wosx0 = vx0 + this._overlaySelectionX0 * (vx1 - vx0) / w;
                    const wosx1 = vx0 + this._overlaySelectionX1 * (vx1 - vx0) / w;
                    const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, wosx1 - wosx0));
                    this._waveformViewportWidth = newViewportWidth;
                    this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                    const centerX = vx0 + (this._overlaySelectionX0) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                    this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX));
                    this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                    this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                    if (this._waveformViewportWidth === this._waveformDataLength) {
                        this._viewportOffsetSlider.value = "0";
                    }
                    else {
                        this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                    }
                }
                else {
                    zoomAreaIsTooSmall = true;
                }
                this._overlaySelectionX0 = null;
                this._overlaySelectionX1 = null;
                if (!zoomAreaIsTooSmall) {
                    this._propagateViewportUpdate();
                    this._render();
                }
                this._renderOverlay();
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlaySong();
                    event.preventDefault();
                }
            };
            this._updatePlaySongButton = () => {
                if (this._doc.synth.playing) {
                    this._playSongButton.classList.remove("playButton");
                    this._playSongButton.classList.add("pauseButton");
                    this._playSongButton.title = "Pause (Space)";
                    this._playSongButton.innerText = "Pause";
                }
                else {
                    this._playSongButton.classList.remove("pauseButton");
                    this._playSongButton.classList.add("playButton");
                    this._playSongButton.title = "Play (Space)";
                    this._playSongButton.innerText = "Play";
                }
            };
            this._propagateViewportUpdate = () => {
                this._startOffsetHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
                this._loopStartHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
                this._loopEndHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
            };
            this._render = () => {
                if (this._chipWaveIsUnavailable)
                    return;
                this._renderWaveform();
                this._startOffsetHandle.render();
                this._loopStartHandle.render();
                this._loopEndHandle.render();
                this._renderOverlay();
            };
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._waveformContext = this._waveformCanvas.getContext("2d");
            this._overlayContext = this._overlayCanvas.getContext("2d");
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const rawChipWave = Config.chipWaves[this._instrument.chipWave];
            const customSampleIsLoading = (rawChipWave.isCustomSampled === true || rawChipWave.isSampled == true)
 
                 
                this._loopControlsContainer.style.display = "";
                this._chipWaveIsUnavailable = false;
                this._waveformData = rawChipWave.samples;
                this._waveformDataLength = this._waveformData.length - 1;
                this._initialChipWaveLoopMode = this._instrument.chipWaveLoopMode;
                this._initialChipWaveStartOffset = this._instrument.chipWaveStartOffset;
                this._initialChipWaveLoopStart = this._instrument.chipWaveLoopStart;
                this._initialChipWaveLoopEnd = this._instrument.chipWaveLoopEnd;
                this._initialChipWavePlayBackwards = this._instrument.chipWavePlayBackwards;
                this._chipWaveLoopMode = this._initialChipWaveLoopMode;
                this._chipWaveStartOffset = this._initialChipWaveStartOffset;
                this._chipWaveLoopStart = this._initialChipWaveLoopStart;
                this._chipWaveLoopEnd = this._initialChipWaveLoopEnd;
                this._chipWavePlayBackwards = this._initialChipWavePlayBackwards;
                const verticalBounds = this._waveformSamplesLookup(0, this._waveformDataLength);
                const maxVerticalBound = Math.max(Math.abs(verticalBounds[0]), Math.abs(verticalBounds[1])) + 0.01;
                verticalBounds[0] = -maxVerticalBound;
                verticalBounds[1] = maxVerticalBound;
                this._waveformViewportX0 = 0;
                this._waveformViewportX1 = this._waveformDataLength;
                this._waveformViewportY0 = verticalBounds[0];
                this._waveformViewportY1 = verticalBounds[1];
                this._waveformViewportWidth = this._waveformViewportX1 - this._waveformViewportX0;
                this._waveformViewportOffset = 0;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                this._startOffsetHandle.update(this._chipWaveStartOffset);
                this._loopStartHandle.update(this._chipWaveLoopStart);
                this._loopEndHandle.update(this._chipWaveLoopEnd);
                this._propagateViewportUpdate();
            
            this._updatePlaySongButton();
            this._render();
            this._reconfigureLoopControls();
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._viewportOffsetSlider.addEventListener("input", this._whenViewportOffsetSliderChanges);
            this._zoomInButton.addEventListener("click", this._whenZoomInClicked);
            this._zoomOutButton.addEventListener("click", this._whenZoomOutClicked);
            this._zoom100Button.addEventListener("click", this._whenZoom100Clicked);
            this._loopModeSelect.addEventListener("change", this._whenLoopModeSelectChanges);
            this._startOffsetStepper.addEventListener("change", this._whenStartOffsetStepperChanges);
            this._loopStartStepper.addEventListener("change", this._whenLoopStartStepperChanges);
            this._loopEndStepper.addEventListener("change", this._whenLoopEndStepperChanges);
            this._playBackwardsBox.addEventListener("input", this._whenPlayBackwardsBoxChanges);
            this._playSongButton.addEventListener("click", this._togglePlaySong);
            window.addEventListener("mousemove", this._whenOverlayMouseMoves);
            this._overlayCanvas.addEventListener("mousedown", this._whenOverlayMouseIsDown);
            window.addEventListener("mouseup", this._whenOverlayMouseIsUp);
            this._overlayCanvas.addEventListener("touchstart", this._whenOverlayTouchIsDown);
            this._overlayCanvas.addEventListener("touchmove", this._whenOverlayTouchMoves);
            this._overlayCanvas.addEventListener("touchend", this._whenOverlayTouchIsUp);
            this._overlayCanvas.addEventListener("touchcancel", this._whenOverlayTouchIsUp);
        }
        
        updatePlayButton() {
}
    }

    const { button: button$9, div: div$9, span: span$3, h2: h2$9, input: input$7, br: br$3, select: select$3, option: option$3 } = HTML;
    class SongDurationPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._barsStepper = input$7({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._positionSelect = select$3({ style: "width: 100%;" }, option$3({ value: "end" }, "Apply change at end of song."), option$3({ value: "beginning" }, "Apply change at beginning of song."));
            this._cancelButton = button$9({ class: "cancelButton" });
            this._okayButton = button$9({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$9({ class: "prompt noSelection", style: "width: 250px;" }, h2$9("Song Length"), div$9({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$9({ style: "display: inline-block; text-align: right;" }, "Bars per song:", br$3(), span$3({ style: `font-size: smaller; color: ${ColorConfig.secondaryText};` }, "(Multiples of 4 are recommended)")), this._barsStepper), div$9({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$9({ class: "selectContainer", style: "width: 100%;" }, this._positionSelect)), div$9({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._barsStepper.removeEventListener("keypress", SongDurationPrompt._validateKey);
                this._barsStepper.removeEventListener("blur", SongDurationPrompt._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("barCountPosition", this._positionSelect.value);
                const group = new ChangeGroup();
                group.append(new ChangeBarCount(this._doc, SongDurationPrompt._validate(this._barsStepper), this._positionSelect.value == "beginning"));
                this._doc.prompt = null;
                this._doc.record(group, true);
            };
            this._barsStepper.value = this._doc.song.barCount + "";
            this._barsStepper.min = Config.barCountMin + "";
            this._barsStepper.max = Config.barCountMax + "";
            const lastPosition = window.localStorage.getItem("barCountPosition");
            if (lastPosition != null) {
                this._positionSelect.value = lastPosition;
            }
            this._barsStepper.select();
            setTimeout(() => this._barsStepper.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._barsStepper.addEventListener("keypress", SongDurationPrompt._validateKey);
            this._barsStepper.addEventListener("blur", SongDurationPrompt._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        static _validateKey(event) {
            const charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 46 && charCode > 31 && (charCode < 48 || charCode > 57)) {
                event.preventDefault();
                return true;
            }
            return false;
        }
        static _validateNumber(event) {
            const input = event.target;
            input.value = String(SongDurationPrompt._validate(input));
        }
        static _validate(input) {
            return Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value))));
        }
    }

    const versionPrefix = "songVersion: ";
    const maximumSongCount = 8;
    const maximumWorkPerVersion = 3 * 60 * 1000;
    const minimumWorkPerSpan = 1 * 60 * 1000;
    function keyIsVersion(key) {
        return key.indexOf(versionPrefix) == 0;
    }
    function keyToVersion(key) {
        return JSON.parse(key.substring(versionPrefix.length));
    }
    function versionToKey(version) {
        return versionPrefix + JSON.stringify(version);
    }
    function generateUid() {
        return ((Math.random() * (-1 >>> 0)) >>> 0).toString(32);
    }
    function compareSongs(a, b) {
        return b.versions[0].time - a.versions[0].time;
    }
    function compareVersions(a, b) {
        return b.time - a.time;
    }
    class SongRecovery {
        constructor() {
            this._song = new Song();
        }
        
        static getAllRecoveredSongs() {
            const songs = [];
            const songsByUid = {};
            for (let i = 0; i < localStorage.length; i++) {
                const itemKey = localStorage.key(i);
                if (keyIsVersion(itemKey)) {
                    const version = keyToVersion(itemKey);
                    let song = songsByUid[version.uid];
                    if (song == undefined) {
                        song = { versions: [] };
                        songsByUid[version.uid] = song;
                        songs.push(song);
                    }
                    song.versions.push(version);
                }
            }
            for (const song of songs) {
                song.versions.sort(compareVersions);
            }
            songs.sort(compareSongs);
            return songs;
        }
        
        saveVersion(uid, name, songData) {
            const newName = name;
            const newTime = Math.round(Date.now());
            clearTimeout(this._saveVersionTimeoutHandle);
            this._saveVersionTimeoutHandle = setTimeout(() => {
            //    try {
                    this._song.fromBase64String(songData);
             /*   }
                catch (error) {
                    window.alert("Whoops, the song data appears to have been corrupted! Please try to recover the last working version of the song from the \"Recover Recent Song...\" option in BeepBox's \"File\" menu.");
                    window.alert(error);
                    return;
                }*/
                const songs = SongRecovery.getAllRecoveredSongs();
                let currentSong = null;
                for (const song of songs) {
                    if (song.versions[0].uid == uid) {
                        currentSong = song;
                    }
                }
                if (currentSong == null) {
                    currentSong = { versions: [] };
                    songs.unshift(currentSong);
                }
                let versions = currentSong.versions;
                let newWork = 1000;
                if (versions.length > 0) {
                    const mostRecentTime = versions[0].time;
                    const mostRecentWork = versions[0].work;
                    newWork = mostRecentWork + Math.min(maximumWorkPerVersion, newTime - mostRecentTime);
                }
                const newVersion = { uid: uid, name: newName, time: newTime, work: newWork };
                const newKey = versionToKey(newVersion);
                versions.unshift(newVersion);
                localStorage.setItem(newKey, songData);
                let minSpan = minimumWorkPerSpan;
                const spanMult = Math.pow(2, 1 / 2);
                for (var i = 1; i < versions.length; i++) {
                    const currentWork = versions[i].work;
                    const olderWork = (i == versions.length - 1) ? 0.0 : versions[i + 1].work;
                    if (currentWork - olderWork < minSpan) {
                        let indexToDiscard = i;
                        if (i < versions.length - 1) {
                            const currentTime = versions[i].time;
                            const newerTime = versions[i - 1].time;
                            const olderTime = versions[i + 1].time;
                            if ((currentTime - olderTime) < 0.5 * (newerTime - currentTime)) {
                                indexToDiscard = i + 1;
                            }
                        }
                        localStorage.removeItem(versionToKey(versions[indexToDiscard]));
                        break;
                    }
                    minSpan *= spanMult;
                }
                while (songs.length > maximumSongCount) {
                    let leastImportantSong = null;
                    let leastImportance = Number.POSITIVE_INFINITY;
                    for (let i = Math.round(maximumSongCount / 2); i < songs.length; i++) {
                        const song = songs[i];
                        const timePassed = newTime - song.versions[0].time;
                        const timeScale = 1.0 / ((timePassed / (12 * 60 * 60 * 1000)) + 1.0);
                        const adjustedWork = song.versions[0].work + 5 * 60 * 1000;
                        const weight = adjustedWork * timeScale;
                        if (leastImportance > weight) {
                            leastImportance = weight;
                            leastImportantSong = song;
                        }
                    }
                    for (const version of leastImportantSong.versions) {
                        localStorage.removeItem(versionToKey(version));
                    }
                    songs.splice(songs.indexOf(leastImportantSong), 1);
                }
            }, 750);
        }
    }

    const { button: button$a, div: div$a, h2: h2$a, p: p$1, select: select$4, option: option$4, iframe } = HTML;
    class SongRecoveryPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._songContainer = div$a();
            this._cancelButton = button$a({ class: "cancelButton" });
            this.container = div$a({ class: "prompt", style: "width: 300px;" }, h2$a("Song Recovery"), div$a({ style: "max-height: 385px; overflow-y: auto;" }, p$1("This is a TEMPORARY list of songs you have recently modified. Please keep your own backups of songs you care about!"), this._songContainer, p$1("(If \"Display Song Data in URL\" is enabled in your preferences, then you may also be able to find song versions in your browser history. However, song recovery won't work if you were browsing in private/incognito mode.)")), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._cancelButton.removeEventListener("click", this._close);
            };
            this._cancelButton.addEventListener("click", this._close);
            const songs = SongRecovery.getAllRecoveredSongs();
            if (songs.length == 0) {
                this._songContainer.appendChild(p$1("There are no recovered songs available yet. Try making a song!"));
            }
            for (const song of songs) {
                const versionMenu = select$4({ style: "width: 100%;" });
                for (const version of song.versions) {
                    versionMenu.appendChild(option$4({ value: version.time }, version.name + ": " + new Date(version.time).toLocaleString()));
                }
                const player = iframe({ style: "width: 100%; height: 60px; border: none; display: block;" });
                player.src = "player/#song=" + window.localStorage.getItem(versionToKey(song.versions[0]));
                const container = div$a({ style: "margin: 4px 0;" }, div$a({ class: "selectContainer", style: "width: 100%; margin: 2px 0;" }, versionMenu), player);
                this._songContainer.appendChild(container);
                versionMenu.addEventListener("change", () => {
                    const version = song.versions[versionMenu.selectedIndex];
                    player.contentWindow.location.replace("player/#song=" + window.localStorage.getItem(versionToKey(version)));
                    player.contentWindow.dispatchEvent(new Event("hashchange"));
                });
            }
        }
    }

    class SpectrumEditor {
        constructor(_doc, _spectrumIndex) {
            this._doc = _doc;
            this._spectrumIndex = _spectrumIndex;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._fill = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._octaves = SVG.svg({ "pointer-events": "none" });
            this._fifths = SVG.svg({ "pointer-events": "none" });
            this._curve = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 2, "pointer-events": "none" });
            this._arrow = SVG.path({ fill: "currentColor", "pointer-events": "none" });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._fill, this._octaves, this._fifths, this._curve, this._arrow);
            this.container = HTML.div({ class: "spectrum", style: "height: 100%;" }, this._svg);
            this._mouseX = 0;
            this._mouseY = 0;
            this._freqPrev = 0;
            this._ampPrev = 0;
            this._mouseDown = false;
            this._change = null;
            this._renderedPath = "";
            this._renderedFifths = true;
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (this._mouseDown) {
                    this._doc.record(this._change);
                    this._change = null;
                }
                this._mouseDown = false;
            };
            for (let i = 0; i < Config.spectrumControlPoints; i += Config.spectrumControlPointsPerOctave) {
                this._octaves.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i + 1) * this._editorWidth / (Config.spectrumControlPoints + 2) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 4; i <= Config.spectrumControlPoints; i += Config.spectrumControlPointsPerOctave) {
                this._fifths.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i + 1) * this._editorWidth / (Config.spectrumControlPoints + 2) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _xToFreq(x) {
            return (Config.spectrumControlPoints + 2) * x / this._editorWidth - 1;
        }
        _yToAmp(y) {
            return Config.spectrumMax * (1 - (y - 1) / (this._editorHeight - 2));
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                const freq = this._xToFreq(this._mouseX);
                const amp = this._yToAmp(this._mouseY);
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                const spectrumWave = (this._spectrumIndex == null) ? instrument.spectrumWave : instrument.drumsetSpectrumWaves[this._spectrumIndex];
                if (freq != this._freqPrev) {
                    const slope = (amp - this._ampPrev) / (freq - this._freqPrev);
                    const offset = this._ampPrev - this._freqPrev * slope;
                    const lowerFreq = Math.ceil(Math.min(this._freqPrev, freq));
                    const upperFreq = Math.floor(Math.max(this._freqPrev, freq));
                    for (let i = lowerFreq; i <= upperFreq; i++) {
                        if (i < 0 || i >= Config.spectrumControlPoints)
                            continue;
                        spectrumWave.spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(i * slope + offset)));
                    }
                }
                spectrumWave.spectrum[Math.max(0, Math.min(Config.spectrumControlPoints - 1, Math.round(freq)))] = Math.max(0, Math.min(Config.spectrumMax, Math.round(amp)));
                this._freqPrev = freq;
                this._ampPrev = amp;
                this._change = new ChangeSpectrum(this._doc, instrument, spectrumWave);
                this._doc.setProspectiveChange(this._change);
            }
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const spectrumWave = (this._spectrumIndex == null) ? instrument.spectrumWave : instrument.drumsetSpectrumWaves[this._spectrumIndex];
            const controlPointToHeight = (point) => {
                return (1 - (point / Config.spectrumMax)) * (this._editorHeight - 1) + 1;
            };
            let lastValue = 0;
            let path = "M 0 " + prettyNumber(this._editorHeight) + " ";
            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                let nextValue = spectrumWave.spectrum[i];
                if (lastValue != 0 || nextValue != 0) {
                    path += "L ";
                }
                else {
                    path += "M ";
                }
                path += prettyNumber((i + 1) * this._editorWidth / (Config.spectrumControlPoints + 2)) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                lastValue = nextValue;
            }
            const lastHeight = controlPointToHeight(lastValue);
            if (lastValue > 0) {
                path += "L " + (this._editorWidth - 1) + " " + prettyNumber(lastHeight) + " ";
            }
            if (this._renderedPath != path) {
                this._renderedPath = path;
                this._curve.setAttribute("d", path);
                this._fill.setAttribute("d", path + "L " + this._editorWidth + " " + prettyNumber(lastHeight) + " L " + this._editorWidth + " " + prettyNumber(this._editorHeight) + " L 0 " + prettyNumber(this._editorHeight) + " z ");
                this._arrow.setAttribute("d", "M " + this._editorWidth + " " + prettyNumber(lastHeight) + " L " + (this._editorWidth - 4) + " " + prettyNumber(lastHeight - 4) + " L " + (this._editorWidth - 4) + " " + prettyNumber(lastHeight + 4) + " z");
                this._arrow.style.display = (lastValue > 0) ? "" : "none";
            }
            if (this._renderedFifths != this._doc.showFifth) {
                this._renderedFifths = this._doc.showFifth;
                this._fifths.style.display = this._doc.showFifth ? "" : "none";
            }
        }
    }

    const { button: button$b, div: div$b, h2: h2$b, select: select$5, option: option$5 } = HTML;
    
    
updateThemes = function() {
	if (filesMap) {
		ColorConfig.themes = { ...ColorConfig.themes, ...CustomThemes };
	}
}
updateThemes()
    class ThemePrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._themeSelect = select$5({ style: "width: 100%;" }, option$5({ value: "FruityBox" }, "FruityBox Dark"),option$5({ value: "FruityBox Dark" }, "FruityBox Darker"),
            option$5({ value: "FruityBoxLight" }, "FruityBox Light"),option$5({ value: "dark classic" }, "BeepBox Dark"), option$5({ value: "light classic" }, "BeepBox Light"), option$5({ value: "dark competition" }, "BeepBox Competition Dark"), option$5({ value: "jummbox classic" }, "JummBox Dark"), option$5({ value: "paandorasbox" }, "Paandora's Box"), option$5({ value: "forest" }, "Forest"), option$5({ value: "canyon" }, "Canyon"), option$5({ value: "midnight" }, "Midnight"), option({ value: "beachcombing" }, "Beachcombing"),
		option$5({ value: "violet verdant" }, "Violet Verdant"),
		
		option$5({ value: "sunset" }, "Sunset"),
		option$5({ value: "autumn" }, "Autumn"),
		option$5({ value: "fruit" }, "Shadowfruit"),
		option$5({ value: "toxic" }, "Toxic"),
		option$5({ value: "roe" }, "Roe"),
		option$5({ value: "moonlight" }, "Moonlight"),
		option$5({ value: "portal" }, "Portal"),
		option$5({ value: "fusion" }, "Fusion"),
		option$5({ value: "inverse" }, "Inverse"),
		option$5({ value: "nebula" }, "Nebula"),
		option$5({ value: "roe light" }, "Roe Light"),
		option$5({ value: "funky" }, "Funky"),
		option$5({ value: "funkylight" }, "Funky Light"),
		option$5({ value: "githubdark" }, "Github DarK"),
        option$5({ value: "mirage" }, "Mirage"),
        option$5({ value: "Mirage" }, "Mirage2"),
        option$5({ value: "dark-monoKai" }, "MonoKai"),
        option$5({ value: "dark-dracula" }, "Dracula"),
         
        option$5({ value: "rainbow" }, "Rainbow"),
        option$5({ value: "neon" }, "Neon"),
        option$5({ value: "greenish" }, "Greenish Dark"),
        option$5({ value: "yellowed" }, "Yellow Light"),
        option$5({ value: "coolblue" }, "Cool Blue"),
        option$5({ value: "energized" }, "Energized"),
        option$5({ value: "microbox" }, "MicroBox"),
        option$5({ value: "nerdbox" }, "NerdBox"),
        option$5({ value: "sandbox classic" }, "SandBox"),
	option({ value: "blutonium" }, "Blutonium"),
	option({ value: "poly" }, "Poly"),
	option({ value: "moonlight" }, "MoonLight"),
        option$5({ value: "WinterIsComing" }, "WinterIsComing"),
        option$5({ value: "grayscale" }, "GrayScale"),
        option$5({ value: "VintageSepia" }, "Sepia"),
        option$5({ value: "TimeForVacation" }, "TimeForVacation Light"),
        option$5({ value: "coollime" }, "Cool Lime"),
        option$5({ value: "coolred" }, "Cool Red"),
        option$5({ value: "matrix" }, "Matrix"),
        option$5({ value: "typebox" }, "Typebox"),
option$5({ value: "Synthwave" }, "Synthwave"),
option({ value: "ToxicGlow" }, "Toxic Glow"),
option$5({ value: "Inferno" }, "Inferno"),
option$5({ value: "Halloween" }, "Halloween"),
option$5({ value: "Paper" }, "Paper"),
option$5({ value: "Void" }, "Void"),
option$5({ value: "DreamyPink" }, "DreamyPink"),
option$5({ value: "Rock" }, "Rock"),
 option({ value: "CyberPunk" }, "CyberPunk"),
option$5({ value: "FioletPower" }, "Fiolet"),
option$5({ value: "axobox" }, "AxoBox"),
option({ value: "copperblue" }, "CopperBlue"),
option({ value: "copper" }, "CopperColor"),
option({ value: "slushie" }, "Slushie"),
 option({ value: "TheOrange" }, "The Orange"),
 option({ value: "Dirty" }, "Dirty"),
 option({ value: "Moai" }, "Moai"),
 option({ value: "Steel" }, "Steel"),
 option({ value: "Texture" }, "Texture"),
            )
            
const existingThemeValues = new Set(
		Array.from(this._themeSelect.options).map(opt => opt.value)
	);
	const newOptions = Object.keys(ColorConfig.themes)
		.filter(key => !existingThemeValues.has(key))
		.map(key => option$5({ value: key }, ColorConfig.themes[key].name || key));
	this._themeSelect.append(...newOptions);

            
            this._cancelButton = button$b({ class: "cancelButton" });
            this._okayButton = button$b({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$b({ class: "prompt noSelection", style: "width: 220px;" }, h2$b("Set Theme"), div$b({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$b({ class: "selectContainer", style: "width: 100%;" }, this._themeSelect)), div$b({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this.lastTheme = window.localStorage.getItem("colorTheme");
            this._close = () => {
                if (this.lastTheme != null) {
                    ColorConfig.setTheme(this.lastTheme);
                }
                else {
                    ColorConfig.setTheme("dark classic");
                }
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("colorTheme", this._themeSelect.value);
                this._doc.prompt = null;
                this._doc.colorTheme = this._themeSelect.value;
                 
function setPlayheadColorToFboxes() {
  const playheadColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-text').trim();
  const fboxes = document.querySelectorAll('.fbox');
  fboxes.forEach(fbox => {
    fbox.style.color = playheadColor;
  });
}
setPlayheadColorToFboxes();

                this._doc.undo();
            };
            this._previewTheme = () => {
                ColorConfig.setTheme(this._themeSelect.value);
                this._doc.notifier.changed();
            };
            if (this.lastTheme != null) {
                this._themeSelect.value = this.lastTheme;
            }
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._themeSelect.addEventListener("change", this._previewTheme);
        }
    }

    const { button: button$c, div: div$c, p: p$2, h2: h2$c, h3 } = HTML;
    class TipPrompt {
    constructor(_doc, type) {
        this._doc = _doc;
        this._closeButton = button({ class: "cancelButton" });
        this._close = () => {
            this._doc.undo();
        };
        this.cleanUp = () => {
            this._closeButton.removeEventListener("click", this._close);
        };
        let message;
        switch (type) {
            case "scale":
                {
                    message = div(h2("Scale"), p("This setting limits the available pitches for adding notes. You may think that there's no point in limiting your choices, but the set of pitches you use has a strong influence on the mood and feel of your song, and these scales serve as guides to help you choose appropriate pitches. Don't worry, you can change the scale at any time, so you're not locked into it. Try making little melodies using all the available pitches of a scale to get a sense for how it sounds."), p("The most common scales are major and minor. Assuming your song uses all pitches in the scale and especially \"tonic\" pitches (the purple rows in the pattern editor) then major scales tend to sound more playful or optimistic, whereas minor scales sound more serious or sad."));
                }
                break;
            case "key":
                {
                    message = div(h2("Song Key"), p("This setting can shift the frequency of every note in your entire song up or down, keeping the \"tonic\" pitches (the brown rows in the pattern editor) aligned with the selected \"key\" pitch."), p("If you've already placed some notes but they don't emphasize \"tonic\" pitches then the selected key isn't very meaningful. You can select the \"Detect Key\" option in the key menu to automatically align the most emphasized notes with \"tonic\" pitches."));
                }
                break;
            case "key_octave":
                {
                    message = div(h2("Octave"), p("This setting can shift the \"key\" by an octave, allowing you to use a B- or C+ key."), p(`This goes from ${Config.octaveMin} to ${Config.octaveMax}.`));
                }
                break;
            case "tempo":
                {
                    message = div(h2("Song Tempo"), p("This setting controls the speed of your song, measured in beats-per-minute. A \"beat\" is the duration of the little gray rectangles in the pattern editor. (In conventional music notation, a \"quarter note\" is usually equivalent to \"beat\".)"));
                }
                break;
            case "reverb":
                {
                    message = div(h2("Reverb"), p("Reverb is like a continuous echo effect. A little bit helps instruments sound more natural. Adding a lot of reverb can add sense of depth or mystery, but too much reverb can kinda \"smear\" sounds so that it's harder to distinguish notes or instruments, especially for lower \"bass\" notes."));
                }
                break;
            case "rhythm":
                {
                    message = div(h2("Rhythm"), p("This setting determines how beats are divided. The pattern editor helps you align notes to fractions of a beat based on this setting."), p("If you've already placed some notes but they don't align with the selected rhythm, you can select the \"Snap Notes To Rhythm\" option in the rhythm menu to force the notes in the currently selected pattern(s) to align with the selected rhythm."));
                }
                break;
            case "instrumentIndex":
                {
                    message = div(h2("Instrument Number"), p("In the \"Channel Settings\" option from Fruitybox's \"Edit\" menu, there are a few ways to enable multiple instruments per channel."), p("First, you could enable multiple simultaneous instruments per channel. All of the channel's instruments will play all of the notes in the channel at the same time, and you can click an instrument number to view and edit its settings."), p("Second, you could enable different instruments per pattern. Only one of the instruments will play at any given time, but you can click the instrument number to change which instrument is used for the currently selected pattern(s)."), p("Finally, you can enable them both, in which case you can click an instrument number once to view it, and again to toggle whether the instrument is used for the currently selected pattern(s)."), p("Either way, you can click the + button to add more instruments to a channel, and you can press shift and a number key on your keyboard to select an instrument as if you had clicked the corresponding button here."));
                }
                break;
            case "instrumentVolume":
                {
                    message = div(h2("Instrument Volume"), p("This setting controls the volume of the selected instrument without affecting the volume of the other instruments. This allows you to balance the loudness of each instrument relative to each other."), p("Please be careful when using volume settings above 0. This indicates amplification and too much of that can trip the audio limiter built into this tool. This can lead to your song sounding muffled if overused. But when used carefully, amplification can be a powerful tool!"));
                }
                break;
            case "pan":
                {
                    message = div(h2("Instrument Panning"), p("If you're listening through headphones or some other stereo sound system, this controls the position of the instrument and where the sound is coming from, ranging from left to right."), p("As a suggestion, composers often put lead melodies, drums, and basses in the center, and spread other instruments toward either side. If too many instruments seem like they're coming from the same place, it can feel crowded and harder to distinguish individual sounds, especially if they cover a similar pitch range."));
                }
                break;
            case "panDelay":
                {
                    message = div(h2("Stereo Delay"), p("When panning, a slight delay is often added between the left and right ear to help make a sound feel more 'directional'. For example, in the real world your left ear will hear a sound coming from the left just slightly before the right ear."), p("This setting controls how much delay is added. When this is set to minimum, panning only affects the volume of the left/right ear without changing the delay. This can help to get a more 'uniform' feeling sound, which can be desirable for making 8-bit music."));
                }
                break;
            case "arpeggioSpeed":
                {
                    message = div(h2("Arpeggio Speed"), p("This setting affects how fast your chord will 'arpeggiate', or cycle between notes. With a fast arpeggio speed it will sound rapid-fire, with a slow speed you can hear each note one after another."));
                }
                break;
            case "twoNoteArpeggio":
                {
                    message = div(h2("Faster Two-Note Arpeggio"), p("This setting makes arpeggios with only two notes in them happen twice as fast. Arpeggios with more notes in them are unaffected."));
                }
                break;
            case "detune":
                {
                    message = div(h2("Detune"), p("This setting can be used to finely control the pitch of your instrument. It is in units of 'cents', 100 of which equal a pitch shift of one semitone."), p("Careful - you can quickly get very dissonant sounding songs by using this setting."));
                }
                break;
            case "instrumentType":
                {
                    message = div(h2("Instrument Type"), p("Fruitybox comes with many instrument presets, try them out! You can also create your own custom instruments!"), p("There are also buttons for copying and pasting instruments at the bottom of the instrument settings tab, and for generating random instruments in the \"Randomize\" category in the instrument type menu."));
                }
                break;
            case "eqFilter":
                {
                    message = div(h2("EQ Filter"), p("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), p("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), p("Insert a new point on the left side of the filter editor to add a \"high-pass\" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a \"low-pass\" filter point which reduces the volume of higher frequencies."), p("You can also enable a \"Note Filter\" as an effect. EQ and note filters are mostly the same, but have different purposes. EQ filters are for overall adjustments, whereas note filters are for dynamic control and can be moved with envelopes. Note filters also change how the distortion effect sounds."));
                }
                break;
            case "noteFilter":
                {
                    message = div(h2("Note Filter"), p("Note filters are mostly the same as EQ filters, but have a different purpose. EQ filters are for overall adjustments, whereas note filters are for dynamic control and can be moved with envelopes. Note filters also change how the distortion effect sounds."), p("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), p("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), p("Insert a new point on the left side of the filter editor to add a \"high-pass\" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a \"low-pass\" filter point which reduces the volume of higher frequencies."));
                }
                break;
            case "fadeInOut":
                {
                    message = div(h2("Fade In/Out"), p("This setting controls how long it takes for notes to reach full volume at the beginning or decay to silence at the end."), p("An instant fade-in sounds like instruments that are played by hitting or plucking, whereas slower fade-ins sound like instruments that are played by blowing air."), p("You can also make the fade-out start before the note ends to leave a gap before the next note starts, or after the note ends to allow the sound of the end of the note to overlap with the start of the next note."));
                }
                break;
            case "transition":
                {
                    message = div(h2("Transition"), p("Usually, when one note ends at the same time another begins, the old note will fade out and the new note will fade in based on the fade in/out settings, but this setting can override that, connecting the end of one note to the beginning of the next."), p("The \"interrupt\" transition makes the wave suddenly change from the old note's frequency to the new note's frequency without any fading, but still restarts envelopes at the beginning of the new note. The \"continue\" transition is similar but it doesn't even restart envelopes, and can be used to make each of the notes in a chord start or stop at different times!"), p("The \"slide\" transition makes the pitch shift quickly but not instantaneously from the old note's frequency to the new note's frequency, and softly restarts envelopes. The \"slide in pattern\" transition is the same except it doesn't connect the last note in a pattern to the first note in the next pattern."));
                }
                break;
            case "chipWave":
                {
                    message = div(h2("Chip Wave"), p("Fruitybox comes with some sound waves based on classic electronic sound chips, as well as several unique waves. This is the basic source of the sound of the instrument, which is modified by the other instrument settings."));
                }
                break;
            case "chipNoise":
                {
                    message = div(h2("Noise"), p("Fruitybox comes with several basic noise sounds. These do not have any distinct musical pitch, and can be used like drums to create beats and emphasize your song's rhythm."));
                }
                break;
            case "supersawDynamism":
                {
                    message = div(h2("Supersaw Dynamism"), p("A supersaw is a combination of many sawtooth waves, and this setting controls the contribution of extra sawtooth waves."), p("At the low end of the slider, only the first wave is contributing to the sound, which sounds like an ordinary static sawtooth wave. At the maximum setting, all of the waves are contributing equally and the resulting tone can randomly shift depending on how the waves line up with each other, similar to the \"unison\" and \"chorus\" settings."));
                }
                break;
            case "supersawSpread":
                {
                    message = div(h2("Supersaw Spread"), p("A supersaw is a combination of many sawtooth waves, and this setting controls the distance between their frequencies. The dynamism setting must be used for the extra waves to have any effect."), p("At the low end of the spread slider, all of the voices have the same frequency but random phase, resulting in a different sound every time a note starts. In the middle, the waves all have slightly different frequencies that shift in and out of phase over time similar to the \"unison\" and \"chorus\" settings, creating a classic supersaw sound. At the extreme end, the frequencies are so far apart they sound dissonant."));
                }
                break;
            case "supersawShape":
                {
                    message = div(h2("Supersaw Shape"), p("This supersaw instrument includes an option to change the shape of the waves from sawtooth waves to pulse waves. Use this setting to morph between the two shapes."), p("When a pulse wave shape is used, you can also control the pulse width with a separate setting."));
                }
                break;
            case "pulseWidth":
                {
                    message = div(h2("Pulse Wave Width"), p("This setting controls the shape and sound of a pulse wave. At the minimum width, it sounds light and buzzy. At the maximum width, it is shaped like a classic square wave."));
                }
                break;
            case "unison":
                {
                    message = div(h2("Unison"), p("This instrument can play two identical waves at different frequencies. When two waves play at slightly different frequencies, they move in and out of phase with each other over time as different parts of the waves line up. This creates a dynamic, shifting sound. Pianos are a common example of this kind of sound, because each piano key strikes multiple strings that are tuned to slightly different frequencies."), p("The distance between two frequencies is called an \"interval\", and this setting controls how large it is. If the interval is too wide, then the waves may sound out-of-tune and \"dissonant\". However, if the interval is even larger, then the two frequencies can even be distinct pitches."));
                }
                break;
            case "chords":
                {
                    message = div(h2("Chords"), p("When multiple different notes occur at the same time, this is called a chord. Chords can be created in Fruitybox's pattern editor by adding notes above or below another note."), p("This setting determines how chords are played. The standard option is \"simultaneous\" which starts playing all of the pitches in a chord at the same instant. The \"strum\" option is similar, but plays the notes starting at slightly different times. The \"arpeggio\" option is used in \"chiptune\" style music and plays a single tone that rapidly alternates between all of the pitches in the chord."), p("Some Fruitybox instruments have an option called \"custom interval\" which uses the chord notes to control the interval between the waves of a single tone. This can create strange sound effects when combined with FM modulators."));
                }
                break;
            case "vibrato":
                {
                    message = div(h2("Vibrato"), p("This setting causes the frequency of a note to wobble slightly. Singers and violinists often use vibrato."));
                }
                break;
            case "vibratoDepth":
                {
                    message = div(h2("Vibrato Depth"), p("This setting affects the depth of your instrument's vibrato, making the wobbling effect sound stronger or weaker."));
                }
                break;
            case "vibratoDelay":
                {
                    message = div(h2("Vibrato Delay"), p("This setting changes when vibrato starts to kick in after a note is played. Vibrato is most common for long held notes and less common in short notes, so this can help you achieve that effect."));
                }
                break;
            case "vibratoSpeed":
                {
                    message = div(h2("Vibrato Speed"), p("This setting determines how fast the vibrato's up-and-down wobble effect will happen for your instrument."));
                }
                break;
            case "vibratoType":
                {
                    message = div(h2("Vibrato Type"), p("This determines the way vibrato causes your instrument's pitch to wobble. The normal type is smooth up and down, the shaky type is chaotic."));
                }
                break;
            case "algorithm":
                {
                    message = div(h2("FM Algorithm"), p('FM Synthesis is a mysterious but powerful technique for crafting sounds, popularized by Yamaha keyboards and the Sega Genesis/Mega Drive. It may seem confusing, but try playing around with the options until you get a feel for it, or check out some of the preset examples!'), p('This FM synthesizer uses up to four waves, numbered 1, 2, 3, and 4. Each wave may have its own frequency and volume.'), p('There are two kinds of waves: "carrier" waves play a tone out loud, but "modulator" waves distort other waves instead. Wave 1 is always a carrier and plays a tone, but other waves may distort it. The "Algorithm" setting determines which waves are modulators, and which other waves those modulators distort. For example, "1←2" means that wave 2 modulates wave 1, and wave 1 plays out loud.'));
                }
                break;
            case "feedbackType":
                {
                    message = div(h2("Feedback Type"), p('Modulators distort in one direction (like 1←2), but you can also use the feedback setting to make any wave distort in the opposite direction (1→2), or even itself (1⟲).'));
                }
                break;
            case "feedbackVolume":
                {
                    message = div(h2("Feedback Distortion"), p("This setting controls the amount of feedback distortion based on the feedback type setting."));
                }
                break;
            case "operatorFrequency":
                {
                    message = div(h2("Operator Frequency"), p('This setting controls the frequency of an individual FM wave, relative to the fundamental frequency of the note. The multiplier 1× is the same as the fundamental frequency, whereas 2x would be an octave (12 semitones) above it. The frequencies with a "~" are slightly detuned and shift in and out of phase over time compared to the other frequencies.'), p('Try different combinations of a "carrier" wave and a "modulator" wave with different frequencies to get a feel for how they sound together.'));
                }
                break;
            case "operatorVolume":
                {
                    message = div(h2("Operator Volume"), p("This setting controls the volume of \"carrier\" waves, or the amount of distortion that \"modulator\" waves apply to other waves."));
                }
                break;
            case "spectrum":
                {
                    message = div(h2("Spectrum"), p("This setting allows you to draw your own noise spectrum! This is good for making drum sounds."), p("If you only use certain frequencies and a soft fade in/out, it's also possible to make howling wind sounds or even musical wind instruments."), p("The left side of the spectrum editor controls the noise energy at lower frequencies, and the right side controls higher frequencies."));
                }
                break;
            case "harmonics":
                {
                    message = div(h2("Harmonics"), p("This setting allows you to design your own sound wave! Most musical waves are actually a combination of sine waves at certain frequencies, and this lets you control the volume of each sine wave individually."), p("The left side of the harmonics editor controls the sine wave volumes at lower frequencies, and the right side controls higher frequencies."));
                }
                break;
            case "effects":
                {
                    message = div(h2("Effects"), p("Fruitybox has many different kinds of special effects you can add to instruments. You can turn on multiple effects at once, and they can be configured individually. Try them all out!"));
                }
                break;
            case "drumsetEnvelope":
                {
                    message = div(h2("Drumset Envelope"), p("This drumset comes with a low-pass filter, and this setting can dynamically change the low-pass filter frequency over time. Each row in the pattern editor can have a different envelope shape."));
                }
                break;
            case "drumsetSpectrum":
                {
                    message = div(h2("Drumset Spectrum"), p("This setting allows you to draw your own noise spectrum! This is good for making drumsets. Each row in the pattern editor gets its own spectrum."), p("The left side of the spectrum editor controls the noise energy at lower frequencies, and the right side controls higher frequencies."));
                }
                break;
            case "chorus":
                {
                    message = div(h2("Chorus"), p("The chorus effect combines multiple copies of the instrument's sound and adds a bit of vibrato to simulate an ensemble of instruments or voices. Drag the slider to control how much chorus is added."));
                }
                break;
            case "echoSustain":
                {
                    message = div(h2("Echo Volume"), p("The echo effect repeats the instrument's sound after a delay. Each echo is a little bit quieter than the last, and this setting controls how much quieter."));
                }
                break;
            case "echoDelay":
                {
                    message = div(h2("Echo Delay"), p("The echo effect repeats the instrument's sound after a delay, and this setting controls how long the delay is."));
                }
                break;
            case "pitchShift":
                {
                    message = div(h2("Pitch Shift"), p("This setting makes instruments play higher or lower pitches than the ones displayed in the pattern editor. Be careful that you don't confuse yourself!"), p("You can combine this with envelopes to bend pitch over time, or play multiple simultaneous instruments with different pitch shifts for interesting layered sounds."), p("The intervals created by this setting are in \"just intonation\" which means they stay in phase with the original pitch instead of shifting in and out of phase over time. If you want the shifting, add the detune effect!"));
                }
                break;
            case "detune":
                {
                    message = div(h2("Detune"), p("This setting slightly adjusts the frequency of notes played by the instrument. You can use a little bit to add a pleasing shifting sound similar to the \"unison\" feature when combined with other instruments. If you use too much, then the instrument may sound unpleasantly out-of-tune."));
                }
                break;
            case "distortion":
                {
                    message = div(h2("Distortion"), p("This is the famous electric guitar effect! However, there are some things to be aware of."), p("First, most chords don't sound right when combined with heavy distortion. The only chords commonly used with distorted electric guitars are \"power chords\" which consist of a root note, a \"fifth\" note above that, and/or any octaves of those two notes."), p("Second, the distortion sound depends a lot on filtering. In particular, I recommend enabling the note filter effect, and adding both high-pass and low-pass points to the note filter. (Note filters are applied first, then distortion which transforms the sound based on that filtering, then the EQ filter is applied last.)"), p("Finally, I recommend adjusting the fade-out setting to allow the end of each note to overlap a little bit with the beginning of the next, but not too much!"));
                }
                break;
            case "bitcrusherQuantization":
                {
                    message = div(h2("Bitcrusher Quantization"), p("This effect makes stuff sounds harsher, artificial, and \"low quality\", which is great if that's what you're going for!"));
                }
                break;
            case "bitcrusherFreq":
                {
                    message = div(h2("Frequency Quantization"), p("The bitcrusher effect comes with an additional frequency quantization effect! This is a fun one to play with, especially when combined with the note filter effect."), p("Every other notch on this slider is aligned with the currently selected key of the song, and the in-between notches are aligned with the tritones of the key."));
                }
                break;
            case "envelopes":
                {
                    message = div(h2("Envelopes"), p("Envelopes are a way to dynamically adjust various other settings over time, usually based on how long the note lasts. Press the + button to add an envelope, then use the menus below to select which setting to control and the curve of the envelope. Try different combinations to see how they sound!"), p("Most envelope curves restart from the beginning every time a new note plays. The \"note size\" option is based on the note width as drawn in the pattern editor."), p("Envelope curves move in the range from 0 to 1 (or vice versa), where 0 means as quiet as possible and 1 is the same as the corresponding position selected in the instrument settings above. If multiple envelopes are targetting the same setting, they are multiplied before applying to the setting."));
                }
                break;
            case "discreteEnvelope":
                {
                    message = div(h2("Use Discrete Envelopes?"), p("Envelopes are usually interpolated, meaning they change continuously and smoothly. This setting, when ticked, makes envelopes not interpolate. It's a small difference, but can be helpful for some chip noises, and it's most noticeable with the 'blip' transitions."));
                }
                break;
            case "envelopeSpeed":
                {
                    message = div(h2("Envelope Speed"), p("This setting controls the speed of ALL envelopes for the instrument. Each envelope 'plays' at a certain speed, and this slider can scale it to play faster or slower. Use this to fine-tune your tremolo or how fast something decays to get just the right effect."), p("Note that, while this setting is limited in the sense that it controls all envelopes at once, you can still achieve a variety of outcomes by trying combinations of modes of each envelope type, which typically differ only in speed."));
                }
                break;
            case "usedInstrument":
                {
                    message = div(h3("'Is this instrument used somewhere else?'"), p("This indicator will light up when the instrument you're currently looking at is used in another place in your song (outside the selection)."), p("This can be useful when you're not sure if you've used the instrument before and making edits carelessly could change other parts of the song."));
                }
                break;
            case "usedPattern":
                {
                    message = div(h3("'Is this pattern used somewhere else?'"), p("This indicator will light up when the pattern you're currently looking at is used in another place in your song (outside the selection)."), p("This can be useful when you're not sure if you've used the pattern before and making edits carelessly could change other parts of the song."));
                }
                break;
            case "modChannel":
                {
                    message = div(h2("Modulator Channel"), p("Modulators can be used to change settings in your song automatically over time. This technique is also known as automation."), p("This setting controls which channel the modulators will take effect for. If you choose 'Song', you can change song-wide settings too!"));
                }
                break;
            case "modInstrument":
                {
                    message = div(h2("Modulator Instrument"), p("Modulators can be used to change settings in your song automatically over time. This technique is also known as automation."), p("This setting controls which instrument your modulator will apply to within the given channel you've chosen."), p("If you choose 'all', every instrument in the channel will be affected. If you choose 'active', just the current ones used in this pattern will be instead."), p("Note that with 'all' or 'active', effects will only be applied to instruments that the effect is applicable on. For example if an instrument does not have panning effects, modulating panning will not affect it."));
                }
                break;
            case "modSet":
                {
                    message = div(h2("Modulator Setting"), p("This is the parameter that you want to change with this modulator. For example, if you set this to 'Tempo', you can speed up or slow down your song by laying notes in the pattern editor."), p("Note that you'll see different options if your channel is set to 'Song' versus a channel number. With 'Song', you'll see song-wide settings such as tempo. With a channel, you'll see specific instrument settings. Adding more effects to the instrument causes modulators for them to be available, so be sure to experiment!"), p("Most modulators behave as you'd expect and work just as if you were moving their associated slider. Click the '?' when you have a setting selected to get more info about it!"));
                }
                break;
            case "modFilter":
                {
                    message = div(h2("Filter Target"), p("This setting specifies which parameter of your targeted filter you would like to change."), p("With the 'morph' setting, the note value for your modulator represents the number of a subfilter to 'morph' into over time. For example, dragging a note from 0 to 7 will morph from your main filter to the 7th subfilter. To change how your subfilters are set up, click the '+' button on the target filter."), p("With a Dot setting, you can fine-tune the exact location of every dot on your filter graph. Note that this is extremely intensive if you want to modulate all dots - a morph is better in that case - but this can come in handy for small adjustments."));
                }
                break;
            case "transitionBar":
                {
                    message = div(h2("Tie Notes Over Bars"), p("With this option ticked, notes won't transition across bars if you put notes with the same pitches at the start of the next bar. Instead they will 'tie over' and sound like one long note."));
                }
                break;
            case "clicklessTransition":
                {
                    message = div(h2("Clickless Transition"), p("Sometimes, seamless and other transition types can make audible 'clicks' when changing between notes. Ticking this option will cause those clicks to be silenced as much as possible."));
                }
                break;
            case "aliases":
                {
                    message = div(h2("Aliasing"), p("Fruitybox applies a technique called 'anti-aliasing' to instruments normally to help them sound cleaner even at high frequencies and low sample rates."), p("When this setting is ticked that technique is disabled, so you may hear strange audio artifacts especially at high pitches and when bending notes. However, this can lend a grungy sound to an instrument that could be desirable."));
                }
                break;
            case "operatorWaveform":
                {
                    message = div(h2("Operator Waveform"), p('This setting controls the what kind of sound wave an individual FM wave uses.'), p('By defualt the FM synth uses sinewaves.'));
                }
                break;
            case "filterType":
                {
                    message = div(h2("Filter Type"), p('Toggling these buttons lets you choose between a simple filter interface with two sliders, or the more advanced filter graph.'), p('The two-slider version controls a single low-pass filter and was used in legacy versions. It is not as powerful, but if you feel overwhelmed you can start with this.'), p('Note that switching from the simple interface to the advanced interface will convert your current settings, so you can also use it as a basis for later tweaking.'));
                }
                break;
            case "filterCutoff":
                {
                    message = div(h2("Low-Pass Filter Cutoff Frequency"), p("The lowest setting feels \"muffled\" or \"dark\", and the highest setting feels \"harsh\" or \"bright\"."), p("Most sounds include a range of frequencies from low to high. Fruitybox instruments have a filter that allows the lowest frequencies to pass through at full volume, but can reduce the volume of the higher frequencies that are above a cutoff frequency. This setting controls the cutoff frequency and thus the range of higher frequencies that are reduced."), p("This cutoff setting also determines which frequency resonates when the resonance peak setting is used."));
                }
                break;
            case "filterResonance":
                {
                    message = div(h2("Low-Pass Filter Resonance Peak"), p("Increasing this setting emphasizes a narrow range of frequencies, based on the position of the filter cutoff setting. This can be used to imitate the resonant bodies of acoustic instruments and other interesting effects."), p("The filter preserves the volume of frequencies that are below the cutoff frequency, and reduces the volume of frequencies that are above the cutoff. If this setting is used, the filter also increases the volume of frequencies that are near the cutoff."));
                }
                break;
            case "loopControls":
                {
                    message = div(h2("Loop Controls"), p("This enables the use of parameters that control how a chip wave should repeat."));
                }
                break;
            case "loopMode":
                {
                    message = div(h2("Loop Mode"), p("This sets the way the chip wave loops when its ends are reached."), p("The \"Loop\" mode is the default: when the end of the loop is reached, it will jump back to the starting point of the loop."), p("The \"Ping-Pong\" mode starts playing the chip wave backwards when the end of the loop is reached. Once it reaches the start of the loop, it will start playing forwards again, endlessly going back and forth."), p("The \"Play Once\" mode stops the chip wave once the end is reached (or the start of the loop, if it's playing backwards)."), p("The \"Play Loop Once\" mode stops the chip wave once the end of the loop is reached (or the start of the loop, if it's playing backwards)."));
                }
                break;
            case "loopStart":
                {
                    message = div(h2("Loop Start Point"), p("This specifies where the loop region of the chip wave starts. It's measured in \"samples\", or rather, it refers to a point on a waveform."), p("Be careful with tiny loop sizes (especially combined with high pitches), they may re-introduce aliasing even if the \"Aliasing\" checkbox is unchecked."));
                }
                break;
            case "loopEnd":
                {
                    message = div(h2("Loop End Point"), p("This specifies where the loop region of the chip wave ends. It's measured in \"samples\", or rather, it refers to a point on a waveform."), p("The button next to the input box sets this to end of the chip wave."), p("Be careful with tiny loop sizes (especially combined with high pitches), they may re-introduce aliasing even if the \"Aliasing\" checkbox is unchecked."));
                }
                break;
            case "offset":
                {
                    message = div(h2("Offset"), p("This specifies where the chip wave should start playing from. You can use this to chop up a large sample, to say, turn a drum loop into a drum kit! It's measured in \"samples\", or rather, it refers to a point on a waveform."));
                }
                break;
            case "backwards":
                {
                    message = div(h2("Backwards"), p("When set, the chip wave will start playing backwards. After checking this, you may want to adjust the offset to start from a different point that makes sense for this mode."));
                }
                break;
            case "decimalOffset":
                {
                    message = div(h2("Decimal Offset"), p("The decimal offset is subtracted from the pulse width value, enabling the use of numbers such as 12.5 or 6.25. This could be useful if you're trying to recreate the sound of old soundchips."));
                }
                break;
            case "unisonVoices":
                {
                    message = div(h2("Unison Voices"), p("This setting controls how many voices there are in a unison. Unisons such as \"none\" or \"detune\" use 1 voice, while most other unisons use 2 voices."));
                }
                break;
            case "unisonSpread":
                {
                    message = div(h2("Unison Spread"), p("This setting controls the distance between the two voices, in semitones. A small amount of spread causes the voice's waves to shift in and out from each other, causing a shimmering effect. Larger spread will cause the voices to act like separate notes."));
                }
                break;
            case "unisonOffset":
                {
                    message = div(h2("Unison Offset"), p("This setting controls the detune applied to BOTH voices, in semitones."));
                }
                break;
            case "unisonExpression":
                {
                    message = div(h2("Unison Volume"), p("This setting controls the unison volume. Use this if the unison makes your instrument too loud in comparison to other instruments."), p("If this is set to a negative value, it will invert the wave!"));
                }
                break;
            case "unisonSign":
                {
                    message = div(h2("Unison Sign"), p("This setting is a volume multiplier applied to the second voice. This setting will only work correctly with two voices."));
                }
                break;
            default:
                if (type.indexOf("modSetInfo") >= 0) {
                    let modNum = +type[type.length - 1];
                    let modulator = _doc.song.channels[_doc.channel].instruments[_doc.getCurrentInstrument()].modulators[modNum];
                    let pList = [];
                    for (let s = 0; s < Config.modulators[modulator].promptDesc.length; s++) {
                        pList.push(p(Config.modulators[modulator].promptDesc[s]
                            .replace("$LO", "" + Config.modulators[modulator].convertRealFactor)
                            .replace("$MID", "" + (Config.modulators[modulator].convertRealFactor + Config.modulators[modulator].maxRawVol / 2))
                            .replace("$HI", "" + (Config.modulators[modulator].convertRealFactor + Config.modulators[modulator].maxRawVol))));
                    }
                    pList[pList.length - 1].style.setProperty("color", "var(--secondary-text)");
                    message = div(h2(Config.modulators[modulator].promptName), pList);
                    break;
                }
                else {
                    throw new Error("Unhandled TipPrompt type: " + type);
                }
        }
        this.container = div({ class: "prompt", style: "width: 300px;" }, message, this._closeButton);
        setTimeout(() => this._closeButton.focus());
        this._closeButton.addEventListener("click", this._close);
    }
}

    class Box {
        constructor(channel, _x, _y, color) {
            this._x = _x;
            this._y = _y;
            this._text = document.createTextNode("1");
            this._label = SVG.text({ "font-family": "sans-serif", "font-size": 20, "text-anchor": "middle", "font-weight": "bold", fill: "red" }, this._text);
            this._rect = SVG.rect({ x: 1, y: 1 });
            this.container = SVG.svg(this._rect, this._label);
            this._renderedIndex = 1;
            this._renderedDim = true;
            this._renderedSelected = false;
            this._renderedColor = "";
            this._rect.setAttribute("fill", ColorConfig.uiWidgetBackground);
            this._label.setAttribute("fill", color);
        }
        setSize(width, height) {
            this.container.setAttribute("x", "" + (this._x * width));
            this.container.setAttribute("y", "" + (Config.barEditorHeight + this._y * height));
            this._rect.setAttribute("width", "" + (width - 2));
            this._rect.setAttribute("height", "" + (height - 2));
            this._label.setAttribute("x", "" + (width / 2));
            this._label.setAttribute("y", "" + Math.round(height / 2 + 7));
        }
        setIndex(index, dim, selected, color, isNoise, isMod) {
            if (this._renderedIndex != index) {
                if (!this._renderedSelected && ((index == 0) != (this._renderedIndex == 0))) {
                    if (index == 0) {
                        this._rect.setAttribute("fill", "none");
                    }
                    else {
                        if (isNoise)
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgNoiseDim : ColorConfig.trackEditorBgNoise);
                        else if (isMod)
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgModDim : ColorConfig.trackEditorBgMod);
                        else
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgPitchDim : ColorConfig.trackEditorBgPitch);
                    }
                }
                if (index >= 100) {
                    this._label.setAttribute("font-size", "16");
                    this._label.setAttribute("style", "transform: translate(0px, -1.5px);");
                }
                else {
                    this._label.setAttribute("font-size", "20");
                    this._label.setAttribute("style", "transform: translate(0px, 0px);");
                }
                this._renderedIndex = index;
                this._text.data = "" + index;
            }
            if (this._renderedDim != dim || this._renderedColor != color) {
                this._renderedDim = dim;
                if (selected) {
                    this._label.setAttribute("fill", ColorConfig.invertedText);
                }
                else {
                    this._label.setAttribute("fill", color);
                    if (this._renderedIndex == 0) {
                        this._rect.setAttribute("fill", ColorConfig.editorBackground);
                    }
                    else {
                        if (isNoise)
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgNoiseDim : ColorConfig.trackEditorBgNoise);
                        else if (isMod)
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgModDim : ColorConfig.trackEditorBgMod);
                        else
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgPitchDim : ColorConfig.trackEditorBgPitch);
                    }
                }
            }
            if (this._renderedSelected != selected || this._renderedColor != color) {
                this._renderedSelected = selected;
                if (selected) {
                    this._rect.setAttribute("fill", color);
                    this._label.setAttribute("fill", ColorConfig.invertedText);
                }
                else {
                    this._label.setAttribute("fill", color);
                    if (this._renderedIndex == 0) {
                        this._rect.setAttribute("fill", ColorConfig.editorBackground);
                    }
                    else {
                        if (isNoise)
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgNoiseDim : ColorConfig.trackEditorBgNoise);
                        else if (isMod)
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgModDim : ColorConfig.trackEditorBgMod);
                        else
                            this._rect.setAttribute("fill", dim ? ColorConfig.trackEditorBgPitchDim : ColorConfig.trackEditorBgPitch);
                    }
                }
            }
            this._renderedColor = color;
        }
    }
    class RecordingSetupPrompt {
 constructor(_doc) {
  this._doc = _doc;
  this._keyboardMode = select({ style: "width: 100%;" }, option({ value: "useCapsLockForNotes" }, "simple shortcuts, use caps lock to play notes"), option({ value: "pressControlForShortcuts" }, "simple notes, press " + EditorConfig.ctrlName + " for shortcuts"));
  this._keyboardLayout = select({ style: "width: 100%;" }, option({ value: "wickiHayden" }, "Wicki-Hayden"), option({ value: "songScale" }, "selected song scale"), option({ value: "pianoAtC" }, "piano starting at C"), option({ value: "pianoAtA" }, "piano starting at A"), option({ value: "pianoTransposingC" }, "piano transposing C to song key"), option({ value: "pianoTransposingA" }, "piano transposing A to song key"));
  this._bassOffset = select({ style: "width: 100%;" }, option({ value: "0" }, "disabled"), option({ value: "-1" }, "before"), option({ value: "1" }, "after"));
  this._keyboardLayoutPreview = div({ style: "display: grid; row-gap: 4px; margin: 4px auto; font-size: 10px;" });
  this._enableMidi = input({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
  this._showRecordButton = input({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
  this._snapRecordedNotesToRhythm = input({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
  this._ignorePerformedNotesNotInScale = input({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
  this._metronomeCountIn = input({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
  this._metronomeWhileRecording = input({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
  this._okayButton = button({ class: "okayButton", style: "width:45%;" }, "Okay");
  this._cancelButton = button({ class: "cancelButton" });
  this.container = div({ class: "prompt noSelection recordingSetupPrompt", style: "width: 600px; text-align: right; max-height: 90%;" }, h2({ style: "align-self: center;" }, "Note Recording Setup"), div({ style: "display: grid; overflow-y: auto; overflow-x: hidden; flex-shrink: 1;" }, p("FruityBox can record notes as you perform them. You can start recording by clicking the button :)"), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Add ● record button next to ▶ play button:", this._showRecordButton), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Snap recorded notes to the song's rhythm:", this._snapRecordedNotesToRhythm), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Ignore notes not in the song's scale:", this._ignorePerformedNotesNotInScale), p("While recording, you can perform notes on your keyboard!"), label({ style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em; height: 2em; justify-content: center;" }, "Keyboard layout:", div({ class: "selectContainer", style: "width: 50%; margin-left: 1em;" }, this._keyboardLayout)), this._keyboardLayoutPreview, p("When not recording, you can use the computer keyboard either for shortcuts (like C and V for copy and paste) or for performing notes, "),     p("The range of pitches available to play via your computer keyboard is affected by the octave scrollbar of the currently selected channel."),  
 div({ style: `width: 100%; height: 80px; background: linear-gradient(rgba(0,0,0,0), ${ColorConfig.editorBackground}); position: sticky; bottom: 0; pointer-events: none;` })), div({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
  this._close = () => {
   this._doc.undo();
  };
  this.cleanUp = () => {
   this._okayButton.removeEventListener("click", this._confirm);
   this._cancelButton.removeEventListener("click", this._close);
   this.container.removeEventListener("keydown", this._whenKeyPressed);
  };
  this._whenKeyPressed = (event) => {
   if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
    this._confirm();
   }
  };
  this._confirm = () => {
   this._doc.pressControlForShortcuts = (this._keyboardMode.value == "pressControlForShortcuts");
   
   this._doc.keyboardLayout = this._keyboardLayout.value;
   this._doc.bassOffset = 0 //Number(this._bassOffset.value);
   this._doc.enableMidi = 0 // this._enableMidi.checked;
   this._doc.showRecordButton = this._showRecordButton.checked;
   this._doc.snapRecordedNotesToRhythm = this._snapRecordedNotesToRhythm.checked;
   this._doc.ignorePerformedNotesNotInScale = this._ignorePerformedNotesNotInScale.checked;
   this._doc.metronomeCountIn = this._metronomeCountIn.checked;
   this._doc.metronomeWhileRecording = this._metronomeWhileRecording.checked;
   this._doc.savePreferences();
   this._close();
  };
  this._renderKeyboardLayoutPreview = () => {
   while (this._keyboardLayoutPreview.firstChild) {
    this._keyboardLayoutPreview.removeChild(this._keyboardLayoutPreview.firstChild);
   }
    
   const rowLengths = [12, 12, 11, 10];
  // const scale = this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
  const scale = Config.scales[this._doc.song.scale].flags;
    
   for (let rowIndex = 0; rowIndex < 4; rowIndex++) {
    const row = div({ style: "display: flex;" });
    this._keyboardLayoutPreview.appendChild(row);
    const spacer = div({ style: "width: " + (rowIndex * 12) + "px; height: 20px; flex-shrink: 0;" });
    row.appendChild(spacer);
    for (let colIndex = 0; colIndex < rowLengths[rowIndex]; colIndex++) {
     const key = div({ style: `width: 20px; height: 20px; margin: 0 2px; box-sizing: border-box; flex-shrink: 0; display: flex; justify-content: center; align-items: center;` });
     row.appendChild(key);
     
     const pitch = KeyboardLayout.keyPosToPitch(this._doc, colIndex, 3 - rowIndex, this._keyboardLayout.value);
     
     if (pitch != null) {
      const scalePitch = pitch % 12;
      if (scale[scalePitch]) {
      	
       if (scalePitch == 0) {
        key.style.background = ColorConfig.tonic;
       }
       else if (scalePitch == 7 && this._doc.showFifth) {
        key.style.background = ColorConfig.fifthNote;
       }
       else {
        key.style.background = ColorConfig.pitchBackground;
       }
      }
      else {
       key.style.border = "2px solid " + ColorConfig.pitchBackground;
      }
      
      if (this._bassOffset.selectedIndex != 0 && pitch <= Piano.getBassCutoffPitch(this._doc)) {
       key.style.setProperty("filter", "hue-rotate(60deg) brightness(0.5)");
      }
      else {
       key.style.setProperty("filter", "");
      }
      const pitchNameIndex = (scalePitch + Config.keys[this._doc.song.key].basePitch) % Config.pitchesPerOctave;
      key.textContent = Piano.getPitchName(pitchNameIndex, scalePitch, Math.floor(pitch / 12));
      
     }
    }
   }
  };
  this._keyboardMode.value = this._doc.pressControlForShortcuts ? "pressControlForShortcuts" : "useCapsLockForNotes";
  this._keyboardLayout.value = this._doc.keyboardLayout;
  this._bassOffset.value = String(this._doc.bassOffset);
  this._enableMidi.checked = this._doc.enableMidi;
  this._showRecordButton.checked = this._doc.showRecordButton;
  this._snapRecordedNotesToRhythm.checked = this._doc.snapRecordedNotesToRhythm;
  this._ignorePerformedNotesNotInScale.checked = this._doc.ignorePerformedNotesNotInScale;
  this._metronomeCountIn.checked = this._doc.metronomeCountIn;
  this._metronomeWhileRecording.checked = this._doc.metronomeWhileRecording;
  setTimeout(() => this._showRecordButton.focus());
  this._okayButton.addEventListener("click", this._confirm);
  this._cancelButton.addEventListener("click", this._close);
  this.container.addEventListener("keydown", this._whenKeyPressed);
  this._renderKeyboardLayoutPreview();
  this._keyboardLayout.addEventListener("change", this._renderKeyboardLayoutPreview);
  this._bassOffset.addEventListener("change", this._renderKeyboardLayoutPreview);
 }
}
    class TrackEditor {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._barDropDown = HTML.select({ style: "width: 32px; height: " + Config.barEditorHeight + "px; top: 0px; position: absolute; opacity: 0" }, HTML.option({ value: "barBefore" }, "Insert Bar Before"), HTML.option({ value: "barAfter" }, "Insert Bar After"), HTML.option({ value: "deleteBar" }, "Delete This Bar"));
            this._boxContainer = SVG.g();
            this._barNumberContainer = SVG.g();
            this._playhead = SVG.rect({ fill: ColorConfig.playhead, x: 0, y: 0, width: 4, height: 128 });
            this._boxHighlight = SVG.rect({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": 2, "pointer-events": "none", x: 1, y: 1, width: 30, height: 30 });
            this._upHighlight = SVG.path({ fill: ColorConfig.invertedText, stroke: ColorConfig.invertedText, "stroke-width": 1, "pointer-events": "none" });
            this._downHighlight = SVG.path({ fill: ColorConfig.invertedText, stroke: ColorConfig.invertedText, "stroke-width": 1, "pointer-events": "none" });
            this._barEditorPath = SVG.path({ fill: ColorConfig.uiWidgetBackground, stroke: ColorConfig.uiWidgetBackground, "stroke-width": 1, "pointer-events": "none" });
            this._selectionRect = SVG.rect({ class: "dashed-line dash-move", fill: ColorConfig.boxSelectionFill, stroke: ColorConfig.hoverPreview, "stroke-width": 2, "stroke-dasharray": "5, 3", "fill-opacity": "0.4", "pointer-events": "none", visibility: "hidden", x: 1, y: 1, width: 62, height: 62 });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; position: absolute;`, height: 128 }, this._boxContainer, this._barEditorPath, this._selectionRect, this._barNumberContainer, this._boxHighlight, this._upHighlight, this._downHighlight, this._playhead);
            this._select = HTML.select({ class: "trackSelectBox", style: "background: none; border: none; appearance: none; border-radius: initial; box-shadow: none; color: transparent; position: absolute; touch-action: none;" });
            this.container = HTML.div({ class: "noSelection", style: "height: 128px; position: relative; overflow:hidden;" }, this._svg, this._select, this._barDropDown);
            this._grid = [];
            this._barNumbers = [];
            this._mouseX = 0;
            this._mouseY = 0;
            this._mouseStartBar = 0;
            this._mouseStartChannel = 0;
            this._mouseBar = 0;
            this._mouseChannel = 0;
            this._mouseOver = false;
            this._mousePressed = false;
            this._mouseDragging = false;
            this._barWidth = 32;
            this._channelHeight = 32;
            this._renderedChannelCount = 0;
            this._renderedBarCount = 0;
            this._renderedPatternCount = 0;
            this._renderedPlayhead = -1;
            this._renderedBarWidth = -1;
            this._renderedChannelHeight = -1;
            this._touchMode = isMobile;
            this._barDropDownBar = 0;
            this._lastScrollTime = 0;
            this._barDropDownGetOpenedPosition = (event) => {
                this._barDropDownBar = Math.floor(Math.min(this._doc.song.barCount - 1, Math.max(0, this._mouseX / this._barWidth)));
            };
            this._barDropDownHandler = (event) => {
                var moveBarOffset = (this._barDropDown.value == "barBefore") ? 0 : 1;
                if (this._barDropDown.value == "barBefore" || this._barDropDown.value == "barAfter") {
                    this._doc.bar = this._barDropDownBar - 1 + moveBarOffset;
                    this._doc.selection.resetBoxSelection();
                    this._doc.selection.insertBars();
                    if (this._doc.synth.playhead >= this._barDropDownBar + moveBarOffset) {
                        this._doc.synth.playhead++;
                        this._songEditor._barScrollBar.animatePlayhead();
                    }
                }
                else if (this._barDropDown.value == "deleteBar") {
                    this._doc.bar = this._barDropDownBar;
                    this._doc.selection.resetBoxSelection();
                    this._doc.selection.deleteBars();
                    if (this._doc.synth.playhead > this._barDropDownBar) {
                        this._doc.synth.playhead--;
                        this._songEditor._barScrollBar.animatePlayhead();
                    }
                }
                this._barDropDown.selectedIndex = -1;
            };
            this._whenSelectChanged = () => {
                this._doc.selection.setPattern(this._select.selectedIndex);
            };
            this._animatePlayhead = (timestamp) => {
                const playhead = (this._barWidth * this._doc.synth.playhead - 2);
                if (this._renderedPlayhead != playhead) {
                    this._renderedPlayhead = playhead;
                    this._playhead.setAttribute("x", "" + playhead);
                }
                window.requestAnimationFrame(this._animatePlayhead);
            };
            this._whenSelectPressed = (event) => {
                this._mousePressed = true;
                this._mouseDragging = true;
                this._updateSelectPos(event);
                this._mouseStartBar = this._mouseBar;
                this._mouseStartChannel = this._mouseChannel;
            };
            this._whenSelectMoved = (event) => {
                this._updateSelectPos(event);
                if (this._mouseStartBar != this._mouseBar || this._mouseStartChannel != this._mouseChannel) {
                    event.preventDefault();
                }
                if (this._mousePressed)
                    this._dragBoxSelection();
                this._updatePreview();
            };
            this._whenSelectReleased = (event) => {
                this._mousePressed = false;
                this._mouseDragging = false;
                this._updatePreview();
            };
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mousePressed = true;
                this._updateMousePos(event);
                this._mouseStartBar = this._mouseBar;
                this._mouseStartChannel = this._mouseChannel;
                if (this._mouseY >= Config.barEditorHeight) {
                    if (event.shiftKey) {
                        this._mouseDragging = true;
                        
                        this._doc.selection.setTrackSelection(this._doc.selection.boxSelectionX0, this._mouseBar, this._doc.selection.boxSelectionY0, this._mouseChannel);
                        this._doc.selection.selectionUpdated();
                    }
                    else {
                        this._mouseDragging = false;
                        if (this._doc.channel != this._mouseChannel || this._doc.bar != this._mouseBar) {
                            this._doc.selection.setChannelBar(this._mouseChannel, this._mouseBar);
                            this._mouseDragging = true;
                        }
                        this._doc.selection.resetBoxSelection();
                    }
                }
            };
            this._whenMouseMoved = (event) => {
                this._updateMousePos(event);
                if (this._mousePressed) {
                    if (this._mouseStartBar != this._mouseBar || this._mouseStartChannel != this._mouseChannel) {
                        this._mouseDragging = true;
                    }
                    this._dragBoxSelection();
                }
                this._updatePreview();
            };
            this._whenMouseReleased = (event) => {
                if (this._mousePressed && !this._mouseDragging) {
                    if (this._doc.channel == this._mouseChannel && this._doc.bar == this._mouseBar) {
                        const up = ((this._mouseY - Config.barEditorHeight) % this._channelHeight) < this._channelHeight / 2;
                        const patternCount = this._doc.song.patternsPerChannel;
                        this._doc.selection.setPattern((this._doc.song.channels[this._mouseChannel].bars[this._mouseBar] + (up ? 1 : patternCount)) % (patternCount + 1));
                    }
                }
                this._mousePressed = false;
                this._mouseDragging = false;
                this._updatePreview();
            };
            window.requestAnimationFrame(this._animatePlayhead);
            this._svg.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenMouseReleased);
            this._svg.addEventListener("mouseover", this._whenMouseOver);
            this._svg.addEventListener("mouseout", this._whenMouseOut);
            this._select.addEventListener("change", this._whenSelectChanged);
            this._select.addEventListener("touchstart", this._whenSelectPressed);
            this._select.addEventListener("touchmove", this._whenSelectMoved);
            this._select.addEventListener("touchend", this._whenSelectReleased);
            this._select.addEventListener("touchcancel", this._whenSelectReleased);
            let determinedCursorType = false;
            document.addEventListener("mousedown", () => {
                if (!determinedCursorType) {
                    this._touchMode = false;
                    this._updatePreview();
                }
                determinedCursorType = true;
            }, true);
            document.addEventListener("touchstart", () => {
                if (!determinedCursorType) {
                    this._touchMode = true;
                    this._updatePreview();
                }
                determinedCursorType = true;
            }, true);
            this._barDropDown.selectedIndex = -1;
            this._barDropDown.addEventListener("change", this._barDropDownHandler);
            this._barDropDown.addEventListener("mousedown", this._barDropDownGetOpenedPosition);
        }
        movePlayheadToMouse() {
            if (this._mouseOver) {
                this._doc.synth.playhead = this._mouseBar + (this._mouseX % this._barWidth) / this._barWidth;
                return true;
            }
            return false;
        }
        _dragBoxSelection() {
            this._doc.selection.setTrackSelection(this._doc.selection.boxSelectionX0, this._mouseBar, this._doc.selection.boxSelectionY0, this._mouseChannel);
            this._doc.selection.selectionUpdated();
             
        }
        _updateSelectPos(event) {
            const boundingRect = this._svg.getBoundingClientRect();
            this._mouseX = event.touches[0].clientX - boundingRect.left;
            this._mouseY = event.touches[0].clientY - boundingRect.top;
            if (isNaN(this._mouseX))
                this._mouseX = 0;
            if (isNaN(this._mouseY))
                this._mouseY = 0;
            this._mouseBar = Math.floor(Math.min(this._doc.song.barCount - 1, Math.max(0, this._mouseX / this._barWidth)));
            this._mouseChannel = Math.floor(Math.min(this._doc.song.getChannelCount() - 1, Math.max(0, (this._mouseY - Config.barEditorHeight) / this._channelHeight)));
        }
        _updateMousePos(event) {
            const boundingRect = this._svg.getBoundingClientRect();
            this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
            this._mouseY = (event.clientY || event.pageY) - boundingRect.top;
            this._mouseBar = Math.floor(Math.min(this._doc.song.barCount - 1, Math.max(0, this._mouseX / this._barWidth)));
            this._mouseChannel = Math.floor(Math.min(this._doc.song.getChannelCount() - 1, Math.max(0, (this._mouseY - Config.barEditorHeight) / this._channelHeight)));
        }
        _updatePreview() {
            let channel = this._mouseChannel;
            let bar = this._mouseBar;
            if (this._touchMode) {
                bar = this._doc.bar;
                channel = this._doc.channel;
            }
            const selected = (bar == this._doc.bar && channel == this._doc.channel);
            const overTrackEditor = (this._mouseY >= Config.barEditorHeight);
            if (this._mouseDragging && this._mouseStartBar != this._mouseBar) {
                var timestamp = Date.now();
                if (timestamp - this._lastScrollTime >= 50) {
                    if (bar > this._doc.barScrollPos + this._doc.trackVisibleBars - 1 && this._doc.barScrollPos < this._doc.song.barCount - this._doc.trackVisibleBars) {
                        this._songEditor.changeBarScrollPos(1);
                    }
                    if (bar < this._doc.barScrollPos && this._doc.barScrollPos > 0) {
                        this._songEditor.changeBarScrollPos(-1);
                    }
                    this._lastScrollTime = timestamp;
                }
            }
            if (this._mouseOver && !this._mousePressed && !selected && overTrackEditor) {
                this._boxHighlight.setAttribute("x", "" + (1 + this._barWidth * bar));
                this._boxHighlight.setAttribute("y", "" + (1 + Config.barEditorHeight + (this._channelHeight * channel)));
                this._boxHighlight.setAttribute("height", "" + (this._channelHeight - 2));
                this._boxHighlight.setAttribute("width", "" + (this._barWidth - 2));
                this._boxHighlight.style.visibility = "visible";
            }
            else if ((this._mouseOver || ((this._mouseX >= bar * this._barWidth) && (this._mouseX < bar * this._barWidth + this._barWidth) && (this._mouseY > 0))) && (!overTrackEditor)) {
                this._boxHighlight.setAttribute("x", "" + (1 + this._barWidth * bar));
                this._boxHighlight.setAttribute("y", "1");
                this._boxHighlight.setAttribute("height", "" + (Config.barEditorHeight - 3));
                this._boxHighlight.style.visibility = "visible";
            }
            else {
                this._boxHighlight.style.visibility = "hidden";
            }
            if ((this._mouseOver || this._touchMode) && selected && overTrackEditor) {
                const up = ((this._mouseY - Config.barEditorHeight) % this._channelHeight) < this._channelHeight / 2;
                const center = this._barWidth * (bar + 0.8);
                const middle = Config.barEditorHeight + this._channelHeight * (channel + 0.5);
                const base = this._channelHeight * 0.1;
                const tip = this._channelHeight * 0.4;
                const width = this._channelHeight * 0.175;
                this._upHighlight.setAttribute("fill", up && !this._touchMode ? ColorConfig.hoverPreview : ColorConfig.invertedText);
                this._downHighlight.setAttribute("fill", !up && !this._touchMode ? ColorConfig.hoverPreview : ColorConfig.invertedText);
                this._upHighlight.setAttribute("d", `M ${center} ${middle - tip} L ${center + width} ${middle - base} L ${center - width} ${middle - base} z`);
                this._downHighlight.setAttribute("d", `M ${center} ${middle + tip} L ${center + width} ${middle + base} L ${center - width} ${middle + base} z`);
                this._upHighlight.style.visibility = "visible";
                this._downHighlight.style.visibility = "visible";
            }
            else {
                this._upHighlight.style.visibility = "hidden";
                this._downHighlight.style.visibility = "hidden";
            }
            this._selectionRect.style.left = (this._barWidth * this._doc.bar) + "px";
            this._selectionRect.style.top = (Config.barEditorHeight + (this._channelHeight * this._doc.channel)) + "px";
            this._select.style.left = (this._barWidth * this._doc.bar) + "px";
            this._select.style.width = this._barWidth + "px";
            this._select.style.top = (Config.barEditorHeight + this._channelHeight * this._doc.channel) + "px";
            this._select.style.height = this._channelHeight + "px";
            this._barDropDown.style.left = (this._barWidth * bar) + "px";
            const patternCount = this._doc.song.patternsPerChannel + 1;
            for (let i = this._renderedPatternCount; i < patternCount; i++) {
                this._select.appendChild(HTML.option({ value: i }, i));
            }
            for (let i = patternCount; i < this._renderedPatternCount; i++) {
                this._select.removeChild(this._select.lastChild);
            }
            this._renderedPatternCount = patternCount;
            const selectedPattern = this._doc.song.channels[this._doc.channel].bars[this._doc.bar];
            if (this._select.selectedIndex != selectedPattern)
                this._select.selectedIndex = selectedPattern;
        }
        render() {
            this._barWidth = this._doc.getBarWidth();
            this._channelHeight = this._doc.getChannelHeight();
            if (this._renderedChannelCount != this._doc.song.getChannelCount()) {
                for (let y = this._renderedChannelCount; y < this._doc.song.getChannelCount(); y++) {
                    this._grid[y] = [];
                    for (let x = 0; x < this._renderedBarCount; x++) {
                        const box = new Box(y, x, y, ColorConfig.getChannelColor(this._doc.song, y).secondaryChannel);
                        box.setSize(this._barWidth, this._channelHeight);
                        this._boxContainer.appendChild(box.container);
                        this._grid[y][x] = box;
                    }
                }
                for (let y = this._doc.song.getChannelCount(); y < this._renderedChannelCount; y++) {
                    for (let x = 0; x < this._renderedBarCount; x++) {
                        this._boxContainer.removeChild(this._grid[y][x].container);
                    }
                }
                this._grid.length = this._doc.song.getChannelCount();
                this._mousePressed = false;
            }
            if (this._renderedBarCount != this._doc.song.barCount || this._renderedBarWidth != this._barWidth) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    for (let x = this._renderedBarCount; x < this._doc.song.barCount; x++) {
                        const box = new Box(y, x, y, ColorConfig.getChannelColor(this._doc.song, y).secondaryChannel);
                        box.setSize(this._barWidth, this._channelHeight);
                        this._boxContainer.appendChild(box.container);
                        this._grid[y][x] = box;
                    }
                    for (let x = this._doc.song.barCount; x < this._renderedBarCount; x++) {
                        this._boxContainer.removeChild(this._grid[y][x].container);
                    }
                    this._grid[y].length = this._doc.song.barCount;
                }
                var pathString = "";
                for (let x = 0; x < this._doc.song.barCount; x++) {
                    var pathLeft = x * this._barWidth + 2;
                    var pathTop = 1;
                    var pathRight = x * this._barWidth + this._barWidth - 2;
                    var pathBottom = Config.barEditorHeight - 3;
                    pathString += `M ${pathLeft} ${pathTop} H ${pathRight} V ${pathBottom} H ${pathLeft} V ${pathTop} Z `;
                }
                this._barEditorPath.setAttribute("d", pathString);
                if (this._renderedBarCount < this._doc.song.barCount) {
                    this._barNumbers.length = this._doc.song.barCount;
                    for (var pos = this._renderedBarCount; pos < this._barNumbers.length; pos++) {
                        this._barNumbers[pos] = SVG.text({ "font-family": "sans-serif", "font-size": "8px", "text-anchor": "middle", "font-weight": "bold", "x": (pos * this._barWidth + this._barWidth / 2) + "px", "y": "7px", fill: ColorConfig.secondaryText }, "" + (pos + 1));
                        if (pos % 4 == 0) {
                            this._barNumbers[pos].setAttribute("fill", ColorConfig.primaryText);
                        }
                        this._barNumberContainer.appendChild(this._barNumbers[pos]);
                    }
                }
                else if (this._renderedBarCount > this._doc.song.barCount) {
                    for (var pos = this._renderedBarCount - 1; pos >= this._doc.song.barCount; pos--) {
                        this._barNumberContainer.removeChild(this._barNumbers[pos]);
                    }
                    this._barNumbers.length = this._doc.song.barCount;
                }
                if (this._renderedBarWidth != this._barWidth) {
                    for (var pos = 0; pos < this._barNumbers.length; pos++) {
                        this._barNumbers[pos].setAttribute("x", (pos * this._barWidth + this._barWidth / 2) + "px");
                    }
                }
                this._renderedBarCount = this._doc.song.barCount;
                const editorWidth = this._barWidth * this._doc.song.barCount;
                this.container.style.width = editorWidth + "px";
                this._svg.setAttribute("width", editorWidth + "");
                this._mousePressed = false;
            }
            if (this._renderedChannelHeight != this._channelHeight || this._renderedBarWidth != this._barWidth) {
                this._renderedBarWidth = this._barWidth;
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    for (let x = 0; x < this._renderedBarCount; x++) {
                        this._grid[y][x].setSize(this._barWidth, this._channelHeight);
                    }
                }
                this._mousePressed = false;
            }
            if (this._renderedChannelHeight != this._channelHeight || this._renderedChannelCount != this._doc.song.getChannelCount()) {
                this._renderedChannelHeight = this._channelHeight;
                this._renderedChannelCount = this._doc.song.getChannelCount();
                const editorHeight = Config.barEditorHeight + this._doc.song.getChannelCount() * this._channelHeight;
                this._svg.setAttribute("height", "" + editorHeight);
                this._playhead.setAttribute("height", "" + editorHeight);
                this.container.style.height = editorHeight + "px";
            }
            for (let j = 0; j < this._doc.song.getChannelCount(); j++) {
                for (let i = 0; i < this._renderedBarCount; i++) {
                    const pattern = this._doc.song.getPattern(j, i);
                    const selected = (i == this._doc.bar && j == this._doc.channel);
                    const dim = (pattern == null || pattern.notes.length == 0);
                    const box = this._grid[j][i];
                    if (i < this._doc.song.barCount) {
                        const colors = ColorConfig.getChannelColor(this._doc.song, j);
                        box.setIndex(this._doc.song.channels[j].bars[i], dim, selected, dim && !selected ? colors.secondaryChannel : colors.primaryChannel, j >= this._doc.song.pitchChannelCount && j < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount, j >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount);
                        box.container.style.visibility = "visible";
                    }
                    else {
                        box.container.style.visibility = "hidden";
                    }
                }
            }
            this._select.style.display = this._touchMode ? "" : "none";
            if (this._doc.selection.boxSelectionWidth > 1 || this._doc.selection.boxSelectionHeight > 1) {
                this._selectionRect.setAttribute("x", String(this._barWidth * this._doc.selection.boxSelectionBar + 1));
                this._selectionRect.setAttribute("y", String(Config.barEditorHeight + this._channelHeight * this._doc.selection.boxSelectionChannel + 1));
                this._selectionRect.setAttribute("width", String(this._barWidth * this._doc.selection.boxSelectionWidth - 2));
                this._selectionRect.setAttribute("height", String(this._channelHeight * this._doc.selection.boxSelectionHeight - 2));
                this._selectionRect.setAttribute("visibility", "visible");
            }
            else {
                this._selectionRect.setAttribute("visibility", "hidden");
            }
            this._updatePreview();
        }
    }

    const { button: button$d, div: div$d, input: input$8, select: select$6, span: span$4, optgroup, option: option$6, canvas } = HTML;
    function buildOptions(menu, items) {
        for (let index = 0; index < items.length; index++) {
            menu.appendChild(option$6({ value: index }, items[index]));
        }
        return menu;
    }
    function buildHeaderedOptions(header, menu, items) {
        menu.appendChild(option$6({ selected: true, disabled: true, value: header }, header));
        for (const item of items) {
            menu.appendChild(option$6({ value: item }, item));
        }
        return menu;
    }
    function buildPresetOptions(isNoise, idSet) {
        const menu = select$6({ id: idSet });
        if (isNoise) {
            menu.appendChild(option$6({ value: 2 }, EditorConfig.valueToPreset(2).name));
            menu.appendChild(option$6({ value: 3 }, EditorConfig.valueToPreset(3).name));
            menu.appendChild(option$6({ value: 4 }, EditorConfig.valueToPreset(4).name));
        }
        else {
            menu.appendChild(option$6({ value: 0 }, EditorConfig.valueToPreset(0).name));
            menu.appendChild(option$6({ value: 6 }, EditorConfig.valueToPreset(6).name));
            menu.appendChild(option$6({ value: 5 }, EditorConfig.valueToPreset(5).name));
            menu.appendChild(option$6({ value: 7 }, EditorConfig.valueToPreset(7).name));
            menu.appendChild(option$6({ value: 3 }, EditorConfig.valueToPreset(3).name));
            menu.appendChild(option$6({ value: 1 }, EditorConfig.valueToPreset(1).name));
            menu.appendChild(option$6({ value: 8 }, EditorConfig.valueToPreset(8).name));
        }
        const randomGroup = optgroup({ label: "Randomize ▾" });
        randomGroup.appendChild(option$6({ value: "randomPreset" }, "Random Preset"));
        randomGroup.appendChild(option$6({ value: "randomGenerated" }, "Random Generated"));
        menu.appendChild(randomGroup);
        for (let categoryIndex = 1; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {
            const category = EditorConfig.presetCategories[categoryIndex];
            const group = optgroup({ label: category.name + " ▾" });
            let foundAny = false;
            for (let presetIndex = 0; presetIndex < category.presets.length; presetIndex++) {
                const preset = category.presets[presetIndex];
                if ((preset.isNoise == true) == isNoise) {
                    group.appendChild(option$6({ value: (categoryIndex << 6) + presetIndex }, preset.name));
                    foundAny = true;
                }
            }
            if (category.name == "String Presets" && foundAny) {
                let moveViolin2 = group.removeChild(group.children[11]);
                group.insertBefore(moveViolin2, group.children[1]);
            }
            if (category.name == "Flute Presets" && foundAny) {
                let moveFlute2 = group.removeChild(group.children[11]);
                group.insertBefore(moveFlute2, group.children[1]);
            }
            if (category.name == "Keyboard Presets" && foundAny) {
                let moveGrandPiano2 = group.removeChild(group.children[9]);
                group.insertBefore(moveGrandPiano2, group.children[1]);
            }
	    if (category.name == "Sampled Instruments" && foundAny) {
                let moveLegatoViolin = group.removeChild(group.children[10]);
                group.insertBefore(moveLegatoViolin, group.children[5]);
		let moveTremoloViolin = group.removeChild(group.children[11]);
                group.insertBefore(moveTremoloViolin, group.children[6]);
		let movePizzicatoViolin = group.removeChild(group.children[12]);
                group.insertBefore(movePizzicatoViolin, group.children[7]);
		let movePiano = group.removeChild(group.children[14]);
                group.insertBefore(movePiano, group.children[2]);
            }
            if (foundAny)
                menu.appendChild(group);
        }
        return menu;
    }
    function setSelectedValue(menu, value) {
    	if(value!==undefined){
        const stringValue = value.toString();
        if (menu.value != stringValue)
            menu.value = stringValue;
            


        if ($(menu).data('select2')) {
            $(menu).val(value).trigger('change.select2');
        }
    }}
    class CustomChipCanvas {
        constructor(canvas, _doc, _getChange) {
            this.canvas = canvas;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._onMouseMove = (event) => {
                if (this.mouseDown) {
                    var x = (event.clientX || event.pageX) - this.canvas.getBoundingClientRect().left;
                    var y = Math.floor((event.clientY || event.pageY) - this.canvas.getBoundingClientRect().top);
                    if (y < 2)
                        y = 2;
                    if (y > 50)
                        y = 50;
                    var ctx = this.canvas.getContext("2d");
                    if (this.continuousEdit == true && Math.abs(this.lastX - x) < 40) {
                        var lowerBound = (x < this.lastX) ? x : this.lastX;
                        var upperBound = (x < this.lastX) ? this.lastX : x;
                        for (let i = lowerBound; i <= upperBound; i += 2) {
                            var progress = (Math.abs(x - this.lastX) > 2.0) ? ((x > this.lastX) ?
                                1.0 - ((i - lowerBound) / (upperBound - lowerBound))
                                : ((i - lowerBound) / (upperBound - lowerBound))) : 0.0;
                            var j = Math.round(y + (this.lastY - y) * progress);
                            ctx.fillStyle = ColorConfig.getComputed("--editor-background");
                            ctx.fillRect(Math.floor(i / 2) * 2, 0, 2, 53);
                            ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                            ctx.fillRect(Math.floor(i / 2) * 2, 25, 2, 2);
                            ctx.fillStyle = ColorConfig.getComputed("--track-editor-bg-pitch-dim");
                            ctx.fillRect(Math.floor(i / 2) * 2, 13, 2, 1);
                            ctx.fillRect(Math.floor(i / 2) * 2, 39, 2, 1);
                            ctx.fillStyle = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
                            ctx.fillRect(Math.floor(i / 2) * 2, j - 2, 2, 4);
                            this.newArray[Math.floor(i / 2)] = (j - 26);
                        }
                    }
                    else {
                        ctx.fillStyle = ColorConfig.getComputed("--editor-background");
                        ctx.fillRect(Math.floor(x / 2) * 2, 0, 2, 52);
                        ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                        ctx.fillRect(Math.floor(x / 2) * 2, 25, 2, 2);
                        ctx.fillStyle = ColorConfig.getComputed("--track-editor-bg-pitch-dim");
                        ctx.fillRect(Math.floor(x / 2) * 2, 13, 2, 1);
                        ctx.fillRect(Math.floor(x / 2) * 2, 39, 2, 1);
                        ctx.fillStyle = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
                        ctx.fillRect(Math.floor(x / 2) * 2, y - 2, 2, 4);
                        this.newArray[Math.floor(x / 2)] = (y - 26);
                    }
                    this.continuousEdit = true;
                    this.lastX = x;
                    this.lastY = y;
                    let instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                    let sum = 0.0;
                    for (let i = 0; i < this.newArray.length; i++) {
                        sum += this.newArray[i];
                    }
                    const average = sum / this.newArray.length;
                    let cumulative = 0;
                    let wavePrev = 0;
                    for (let i = 0; i < this.newArray.length; i++) {
                        cumulative += wavePrev;
                        wavePrev = this.newArray[i] - average;
                        instrument.customChipWaveIntegral[i] = cumulative;
                    }
                    instrument.customChipWaveIntegral[64] = 0.0;
                }
            };
            this._onMouseDown = (event) => {
                this.mouseDown = true;
                this._onMouseMove(event);
            };
            this._onMouseUp = () => {
                this.mouseDown = false;
                this.continuousEdit = false;
                this._whenChange();
            };
            this._whenChange = () => {
                this._change = this._getChange(this.newArray);
                this._doc.record(this._change);
                this._change = null;
            };
            canvas.addEventListener("mousemove", this._onMouseMove);
            canvas.addEventListener("mousedown", this._onMouseDown);
            canvas.addEventListener("mouseup", this._onMouseUp);
            canvas.addEventListener("mouseleave", this._onMouseUp);
            this.mouseDown = false;
            this.continuousEdit = false;
            this.lastX = 0;
            this.lastY = 0;
            this.newArray = new Float64Array(64);
            this.redrawCanvas();
        }
        redrawCanvas() {
            var ctx = this.canvas.getContext("2d");
            ctx.fillStyle = ColorConfig.getComputed("--editor-background");
            ctx.fillRect(0, 0, 128, 52);
            ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
            ctx.fillRect(0, 25, 128, 2);
            ctx.fillStyle = ColorConfig.getComputed("--track-editor-bg-pitch-dim");
            ctx.fillRect(0, 13, 128, 1);
            ctx.fillRect(0, 39, 128, 1);
            ctx.fillStyle = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
            for (let x = 0; x < 64; x++) {
                var y = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].customChipWave[x] + 26;
                ctx.fillRect(x * 2, y - 2, 2, 4);
                this.newArray[x] = y - 26;
            }
        }
    }
class WhistleRecordContainer {
	constructor(parent = document.body, _doc=this._doc) {
		this.parent = parent;
		this.container = document.createElement("div");
		Object.assign(this.container.style, {
			position: "fixed",
			left: "50%",
			top: "50%",
			transform: "translate(-50%,-50%)",
			background: "var(--editor-background)",
			border: `2px solid ${ColorConfig.uiWidgetBackground}`,
			borderRadius: "8px",
			padding: "12px",
			zIndex: 100,
			color: ColorConfig.primaryText,
			width: "280px",
			maxHeight:"90vh",
			overflow:"hidden scroll ",
			fontFamily: "sans-serif",
			display: "none",
		});

		const title = document.createElement("h2");
		title.textContent = "Whistle Settings";
		title.style.margin = "0 0 10px 0";
		title.style.textAlign = "center";
		this.container.appendChild(title);
 
		this.inputStable = this._mkInput("Stable N", _doc.synth.STABLE_N);
		this.inputSilence = this._mkInput("Silence N", _doc.synth.SILENCE_N);
		this.inputMin = this._mkInput("Min Note MS", _doc.synth.MIN_NOTE_MS);
		this.inputChange = this._mkInput("Change Hold MS", _doc.synth.CHANGE_HOLD_MS );
		this.inputDb = this._mkInput("dB MIN", _doc.synth.Db);
		this.inputShift = this._mkInput("Pitch Shift", _doc.synth.SHIFT );
  this.inputTolerance = this._mkInput("Tolerance", _doc.synth.TOLERANCE );
  this.inputNoteHold = this._mkInput("Note Hold", _doc.synth.NOTE_HOLD_EXTRA );
		const btnRow = document.createElement("div");
		Object.assign(btnRow.style, { display: "flex", justifyContent: "flex-end", gap: "6px" });
		this.btnCancel = this._mkBtn("Cancel");
		this.btnDone = this._mkBtn("Done");
		btnRow.appendChild(this.btnCancel);
		btnRow.appendChild(this.btnDone);
		this.container.appendChild(btnRow);

		this.parent.appendChild(this.container);

		this.btnCancel.onclick = () => this.hide();
		this.btnDone.onclick = () => {
			const params = {
				STABLE_N: Number(this.inputStable.value),
				SILENCE_N: Number(this.inputSilence.value),
				MIN_NOTE_MS: Number(this.inputMin.value),
				CHANGE_HOLD_MS: Number(this.inputChange.value),
				DB: Number(this.inputDb.value),
				Shift: Number(this.inputShift.value),
				TOLERANCE: Number(this.inputTolerance.value),
				NOTE_HOLD_EXTRA: Number(this.inputNoteHold.value),
			};
			if (this.ondone) this.ondone(params);
			this.hide();
		};

		this.ondone = null;
	}

	_mkInput(label, def) {
		const wrap = document.createElement("div");
		wrap.style.marginBottom = "6px";
		const lbl = document.createElement("label");
		lbl.textContent = label;
		lbl.style.display = "block";
		lbl.style.marginBottom = "2px";
		const inp = document.createElement("input");
		inp.type = "number";
		inp.value = def;
		Object.assign(inp.style, {
			width: "100%",
			padding: "4px",
			boxSizing: "border-box",
			background: "transparent",
			color: ColorConfig.primaryText,
			border: `1px solid ${ColorConfig.uiWidgetBackground}`
		});
		wrap.appendChild(lbl);
		wrap.appendChild(inp);
		this.container.appendChild(wrap);
		return inp;
	}

	_mkBtn(txt) {
		const b = document.createElement("button");
		b.textContent = txt;
		Object.assign(b.style, {
			padding: "6px 10px",
			cursor: "pointer",
			borderRadius: "4px",
			border: "1px solid #555",
			background: "#333",
			color: "#fff",
		});
		return b;
	}

	show() { this.container.style.display = "block"; }
	hide() { this.container.style.display = "none"; }
	destroy() { this.container.remove(); }
}

    
class SelectMoreContainer {
	constructor(parent = document.body) {
		this.parent = parent;
		this.container = document.createElement('div');
		Object.assign(this.container.style, {
			position: 'fixed',
			right: '12px',
			top: '50vh',
			left: "50vw",
			minHeight: "40vh",
			transform: "translate(-50%,-50%)",
			zIndex: '5',
			borderRadius: "15px",
			border: `4px solid ${ColorConfig.uiWidgetBackground}`,
			color: `${ColorConfig.primaryText}`,
			background: 'var(--editor-background)',
			padding: '8px',
			width: "calc(100vw - 48px)",
			overflow: "hidden scroll",
			borderRadius: '6px',
			boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
			fontFamily: 'Arial, sans-serif',
			fontSize: '13px',
			display: 'none'
		});
		const inputsWrap = document.createElement('div');
		Object.assign(inputsWrap.style, {
			display: 'grid',
			background: "transparent",
			color: ColorConfig.primaryText,
			gridTemplateColumns: 'repeat(2, 1fr)',
			gap: '6px',
			marginBottom: '8px',
			color: "white"
		});
		const placeholderClass = 'custom-placeholder';
		const style = document.createElement('style');
		style.textContent = `
			.${placeholderClass}::placeholder {
				color: ${ColorConfig.primaryText};
			}
		`;
		document.head.appendChild(style);
		this.inputX2 = document.createElement('input');
		this.inputX2.type = 'number';
		this.inputX2.placeholder = 'bar index';
		Object.assign(this.inputX2.style, {
			padding: '6px',
			width: '100%',
			boxSizing: 'border-box',
			background: "transparent",
			border: `1px solid ${ColorConfig.uiWidgetBackground}`,
			borderRadius: "0px",
			color: ColorConfig.primaryText,
		});
		this.inputX2.classList.add(placeholderClass);
		this.inputY2 = document.createElement('input');
		this.inputY2.type = 'number';
		this.inputY2.placeholder = 'channel index';
		Object.assign(this.inputY2.style, {
			padding: '6px',
			width: '100%',
			boxSizing: 'border-box',
			background: "transparent",
			border: `1px solid ${ColorConfig.uiWidgetBackground}`,
			borderRadius: "0px",
			color: ColorConfig.primaryText,
		});
		this.inputY2.classList.add(placeholderClass);
		inputsWrap.appendChild(this.inputX2);
		inputsWrap.appendChild(this.inputY2);
		const buttonsWrap = document.createElement('div');
		Object.assign(buttonsWrap.style, {
			display: 'flex',
			gap: '6px',
			justifyContent: 'flex-end'
		});
		this.btnCancel = document.createElement('button');
		this.btnCancel.type = 'button';
		this.btnCancel.textContent = 'Cancel';
		Object.assign(this.btnCancel.style, {
			padding: '6px 10px',
			borderRadius: '4px',
			border: '1px solid #ccc',
			background: '#f5f5f5',
			cursor: 'pointer',
		});
		this.btnDone = document.createElement('button');
		this.btnDone.type = 'button';
		this.btnDone.textContent = 'Done';
		Object.assign(this.btnDone.style, {
			padding: '6px 10px',
			borderRadius: '4px',
			border: '1px solid #0a66ff',
			background: '#0a66ff',
			color: '#fff',
			cursor: 'pointer',
			opacity: '0.6'
		});
		this.btnDone.disabled = true;
		buttonsWrap.appendChild(this.btnCancel);
		buttonsWrap.appendChild(this.btnDone);
		this.container.appendChild(inputsWrap);
		this.container.appendChild(buttonsWrap);
		document.body.appendChild(this.container);
		this.ondone = null;
		this._onInput = this._onInput.bind(this);
		this._onDone = this._onDone.bind(this);
		this._onCancel = this._onCancel.bind(this);
		this.inputX2.addEventListener('input', this._onInput);
		this.inputY2.addEventListener('input', this._onInput);
		this.btnDone.addEventListener('click', this._onDone);
		this.btnCancel.addEventListener('click', this._onCancel);
	}
	_isValid(v) {
		return v !== '' && !Number.isNaN(Number(v));
	}
	_onInput() {
		const v2 = this.inputX2.value;
		const v4 = this.inputY2.value;
		const ok = this._isValid(v2) && this._isValid(v4);
		this.btnDone.disabled = !ok;
		this.btnDone.style.opacity = ok ? '1' : '0.6';
	}
	_onDone() {
		const x2 = Number(this.inputX2.value);
		const y2 = Number(this.inputY2.value);
		if (this.ondone) this.ondone(x2, y2);
		this.hide();
	}
	_onCancel() {
		this.hide();
	}
	show(x2 = '', y2 = '') {
		this.inputX2.value = x2 !== '' ? x2 : '';
		this.inputY2.value = y2 !== '' ? y2 : '';
		this.container.style.display = 'block';
		this._onInput();
	}
	hide() {
		this.container.style.display = 'none';
	}
	destroy() {
		this.inputX2.removeEventListener('input', this._onInput);
		this.inputY2.removeEventListener('input', this._onInput);
		this.btnDone.removeEventListener('click', this._onDone);
		this.btnCancel.removeEventListener('click', this._onCancel);
		this.container.remove();
	}
}


 

 

    
    
    class SongEditor {
 _getWavesForChip(chipName) {
    switch (chipName) {
        case "chip1": return ["sine", "square"];
        case "chip2": return ["triangle", "noise"];
        default: return ["sine"];
    }
}
        constructor(_doc) {
            this._doc = _doc;
            this.prompt = null;
            
            this._patternEditorPrev = new PatternEditor(this._doc, false, -1);
            this._patternEditor = new PatternEditor(this._doc, true, 0);
            this._patternEditorNext = new PatternEditor(this._doc, false, 1);
            this._openUnisonDropdown = false;
            this._trackEditor = new TrackEditor(this._doc, this);
            this._muteEditor = new MuteEditor(this._doc, this);
            this._loopEditor = new LoopEditor(this._doc);
            this._piano = new Piano(this._doc);
            this.changedUnisonPreview=0;
            this._octaveScrollBar = new OctaveScrollBar(this._doc, this._piano);
            this._playButton = button$d({ style: "width: 45px; ", type: "button" });
this._recordButton = button({ class: "recordButton", style: "display: none; width: 30px; ", type: "button", title: "Record (Ctrl+Space)" }, span(""));
this._stopButton = button({ class: "stopButton", style: "display: none; ", type: "button", title: "Stop Recording (Space)" }, "  Stop Recording");

            this._prevBarButton = button$d({ class: "prevBarButton", style: "width: 40px;", type: "button", title: "Previous Bar (left bracket)" });
            this._nextBarButton = button$d({ class: "nextBarButton", style: "width: 40px;", type: "button", title: "Next Bar (right bracket)" });
            this._volumeSlider = new Slider(input$8({ title: "main volume", style: "width: 5em; flex-grow: 1; margin: 0;", type: "range", min: "0", max: "75", value: "50", step: "1" }), this._doc, null, false);
            this._outVolumeBarBg = SVG.rect({ "pointer-events": "none", width: "90%", height: "50%", x: "5%", y: "25%", fill: ColorConfig.uiWidgetBackground });
            this._outVolumeBar = SVG.rect({ "pointer-events": "none", height: "50%", width: "0%", x: "5%", y: "25%", fill: "url('#volumeGrad2')" });
            this._outVolumeCap = SVG.rect({ "pointer-events": "none", width: "2px", height: "50%", x: "5%", y: "25%", fill: ColorConfig.uiWidgetFocus });
            this._stop1 = SVG.stop({ "stop-color": "lime", offset: "60%" });
            this._stop2 = SVG.stop({ "stop-color": "orange", offset: "90%" });
            this._stop3 = SVG.stop({ "stop-color": "red", offset: "100%" });
            this._gradient = SVG.linearGradient({ id: "volumeGrad2", gradientUnits: "userSpaceOnUse" }, this._stop1, this._stop2, this._stop3);
            this._defs = SVG.defs({}, this._gradient);
            this._volumeBarContainer = SVG.svg({ style: `touch-action: none; overflow: visible; margin: auto; max-width: 20vw;`, width: "160px", height: "100%", preserveAspectRatio: "none", viewBox: "0 0 160 12" }, this._defs, this._outVolumeBarBg, this._outVolumeBar, this._outVolumeCap);
            this._volumeBarBox = div$d({ class: "playback-volume-bar", style: "height: 12px; align-self: center;" }, this._volumeBarContainer);
            this._fileMenu = select$6({ style: "width: 100%;" }, option$6({ selected: true, disabled: true, hidden: false }, "File"), option$6({ value: "new" }, "+ New Blank Song"), option$6({ value: "import" }, "↑ Import Song... (" + EditorConfig.ctrlSymbol + "O)"), option$6({ value: "export" }, "↓ Export Song... (" + EditorConfig.ctrlSymbol + "S)"), option$6({ value: "copyUrl" }, "⎘ Copy Song URL"), option$6({ value: "shareUrl" }, "⤳ Share Song URL"), option$6({ value: "shortenUrl" }, "… Shorten Song URL"), option$6({ value: "copyEmbed" }, "⎘ Copy HTML Embed Code"), option({ value: "viewPlayer" }, "▶ View in Song Player (⇧P)")  );
            this._editMenu = select$6({ style: "width: 100%;" }, option$6({ selected: true, disabled: true, hidden: false }, "Edit"), option$6({ value: "undo" }, "Undo (Z)"), option$6({ value: "redo" }, "Redo (Y)"), option$6({ value: "copy" }, "Copy Pattern (C)"), option$6({ value: "pasteNotes" }, "Paste Pattern Notes (V)"), option$6({ value: "pasteNumbers" }, "Paste Pattern Numbers (" + EditorConfig.ctrlSymbol + "⇧V)"), option$6({ value: "insertBars" }, "Insert Bar (⏎)"), option$6({ value: "deleteBars" }, "Delete Selected Bars (⌫)"), option$6({ value: "insertChannel" }, "Insert Channel (" + EditorConfig.ctrlSymbol + "⏎)"), option$6({ value: "deleteChannel" }, "Delete Selected Channels (" + EditorConfig.ctrlSymbol + "⌫)"), option$6({ value: "selectChannel" }, "Select Channel (⇧A)"),option$6({ value: "selectAll" }, "Select All (A)"), option$6({ value: "selectMore" }, "Select More (XY)"),  option$6({ value: "duplicatePatterns" }, "Duplicate Reused Patterns (D)"), option$6({ value: "transposeUp" }, "Move Notes Up (+ or ⇧+)"), option$6({ value: "transposeDown" }, "Move Notes Down (- or ⇧-)"),  option$6({ value: "transposeOctaveUp" }, "Move Notes Up Octave +"), option$6({ value: "transposeOctaveDown" }, "Move Notes Down Octave -")  , option$6({ value: "moveNotesSideways" }, "Move All Notes Sideways... (W)"), option$6({ value: "beatsPerBar" }, "Change Beats Per Bar..."), option$6({ value: "barCount" }, "Change Song Length... (L)"), option$6({ value: "channelSettings" }, "Channel Settings... (Q)"),  option$6({ value: "limiterSettings" }, "Limiter Settings... (⇧L)"));
            this._optionsMenu = select$6({ style: "width: 100%;" }, option$6({ selected: true, disabled: true, hidden: false }, "Preferences"), option$6({ value: "autoPlay" }, "Auto Play On Load"), option$6({ value: "autoFollow" }, "Auto Follow Track"), option$6({ value: "enableNotePreview" }, "Preview Added Notes"), option$6({ value: "showLetters" }, "Show Piano Keys"), option$6({ value: "showFifth" }, 'Highlight "Fifth" Notes'),  option$6({ value: "notesOutsideScale" }, "Allow Notes Outside Scale"), option$6({ value: "setDefaultScale" }, "Use Current Scale as Default"), option$6({ value: "showChannels" }, "Show All Channels"), option$6({ value: "showScrollBar" }, "Octave Scroll Bar"),
            option$6({ value: "differentMod" }, "Better Mod Visuals"),
            option$6({ value: "alwaysFineNoteVol" }, "Always Fine Note Vol."), option$6({ value: "enableChannelMuting" }, "Enable Channel Muting"), option$6({ value: "displayBrowserUrl" }, "Display Song Data in URL"), option$6({ value: "displayVolumeBar" }, "Show Playback Volume"), option$6({ value: "layout" }, "Set Layout..."),  option$6({ value: "colorTheme" }, "Set Theme..."), option({ value: "notesFlashWhenPlayed" }, " Notes Flash When Played in Player") ,option({ value: "showDescription" }, "Show Description"), option({ value: "showPlugins" }, "Show Plugins"), option$6({ value: "increaseAllPins" }, "Increase All Pins ."),  option$6({ value: "whistleRecord" }, "Record With Whistle "), option({ value: "recordingSetup" }, "Note Recording..."), );
            this._scaleSelect = buildOptions(select$6(), Config.scales.map(scale => scale.name));
            this._keySelect = buildOptions(select$6(), Config.keys.map(key => key.name).reverse());
            this._tempoSlider = new Slider(input$8({ style: "margin: 0; vertical-align: middle;", type: "range", min: "1", max: "960", value: "160", step: "1" }), this._doc, (oldValue, newValue) => new ChangeTempo(this._doc, oldValue, newValue), false);
            this._tempoStepper = input$8({ style: "width: 4em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", type: "number", step: "1" });
            this._chorusSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.chorusRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeChorus(this._doc, oldValue, newValue), false);
            this._chorusRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("chorus") }, "Chorus:"), this._chorusSlider.container);
            this._reverbSlider = new Slider(input$8({ style: "margin: 0; position: sticky,", type: "range", min: "0", max: Config.reverbRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeReverb(this._doc, oldValue, newValue), false);
            this._reverbRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("reverb") }, "Reverb:"), this._reverbSlider.container);
            
            
            this._ringModWaveSelect = buildOptions(select({}), Config.operatorWaves.map(wave => wave.name));
            this._ringModSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.ringModRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeRingMod(this._doc, oldValue, newValue), false);
            
            
            this._ringModPulsewidthSlider = new Slider(input({ style: "margin-left: 10px; width: 85%;", type: "range", min: "0", max: Config.pwmOperatorWaves.length - 1, value: "0", step: "1", title: "Pulse Width" }), this._doc, (oldValue, newValue) => new ChangeRingModPulseWidth(this._doc, oldValue, newValue), true);
            
            this._ringModRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("ringMod") }, "Ring Mod:"), this._ringModSlider.container);
            this._ringModHzSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.ringModHzRange - 1, value: (Config.ringModHzRange - (Config.ringModHzRange / 2)), step: "1" }), this._doc, (oldValue, newValue) => new ChangeRingModHz(this._doc, oldValue, newValue), true);
            this.ringModHzNum = div({ style: "font-size: 80%; ", id: "ringModHzNum" });
            this._ringModHzSliderRow = div({ class: "selectRow", style: "width:100%;" }, div({ style: "display:flex; flex-direction:column; align-items:center;" }, span({ class: "tip", style: "font-size: smaller;", onclick: () => this._openPrompt("RingModHz") }, "Hertz: "), div({ style: `color: ${ColorConfig.secondaryText}; ` }, this.ringModHzNum)), this._ringModHzSlider.container);
            this._ringModWaveText = span({ class: "tip", onclick: () => this._openPrompt("chipWave") }, "Wave: ");
            this._ringModWaveSelectRow = div({ class: "selectRow", style: "width: 100%;" }, this._ringModWaveText, this._ringModPulsewidthSlider.container, div({ class: "selectContainer", style: "width:40%;" }, this._ringModWaveSelect));
            this._ringModContainerRow = div({ class: "", style: "display:flex; flex-direction:column;" }, this._ringModRow, this._ringModHzSliderRow, this._ringModWaveSelectRow);
            
            
            
            this._echoSustainSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.echoSustainRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeEchoSustain(this._doc, oldValue, newValue), false);
            this._echoSustainRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("echoSustain") }, "Echo:"), this._echoSustainSlider.container);
            this._echoDelaySlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.echoDelayRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeEchoDelay(this._doc, oldValue, newValue), false);
            this._echoDelayRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("echoDelay") }, "Echo Delay:"), this._echoDelaySlider.container);
            this._rhythmSelect = buildOptions(select$6(), Config.rhythms.map(rhythm => rhythm.name));
            this._pitchedPresetSelect = buildPresetOptions(false, "pitchPresetSelect");
            this._drumPresetSelect = buildPresetOptions(true, "drumPresetSelect");
            this._algorithmSelect = buildOptions(select$6(), Config.algorithms.map(algorithm => algorithm.name));
            this._algorithmSelectRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("algorithm") }, "Algorithm: "), div$d({ class: "selectContainer" }, this._algorithmSelect));
            this._instrumentButtons = [];
            this._instrumentAddButton = button$d({ type: "button", class: "add-instrument last-button" });
            this._instrumentRemoveButton = button$d({ type: "button", class: "remove-instrument" });
            this._instrumentsButtonBar = div$d({ class: "instrument-bar" }, this._instrumentRemoveButton, this._instrumentAddButton);
            this._instrumentsButtonRow = div$d({ class: "selectRow", style: "display: none;" }, span$4({ class: "tip", onclick: () => this._openPrompt("instrumentIndex") }, "Instrument:"), this._instrumentsButtonBar);
            this._instrumentVolumeSlider = new Slider(input$8({ style: "margin: 0; position: sticky;", type: "range", min: Math.floor(-Config.volumeRange / 2), max: Math.floor(Config.volumeRange / 2), value: "0", step: "0.025" }), this._doc, (oldValue, newValue) => new ChangeVolume(this._doc, oldValue, newValue), true);
            this._instrumentVolumeSliderInputBox = input$8({ style: "width: 4em; font-size: 80%", id: "volumeSliderInputBox", type: "number", step: "0.025", min: Math.floor(-Config.volumeRange / 2), max: Math.floor(Config.volumeRange / 2), value: "0" });
            this._instrumentVolumeSliderTip = div$d({ class: "selectRow", style: "height: 1em" }, span$4({ class: "tip", style: "font-size: smaller;", onclick: () => this._openPrompt("instrumentVolume") }, "Volume: "));
            this._instrumentVolumeSliderRow = div$d({ class: "selectRow" }, div$d({}, div$d({ style: "color: " + ColorConfig.secondaryText + ";" }, span$4({ class: "tip" }, this._instrumentVolumeSliderTip)), div$d({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._instrumentVolumeSliderInputBox)), this._instrumentVolumeSlider.container);
            this._panSlider = new Slider(input$8({ style: "margin: 0; position: sticky;", type: "range", min: "0", max: Config.panMax, value: Config.panCenter, step: "1" }), this._doc, (oldValue, newValue) => new ChangePan(this._doc, oldValue, newValue), true);
            this._panDropdown = button$d({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(1) }, "▼");
            this._panSliderInputBox = input$8({ style: "width: 4em; font-size: 80%; ", id: "panSliderInputBox", type: "number", step: "1", min: "0", max: "100", value: "0" });
            this._panSliderRow = div$d({ class: "selectRow" }, div$d({}, span$4({ class: "tip", tabindex: "0", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("pan") }, "Pan: "), div$d({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._panSliderInputBox)), this._panDropdown, this._panSlider.container);
            this._panDelaySlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["pan delay"].maxRawVol, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangePanDelay(this._doc, oldValue, newValue), false);
            this._panDelayRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("panDelay") }, "Delay:"), this._panDelaySlider.container);
            this._panDropdownGroup = div$d({ class: "editor-controls", style: "display: none;" }, this._panDelayRow);
            
            
  

 
            this._chipNoiseSelect = buildOptions(select$6(), Config.chipNoises.map(wave => wave.name));
            this._chipWaveSelect = buildOptions(select$6(), Config.chipWaves.map(wave => wave.name));
            this._chipWaveSelectRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("chipWave") }, "Wave: "), div$d({ class: "selectContainer" }, this._chipWaveSelect));
            
  
            this._chipNoiseSelectRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("chipNoise") }, "Noise: "), div$d({ class: "selectContainer" }, this._chipNoiseSelect));
            
            
this._useChipWaveAdvancedLoopControlsBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: 0.4em; margin-right: 4em;" });
this._chipWaveLoopModeSelect = buildOptions(select(), ["Loop", "Ping-Pong", "Play Once", "Play Loop Once"]);
this._chipWaveLoopStartStepper = input({ type: "number", min: "0", step: "1", value: "0", style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;" });
this._chipWaveLoopEndStepper = input({ type: "number", min: "0", step: "1", value: "0", style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;" });
this._setChipWaveLoopEndToEndButton = button({ type: "button", style: "width: 1.5em; height: 1.5em; padding: 0; margin-left: 0.5em;" }, SVG.svg({ width: "16", height: "16", viewBox: "-13 -14 26 26", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.rect({ x: "4", y: "-6", width: "2", height: "12", fill: ColorConfig.primaryText }), SVG.path({ d: "M -6 -6 L -6 6 L 3 0 z", fill: ColorConfig.primaryText })));
this._chipWaveStartOffsetStepper = input({ type: "number", min: "0", step: "1", value: "0", style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;" });
this._chipWavePlayBackwardsBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: 0.4em; margin-right: 4em;" });
this._chipWaveSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("chipWave") }, "Wave: "), div({ class: "selectContainer" }, this._chipWaveSelect));
this._visualLoopControlsButton = button({ style: "margin-left: 0em; padding-left: 0.2em; height: 1.5em; max-width: 12px;", onclick: () => this._openPrompt("visualLoopControls") }, "+");
this._useChipWaveAdvancedLoopControlsRow = div({ class: "selectRow" }, span({ class: "tip", style: "flex-shrink: 0;", onclick: () => this._openPrompt("loopControls") }, "Loop Controls: "), this._useChipWaveAdvancedLoopControlsBox);



this._chipWaveLoopModeSelectRow = div({ class: "selectRow" }, span({ class: "tip", style: "font-size: x-small;", onclick: () => this._openPrompt("loopMode") }, "Loop Mode: "), div({ class: "selectContainer" }, this._chipWaveLoopModeSelect));
this._chipWaveLoopStartRow = div({ class: "selectRow" }, span({ class: "tip", style: "font-size: x-small;", onclick: () => this._openPrompt("loopStart") }, "Loop Start: "), this._visualLoopControlsButton, span({ style: "display: flex;" }, this._chipWaveLoopStartStepper));
this._chipWaveLoopEndRow = div({ class: "selectRow" }, span({ class: "tip", style: "font-size: x-small;", onclick: () => this._openPrompt("loopEnd") }, "Loop End: "), span({ style: "display: flex;" }, this._chipWaveLoopEndStepper, this._setChipWaveLoopEndToEndButton));
this._chipWaveStartOffsetRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("offset") }, "Offset: "), span({ style: "display: flex;" }, this._chipWaveStartOffsetStepper));
this._chipWavePlayBackwardsRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("backwards") }, "Backwards: "), this._chipWavePlayBackwardsBox);
            
            this._fadeInOutEditor = new FadeInOutEditor(this._doc);
            this._fadeInOutRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("fadeInOut") }, "Fade:"), this._fadeInOutEditor.container);
            this._transitionSelect = buildOptions(select$6(), Config.transitions.map(transition => transition.name));
            this._transitionDropdown = button$d({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(3) }, "▼");
            this._transitionRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("transition") }, "Transition:"), this._transitionDropdown, div$d({ class: "selectContainer", style: "width: 52.5%;" }, this._transitionSelect));
            this._clicklessTransitionBox = input$8({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;" });
            this._clicklessTransitionRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("clicklessTransition") }, "Clickless:"), this._clicklessTransitionBox);
            this._transitionDropdownGroup = div$d({ class: "editor-controls", style: "display: none;" }, this._clicklessTransitionRow);
            this._effectsSelect = select$6(option$6({ selected: true, disabled: true, hidden: false }));
            this._eqFilterSimpleButton = button$d({ style: "font-size: x-small; width: 50%; height: 40%", onclick: () => this._switchEQFilterType(true) }, "simple");
            this._eqFilterAdvancedButton = button$d({ style: "font-size: x-small; width: 50%; height: 40%", class: "last-button", onclick: () => this._switchEQFilterType(false) }, "advanced");
            this._eqFilterTypeRow = div$d({ class: "selectRow", style: "padding-top: 4px; margin-bottom: 0px;" }, span$4({ style: "font-size: x-small;", class: "tip", onclick: () => this._openPrompt("filterType") }, "EQ Filt.Type:"), div$d({ class: "instrument-bar" }, this._eqFilterSimpleButton, this._eqFilterAdvancedButton));
            this._eqFilterEditor = new FilterEditor(this._doc);
            this._eqFilterZoom = button$d({ style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("customEQFilterSettings") }, "+");
            this._eqFilterRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("eqFilter") }, "EQ Filt:"), this._eqFilterZoom, this._eqFilterEditor.container);
            this._eqFilterSimpleCutSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimpleCutRange - 1, value: "6", step: "1" }), this._doc, (oldValue, newValue) => new ChangeEQFilterSimpleCut(this._doc, oldValue, newValue), false);
            this._eqFilterSimpleCutRow = div$d({ class: "selectRow", title: "Low-pass Filter Cutoff Frequency" }, span$4({ class: "tip", onclick: () => this._openPrompt("filterCutoff") }, "Filter Cut:"), this._eqFilterSimpleCutSlider.container);
            this._eqFilterSimplePeakSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimplePeakRange - 1, value: "6", step: "1" }), this._doc, (oldValue, newValue) => new ChangeEQFilterSimplePeak(this._doc, oldValue, newValue), false);
            this._eqFilterSimplePeakRow = div$d({ class: "selectRow", title: "Low-pass Filter Peak Resonance" }, span$4({ class: "tip", onclick: () => this._openPrompt("filterResonance") }, "Filter Peak:"), this._eqFilterSimplePeakSlider.container);
            this._noteFilterSimpleButton = button$d({ style: "font-size: x-small; width: 50%; height: 40%", onclick: () => this._switchNoteFilterType(true) }, "simple");
            this._noteFilterAdvancedButton = button$d({ style: "font-size: x-small; width: 50%; height: 40%", class: "last-button", onclick: () => this._switchNoteFilterType(false) }, "advanced");
            this._noteFilterTypeRow = div$d({ class: "selectRow", style: "padding-top: 4px; margin-bottom: 0px;" }, span$4({ style: "font-size: x-small;", class: "tip", onclick: () => this._openPrompt("filterType") }, "Note Filt.Type:"), div$d({ class: "instrument-bar" }, this._noteFilterSimpleButton, this._noteFilterAdvancedButton));
            this._noteFilterEditor = new FilterEditor(this._doc, true);
            this._noteFilterZoom = button$d({ style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("customNoteFilterSettings") }, "+");
            this._noteFilterRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("noteFilter") }, "Note Filt:"), this._noteFilterZoom, this._noteFilterEditor.container);
            this._noteFilterSimpleCutSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimpleCutRange - 1, value: "6", step: "1" }), this._doc, (oldValue, newValue) => new ChangeNoteFilterSimpleCut(this._doc, oldValue, newValue), false);
            this._noteFilterSimpleCutRow = div$d({ class: "selectRow", title: "Low-pass Filter Cutoff Frequency" }, span$4({ class: "tip", onclick: () => this._openPrompt("filterCutoff") }, "Filter Cut:"), this._noteFilterSimpleCutSlider.container);
            this._noteFilterSimplePeakSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimplePeakRange - 1, value: "6", step: "1" }), this._doc, (oldValue, newValue) => new ChangeNoteFilterSimplePeak(this._doc, oldValue, newValue), false);
            this._noteFilterSimplePeakRow = div$d({ class: "selectRow", title: "Low-pass Filter Peak Resonance" }, span$4({ class: "tip", onclick: () => this._openPrompt("filterResonance") }, "Filter Peak:"), this._noteFilterSimplePeakSlider.container);
            this._pulseWidthSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "1", max: Config.pulseWidthRange, value: "1", step: "1" }), this._doc, (oldValue, newValue) => new ChangePulseWidth(this._doc, oldValue, newValue), false);
            
            this._pulseWidthRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("pulseWidth") }, "Pulse Width:"), this._pulseWidthSlider.container);
       
 
            
            
            this._pitchShiftSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.pitchShiftRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangePitchShift(this._doc, oldValue, newValue), true);
this._pitchShiftTonicMarkers = [div$d({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic } }), div$d({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic, left: "50%" } }), div$d({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic, left: "100%" } })];
this._pitchShiftFifthMarkers = [div$d({ class: "pitchShiftMarker", style: { color: ColorConfig.fifthNote, left: (100 * 7 / 24) + "%" } }), div$d({ class: "pitchShiftMarker", style: { color: ColorConfig.fifthNote, left: (100 * 19 / 24) + "%" } })];
            
             

            
 
            
            
            
            
            this._pitchShiftMarkerContainer = div$d({ style: "display: flex; position: relative;" }, this._pitchShiftSlider.container, div$d({ class: "pitchShiftMarkerContainer" }, this._pitchShiftTonicMarkers, this._pitchShiftFifthMarkers));
            this._pitchShiftBox = input$8({ style: "width: 4em; font-size: 80%; ", id: "pitchShiftBox", type: "number", step: "1", min: "0", max: "32", value: "0" });
            this._pitchShiftRow = div$d({ class: "selectRow" }, div$d({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._pitchShiftBox), span$4({ class: "tip", onclick: () => this._openPrompt("pitchShift") }, "Pitch Shift:"), this._pitchShiftMarkerContainer);
            this._detuneSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: Config.detuneMin - Config.detuneCenter, max: Config.detuneMax - Config.detuneCenter, value: 0, step: "4" }), this._doc, (oldValue, newValue) => new ChangeDetune(this._doc, oldValue, newValue), true);
            this._detuneSliderInputBox = input$8({ style: "width: 4em; font-size: 80%; ", id: "detuneSliderInputBox", type: "number", step: "1", min: Config.detuneMin - Config.detuneCenter, max: Config.detuneMax - Config.detuneCenter, value: 0 });
            this._detuneSliderRow = div$d({ class: "selectRow" }, div$d({}, span$4({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("detune") }, "Detune: "), div$d({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._detuneSliderInputBox)), this._detuneSlider.container);
            this._distortionSlider = new Slider(input$8({ style: "margin: 0; position: sticky;", type: "range", min: "0", max: Config.distortionRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeDistortion(this._doc, oldValue, newValue), false);
            this._distortionRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("distortion") }, "Distortion:"), this._distortionSlider.container);
            this._aliasingBox = input$8({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;" });
            this._aliasingRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("aliases") }, "Aliasing:"), this._aliasingBox);
            this._bitcrusherQuantizationSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.bitcrusherQuantizationRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeBitcrusherQuantization(this._doc, oldValue, newValue), false);
            this._bitcrusherQuantizationRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("bitcrusherQuantization") }, "Bit Crush:"), this._bitcrusherQuantizationSlider.container);
            this._bitcrusherFreqSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.bitcrusherFreqRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeBitcrusherFreq(this._doc, oldValue, newValue), false);
            this._bitcrusherFreqRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("bitcrusherFreq") }, "Freq Crush:"), this._bitcrusherFreqSlider.container);
            this._stringSustainSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.stringSustainRange - 1, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeStringSustain(this._doc, oldValue, newValue), false);
            this._stringSustainRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("stringSustain") }, "Sustain:"), this._stringSustainSlider.container);
            
this._unisonDropdown = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(6) }, "▼");

this._unisonSelect = buildOptions(select(), Config.unisons.map(unison => unison.name));
this._unisonSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("unison") }, "Unison:"), this._unisonDropdown, div({ class: "selectContainer", style: "width: 61.5%;" }, this._unisonSelect)); 

this._unisonVoicesInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle; ", id: "unisonVoicesInputBox", type: "number", step: "1", min: Config.unisonVoicesMin, max: Config.unisonVoicesMax, value: 1 });
this._unisonVoicesRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonVoices") }, " Voices: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonVoicesInputBox)));
this._unisonSpreadInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonSpreadInputBox", type: "number", step: "0.001", min: Config.unisonSpreadMin, max: Config.unisonSpreadMax, value: 0.0 });
this._unisonSpreadRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonSpread") }, " Spread: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonSpreadInputBox)));
this._unisonOffsetInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonOffsetInputBox", type: "number", step: "0.001", min: Config.unisonOffsetMin, max: Config.unisonOffsetMax, value: 0.0 });
this._unisonOffsetRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonOffset") }, " Offset: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonOffsetInputBox)));
this._unisonExpressionInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonExpressionInputBox", type: "number", step: "0.001", min: Config.unisonExpressionMin, max: Config.unisonExpressionMax, value: 1.4 });
this._unisonExpressionRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonExpression") }, " Volume: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonExpressionInputBox)));
this._unisonSignInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonSignInputBox", type: "number", step: "0.001", min: Config.unisonSignMin, max: Config.unisonSignMax, value: 1.0 });
this._unisonSignRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonSign") }, " Sign: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonSignInputBox)));
this._unisonDropdownGroup = div({ class: "editor-controls", style: "display: none; gap: 3px; margin-bottom: 0.5em;" }, this._unisonVoicesRow, this._unisonSpreadRow, this._unisonOffsetRow, this._unisonExpressionRow, this._unisonSignRow);


            this._chordSelect = buildOptions(select$6(), Config.chords.map(chord => chord.name));
            this._chordDropdown = button$d({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(2) }, "▼");
            this._chordSelectRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("chords") }, "Chords:"), this._chordDropdown, div$d({ class: "selectContainer" }, this._chordSelect));
            this._arpeggioSpeedSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["arp speed"].maxRawVol, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeArpeggioSpeed(this._doc, oldValue, newValue), false);
            this._arpeggioSpeedRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("arpeggioSpeed") }, "Speed:"), this._arpeggioSpeedSlider.container);
            this._twoNoteArpBox = input$8({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;" });
            this._twoNoteArpRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("twoNoteArpeggio") }, "Fast Two-Note:"), this._twoNoteArpBox);
            this._chordDropdownGroup = div$d({ class: "editor-controls", style: "display: none;" }, this._arpeggioSpeedRow, this._twoNoteArpRow);
            this._vibratoSelect = buildOptions(select$6(), Config.vibratos.map(vibrato => vibrato.name));
            this._vibratoDropdown = button$d({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(0) }, "▼");
            this._vibratoSelectRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("vibrato") }, "Vibrato:"), this._vibratoDropdown, div$d({ class: "selectContainer", style: "width: 61.5%;" }, this._vibratoSelect));
            this._vibratoDepthSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["vibrato depth"].maxRawVol, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeVibratoDepth(this._doc, oldValue, newValue), false);
            this._vibratoDepthRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("vibratoDepth") }, "Depth:"), this._vibratoDepthSlider.container);
            this._vibratoSpeedSlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["vibrato speed"].maxRawVol, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeVibratoSpeed(this._doc, oldValue, newValue), false);
            this._vibratoSpeedRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("vibratoSpeed") }, "Speed:"), this._vibratoSpeedSlider.container);
            this._vibratoDelaySlider = new Slider(input$8({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["vibrato delay"].maxRawVol, value: "0", step: "1" }), this._doc, (oldValue, newValue) => new ChangeVibratoDelay(this._doc, oldValue, newValue), false);
            this._vibratoDelayRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("vibratoDelay") }, "Delay:"), this._vibratoDelaySlider.container);
            this._vibratoTypeSelect = buildOptions(select$6(), Config.vibratoTypes.map(vibrato => vibrato.name));
            this._vibratoTypeSelectRow = div$d({ class: "selectRow" }, span$4({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("vibratoType") }, "Type:"), div$d({ class: "selectContainer", style: "width: 61.5%;" }, this._vibratoTypeSelect));
            this._vibratoDropdownGroup = div$d({ class: "editor-controls", style: "display: none;" }, this._vibratoDepthRow, this._vibratoSpeedRow, this._vibratoDelayRow, this._vibratoTypeSelectRow);
            this._phaseModGroup = div$d({ class: "editor-controls" });
            this._feedbackTypeSelect = buildOptions(select$6(), Config.feedbacks.map(feedback => feedback.name));
            this._feedbackRow1 = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("feedbackType") }, "Feedback:"), div$d({ class: "selectContainer" }, this._feedbackTypeSelect));
            this._spectrumEditor = new SpectrumEditor(this._doc, null);
            this._spectrumRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("spectrum") }, "Spectrum:"), this._spectrumEditor.container);
            this._harmonicsEditor = new HarmonicsEditor(this._doc);
            this._harmonicsRow = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("harmonics") }, "Harmonics:"), this._harmonicsEditor.container);
            this._envelopeEditor = new EnvelopeEditor(this._doc, (id, submenu, subtype) => this._toggleDropdownMenu(id, submenu, subtype), (name) => this._openPrompt(name));
this._envelopeSpeedDisplay = span({ style: `color: ${ColorConfig.secondaryText}; font-size: smaller; text-overflow: clip;` }, "x1");
this._envelopeSpeedSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["envelope speed"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeEnvelopeSpeed(this.doc, oldValue, newValue), false);
this._envelopeSpeedRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("envelopeSpeed") }, "‣ Spd:"), this._envelopeSpeedDisplay, this._envelopeSpeedSlider.container);
this._envelopeDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._envelopeSpeedRow);
this._envelopeDropdown = button({ style: "margin-left:0em; margin-right: 1em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(7) }, "▼");
            
            
            
            
            
            this._drumsetGroup = div$d({ class: "editor-controls" });
            this._modulatorGroup = div$d({ class: "editor-controls" });
            this._instrumentCopyButton = button$d({ style: "max-width:86px;", class: "copyButton" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this._instrumentPasteButton = button$d({ style: "max-width:86px;", class: "pasteButton" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this._customWaveDrawCanvas = new CustomChipCanvas(canvas({ width: 128, height: 52, style: "border:2px solid " + ColorConfig.uiWidgetBackground, id: "customWaveDrawCanvas" }), this._doc, (newArray) => new ChangeCustomWave(this._doc, newArray));
            this._customWavePresetDrop = buildHeaderedOptions("Load Preset", select$6({ style: "width: 50%; height:1.5em; text-align: center; text-align-last: center;" }), Config.jummboxWaves.map(wave => wave.name));
            this._customWaveZoom = button$d({ style: "margin-left:0.5em; height:1.5em; max-width: 20px;", onclick: () => this._openPrompt("customChipSettings") }, "+");
            this._customWaveDraw = div$d({ style: "height:80px; margin-top:10px; margin-bottom:5px" }, [
                div$d({ style: "height:54px; display:flex; justify-content:center;" }, [this._customWaveDrawCanvas.canvas]),
                div$d({ style: "margin-top:5px; display:flex; justify-content:center;" }, [this._customWavePresetDrop, this._customWaveZoom]),
            ]);
            this._songTitleInputBox = new InputBox(input$8({ style: "font-weight:bold; border:none; width: 100%; background-color:${ColorConfig.editorBackground}; color:${ColorConfig.primaryText}; text-align:center", maxlength: "30", type: "text",id:"TitleBox", value: EditorConfig.versionDisplayName }), this._doc, (oldValue, newValue) => new ChangeSongTitle(this._doc, oldValue, newValue));
            this._feedbackAmplitudeSlider = new Slider(input$8({ type: "range", min: "0", max: Config.operatorAmplitudeMax, value: "0", step: "1", title: "Feedback Amplitude" }), this._doc, (oldValue, newValue) => new ChangeFeedbackAmplitude(this._doc, oldValue, newValue), false);
            this._feedbackRow2 = div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("feedbackVolume") }, "Fdback Vol:"), this._feedbackAmplitudeSlider.container);
            this._addEnvelopeButton = button$d({ type: "button", class: "add-envelope" });
            this._customInstrumentSettingsGroup = div$d({ class: "editor-controls" }, this._chipWaveSelectRow, this._chipNoiseSelectRow, this._useChipWaveAdvancedLoopControlsRow, this._chipWaveLoopModeSelectRow, this._chipWaveLoopStartRow, this._chipWaveLoopEndRow, this._chipWaveStartOffsetRow, this._chipWavePlayBackwardsRow, this._customWaveDraw, this._eqFilterTypeRow, this._eqFilterRow, this._eqFilterSimpleCutRow, this._eqFilterSimplePeakRow, this._fadeInOutRow, this._algorithmSelectRow, this._phaseModGroup, this._feedbackRow1, this._feedbackRow2, this._spectrumRow, this._harmonicsRow, this._drumsetGroup, this._pulseWidthRow, this._stringSustainRow, this._unisonSelectRow ,this._unisonDropdownGroup, div$d({ style: `padding: 2px 0; margin-left: 2em; display: flex; align-items: center;` }, span$4({ style: `flex-grow: 1; text-align: center;` }, span$4({ class: "tip", onclick: () => this._openPrompt("effects") }, "Effects")), div$d({ class: "effects-menu" }, this._effectsSelect)), this._transitionRow, this._transitionDropdownGroup, this._chordSelectRow, this._chordDropdownGroup, this._pitchShiftRow, this._detuneSliderRow, this._vibratoSelectRow, this._vibratoDropdownGroup, this._noteFilterTypeRow, this._noteFilterRow, this._noteFilterSimpleCutRow, this._noteFilterSimplePeakRow, this._distortionRow, this._aliasingRow, this._bitcrusherQuantizationRow, this._bitcrusherFreqRow, this._panSliderRow, this._panDropdownGroup, this._chorusRow, this._echoSustainRow, this._echoDelayRow, this._reverbRow,this._ringModContainerRow, div$d({ style: `padding: 2px 0; margin-left: 2em; display: flex; align-items: center;` }, span$4({ style: `flex-grow: 1; text-align: center;` }, span$4({ class: "tip", onclick: () => this._openPrompt("envelopes") }, "Envelopes")),this._envelopeDropdown,  this._addEnvelopeButton),this._envelopeDropdownGroup, this._envelopeEditor.container);
            this._instrumentCopyGroup = div$d({ class: "editor-controls" }, div$d({ class: "selectRow" }, this._instrumentCopyButton, this._instrumentPasteButton));
            
this._instrumentName = input$8({ style: "width: 10em; font-size: 80%; ", id: "instrumentName", type: "text", value: "Instrument Settings" });
 
            
            this._instrumentSettingsTextRow = div$d({ id: "instrumentSettingsText", style: `padding: 3px 0; max-width: 15em; text-align: center; color: ${ColorConfig.secondaryText};` },  "Instrument Settings",);
            
            this._instrumentSettingsGroup = div$d({ class: "editor-controls" },this._instrumentName, this._instrumentSettingsTextRow, this._instrumentsButtonRow, div$d({ class: "selectRow", id: "typeSelectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("instrumentType") }, "Type:"), div$d(div$d({ class: "pitchSelect" }, this._pitchedPresetSelect), div$d({ class: "drumSelect" }, this._drumPresetSelect))), this._instrumentVolumeSliderRow, this._customInstrumentSettingsGroup);
            this._usedPatternIndicator = SVG.path({ d: "M -6 -6 H 6 V 6 H -6 V -6 M -2 -3 L -2 -3 L -1 -4 H 1 V 4 H -1 V -1.2 L -1.2 -1 H -2 V -3 z", fill: ColorConfig.indicatorSecondary, "fill-rule": "evenodd" });
            this._usedInstrumentIndicator = SVG.path({ d: "M -6 -0.8 H -3.8 V -6 H 0.8 V 4.4 H 2.2 V -0.8 H 6 V 0.8 H 3.8 V 6 H -0.8 V -4.4 H -2.2 V 0.8 H -6 z", fill: ColorConfig.indicatorSecondary });
            this._jumpToModIndicator = SVG.svg({ style: "width: 92%; height: 1.3em; flex-shrink: 0; position: absolute;", viewBox: "0 0 200 200" }, [
                SVG.path({ d: "M90 155 l0 -45 -45 0 c-25 0 -45 -4 -45 -10 0 -5 20 -10 45 -10 l45 0 0 -45 c0 -25 5 -45 10 -45 6 0 10 20 10 45 l0 45 45 0 c25 0 45 5 45 10 0 6 -20 10 -45 10 l -45 0 0 45 c0 25 -4 45 -10 45 -5 0 -10 -20 -10 -45z" }),
                SVG.path({ d: "M42 158 c-15 -15 -16 -38 -2 -38 6 0 10 7 10 15 0 8 7 15 15 15 8 0 15 5 15 10 0 14 -23 13 -38 -2z" }),
                SVG.path({ d: "M120 160 c0 -5 7 -10 15 -10 8 0 15 -7 15 -15 0 -8 5 -15 10 -15 14 0 13 23 -2 38 -15 15 -38 16 -38 2z" }),
                SVG.path({ d: "M32 58 c3 -23 48 -40 48 -19 0 6 -7 11 -15 11 -8 0 -15 7 -15 15 0 8 -5 15 -11 15 -6 0 -9 -10 -7 -22z" }),
                SVG.path({ d: "M150 65 c0 -8 -7 -15 -15 -15 -8 0 -15 -4 -15 -10 0 -14 23 -13 38 2 15 15 16 38 2 38 -5 0 -10 -7 -10 -15z" })
            ]);
            this._promptContainer = div$d({ class: "promptContainer", style: "display: none;" });
            this._zoomInButton = button$d({ class: "zoomInButton", type: "button", title: "Zoom In" });
            this._zoomOutButton = button$d({ class: "zoomOutButton", type: "button", title: "Zoom Out" });
            this._patternEditorRow = div$d({ style: "flex: 1; height: 100%; display: flex; overflow: hidden; justify-content: center;" }, this._patternEditorPrev.container, this._patternEditor.container, this._patternEditorNext.container);
            this._patternArea = div$d({ class: "pattern-area" }, this._piano.container, this._patternEditorRow, this._octaveScrollBar.container, this._zoomInButton, this._zoomOutButton);
            this._trackContainer = div$d({ class: "trackContainer" }, this._trackEditor.container, this._loopEditor.container);
            this._trackVisibleArea = div$d({ style: "position: absolute; width: 100%; height: 100%; pointer-events: none;" });
            this._trackAndMuteContainer = div$d({ class: "trackAndMuteContainer" }, this._muteEditor.container, this._trackContainer, this._trackVisibleArea);
            this._barScrollBar = new BarScrollBar(this._doc, this._trackAndMuteContainer);
            this._trackArea = div$d({ class: "track-area" }, this._trackAndMuteContainer, this._barScrollBar.container);
            this._instrumentSettingsArea = div$d({ class: "instrument-settings-area" }, this._instrumentSettingsGroup, this._modulatorGroup);
            this._settingsArea = div$d({ class: "settings-area noSelection" }, div$d({ class: "version-area" }, div$d({ style: `text-align: center; margin: 3px 0; color: ${ColorConfig.secondaryText};` }, this._songTitleInputBox.input)), div$d({ class: "play-pause-area" }, this._volumeBarBox, div$d({ class: "playback-bar-controls" }, this._playButton ,this._recordButton, this._stopButton, this._prevBarButton, this._nextBarButton), div$d({ class: "playback-volume-controls" }, span$4({ class: "volume-speaker" }), this._volumeSlider.container)), div$d({ class: "menu-area" }, div$d({ class: "selectContainer menu file" }, this._fileMenu), div$d({ class: "selectContainer menu edit" }, this._editMenu), div$d({ class: "selectContainer menu preferences" }, this._optionsMenu)), div$d({ class: "song-settings-area" }, div$d({ class: "editor-controls" }, div$d({ class: "editor-song-settings" }, div$d({ style: "margin: 3px 0; position: relative; text-align: center; color: ${ColorConfig.secondaryText};" }, div$d({ class: "tip", style: "flex-shrink: 0; position:absolute; left: 0; top: 0; width: 12px; height: 12px", onclick: () => this._openPrompt("usedPattern") }, SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 0; pointer-events: none;", width: "12px", height: "12px", "margin-right": "0.5em", viewBox: "-6 -6 12 12" }, this._usedPatternIndicator)), div$d({ class: "tip", style: "flex-shrink: 0; position: absolute; left: 14px; top: 0; width: 12px; height: 12px", onclick: () => this._openPrompt("usedInstrument") }, SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 0; pointer-events: none;", width: "12px", height: "12px", "margin-right": "1em", viewBox: "-6 -6 12 12" }, this._usedInstrumentIndicator)), "Song Settings", div$d({ style: "width: 100%; left: 0; top: -1px; position:absolute; overflow-x:clip;" }, this._jumpToModIndicator))), div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("scale") }, "Scale: "), div$d({ class: "selectContainer" }, this._scaleSelect)), div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("key") }, "Key: "), div$d({ class: "selectContainer" }, this._keySelect)), div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("tempo") }, "Tempo: "), span$4({ style: "display: flex;" }, this._tempoSlider.container, this._tempoStepper)), div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("rhythm") }, "Rhythm: "), div$d({ class: "selectContainer" }, this._rhythmSelect)))), this._instrumentSettingsArea);
            this.mainLayer = div$d({ class: "beepboxEditor", tabIndex: "0" }, this._patternArea, this._trackArea, this._settingsArea, this._promptContainer);
            this._wasPlaying = false;
            this._currentPromptName = null;
            this._highlightedInstrumentIndex = -1;
            this._renderedInstrumentCount = 0;
            this._deactivatedInstruments = false;
            this._operatorRows = [];
            this._operatorAmplitudeSliders = [];
            this._operatorFrequencySelects = [];
            this._operatorDropdowns = [];
            this._operatorWaveformSelects = [];
            this._operatorWaveformHints = [];
            this._operatorWaveformPulsewidthSliders = [];
            this._operatorDropdownRows = [];
            this._operatorDropdownGroups = [];
            this._drumsetSpectrumEditors = [];
            this._drumsetEnvelopeSelects = [];
            this._showModSliders = [];
            this._newShowModSliders = [];
            this._modSliderValues = [];
            this._hasActiveModSliders = false;
            this._modSliderHandle = 0;
            this._volumeHandle = 0;
            this._barScrollbarHandle = 0;
            this._openPanDropdown = false;
            this._openVibratoDropdown = false;
            this._openEnvelopeDropdown = false;
            
            this._openChordDropdown = false;
            this._openTransitionDropdown = false;
            this._openOperatorDropdowns = [];
            this.outVolumeHistoricTimer = 0;
            this.outVolumeHistoricCap = 0;
            this.lastOutVolumeCap = 0;
            this.refocusStage = () => {
                this.mainLayer.focus({ preventScroll: true });
            };
            this._refocusStageNotEditing = () => {
                if (!this._patternEditor.editingModLabel)
                    this.mainLayer.focus({ preventScroll: true });
            };
            this.whenUpdated = () => {
                this._muteEditor.container.style.display = this._doc.enableChannelMuting ? "" : "none";
                const trackBounds = this._trackVisibleArea.getBoundingClientRect();
                this._doc.trackVisibleBars = Math.floor((trackBounds.right - trackBounds.left - (this._doc.enableChannelMuting ? 32 : 0)) / this._doc.getBarWidth());
                this._doc.trackVisibleChannels = Math.floor((trackBounds.bottom - trackBounds.top - 30) / this._doc.getChannelHeight());
                for (let i = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; i < this._doc.song.channels.length; i++) {
                    const channel = this._doc.song.channels[i];
                    for (let j = 0; j < channel.instruments.length; j++) {
                        this._doc.synth.determineInvalidModulators(channel.instruments[j]);
                    }
                }
                
                
                this._barScrollBar.render();
                this._muteEditor.render();
                this._trackEditor.render();
                if (document.activeElement != this._patternEditor.modDragValueLabel && this._patternEditor.editingModLabel) {
                    this._patternEditor.stopEditingModLabel(false);
                }
                this._piano.container.style.display = this._doc.showLetters ? "" : "none";
                this._octaveScrollBar.container.style.display = this._doc.showScrollBar ? "" : "none";
                this._barScrollBar.container.style.display = this._doc.song.barCount > this._doc.trackVisibleBars ? "" : "none";
                this._volumeBarBox.style.display = this._doc.displayVolumeBar ? "" : "none";
                
if (document.getElementById('text-content')){
 if( !(document.getElementById('text-content').style.display=="" && this._doc.showDescription ) ){ document.getElementById('text-content').style.display = this._doc.showDescription ? "" : "none"; }
 if( !(document.getElementById('text-content').style.display=="none" && !this._doc.showDescription ) ){ document.getElementById('text-content').style.display = this._doc.showDescription ? "" : "none"; }
}
if (document.getElementById('plugins-content')) {
 if (!(document.getElementById('plugins-content').style.display == "" && this._doc.showPlugins)) { document.getElementById('plugins-content').style.display = this._doc.showPlugins ? "" : "none"; }
 if (!(document.getElementById('plugins-content').style.display == "none" && !this._doc.showPlugins)) { document.getElementById('plugins-content').style.display = this._doc.showPlugins ? "" : "none"; }
}
  
 
                if (this._doc.getFullScreen()) {
                    const semitoneHeight = this._patternEditorRow.clientHeight / this._doc.getVisiblePitchCount();
                    const targetBeatWidth = semitoneHeight * 5;
                    const minBeatWidth = this._patternEditorRow.clientWidth / (this._doc.song.beatsPerBar * 3);
                    const maxBeatWidth = this._patternEditorRow.clientWidth / (this._doc.song.beatsPerBar + 2);
                    const beatWidth = Math.max(minBeatWidth, Math.min(maxBeatWidth, targetBeatWidth));
                    const patternEditorWidth = beatWidth * this._doc.song.beatsPerBar;
                    this._patternEditorPrev.container.style.width = patternEditorWidth + "px";
                    this._patternEditor.container.style.width = patternEditorWidth + "px";
                    this._patternEditorNext.container.style.width = patternEditorWidth + "px";
                    this._patternEditorPrev.container.style.flexShrink = "0";
                    this._patternEditor.container.style.flexShrink = "0";
                    this._patternEditorNext.container.style.flexShrink = "0";
                    this._patternEditorPrev.container.style.display = "";
                    this._patternEditorNext.container.style.display = "";
                    this._patternEditorPrev.render();
                    this._patternEditorNext.render();
                    this._zoomInButton.style.display = (this._doc.channel < this._doc.song.pitchChannelCount) ? "" : "none";
                    this._zoomOutButton.style.display = (this._doc.channel < this._doc.song.pitchChannelCount) ? "" : "none";
                    this._zoomInButton.style.right = this._doc.showScrollBar ? "24px" : "4px";
                    this._zoomOutButton.style.right = this._doc.showScrollBar ? "24px" : "4px";
                }
                else {
                    this._patternEditor.container.style.width = "";
                    this._patternEditor.container.style.flexShrink = "";
                    this._patternEditorPrev.container.style.display = "none";
                    this._patternEditorNext.container.style.display = "none";
                    this._zoomInButton.style.display = "none";
                    this._zoomOutButton.style.display = "none";
                }
                this._patternEditor.render();
                const optionCommands = [
                    (this._doc.autoPlay ? "✓ " : "　") + "Auto Play On Load",
                    (this._doc.autoFollow ? "✓ " : "　") + "Auto Follow Track",
                    (this._doc.enableNotePreview ? "✓ " : "　") + "Preview Added Notes",
                    (this._doc.showLetters ? "✓ " : "　") + "Show Piano Keys",
                    (this._doc.showFifth ? "✓ " : "　") + 'Highlight "Fifth" Notes',
                    (this._doc.notesOutsideScale ? "✓ " : "　") + "Allow Notes Outside Scale",
                    (this._doc.defaultScale == this._doc.song.scale ? "✓ " : "　") + "Use Current Scale as Default",
                    (this._doc.showChannels ? "✓ " : "　") + "Show All Channels",
                    (this._doc.showScrollBar ? "✓ " : "　") + "Octave Scroll Bar",
                    (this._doc.differentMod ? "✓ " : "　") + "Different Mod",
                    (this._doc.alwaysFineNoteVol ? "✓ " : "") + "Always Fine Note Vol.",
                    (this._doc.enableChannelMuting ? "✓ " : "　") + "Enable Channel Muting",
                    (this._doc.displayBrowserUrl ? "✓ " : "　") + "Display Song Data in URL",
                    (this._doc.displayVolumeBar ? "✓ " : "　") + "Show Playback Volume",
                    "　Set Layout...",
                    "　Set Theme...",

                    (this._doc.notesFlashWhenPlayed ? "✓ " : "　") + "Notes Flash When Played in Player",
                     (this._doc.showDescription ? "✓ " : "　") + "Show Description",
                     (this._doc.showPlugins ? "✓ " : "　") + "Show Plugins",
                     (this._doc.increaseAllPins ? "✓ " : "　") + "Increase All Pins",
                ];
                for (let i = 0; i < optionCommands.length; i++) {
                    const option = this._optionsMenu.children[i + 1];
                    if (option.textContent != optionCommands[i])
                        option.textContent = optionCommands[i];
                }
                const channel = this._doc.song.channels[this._doc.channel];
                const instrumentIndex = this._doc.getCurrentInstrument();
                const instrument = channel.instruments[instrumentIndex];
                const wasActive = this.mainLayer.contains(document.activeElement);
                const activeElement = document.activeElement;
                const colors = ColorConfig.getChannelColor(this._doc.song, this._doc.channel);
                for (let i = this._effectsSelect.childElementCount - 1; i < Config.effectOrder.length; i++) {
                    this._effectsSelect.appendChild(option$6({ value: i }));
                }
                this._effectsSelect.selectedIndex = -1;
                for (let i = 0; i < Config.effectOrder.length; i++) {
                    let effectFlag = Config.effectOrder[i];
                    const selected = ((instrument.effects & (1 << effectFlag)) != 0);
                    const label = (selected ? "✓ " : "　") + Config.effectNames[effectFlag];
                    const option = this._effectsSelect.children[i + 1];
                    if (option.textContent != label)
                        option.textContent = label;
                }
                setSelectedValue(this._scaleSelect, this._doc.song.scale);
                this._scaleSelect.title = Config.scales[this._doc.song.scale].realName;
                setSelectedValue(this._keySelect, Config.keys.length - 1 - this._doc.song.key);
                this._tempoSlider.updateValue(Math.max(0, Math.round(this._doc.song.tempo)));
                this._tempoStepper.value = Math.round(this._doc.song.tempo).toString();
                this._songTitleInputBox.updateValue(this._doc.song.title);
                this._eqFilterTypeRow.style.setProperty("--text-color-lit", colors.primaryNote);
                this._eqFilterTypeRow.style.setProperty("--text-color-dim", colors.secondaryNote);
                this._eqFilterTypeRow.style.setProperty("--background-color-lit", colors.primaryChannel);
                this._eqFilterTypeRow.style.setProperty("--background-color-dim", colors.secondaryChannel);
                if (instrument.eqFilterType) {
                    this._eqFilterSimpleButton.classList.remove("deactivated");
                    this._eqFilterAdvancedButton.classList.add("deactivated");
                    this._eqFilterRow.style.display = "none";
                    this._eqFilterSimpleCutRow.style.display = "";
                    this._eqFilterSimplePeakRow.style.display = "";
                }
                else {
                    this._eqFilterSimpleButton.classList.add("deactivated");
                    this._eqFilterAdvancedButton.classList.remove("deactivated");
                    this._eqFilterRow.style.display = "";
                    this._eqFilterSimpleCutRow.style.display = "none";
                    this._eqFilterSimplePeakRow.style.display = "none";
                }
                setSelectedValue(this._rhythmSelect, this._doc.song.rhythm);
                if (!this._doc.song.getChannelIsMod(this._doc.channel)) {
                    this._customInstrumentSettingsGroup.style.display = "";
                    this._panSliderRow.style.display = "";
                    this._panDropdownGroup.style.display = (this._openPanDropdown ? "" : "none");
                    this._detuneSliderRow.style.display = "";
                    this._instrumentVolumeSliderRow.style.display = "";
                    $("#typeSelectRow").css("display", "");
                    this._instrumentSettingsGroup.appendChild(this._instrumentCopyGroup);
                    this._instrumentSettingsGroup.insertBefore(this._instrumentsButtonRow, this._instrumentSettingsGroup.firstChild);
                    this._instrumentSettingsGroup.insertBefore(this._instrumentSettingsTextRow, this._instrumentSettingsGroup.firstChild);
                    if (this._doc.song.channels[this._doc.channel].name == "") {
                        this._instrumentSettingsTextRow.textContent = "Instrument Settings";
                    }
                    else {
                        this._instrumentSettingsTextRow.textContent = this._doc.song.channels[this._doc.channel].name;
                    }
                    this._modulatorGroup.style.display = "none";
                    this._usageCheck(this._doc.channel, instrumentIndex);
                    if (this._doc.song.getChannelIsNoise(this._doc.channel)) {
                        this._pitchedPresetSelect.style.display = "none";
                        this._drumPresetSelect.style.display = "";
                        $("#pitchPresetSelect").parent().hide();
                        $("#drumPresetSelect").parent().show();
                        setSelectedValue(this._drumPresetSelect, instrument.preset);
                    }
                    else {
                        this._pitchedPresetSelect.style.display = "";
                        this._drumPresetSelect.style.display = "none";
                        $("#pitchPresetSelect").parent().show();
                        $("#drumPresetSelect").parent().hide();
                        setSelectedValue(this._pitchedPresetSelect, instrument.preset);
                    }
                    if (!this._doc.alwaysShowSettings && instrument.preset != instrument.type) ;
                    else {
                        if (instrument.type == 2) {
                            this._chipNoiseSelectRow.style.display = "";
                            setSelectedValue(this._chipNoiseSelect, instrument.chipNoise);
                        }
                        else {
                            this._chipNoiseSelectRow.style.display = "none";
                        }
                        if (instrument.type == 3) {
                            this._chipWaveSelectRow.style.display = "none";
                            this._useChipWaveAdvancedLoopControlsRow.style.display = "none";                         this._chipWaveLoopModeSelectRow.style.display = "none";                         this._chipWaveLoopStartRow.style.display = "none";                         this._chipWaveLoopEndRow.style.display = "none";                         this._chipWaveStartOffsetRow.style.display = "none";                         this._chipWavePlayBackwardsRow.style.display = "none";
                            this._spectrumRow.style.display = "";
                            this._spectrumEditor.render();
                        }
                        else {
                            this._spectrumRow.style.display = "none";
                        }
                        if (instrument.type == 5 || instrument.type == 7) {
                            this._chipWaveSelectRow.style.display = "none";
                            this._useChipWaveAdvancedLoopControlsRow.style.display = "none";                         this._chipWaveLoopModeSelectRow.style.display = "none";                         this._chipWaveLoopStartRow.style.display = "none";                         this._chipWaveLoopEndRow.style.display = "none";                         this._chipWaveStartOffsetRow.style.display = "none";                         this._chipWavePlayBackwardsRow.style.display = "none";
                            this._harmonicsRow.style.display = "";
                            this._harmonicsEditor.render();
                        }
                        else {
                            this._harmonicsRow.style.display = "none";
                        }
                        if (instrument.type == 7) {
                            this._stringSustainRow.style.display = "";
                            this._stringSustainSlider.updateValue(instrument.stringSustain);
                        }
                        else {
                            this._stringSustainRow.style.display = "none";
                        }
                        if (instrument.type == 4) {
                            this._drumsetGroup.style.display = "";
                            this._fadeInOutRow.style.display = "none";
                            for (let i = 0; i < Config.drumCount; i++) {
                                setSelectedValue(this._drumsetEnvelopeSelects[i], instrument.drumsetEnvelopes[i]);
                                this._drumsetSpectrumEditors[i].render();
                            }
                        }
                        else {
                            this._drumsetGroup.style.display = "none";
                            this._fadeInOutRow.style.display = "";
                            this._fadeInOutEditor.render();
                        }
                        
this._useChipWaveAdvancedLoopControlsBox.checked = instrument.isUsingAdvancedLoopControls ? true : false;
this._chipWaveLoopStartStepper.value = instrument.chipWaveLoopStart + "";
this._chipWaveLoopEndStepper.value = instrument.chipWaveLoopEnd + "";
this._chipWaveStartOffsetStepper.value = instrument.chipWaveStartOffset + "";
this._chipWavePlayBackwardsBox.checked = instrument.chipWavePlayBackwards ? true : false;
                        if (instrument.type == 0) {
                            this._chipWaveSelectRow.style.display = "";
                            this._useChipWaveAdvancedLoopControlsRow.style.display = "";
                            
if (instrument.isUsingAdvancedLoopControls) {
	this._chipWaveLoopModeSelectRow.style.display = "";
	this._chipWaveLoopStartRow.style.display = "";
	this._chipWaveLoopEndRow.style.display = "";
	this._chipWaveStartOffsetRow.style.display = "";
	this._chipWavePlayBackwardsRow.style.display = "";
}
else {
	this._chipWaveLoopModeSelectRow.style.display = "none";
	this._chipWaveLoopStartRow.style.display = "none";
	this._chipWaveLoopEndRow.style.display = "none";
	this._chipWaveStartOffsetRow.style.display = "none";
	this._chipWavePlayBackwardsRow.style.display = "none";
}
let instrlast=instrument.chipWave;
setSelectedValue(this._chipWaveSelect, instrument.chipWave);

var objectObject=buildOptions(select$6(), Config.chipWaves.map(wave => wave.name))
this._chipWaveSelect.innerHTML=objectObject.innerHTML 
// console.log(this._chipWaveSelect.outerHTML)
setSelectedValue(this._chipWaveSelect, instrlast );




                        }

                        if (instrument.type == 8) {
                            this._customWaveDraw.style.display = "";
                            this._chipWaveSelectRow.style.display = "none";
                            this._useChipWaveAdvancedLoopControlsRow.style.display = "none";                         this._chipWaveLoopModeSelectRow.style.display = "none";                         this._chipWaveLoopStartRow.style.display = "none";                         this._chipWaveLoopEndRow.style.display = "none";                         this._chipWaveStartOffsetRow.style.display = "none";                         this._chipWavePlayBackwardsRow.style.display = "none";
                        }
                        else {
                            this._customWaveDraw.style.display = "none";
                        }
                        if (instrument.type == 6) {
                            this._chipWaveSelectRow.style.display = "none";
                            this._useChipWaveAdvancedLoopControlsRow.style.display = "none";                         this._chipWaveLoopModeSelectRow.style.display = "none";                         this._chipWaveLoopStartRow.style.display = "none";                         this._chipWaveLoopEndRow.style.display = "none";                         this._chipWaveStartOffsetRow.style.display = "none";                         this._chipWavePlayBackwardsRow.style.display = "none";
                            this._pulseWidthRow.style.display = "";
                            this._pulseWidthSlider.input.title = prettyNumber(instrument.pulseWidth) + "%";
                            this._pulseWidthSlider.updateValue(instrument.pulseWidth);
                        }
                        else {
                            this._pulseWidthRow.style.display = "none";
                        }
                        if (instrument.type == 1) {
                            this._algorithmSelectRow.style.display = "";
                            this._phaseModGroup.style.display = "";
                            this._feedbackRow1.style.display = "";
                            this._feedbackRow2.style.display = "";
                            this._chipWaveSelectRow.style.display = "none";
                            this._useChipWaveAdvancedLoopControlsRow.style.display = "none";                         this._chipWaveLoopModeSelectRow.style.display = "none";                         this._chipWaveLoopStartRow.style.display = "none";                         this._chipWaveLoopEndRow.style.display = "none";                         this._chipWaveStartOffsetRow.style.display = "none";                         this._chipWavePlayBackwardsRow.style.display = "none";
                            setSelectedValue(this._algorithmSelect, instrument.algorithm);
                            setSelectedValue(this._feedbackTypeSelect, instrument.feedbackType);
                            this._feedbackAmplitudeSlider.updateValue(instrument.feedbackAmplitude);
                            for (let i = 0; i < Config.operatorCount; i++) {
                                const isCarrier = (i < Config.algorithms[instrument.algorithm].carrierCount);
                                this._operatorRows[i].style.color = isCarrier ? ColorConfig.primaryText : "";
                                setSelectedValue(this._operatorFrequencySelects[i], instrument.operators[i].frequency);
                                this._operatorAmplitudeSliders[i].updateValue(instrument.operators[i].amplitude);
                                setSelectedValue(this._operatorWaveformSelects[i], instrument.operators[i].waveform);
                                this._operatorWaveformPulsewidthSliders[i].updateValue(instrument.operators[i].pulseWidth);
                                this._operatorDropdownGroups[i].style.color = isCarrier ? ColorConfig.primaryText : "";
                                const operatorName = (isCarrier ? "Voice " : "Modulator ") + (i + 1);
                                this._operatorFrequencySelects[i].title = operatorName + " Frequency";
                                this._operatorAmplitudeSliders[i].input.title = operatorName + (isCarrier ? " Volume" : " Amplitude");
                                this._operatorDropdownGroups[i].style.display = (this._openOperatorDropdowns[i] ? "" : "none");
                                if (instrument.operators[i].waveform == 3) {
                                    this._operatorWaveformPulsewidthSliders[i].container.style.display = "";
                                    this._operatorWaveformHints[i].style.display = "none";
                                }
                                else {
                                    this._operatorWaveformPulsewidthSliders[i].container.style.display = "none";
                                    this._operatorWaveformHints[i].style.display = "";
                                }
                            }
                        }
                        else {
                            this._algorithmSelectRow.style.display = "none";
                            this._phaseModGroup.style.display = "none";
                            this._feedbackRow1.style.display = "none";
                            this._feedbackRow2.style.display = "none";
                        }
                        this._pulseWidthSlider.input.title = prettyNumber(instrument.pulseWidth) + "%";
                        if (effectsIncludeTransition(instrument.effects)) {
                            this._transitionRow.style.display = "";
                            if (this._openTransitionDropdown)
                                this._transitionDropdownGroup.style.display = "";
                            setSelectedValue(this._transitionSelect, instrument.transition);
                        }
                        else {
                            this._transitionDropdownGroup.style.display = "none";
                            this._transitionRow.style.display = "none";
                        }
                        if (effectsIncludeChord(instrument.effects)) {
                            this._chordSelectRow.style.display = "";
                            this._chordDropdown.style.display = (instrument.chord == Config.chords.dictionary["arpeggio"].index) ? "" : "none";
                            this._chordDropdownGroup.style.display = (instrument.chord == Config.chords.dictionary["arpeggio"].index && this._openChordDropdown) ? "" : "none";
                            setSelectedValue(this._chordSelect, instrument.chord);
                        }
                        else {
                            this._chordSelectRow.style.display = "none";
                            this._chordDropdown.style.display = "none";
                            this._chordDropdownGroup.style.display = "none";
                        }
                        if (effectsIncludePitchShift(instrument.effects)) {
                            this._pitchShiftRow.style.display = "";
                            this._pitchShiftSlider.updateValue(instrument.pitchShift);
                            this._pitchShiftSlider.input.title = (instrument.pitchShift - Config.pitchShiftCenter) + " semitone(s)";
                            for (const marker of this._pitchShiftFifthMarkers) {
                                marker.style.display = this._doc.showFifth ? "" : "none";
                            }
                        }
                        else {
                            this._pitchShiftRow.style.display = "none";
                        }
                        if (effectsIncludeDetune(instrument.effects)) {
                            this._detuneSliderRow.style.display = "";
                            this._detuneSlider.updateValue(instrument.detune - Config.detuneCenter);
                            this._detuneSlider.input.title = (Synth.detuneToCents(instrument.detune)) + " cent(s)";
                        }
                        else {
                            this._detuneSliderRow.style.display = "none";
                        }
                        if (effectsIncludeVibrato(instrument.effects)) {
                            this._vibratoSelectRow.style.display = "";
                            if (this._openVibratoDropdown)
                                this._vibratoDropdownGroup.style.display = "";
                            setSelectedValue(this._vibratoSelect, instrument.vibrato);
                        }
                        else {
                            this._vibratoDropdownGroup.style.display = "none";
                            this._vibratoSelectRow.style.display = "none";
                        }
                        if (effectsIncludeNoteFilter(instrument.effects)) {
                            this._noteFilterTypeRow.style.setProperty("--text-color-lit", colors.primaryNote);
                            this._noteFilterTypeRow.style.setProperty("--text-color-dim", colors.secondaryNote);
                            this._noteFilterTypeRow.style.setProperty("--background-color-lit", colors.primaryChannel);
                            this._noteFilterTypeRow.style.setProperty("--background-color-dim", colors.secondaryChannel);
                            this._noteFilterTypeRow.style.display = "";
                            this._noteFilterEditor.render();
                            if (instrument.noteFilterType) {
                                this._noteFilterSimpleButton.classList.remove("deactivated");
                                this._noteFilterAdvancedButton.classList.add("deactivated");
                                this._noteFilterRow.style.display = "none";
                                this._noteFilterSimpleCutRow.style.display = "";
                                this._noteFilterSimplePeakRow.style.display = "";
                            }
                            else {
                                this._noteFilterSimpleButton.classList.add("deactivated");
                                this._noteFilterAdvancedButton.classList.remove("deactivated");
                                this._noteFilterRow.style.display = "";
                                this._noteFilterSimpleCutRow.style.display = "none";
                                this._noteFilterSimplePeakRow.style.display = "none";
                            }
                        }
                        else {
                            this._noteFilterRow.style.display = "none";
                            this._noteFilterSimpleCutRow.style.display = "none";
                            this._noteFilterSimplePeakRow.style.display = "none";
                            this._noteFilterTypeRow.style.display = "none";
                        }
                        if (effectsIncludeDistortion(instrument.effects)) {
                            this._distortionRow.style.display = "";
                            if (instrument.type == 0 || instrument.type == 8 || instrument.type == 6)
                                this._aliasingRow.style.display = "";
                            else
                                this._aliasingRow.style.display = "none";
                            this._distortionSlider.updateValue(instrument.distortion);
                        }
                        else {
                            this._distortionRow.style.display = "none";
                            this._aliasingRow.style.display = "none";
                        }
                        if (effectsIncludeBitcrusher(instrument.effects)) {
                            this._bitcrusherQuantizationRow.style.display = "";
                            this._bitcrusherFreqRow.style.display = "";
                            this._bitcrusherQuantizationSlider.updateValue(instrument.bitcrusherQuantization);
                            this._bitcrusherFreqSlider.updateValue(instrument.bitcrusherFreq);
                        }
                        else {
                            this._bitcrusherQuantizationRow.style.display = "none";
                            this._bitcrusherFreqRow.style.display = "none";
                        }
                        if (effectsIncludePanning(instrument.effects)) {
                            this._panSliderRow.style.display = "";
                            if (this._openPanDropdown)
                                this._panDropdownGroup.style.display = "";
                            this._panSlider.updateValue(instrument.pan);
                        }
                        else {
                            this._panSliderRow.style.display = "none";
                            this._panDropdownGroup.style.display = "none";
                        }
                        if (effectsIncludeChorus(instrument.effects)) {
                            this._chorusRow.style.display = "";
                            this._chorusSlider.updateValue(instrument.chorus);
                        }
                        else {
                            this._chorusRow.style.display = "none";
                        }
                        if (effectsIncludeEcho(instrument.effects)) {
                            this._echoSustainRow.style.display = "";
                            this._echoSustainSlider.updateValue(instrument.echoSustain);
                            this._echoDelayRow.style.display = "";
                            this._echoDelaySlider.updateValue(instrument.echoDelay);
                            this._echoDelaySlider.input.title = (Math.round((instrument.echoDelay + 1) * Config.echoDelayStepTicks / (Config.ticksPerPart * Config.partsPerBeat) * 1000) / 1000) + " beat(s)";
                        }
                        else {
                            this._echoSustainRow.style.display = "none";
                            this._echoDelayRow.style.display = "none";
                        }
                        if (effectsIncludeReverb(instrument.effects)) {
                            this._reverbRow.style.display = "";
                            this._reverbSlider.updateValue(instrument.reverb);
                        }
                        else {
                            this._reverbRow.style.display = "none";
                        }
                        
if (effectsIncludeRingModulation(instrument.effects)) {
	this._ringModContainerRow.style.display = "";
	this._ringModSlider.updateValue(instrument.ringModulation);
	this._ringModHzSlider.updateValue(instrument.ringModulationHz);
	this._ringModPulsewidthSlider.updateValue(instrument.ringModPulseWidth);
	setSelectedValue(this._ringModWaveSelect, instrument.ringModWaveformIndex);
}
else {
	this._ringModContainerRow.style.display = "none";
}
                        
                        
if (instrument.type == 0 || instrument.type == 8 || instrument.type == 5 || instrument.type == 7   || instrument.type == 6/*pulse width*/   ) {
	this._unisonSelectRow.style.display = "";
	setSelectedValue(this._unisonSelect, instrument.unison);
this._unisonVoicesInputBox.value = instrument.unisonVoices + "";
	this._unisonSpreadInputBox.value = instrument.unisonSpread + "";
	this._unisonOffsetInputBox.value = instrument.unisonOffset + "";
	this._unisonExpressionInputBox.value = instrument.unisonExpression + "";
	this._unisonSignInputBox.value = instrument.unisonSign + "";
//	alert(this._openUnisonDropdown )
	this._unisonDropdownGroup.style.display = (this._openUnisonDropdown ? " " : "none");
}else {
this._unisonSelectRow.style.display = "none";
this._unisonDropdownGroup.style.display = "none";
}

if (this._openEnvelopeDropdown)
 this._envelopeDropdownGroup.style.display = "";
else
 this._envelopeDropdownGroup.style.display = "none";

                        this._envelopeEditor.render();
                    }
                    for (let chordIndex = 0; chordIndex < Config.chords.length; chordIndex++) {
                        let hidden = (!Config.instrumentTypeHasSpecialInterval[instrument.type] && Config.chords[chordIndex].customInterval);
                        const option = this._chordSelect.children[chordIndex];
                        if (hidden) {
                            if (!option.hasAttribute("hidden")) {
                                option.setAttribute("hidden", "");
                            }
                        }
                        else {
                            option.removeAttribute("hidden");
                        }
                    }
                    this._instrumentSettingsGroup.style.color = ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote;
                    setSelectedValue(this._transitionSelect, instrument.transition);
                    setSelectedValue(this._vibratoSelect, instrument.vibrato);
                    setSelectedValue(this._vibratoTypeSelect, instrument.vibratoType);
                    setSelectedValue(this._chordSelect, instrument.chord);
                    if(instrument){
                        if(instrument.pitchShift){
                    this._pitchShiftBox.value = instrument.pitchShift
                        }
if (true) {
    if(true){
        this._instrumentName.value=this._doc.song.channels[this._doc.channel].name
    }
}
                    }
                  //  alert(JSON.stringify(instrument))
                    this._panSliderInputBox.value = instrument.pan + "";
                    this._detuneSliderInputBox.value = (instrument.detune - Config.detuneCenter) + "";
                    this.ringModHzNum.innerHTML = " (" + calculateRingModHertz(instrument.ringModulationHz / (Config.ringModHzRange - 1)) + ")";
                    
                    this._instrumentVolumeSlider.updateValue(instrument.volume);
                    this._instrumentVolumeSliderInputBox.value = "" + (instrument.volume);
                    this._vibratoDepthSlider.updateValue(Math.round(instrument.vibratoDepth * 25));
                    this._vibratoDelaySlider.updateValue(instrument.vibratoDelay);
                    this._vibratoSpeedSlider.updateValue(instrument.vibratoSpeed);
                    setSelectedValue(this._vibratoTypeSelect, instrument.vibratoType);
                    this._arpeggioSpeedSlider.updateValue(instrument.arpeggioSpeed);
                    this._panDelaySlider.updateValue(instrument.panDelay);
                    this._vibratoDelaySlider.input.title = "" + instrument.vibratoDelay;
                    this._vibratoDepthSlider.input.title = "" + instrument.vibratoDepth;
                    this._vibratoSpeedSlider.input.title = "" + instrument.vibratoSpeed;
                    this._panDelaySlider.input.title = "" + instrument.panDelay;
                    
                    this._arpeggioSpeedSlider.input.title = "x" + prettyNumber(Config.arpSpeedScale[instrument.arpeggioSpeed]);
                    this._eqFilterSimpleCutSlider.updateValue(instrument.eqFilterSimpleCut);
                    this._eqFilterSimplePeakSlider.updateValue(instrument.eqFilterSimplePeak);
                    this._noteFilterSimpleCutSlider.updateValue(instrument.noteFilterSimpleCut);
                    this._noteFilterSimplePeakSlider.updateValue(instrument.noteFilterSimplePeak);
                    if (instrument.type == 8) {
                        this._customWaveDrawCanvas.redrawCanvas();
                        if (this.prompt instanceof CustomChipPrompt) {
                            this.prompt.customChipCanvas.render();
                        }
                    }
                    if (this._ringModWaveSelect.selectedIndex == Config.operatorWaves.dictionary['pulse width'].index) {
	this._ringModPulsewidthSlider.container.style.display = "";
	this._ringModWaveText.style.display = "none";
}
else {
	this._ringModPulsewidthSlider.container.style.display = "none";
	this._ringModWaveText.style.display = "";
}
                    this._renderInstrumentBar(channel, instrumentIndex, colors);
                }
                else {
                    this._usageCheck(this._doc.channel, instrumentIndex);
                    this._pitchedPresetSelect.style.display = "none";
                    this._drumPresetSelect.style.display = "none";
                    $("#pitchPresetSelect").parent().hide();
                    $("#drumPresetSelect").parent().hide();
                    this._modulatorGroup.appendChild(this._instrumentCopyGroup);
                    this._modulatorGroup.insertBefore(this._instrumentsButtonRow, this._modulatorGroup.firstChild);
                    this._modulatorGroup.insertBefore(this._instrumentSettingsTextRow, this._modulatorGroup.firstChild);
                    if (this._doc.song.channels[this._doc.channel].name == "") {
                        this._instrumentSettingsTextRow.textContent = "Modulator Settings";
                    }
                    else {
                        this._instrumentSettingsTextRow.textContent = this._doc.song.channels[this._doc.channel].name;
                    }
                    this._chipNoiseSelectRow.style.display = "none";
                    this._chipWaveSelectRow.style.display = "none";
                    this._useChipWaveAdvancedLoopControlsRow.style.display = "none";                         this._chipWaveLoopModeSelectRow.style.display = "none";                         this._chipWaveLoopStartRow.style.display = "none";                         this._chipWaveLoopEndRow.style.display = "none";                         this._chipWaveStartOffsetRow.style.display = "none";                         this._chipWavePlayBackwardsRow.style.display = "none";
                    this._spectrumRow.style.display = "none";
                    this._harmonicsRow.style.display = "none";
                    this._transitionRow.style.display = "none";
                    this._chordSelectRow.style.display = "none";
                    this._chordDropdownGroup.style.display = "none";
                    this._drumsetGroup.style.display = "none";
                    this._customWaveDraw.style.display = "none";
                    this._algorithmSelectRow.style.display = "none";
                    this._phaseModGroup.style.display = "none";
                    this._feedbackRow1.style.display = "none";
                    this._feedbackRow2.style.display = "none";
                    this._pulseWidthRow.style.display = "none";
                    this._vibratoSelectRow.style.display = "none";
                    this._vibratoDropdownGroup.style.display = "none";
                    this._detuneSliderRow.style.display = "none";
                    this._panSliderRow.style.display = "none";
                    this._panDropdownGroup.style.display = "none";
                    this._modulatorGroup.style.display = "";
                    this._modulatorGroup.style.color = ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote;
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        let instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                        let modChannel = Math.max(0, instrument.modChannels[mod]);
                        let modInstrument = instrument.modInstruments[mod];
                        if (modInstrument >= this._doc.song.channels[modChannel].instruments.length + 2 || (modInstrument > 0 && this._doc.song.channels[modChannel].instruments.length <= 1)) {
                            modInstrument = 0;
                            instrument.modInstruments[mod] = 0;
                            instrument.modulators[mod] = 0;
                        }
                        if (modChannel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                            instrument.modInstruments[mod] = 0;
                            instrument.modulators[mod] = 0;
                        }
                        if (this._doc.recalcChannelNames || (this._modChannelBoxes[mod].children.length != 2 + this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)) {
                            while (this._modChannelBoxes[mod].firstChild)
                                this._modChannelBoxes[mod].remove(0);
                            const channelList = [];
                            channelList.push("none");
                            channelList.push("song");
                            for (let i = 0; i < this._doc.song.pitchChannelCount; i++) {
                                if (this._doc.song.channels[i].name == "") {
                                    channelList.push("pitch " + (i + 1));
                                }
                                else {
                                    channelList.push(this._doc.song.channels[i].name);
                                }
                            }
                            for (let i = 0; i < this._doc.song.noiseChannelCount; i++) {
                                if (this._doc.song.channels[i + this._doc.song.pitchChannelCount].name == "") {
                                    channelList.push("noise " + (i + 1));
                                }
                                else {
                                    channelList.push(this._doc.song.channels[i + this._doc.song.pitchChannelCount].name);
                                }
                            }
                            buildOptions(this._modChannelBoxes[mod], channelList);
                        }
                        this._modChannelBoxes[mod].selectedIndex = instrument.modChannels[mod] + 2;
                        let channel = this._doc.song.channels[modChannel];
                        if (this._modInstrumentBoxes[mod].children.length != channel.instruments.length + 2) {
                            while (this._modInstrumentBoxes[mod].firstChild)
                                this._modInstrumentBoxes[mod].remove(0);
                            const instrumentList = [];
                            for (let i = 0; i < channel.instruments.length; i++) {
                                instrumentList.push("" + i + 1);
                            }
                            instrumentList.push("all");
                            instrumentList.push("active");
                            buildOptions(this._modInstrumentBoxes[mod], instrumentList);
                        }
                        if (channel.bars[this._doc.bar] > 0) {
                            let usedInstruments = channel.patterns[channel.bars[this._doc.bar] - 1].instruments;
                            for (let i = 0; i < channel.instruments.length; i++) {
                                if (usedInstruments.includes(i)) {
                                    this._modInstrumentBoxes[mod].options[i].label = "🢒" + (i + 1);
                                }
                                else {
                                    this._modInstrumentBoxes[mod].options[i].label = "" + (i + 1);
                                }
                            }
                        }
                        else {
                            for (let i = 0; i < channel.instruments.length; i++) {
                                this._modInstrumentBoxes[mod].options[i].label = "" + (i + 1);
                            }
                        }
                        this._modInstrumentBoxes[mod].selectedIndex = instrument.modInstruments[mod];
                        if (instrument.modChannels[mod] != -2) {
                            while (this._modSetBoxes[mod].firstChild)
                                this._modSetBoxes[mod].remove(0);
                            const settingList = [];
                            settingList.push("none");
                            if (instrument.modChannels[mod] == -1) {
                                settingList.push("song volume");
                                settingList.push("tempo");
                                settingList.push("song reverb");
                                settingList.push("next bar");
                                settingList.push("song detune");
                                settingList.push("song mastergain");
                                settingList.push("song limitratio");
                            }
                            else {
                                settingList.push("volume");
                                
                                let tgtInstrumentTypes = [];
                                let anyInstrumentAdvancedEQ, anyInstrumentSimpleEQ, anyInstrumentAdvancedNote, anyInstrumentSimpleNote, anyInstrumentArps, anyInstrumentPitchShifts, anyInstrumentDetunes, anyInstrumentVibratos, anyInstrumentNoteFilters, anyInstrumentDistorts, anyInstrumentBitcrushes, anyInstrumentPans, anyInstrumentChorus, anyInstrumentEchoes,anyInstrumentRingMods,anyInstrumentCustomUnison,  anyInstrumentReverbs = false;
                                
                               
                                let instrumentCandidates = [];
                                if (modInstrument >= channel.instruments.length) {
                                    for (let i = 0; i < channel.instruments.length; i++) {
                                        instrumentCandidates.push(i);
                                    }
                                }
                                else {
                                    instrumentCandidates.push(modInstrument);
                                }
                                for (let i = 0; i < instrumentCandidates.length; i++) {
                                    let instrumentIndex = instrumentCandidates[i];
let thisinstrument = channel.instruments[instrumentCandidates[i]];
if (thisinstrument.unison === Config.unisons.length) {
	anyInstrumentCustomUnison = true;
}
                                    if (!tgtInstrumentTypes.includes(channel.instruments[instrumentIndex].type))
                                        tgtInstrumentTypes.push(channel.instruments[instrumentIndex].type);
                                    if (channel.instruments[instrumentIndex].eqFilterType)
                                        anyInstrumentSimpleEQ = true;
                                    else
                                        anyInstrumentAdvancedEQ = true;
                                    if (effectsIncludeChord(channel.instruments[instrumentIndex].effects) && channel.instruments[instrumentIndex].getChord().arpeggiates) {
                                        anyInstrumentArps = true;
                                    }
                                    if (effectsIncludePitchShift(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentPitchShifts = true;
                                    }
                                    if (effectsIncludeDetune(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentDetunes = true;
                                    }
                                    if (effectsIncludeVibrato(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentVibratos = true;
                                    }
                                    if (effectsIncludeNoteFilter(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentNoteFilters = true;
                                        if (channel.instruments[instrumentIndex].noteFilterType)
                                            anyInstrumentSimpleNote = true;
                                        else
                                            anyInstrumentAdvancedNote = true;
                                    }
                                    if (effectsIncludeDistortion(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentDistorts = true;
                                    }
                                    if (effectsIncludeBitcrusher(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentBitcrushes = true;
                                    }
                                    if (effectsIncludePanning(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentPans = true;
                                    }
                                    if (effectsIncludeChorus(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentChorus = true;
                                    }
                                    if (effectsIncludeEcho(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentEchoes = true;
                                    }
                                    if (effectsIncludeReverb(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentReverbs = true;
                                    }
if (effectsIncludeRingModulation(channel.instruments[instrumentIndex].effects)) {
anyInstrumentRingMods = true;
}
}


                                if (anyInstrumentAdvancedEQ) {
                                    settingList.push("eq filter");
                                }
                                if (anyInstrumentSimpleEQ) {
                                    settingList.push("eq filt cut");
                                    settingList.push("eq filt peak");
                                }
                                if (tgtInstrumentTypes.includes(1)) {
                                    settingList.push("fm slider 1");
                                    settingList.push("fm slider 2");
                                    settingList.push("fm slider 3");
                                    settingList.push("fm slider 4");
                                    settingList.push("fm feedback");
                                }
                                if (tgtInstrumentTypes.includes(6)) {
                                    settingList.push("pulse width");
                                }
                                if (tgtInstrumentTypes.includes(7)) {
                                    settingList.push("sustain");
                                }
                                if (anyInstrumentArps) {
                                    settingList.push("arp speed");
                                    settingList.push("reset arp");
                                }
                                if (anyInstrumentPitchShifts) {
                                    settingList.push("pitch shift");
                                }
                                if (anyInstrumentDetunes)
                                    settingList.push("detune");
                                if (anyInstrumentVibratos) {
                                    settingList.push("vibrato depth");
                                    settingList.push("vibrato speed");
                                    settingList.push("vibrato delay");
                                }
                                if (anyInstrumentNoteFilters) {
                                    if (anyInstrumentAdvancedNote) {
                                        settingList.push("note filter");
                                    }
                                    if (anyInstrumentSimpleNote) {
                                        settingList.push("note filt cut");
                                        settingList.push("note filt peak");
                                    }
                                }
                                if (anyInstrumentDistorts) {
                                    settingList.push("distortion");
                                }
                                if (anyInstrumentBitcrushes) {
                                    settingList.push("bit crush");
                                    settingList.push("freq crush");
                                }
                                if (anyInstrumentPans) {
                                    settingList.push("pan");
                                    settingList.push("pan delay");
                                }
                                if (anyInstrumentChorus) {
                                    settingList.push("chorus");
                                }
                                if (anyInstrumentEchoes) {
                                    settingList.push("echo");
                                }
                                if (anyInstrumentReverbs) {
                                    settingList.push("reverb");
                                }
                                  if (anyInstrumentRingMods) {
                                    settingList.push("ring modulation");
                                    settingList.push("ring mod hertz");
                                    
                                     
if(channel.instruments[instrumentIndex].ringModWaveformIndex == Config.operatorWaves.dictionary['pulse width'].index){
	settingList.push("ring pulse mod")
}
                                }
if(anyInstrumentCustomUnison){
settingList.push("unisonExpression");
settingList.push("unisonSign")
settingList.push("unisonOffset")
settingList.push("unisonVoices")
settingList.push("unisonSpread")
}
                                
                                
                                settingList.push("extra volume");
                            }
                            buildOptions(this._modSetBoxes[mod], settingList);
                            let setIndex = settingList.indexOf(Config.modulators[instrument.modulators[mod]].name);
                            if (setIndex == -1) {
                                this._modSetBoxes[mod].insertBefore(option$6({ value: Config.modulators[instrument.modulators[mod]].name, style: "color: red;" }, Config.modulators[instrument.modulators[mod]].name), this._modSetBoxes[mod].children[0]);
                                this._modSetBoxes[mod].selectedIndex = 0;
                                this._whenSetModSetting(mod, true);
                            }
                            else {
                                this._modSetBoxes[mod].selectedIndex = setIndex;
                                this._modSetBoxes[mod].classList.remove("invalidSetting");
                                instrument.invalidModulators[mod] = false;
                            }
                        }
                        else if (this._modSetBoxes[mod].selectedIndex > 0) {
                            this._modSetBoxes[mod].selectedIndex = 0;
                            this._whenSetModSetting(mod);
                        }
                        if (instrument.modChannels[mod] < 0) {
                            (this._modInstrumentBoxes[mod].parentElement).style.display = "none";
                            $("#modInstrumentText" + mod).get(0).style.display = "none";
                            $("#modChannelText" + mod).get(0).innerText = "Channel:";
                            if (instrument.modChannels[mod] == -2) {
                                $("#modSettingText" + mod).get(0).style.display = "none";
                                (this._modSetBoxes[mod].parentElement).style.display = "none";
                            }
                            else {
                                $("#modSettingText" + mod).get(0).style.display = "";
                                (this._modSetBoxes[mod].parentElement).style.display = "";
                            }
                            this._modTargetIndicators[mod].style.setProperty("fill", ColorConfig.uiWidgetFocus);
                            this._modTargetIndicators[mod].classList.remove("modTarget");
                        }
                        else {
                            (this._modInstrumentBoxes[mod].parentElement).style.display = (channel.instruments.length > 1) ? "" : "none";
                            $("#modInstrumentText" + mod).get(0).style.display = (channel.instruments.length > 1) ? "" : "none";
                            $("#modChannelText" + mod).get(0).innerText = (channel.instruments.length > 1) ? "Ch:" : "Channel:";
                            $("#modSettingText" + mod).get(0).style.display = "";
                            (this._modSetBoxes[mod].parentElement).style.display = "";
                            this._modTargetIndicators[mod].style.setProperty("fill", ColorConfig.indicatorPrimary);
                            this._modTargetIndicators[mod].classList.add("modTarget");
                        }
                        let filterType = Config.modulators[instrument.modulators[mod]].name;
                        if (filterType == "eq filter" || filterType == "note filter") {
                            $("#modFilterText" + mod).get(0).style.display = "";
                            $("#modSettingText" + mod).get(0).style.setProperty("margin-bottom", "2px");
                            let useInstrument = instrument.modInstruments[mod];
                            let modChannel = this._doc.song.channels[Math.max(0, instrument.modChannels[mod])];
                            let tmpCount = -1;
                            if (useInstrument >= modChannel.instruments.length) {
                                for (let i = 0; i < modChannel.instruments.length; i++) {
                                    if (filterType == "eq filter") {
                                        if (modChannel.instruments[i].eqFilter.controlPointCount > tmpCount) {
                                            tmpCount = modChannel.instruments[i].eqFilter.controlPointCount;
                                            useInstrument = i;
                                        }
                                    }
                                    else {
                                        if (modChannel.instruments[i].noteFilter.controlPointCount > tmpCount) {
                                            tmpCount = modChannel.instruments[i].noteFilter.controlPointCount;
                                            useInstrument = i;
                                        }
                                    }
                                }
                            }
                            let dotCount = (filterType == "eq filter")
                                ? channel.instruments[useInstrument].eqFilter.controlPointCount
                                : channel.instruments[useInstrument].noteFilter.controlPointCount;
                            const isSimple = (filterType == "eq filter" ? channel.instruments[useInstrument].eqFilterType : channel.instruments[useInstrument].noteFilterType);
                            if (isSimple)
                                dotCount = 0;
                            if (isSimple || this._modFilterBoxes[mod].children.length != 1 + dotCount * 2) {
                                while (this._modFilterBoxes[mod].firstChild)
                                    this._modFilterBoxes[mod].remove(0);
                                const dotList = [];
                                if (!isSimple)
                                    dotList.push("morph");
                                for (let i = 0; i < dotCount; i++) {
                                    dotList.push("dot " + (i + 1) + " x");
                                    dotList.push("dot " + (i + 1) + " y");
                                }
                                buildOptions(this._modFilterBoxes[mod], dotList);
                            }
                            if (isSimple || instrument.modFilterTypes[mod] >= this._modFilterBoxes[mod].length) {
                                this._modFilterBoxes[mod].classList.add("invalidSetting");
                                instrument.invalidModulators[mod] = true;
                                let useName = ((instrument.modFilterTypes[mod] - 1) % 2 == 1) ?
                                    "dot " + (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) + 1) + " y"
                                    : "dot " + (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) + 1) + " x";
                                if (instrument.modFilterTypes[mod] == 0)
                                    useName = "morph";
                                this._modFilterBoxes[mod].insertBefore(option$6({ value: useName, style: "color: red;" }, useName), this._modFilterBoxes[mod].children[0]);
                                this._modFilterBoxes[mod].selectedIndex = 0;
                            }
                            else {
                                this._modFilterBoxes[mod].classList.remove("invalidSetting");
                                instrument.invalidModulators[mod] = false;
                                this._modFilterBoxes[mod].selectedIndex = instrument.modFilterTypes[mod];
                            }
                        }
                        else {
                            $("#modFilterText" + mod).get(0).style.display = "none";
                            $("#modSettingText" + mod).get(0).style.setProperty("margin-bottom", "0.9em");
                        }
                    }
                    this._doc.recalcChannelNames = false;
                    for (let chordIndex = 0; chordIndex < Config.chords.length; chordIndex++) {
                        const option = this._chordSelect.children[chordIndex];
                        if (!option.hasAttribute("hidden")) {
                            option.setAttribute("hidden", "");
                        }
                    }
                    this._customInstrumentSettingsGroup.style.display = "none";
                    this._panSliderRow.style.display = "none";
                    this._panDropdownGroup.style.display = "none";
                    this._instrumentVolumeSliderRow.style.display = "none";
                    $("#typeSelectRow").css("display", "none");
                    this._instrumentSettingsGroup.style.color = ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote;
                    if (this._doc.channel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        this._piano.forceRender();
                    }
                    this._renderInstrumentBar(channel, instrumentIndex, colors);
                }
                this._instrumentSettingsGroup.style.color = colors.primaryNote;
                this._eqFilterEditor.render();
                this._instrumentVolumeSlider.updateValue(instrument.volume);
                this._detuneSlider.updateValue(instrument.detune - Config.detuneCenter);
                this._twoNoteArpBox.checked = instrument.fastTwoNoteArp ? true : false;
                this._clicklessTransitionBox.checked = instrument.clicklessTransition ? true : false;
                this._aliasingBox.checked = instrument.aliases ? true : false;
                this._addEnvelopeButton.disabled = (instrument.envelopeCount >= Config.maxEnvelopeCount);
                this._volumeSlider.updateValue(this._doc.volume);
                if (wasActive && activeElement != null && activeElement.clientWidth == 0) {
                    this.refocusStage();
                }
                this._setPrompt(this._doc.prompt);
                if (this._doc.autoFollow && !this._doc.synth.playing) {
                    this._doc.synth.goToBar(this._doc.bar);
                }
                if (this._doc.addedEffect) {
                    const envButtonRect = this._addEnvelopeButton.getBoundingClientRect();
                    const instSettingsRect = this._instrumentSettingsArea.getBoundingClientRect();
                    const settingsRect = this._settingsArea.getBoundingClientRect();
                    this._instrumentSettingsArea.scrollTop += Math.max(0, envButtonRect.top - (instSettingsRect.top + instSettingsRect.height));
                    this._settingsArea.scrollTop += Math.max(0, envButtonRect.top - (settingsRect.top + settingsRect.height));
                    this._doc.addedEffect = false;
                }
                if (this._doc.addedEnvelope) {
                    this._instrumentSettingsArea.scrollTop = this._instrumentSettingsArea.scrollHeight;
                    this._settingsArea.scrollTop = this._settingsArea.scrollHeight;
                    this._doc.addedEnvelope = false;
                }
            };
            this._disableCtrlContextMenu = (event) => {
                if (event.ctrlKey) {
                    event.preventDefault();
                    return false;
                }
                return true;
            };
            this._whenKeyUp = (event) => {
                this._muteEditor.onKeyUp(event);
                if (event.keyCode == 17) {
                    this._patternEditor.controlMode = false;
                }
                else if (event.keyCode == 16) {
                    this._patternEditor.shiftMode = false;
                }
            };
            this._tempoStepperCaptureNumberKeys = (event) => {
                switch (event.keyCode) {
                    case 8:
                    case 13:
                    case 38:
                    case 40:
                    case 37:
                    case 39:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                        event.stopPropagation();
                        break;
                }
            };
            this._whenKeyPressed = (event) => {
                if (this.prompt) {
                    if (this.prompt instanceof CustomChipPrompt || this.prompt instanceof LimiterPrompt || this.prompt instanceof CustomFilterPrompt) {
                        this.prompt.whenKeyPressed(event);
                    }
                    if (event.keyCode == 27) {
                        this._doc.undo();
                    }
                    return;
                }
                if (document.activeElement == this._songTitleInputBox.input || this._patternEditor.editingModLabel || document.activeElement == this._muteEditor._channelNameInput.input) {
                    if (event.keyCode == 13 || event.keyCode == 27) {
                        this.mainLayer.focus();
                        this._patternEditor.stopEditingModLabel(event.keyCode == 27);
                    }
                    return;
                }
                if (document.activeElement == this._panSliderInputBox|| document.activeElement == this._pitchShiftBox  || document.activeElement == this._instrumentName  || document.activeElement == this._detuneSliderInputBox || document.activeElement == this._instrumentVolumeSliderInputBox    
|| document.activeElement == this._chipWaveLoopStartStepper
|| document.activeElement == this._chipWaveLoopEndStepper
|| document.activeElement == this._chipWaveStartOffsetStepper
                || document.activeElement == this._unisonVoicesInputBox ||
      	document.activeElement == this._unisonSpreadInputBox ||
      	document.activeElement == this._unisonOffsetInputBox ||
      	document.activeElement == this._unisonExpressionInputBox ||
      	document.activeElement == this._unisonSignInputBox) {
                    if (event.keyCode == 13 || event.keyCode == 27) {
                        this.mainLayer.focus();
                    }
                    return;
                }
                switch (event.keyCode) {
                    case 27:
                        if (!event.ctrlKey && !event.metaKey) {
                            new ChangePatternSelection(this._doc, 0, 0);
                            this._doc.selection.resetBoxSelection();
                        }
                        break;
                    case 16:
                        this._patternEditor.shiftMode = true;
                        break;
                    case 17:
                        this._patternEditor.controlMode = true;
                        break;
                    case 32:
                        if (event.shiftKey) {
                            if (this._trackEditor.movePlayheadToMouse() || this._patternEditor.movePlayheadToMouse()) {
                                if (!this._doc.synth.playing)
                                    this._play();
                            }
                        }
                        else {
                            this._togglePlay();
                        }
                        event.preventDefault();
                        this.refocusStage();
                        break;
                    case 90:
                        if (event.shiftKey) {
                            this._doc.redo();
                        }
                        else {
                            this._doc.undo();
                        }
                        event.preventDefault();
                        break;
                    case 89:
                        this._doc.redo();
                        event.preventDefault();
                        break;
                    case 67:
                        if (event.shiftKey) {
                            this._copyInstrument();
                        }
                        else {
                            this._doc.selection.copy();
                        }
                        this._doc.selection.resetBoxSelection();
                        this._doc.selection.selectionUpdated();
                        event.preventDefault();
                        break;
                    case 13:
                        if (event.ctrlKey || event.metaKey) {
                            this._doc.selection.insertChannel();
                        }
                        else {
                            this._doc.selection.insertBars();
                        }
                        event.preventDefault();
                        break;
                    case 8:
                        if (event.ctrlKey || event.metaKey) {
                            this._doc.selection.deleteChannel();
                        }
                        else {
                            this._doc.selection.deleteBars();
                        }
                        this._barScrollBar.animatePlayhead();
                        event.preventDefault();
                        break;
                    case 65:
                        if (event.shiftKey) {
                            this._doc.selection.selectChannel();
                        }
                        else {
                            this._doc.selection.selectAll();
                        }
                        event.preventDefault();
                        break;
                    case 68:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.selection.duplicatePatterns();
                            event.preventDefault();
                        }
                        break;
                    case 69:
                        if (event.shiftKey) {
                            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                            if (!instrument.eqFilterType && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                                this._openPrompt("customEQFilterSettings");
                        }
                        break;
                    case 70:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.synth.snapToStart();
                            this._doc.synth.computeLatestModValues();
                            if (this._doc.autoFollow) {
                                this._doc.selection.setChannelBar(this._doc.channel, Math.floor(this._doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 72:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.synth.goToBar(this._doc.bar);
                            this._doc.synth.snapToBar();
                            this._doc.synth.computeLatestModValues();
                            if (this._doc.autoFollow) {
                                this._doc.selection.setChannelBar(this._doc.channel, Math.floor(this._doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 74:
                        if (event.shiftKey && event.ctrlKey && event.altKey) {
                            this._doc.autoPlay = false;
                            this._doc.autoFollow = false;
                            this._doc.enableNotePreview = true;
                            this._doc.showFifth = true;
                            this._doc.notesOutsideScale = false;
                            this._doc.defaultScale = 0;
                            this._doc.showLetters = true;
                            this._doc.showChannels = true;
                            this._doc.showScrollBar = true;
                            this._doc.alwaysFineNoteVol = false;
                            this._doc.enableChannelMuting = true;
                            this._doc.displayBrowserUrl = true;
                            this._doc.displayVolumeBar = true;
                            this._doc.notesFlashWhenPlayed = false;
                            
                            this._doc.layout = "wide";
                            this._doc.visibleOctaves = 5;
                            this._doc.savePreferences();
                            event.preventDefault();
                            location.reload();
                        }
                        break;
                    case 76:
                        if (event.shiftKey) {
                            this._openPrompt("limiterSettings");
                        }
                        else {
                            this._openPrompt("barCount");
                        }
                        break;
                    case 77:
                        if (!event.ctrlKey && !event.metaKey) {
                            if (this._doc.enableChannelMuting) {
                                this._doc.selection.muteChannels(event.shiftKey);
                                event.preventDefault();
                            }
                        }
                        break;
                    case 78:
                        const group = new ChangeGroup();
                        if (event.shiftKey) {
                            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                            if (effectsIncludeNoteFilter(instrument.effects) && !instrument.noteFilterType && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                                this._openPrompt("customNoteFilterSettings");
                            break;
                        }
                        else if (event.ctrlKey) {
                            let nextEmpty = 0;
                            while (nextEmpty < this._doc.song.patternsPerChannel && this._doc.song.channels[this._doc.channel].patterns[nextEmpty].notes.length > 0)
                                nextEmpty++;
                            nextEmpty++;
                            if (nextEmpty <= Config.barCountMax) {
                                if (nextEmpty > this._doc.song.patternsPerChannel) {
                                    group.append(new ChangePatternsPerChannel(this._doc, nextEmpty));
                                }
                                group.append(new ChangePatternNumbers(this._doc, nextEmpty, this._doc.bar, this._doc.channel, 1, 1));
                            }
                        }
                        else {
                            let nextUnused = 1;
                            while (this._doc.song.channels[this._doc.channel].bars.indexOf(nextUnused) != -1
                                && nextUnused <= this._doc.song.patternsPerChannel)
                                nextUnused++;
                            if (nextUnused <= Config.barCountMax) {
                                if (nextUnused > this._doc.song.patternsPerChannel) {
                                    group.append(new ChangePatternsPerChannel(this._doc, nextUnused));
                                }
                                group.append(new ChangePatternNumbers(this._doc, nextUnused, this._doc.bar, this._doc.channel, 1, 1));
                            }
                        }
                        this._doc.record(group);
                        event.preventDefault();
                        break;
                    case 81:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._openPrompt("channelSettings");
                            event.preventDefault();
                        }
                        break;
                    case 83:
                        if (event.ctrlKey || event.metaKey) {
                            this._openPrompt("export");
                            event.preventDefault();
                        }
                        else {
                            if (this._doc.enableChannelMuting) {
                                if (event.shiftKey) {
                                    this._doc.selection.muteChannels(false);
                                }
                                else {
                                    this._doc.selection.soloChannels(false);
                                }
                                event.preventDefault();
                            }
                        }
                        break;
                    case 79:
                        if (event.ctrlKey || event.metaKey) {
                            this._openPrompt("import");
                            event.preventDefault();
                        }
                        break;
                    case 86:
                        if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
                            this._doc.selection.pasteNumbers();
                        }
                        else if (event.shiftKey) {
                            this._pasteInstrument();
                        }
                        else {
                            this._doc.selection.pasteNotes();
                        }
                        event.preventDefault();
                        break;
                    case 87:
                        this._openPrompt("moveNotesSideways");
                        break;
                    case 73:
                        if (!event.ctrlKey && !event.metaKey && event.shiftKey) {
                            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                            const instrumentObject = instrument.toJsonObject();
                            delete instrumentObject["preset"];
                            delete instrumentObject["volume"];
                            delete instrumentObject["pan"];
                            const panningEffectIndex = instrumentObject["effects"].indexOf(Config.effectNames[2]);
                            if (panningEffectIndex != -1)
                                instrumentObject["effects"].splice(panningEffectIndex, 1);
                            for (let i = 0; i < instrumentObject["envelopes"].length; i++) {
                                const envelope = instrumentObject["envelopes"][i];
                                if (envelope["target"] == "panning" || envelope["target"] == "none" || envelope["envelope"] == "none") {
                                    instrumentObject["envelopes"].splice(i, 1);
                                    i--;
                                }
                            }
                            this._copyTextToClipboard(JSON.stringify(instrumentObject));
                            event.preventDefault();
                        }
                        break;
                    case 82:
                        if (!event.ctrlKey && !event.metaKey) {
                            if (event.shiftKey) {
                                this._randomGenerated();
                            }
                            else {
                                this._randomPreset();
                            }
                            event.preventDefault();
                        }
                        break;
                    case 219:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.synth.goToPrevBar();
                            if (this._doc.autoFollow) {
                                this._doc.selection.setChannelBar(this._doc.channel, Math.floor(this._doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 221:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.synth.goToNextBar();
                            if (this._doc.autoFollow) {
                                this._doc.selection.setChannelBar(this._doc.channel, Math.floor(this._doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 189:
                    case 173:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.selection.transpose(false, event.shiftKey);
                            event.preventDefault();
                        }
                        break;
                    case 187:
                    case 61:
                    case 171:
                        if (!event.ctrlKey && !event.metaKey) {
                            this._doc.selection.transpose(true, event.shiftKey);
                            event.preventDefault();
                        }
                        break;
                    case 38:
                        if (event.ctrlKey || event.metaKey) {
                            this._doc.selection.swapChannels(-1);
                        }
                        else if (event.shiftKey) {
                            this._doc.selection.boxSelectionY1 = Math.max(0, this._doc.selection.boxSelectionY1 - 1);
                            this._doc.selection.scrollToSelection();
                            this._doc.selection.selectionUpdated();
                        }
                        else {
                            this._doc.selection.setChannelBar((this._doc.channel - 1 + this._doc.song.getChannelCount()) % this._doc.song.getChannelCount(), this._doc.bar);
                            this._doc.selection.resetBoxSelection();
                        }
                        event.preventDefault();
                        break;
                    case 40:
                        if (event.ctrlKey || event.metaKey) {
                            this._doc.selection.swapChannels(1);
                        }
                        else if (event.shiftKey) {
                            this._doc.selection.boxSelectionY1 = Math.min(this._doc.song.getChannelCount() - 1, this._doc.selection.boxSelectionY1 + 1);
                            this._doc.selection.scrollToSelection();
                            this._doc.selection.selectionUpdated();
                        }
                        else {
                            this._doc.selection.setChannelBar((this._doc.channel + 1) % this._doc.song.getChannelCount(), this._doc.bar);
                            this._doc.selection.resetBoxSelection();
                        }
                        event.preventDefault();
                        break;
                    case 37:
                        if (event.shiftKey) {
                            this._doc.selection.boxSelectionX1 = Math.max(0, this._doc.selection.boxSelectionX1 - 1);
                            this._doc.selection.scrollToSelection();
                            this._doc.selection.selectionUpdated();
                        }
                        else {
                            this._doc.selection.setChannelBar(this._doc.channel, (this._doc.bar + this._doc.song.barCount - 1) % this._doc.song.barCount);
                            this._doc.selection.resetBoxSelection();
                        }
                        event.preventDefault();
                        break;
                    case 39:
                        if (event.shiftKey) {
                            this._doc.selection.boxSelectionX1 = Math.min(this._doc.song.barCount - 1, this._doc.selection.boxSelectionX1 + 1);
                            this._doc.selection.scrollToSelection();
                            this._doc.selection.selectionUpdated();
                        }
                        else {
                            this._doc.selection.setChannelBar(this._doc.channel, (this._doc.bar + 1) % this._doc.song.barCount);
                            this._doc.selection.resetBoxSelection();
                        }
                        event.preventDefault();
                        break;
                    case 46:
                        this._doc.selection.digits = "";
                        this._doc.selection.nextDigit("0", false, false);
                        break;
                    case 48:
                        this._doc.selection.nextDigit("0", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 49:
                        this._doc.selection.nextDigit("1", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 50:
                        this._doc.selection.nextDigit("2", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 51:
                        this._doc.selection.nextDigit("3", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 52:
                        this._doc.selection.nextDigit("4", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 53:
                        this._doc.selection.nextDigit("5", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 54:
                        this._doc.selection.nextDigit("6", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 55:
                        this._doc.selection.nextDigit("7", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 56:
                        this._doc.selection.nextDigit("8", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    case 57:
                        this._doc.selection.nextDigit("9", event.shiftKey || event.ctrlKey, event.altKey);
                        event.preventDefault();
                        break;
                    default:
                        this._doc.selection.digits = "";
                        this._doc.selection.instrumentDigits = "";
                        break;
                }
            };
            
            
 
		
            
            
            this._whenPrevBarPressed = () => {
                this._doc.synth.goToPrevBar();
                this._barScrollBar.animatePlayhead();
            };
            this._whenNextBarPressed = () => {
                this._doc.synth.goToNextBar();
                this._barScrollBar.animatePlayhead();
            };
this._toggleRecord = () => {
	if (this._doc.synth.playing) {
		this._doc.performance.pause();
		this._doc.synth.isRecording=false
		this._doc.synth.isRecordingWhistle = false
	}
	else {
		this._doc.performance.record();
		this._doc.synth.isRecording=true
	}
};
            this._togglePlay = () => {
                if (this._doc.synth.playing) {
                    this._pause();
                    this._doc.synth.isRecordingWhistle = false
                    this._doc.selection.closeMic()
                }
                else {
                    this._doc.synth.snapToBar();
                    this._play();
                }
            };
            this._animate = () => {
                this._modSliderUpdate();
function step1(value, stepSize) {
	return (value).toFixed(2);
}
let instrument =false
if(this._doc.synth.playing){
let usesCustomUnison ;
	for (let instrumentIndex = 0; instrumentIndex < this._doc.song.channels[this._doc.channel].instruments.length; instrumentIndex++) {
	 instrument = this._doc.song.channels[this._doc.channel].instruments[instrumentIndex];
		usesCustomUnison = instrument.unison === Config.unisons.length
	}
if (usesCustomUnison) {
	this.changedUnisonPreview=0;
	this._unisonVoicesInputBox.style.color = "red"
this._unisonSpreadInputBox.style.color = "red"
this._unisonOffsetInputBox.style.color = "red"
this._unisonExpressionInputBox.style.color = "red"
this._unisonSignInputBox.style.color = "red"

this._unisonVoicesInputBox.disabled=true;
this._unisonSpreadInputBox.disabled=true;
this._unisonOffsetInputBox.disabled=true;
this._unisonExpressionInputBox.disabled=true;
this._unisonSignInputBox.disabled=true;
if(instrument){
this._unisonVoicesInputBox.value = step1(instrument.unisonVoices,0.01) + "";
this._unisonSpreadInputBox.value = step1(instrument.unisonSpread,0.01) + "";
this._unisonOffsetInputBox.value = step1(instrument.unisonOffset,0.01) + "";
this._unisonExpressionInputBox.value = step1(instrument.unisonExpression,0.1) + "";
this._unisonSignInputBox.value = step1(instrument.unisonSign,0.1) + ""
}
}else{
this._unisonVoicesInputBox.disabled = false;
this._unisonSpreadInputBox.disabled = false;
this._unisonOffsetInputBox.disabled = false;
this._unisonExpressionInputBox.disabled = false;
this._unisonSignInputBox.disabled = false;

this._unisonVoicesInputBox.style.color = "white"
this._unisonSpreadInputBox.style.color = "white"
this._unisonOffsetInputBox.style.color = "white"
this._unisonExpressionInputBox.style.color = "white"
this._unisonSignInputBox.style.color = "white"

if(this.changedUnisonPreview==0){
	if(instrument){
this._unisonVoicesInputBox.value = instrument.last_unisonVoices + "";
this._unisonSpreadInputBox.value = instrument.last_unisonSpread + "";
this._unisonOffsetInputBox.value = instrument.last_unisonOffset + "";
this._unisonExpressionInputBox.value = instrument.last_unisonExpression + "";
this._unisonSignInputBox.value = instrument.last_unisonSign + "";
}}
this.changedUnisonPreview = 1
}
}else{
this._unisonVoicesInputBox.disabled = false;
this._unisonSpreadInputBox.disabled = false;
this._unisonOffsetInputBox.disabled = false;
this._unisonExpressionInputBox.disabled = false;
this._unisonSignInputBox.disabled = false;

this._unisonVoicesInputBox.style.color = "white"
this._unisonSpreadInputBox.style.color = "white"
this._unisonOffsetInputBox.style.color = "white"
this._unisonExpressionInputBox.style.color = "white"
this._unisonSignInputBox.style.color = "white"
}
                
                if (this._doc.displayVolumeBar) {
                    this._volumeUpdate();
                }
                this._barScrollBar.animatePlayhead();
                if (this._doc.synth.isFilterModActive(false, this._doc.channel, this._doc.getCurrentInstrument())) {
                    this._eqFilterEditor.render(true);
                }
                if (this._doc.synth.isFilterModActive(true, this._doc.channel, this._doc.getCurrentInstrument())) {
                    this._noteFilterEditor.render(true);
                }
                window.requestAnimationFrame(this._animate);
            };
            this._volumeUpdate = () => {
                this.outVolumeHistoricTimer--;
                if (this.outVolumeHistoricTimer <= 0) {
                    this.outVolumeHistoricCap -= 0.03;
                }
                if (this._doc.song.outVolumeCap > this.outVolumeHistoricCap) {
                    this.outVolumeHistoricCap = this._doc.song.outVolumeCap;
                    this.outVolumeHistoricTimer = 50;
                }
                if (this._doc.song.outVolumeCap != this.lastOutVolumeCap) {
                    this.lastOutVolumeCap = this._doc.song.outVolumeCap;
                    this._animateVolume(this._doc.song.outVolumeCap, this.outVolumeHistoricCap);
                }
            };
            this._setVolumeSlider = () => {
                this._doc.setVolume(Number(this._volumeSlider.input.value));
            };
            this._copyInstrument = () => {
                const channel = this._doc.song.channels[this._doc.channel];
                const instrument = channel.instruments[this._doc.getCurrentInstrument()];
                const instrumentCopy = instrument.toJsonObject();
                instrumentCopy["isDrum"] = this._doc.song.getChannelIsNoise(this._doc.channel);
                window.localStorage.setItem("instrumentCopy", JSON.stringify(instrumentCopy));
              //  alert(JSON.stringify(instrumentCopy))
                this.refocusStage();
            };
            this._pasteInstrument = () => {
                const channel = this._doc.song.channels[this._doc.channel];
                const instrument = channel.instruments[this._doc.getCurrentInstrument()];
                const instrumentCopy = JSON.parse(String(window.localStorage.getItem("instrumentCopy")));
                if (instrumentCopy != null && instrumentCopy["isDrum"] == this._doc.song.getChannelIsNoise(this._doc.channel)) {
                    this._doc.record(new ChangePasteInstrument(this._doc, instrument, instrumentCopy));
                }
                this.refocusStage();
            };
            this._whenSetTempo = () => {
                this._doc.record(new ChangeTempo(this._doc, -1, parseInt(this._tempoStepper.value) | 0));
            };
            this._whenSetScale = () => {
                if (isNaN(this._scaleSelect.value)) {
                    switch (this._scaleSelect.value) {
                        case "forceScale":
                            this._doc.selection.forceScale();
                            break;
                    }
                    this._doc.notifier.changed();
                }
                else {
                    this._doc.record(new ChangeScale(this._doc, this._scaleSelect.selectedIndex));
                }
            };
            this._whenSetKey = () => {
                if (isNaN(this._keySelect.value)) {
                    switch (this._keySelect.value) {
                        case "detectKey":
                            this._doc.record(new ChangeDetectKey(this._doc));
                            break;
                    }
                    this._doc.notifier.changed();
                }
                else {
                    this._doc.record(new ChangeKey(this._doc, Config.keys.length - 1 - this._keySelect.selectedIndex));
                }
            };
            this._whenSetUseChipWaveAdvancedLoopControls = () => {
	this._doc.record(new ChangeChipWaveUseAdvancedLoopControls(this._doc, this._useChipWaveAdvancedLoopControlsBox.checked ? true : false));
};
this._whenSetChipWaveLoopMode = () => {
	this._doc.record(new ChangeChipWaveLoopMode(this._doc, this._chipWaveLoopModeSelect.selectedIndex));
};
this._whenSetChipWaveLoopStart = () => {
	this._doc.record(new ChangeChipWaveLoopStart(this._doc, parseInt(this._chipWaveLoopStartStepper.value) | 0));
};
this._whenSetChipWaveLoopEnd = () => {
	this._doc.record(new ChangeChipWaveLoopEnd(this._doc, parseInt(this._chipWaveLoopEndStepper.value) | 0));
};
this._whenSetChipWaveLoopEndToEnd = () => {
	const channel = this._doc.song.channels[this._doc.channel];
	const instrument = channel.instruments[this._doc.getCurrentInstrument()];
	const chipWave = Config.chipWaves[instrument.chipWave];
	const chipWaveLength = chipWave.samples.length;
	this._doc.record(new ChangeChipWaveLoopEnd(this._doc, chipWaveLength - 1));
};
this._whenSetChipWaveStartOffset = () => {
	this._doc.record(new ChangeChipWaveStartOffset(this._doc, parseInt(this._chipWaveStartOffsetStepper.value) | 0));
};
this._whenSetChipWavePlayBackwards = () => {
	this._doc.record(new ChangeChipWavePlayBackwards(this._doc, this._chipWavePlayBackwardsBox.checked));
};
            this._whenSetRhythm = () => {
                if (isNaN(this._rhythmSelect.value)) {
                    switch (this._rhythmSelect.value) {
                        case "forceRhythm":
                            this._doc.selection.forceRhythm();
                            break;
                    }
                    this._doc.notifier.changed();
                }
                else {
                    this._doc.record(new ChangeRhythm(this._doc, this._rhythmSelect.selectedIndex));
                }
            };
            this._refocus = () => {
                var selfRef = this;
                setTimeout(function () { selfRef.mainLayer.focus(); }, 20);
            };
            this._whenSetPitchedPreset = () => {
                this._setPreset($('#pitchPresetSelect').val() + "");
            };
            this._whenSetDrumPreset = () => {
                this._setPreset($('#drumPresetSelect').val() + "");
            };
            this._whenSetFeedbackType = () => {
                this._doc.record(new ChangeFeedbackType(this._doc, this._feedbackTypeSelect.selectedIndex));
            };
            this._whenSetAlgorithm = () => {
                this._doc.record(new ChangeAlgorithm(this._doc, this._algorithmSelect.selectedIndex));
            };
            this._whenSelectInstrument = (event) => {
                if (event.target == this._instrumentAddButton) {
                    this._doc.record(new ChangeAddChannelInstrument(this._doc));
                }
                else if (event.target == this._instrumentRemoveButton) {
                    this._doc.record(new ChangeRemoveChannelInstrument(this._doc));
                }
                else {
                    const index = this._instrumentButtons.indexOf(event.target);
                    if (index != -1) {
                        this._doc.selection.selectInstrument(index);
                    }
                    if (this._doc.channel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        this._piano.forceRender();
                    }
                }
                this.refocusStage();
            };
            this._whenSetModChannel = (mod) => {
                let instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                let previouslyUnset = (instrument.modulators[mod] == 0 || Config.modulators[instrument.modulators[mod]].forSong);
                this._doc.selection.setModChannel(mod, this._modChannelBoxes[mod].selectedIndex);
                const modChannel = Math.max(0, instrument.modChannels[mod]);
                if (this._doc.song.channels[modChannel].instruments.length > 1 && previouslyUnset && this._modChannelBoxes[mod].selectedIndex >= 2) {
                    if (this._doc.song.channels[modChannel].bars[this._doc.bar] > 0) {
                        this._doc.selection.setModInstrument(mod, this._doc.song.channels[modChannel].patterns[this._doc.song.channels[modChannel].bars[this._doc.bar] - 1].instruments[0]);
                    }
                }
                this._piano.forceRender();
            };
            this._whenSetModInstrument = (mod) => {
                this._doc.selection.setModInstrument(mod, this._modInstrumentBoxes[mod].selectedIndex);
                this._piano.forceRender();
            };
            this._whenSetModSetting = (mod, invalidIndex = false) => {
                let text = "none";
                if (this._modSetBoxes[mod].selectedIndex != -1) {
                    text = this._modSetBoxes[mod].children[this._modSetBoxes[mod].selectedIndex].textContent;
                    if (invalidIndex) {
                        this._modSetBoxes[mod].selectedOptions.item(0).style.setProperty("color", "red");
                        this._modSetBoxes[mod].classList.add("invalidSetting");
                        this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].invalidModulators[mod] = true;
                    }
                    else {
                        this._modSetBoxes[mod].classList.remove("invalidSetting");
                        this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].invalidModulators[mod] = false;
                    }
                }
                if (!invalidIndex)
                    this._doc.selection.setModSetting(mod, text);
                this._piano.forceRender();
            };
            this._whenClickModTarget = (mod) => {
                if (this._modChannelBoxes[mod].selectedIndex >= 2) {
                    this._doc.selection.setChannelBar(this._modChannelBoxes[mod].selectedIndex - 2, this._doc.bar);
                    
                }
            };
            this._whenClickJumpToModTarget = () => {
                const channelIndex = this._doc.channel;
                const instrumentIndex = this._doc.getCurrentInstrument();
                if (channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                    for (let modChannelIdx = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; modChannelIdx < this._doc.song.channels.length; modChannelIdx++) {
                        const modChannel = this._doc.song.channels[modChannelIdx];
                        const patternIdx = modChannel.bars[this._doc.bar];
                        if (patternIdx > 0) {
                            const modInstrumentIdx = modChannel.patterns[patternIdx - 1].instruments[0];
                            const modInstrument = modChannel.instruments[modInstrumentIdx];
                            for (let mod = 0; mod < Config.modCount; mod++) {
                                if (modInstrument.modChannels[mod] == channelIndex && (modInstrument.modInstruments[mod] == instrumentIndex || modInstrument.modInstruments[mod] >= this._doc.song.channels[channelIndex].instruments.length)) {
                                    this._doc.selection.setChannelBar(modChannelIdx, this._doc.bar);
                                    return;
                                }
                            }
                        }
                    }
                }
            };
            this._whenSetModFilter = (mod) => {
                this._doc.selection.setModFilter(mod, this._modFilterBoxes[mod].selectedIndex);
                
                
            };
            this._whenSetChipWave = () => {
                this._doc.record(new ChangeChipWave(this._doc, this._chipWaveSelect.selectedIndex));
                

            };
            this._whenSetRingModChipWave = () => {
	this._doc.record(new ChangeRingModChipWave(this._doc, this._ringModWaveSelect.selectedIndex));
};
            this._whenSetNoiseWave = () => {
                this._doc.record(new ChangeNoiseWave(this._doc, this._chipNoiseSelect.selectedIndex));
            };
            this._whenSetTransition = () => {
                this._doc.record(new ChangeTransition(this._doc, this._transitionSelect.selectedIndex));
            };
            this._whenSetEffects = () => {
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                const oldValue = instrument.effects;
                const toggleFlag = Config.effectOrder[this._effectsSelect.selectedIndex - 1];
                this._doc.record(new ChangeToggleEffects(this._doc, toggleFlag));
                this._effectsSelect.selectedIndex = 0;
                if (instrument.effects > oldValue) {
                    this._doc.addedEffect = true;
                }
                this._doc.notifier.changed();
            };
            this._whenSetVibrato = () => {
                this._doc.record(new ChangeVibrato(this._doc, this._vibratoSelect.selectedIndex));
            };
            this._whenSetVibratoType = () => {
                this._doc.record(new ChangeVibratoType(this._doc, this._vibratoTypeSelect.selectedIndex));
            };
            this._whenSetUnison = () => {
                this._doc.record(new ChangeUnison(this._doc, this._unisonSelect.selectedIndex));
            };
            this._whenSetChord = () => {
                this._doc.record(new ChangeChord(this._doc, this._chordSelect.selectedIndex));
            };
            this._addNewEnvelope = () => {
                this._doc.record(new ChangeAddEnvelope(this._doc));
                this.refocusStage();
                this._doc.addedEnvelope = true;
            };
            this._zoomIn = () => {
                this._doc.visibleOctaves = Math.max(1, this._doc.visibleOctaves - 1);
                this._doc.savePreferences();
                this._doc.notifier.changed();
                this.refocusStage();
            };
            this._zoomOut = () => {
                this._doc.visibleOctaves = Math.min(Config.pitchOctaves, this._doc.visibleOctaves + 1);
                this._doc.savePreferences();
                this._doc.notifier.changed();
                this.refocusStage();
            };
            this._fileMenuHandler = (event) => {
                switch (this._fileMenu.value) {
                    case "new":
                        this._doc.goBackToStart();
                        this._doc.song.restoreLimiterDefaults();
                        for (const channel of this._doc.song.channels) {
                            channel.muted = false;
                            channel.name = "";
                        }
                        this._doc.record(new ChangeSong(this._doc, ""), false, true);
                        break;
                    case "export":
                        this._openPrompt("export");
                        break;
                    case "import":
                        this._openPrompt("import");
                        break;
                    case "copyUrl":
                        this._copyTextToClipboard(new URL("#" + this._doc.song.toBase64String(), location.href).href);
                        break;
                    case "shareUrl":
                        navigator.share({ url: new URL("#" + this._doc.song.toBase64String(), location.href).href });
                        break;
                    case "shortenUrl":
                        window.open("https://tinyurl.com/api-create.php?url=" + encodeURIComponent(new URL("#" + this._doc.song.toBase64String(), location.href).href));
                        break;
                    case "viewPlayer":
editor._pause();
if (location.href.startsWith("file:///")) {
let fileFull= "file:///android_asset/WebView/player.html#"+this._doc.song.toBase64String();
window.open(fileFull, "_self")
 
                }else{
                        location.href = "./player.html"+"#" + this._doc.song.toBase64String();
                }
                        break;
                    case "copyEmbed":
                        this._copyTextToClipboard(`<iframe width="384" height="60" style="border: none;" src="${new URL("player/#song=" + this._doc.song.toBase64String(), location.href).href}"></iframe>`);
                        break;
					case "songRecovery":
                        this._openPrompt("songRecovery");
                        break;
                }
                this._fileMenu.selectedIndex = 0;
            };
            this._editMenuHandler = (event) => {
                switch (this._editMenu.value) {
                    case "undo":
                        this._doc.undo();
                        break;
                    case "redo":
                        this._doc.redo();
                        break;
                    case "copy":
                        this._doc.selection.copy();
                        break;
                    case "insertBars":
                        this._doc.selection.insertBars();
                        break;
                    case "deleteBars":
                        this._doc.selection.deleteBars();
                        break;
                    case "insertChannel":
                        this._doc.selection.insertChannel();
                        break;
                    case "deleteChannel":
                        this._doc.selection.deleteChannel();
                        break;
                    case "pasteNotes":
                        this._doc.selection.pasteNotes();
                        break;
                    case "pasteNumbers":
                        this._doc.selection.pasteNumbers();
                        break;
                    case "transposeUp":
                        this._doc.selection.transpose(true, false);
                        break;
                    case "transposeDown":
                        this._doc.selection.transpose(false, false);
                        break;
case "transposeOctaveUp":
this._doc.selection.transpose(true, true);
break;
case "transposeOctaveDown":
this._doc.selection.transpose(false, true);
break;
                    case "selectAll":
                        this._doc.selection.selectAll();
                        break;
 case "selectMore":
this._doc.selection.selectMore();
break;

                    case "selectChannel":
                        this._doc.selection.selectChannel();
                        break;
                    case "duplicatePatterns":
                        this._doc.selection.duplicatePatterns();
                        break;
                    case "barCount":
                        this._openPrompt("barCount");
                        break;
                    case "beatsPerBar":
                        this._openPrompt("beatsPerBar");
                        break;
                    case "moveNotesSideways":
                        this._openPrompt("moveNotesSideways");
                        break;
                    case "channelSettings":
                        this._openPrompt("channelSettings");
                        break;
                    case "limiterSettings":
                        this._openPrompt("limiterSettings");
                        break;
                }
                this._editMenu.selectedIndex = 0;
            };
            this._optionsMenuHandler = (event) => {
                switch (this._optionsMenu.value) {
                    case "autoPlay":
                        this._doc.autoPlay = !this._doc.autoPlay;
                        break;
                    case "autoFollow":
                        this._doc.autoFollow = !this._doc.autoFollow;
                        break;
                    case "enableNotePreview":
                        this._doc.enableNotePreview = !this._doc.enableNotePreview;
                        break;
                    case "showLetters":
                        this._doc.showLetters = !this._doc.showLetters;
                        break;
                    case "showFifth":
                        this._doc.showFifth = !this._doc.showFifth;
                        break;
                    case "notesOutsideScale":
                        this._doc.notesOutsideScale = !this._doc.notesOutsideScale;
                        break;
                    case "setDefaultScale":
                        this._doc.defaultScale = this._doc.song.scale;
                        break;
                    case "showChannels":
                        this._doc.showChannels = !this._doc.showChannels;
                        break;
                    case "showScrollBar":
                        this._doc.showScrollBar = !this._doc.showScrollBar;
break;
case "showDescription":
this._doc.showDescription = !this._doc.showDescription;
break;
case "showPlugins":
this._doc.showPlugins = !this._doc.showPlugins;
break;
case "increaseAllPins":
this._doc.increaseAllPins = !this._doc.increaseAllPins;
break;
case "differentMod":
this._doc.differentMod = !this._doc.differentMod;
break;
 
                    case "alwaysFineNoteVol":
                        this._doc.alwaysFineNoteVol = !this._doc.alwaysFineNoteVol;
                        break;
                    case "enableChannelMuting":
                        this._doc.enableChannelMuting = !this._doc.enableChannelMuting;
                        for (const channel of this._doc.song.channels)
                            channel.muted = false;
                        break;
                    case "displayBrowserUrl":
                        this._doc.toggleDisplayBrowserUrl();
                        break;
                    case "displayVolumeBar":
                        this._doc.displayVolumeBar = !this._doc.displayVolumeBar;
                        break;
                    case "layout":
                        this._openPrompt("layout");
                        break;
                    case "colorTheme":
                        this._openPrompt("theme");
                        break;
                        
 case "notesFlashWhenPlayed":
this._doc.notesFlashWhenPlayed = !this._doc.notesFlashWhenPlayed;
break;
case "whistleRecord":
this._doc.selection.whistleRecord();
break;
case "recordingSetup":
this._openPrompt("recordingSetup");
break;
case "increaseAllPins":
this._openPrompt("increaseAllPins");
break;
                }
                this._optionsMenu.selectedIndex = 0;
                this._doc.notifier.changed();
                this._doc.savePreferences();
            };
            this._customWavePresetHandler = (event) => {
                let customWaveArray = new Float64Array(64);
                let index = this._customWavePresetDrop.selectedIndex - 1;
                let maxValue = Number.MIN_VALUE;
                let minValue = Number.MAX_VALUE;
                let arrayPoint = 0;
                let arrayStep = (Config.chipWaves[index].samples.length - 1) / 64.0;
                for (let i = 0; i < 64; i++) {
                    customWaveArray[i] = (Config.chipWaves[index].samples[Math.floor(arrayPoint)] - Config.chipWaves[index].samples[(Math.floor(arrayPoint) + 1)]) / arrayStep;
                    if (customWaveArray[i] < minValue)
                        minValue = customWaveArray[i];
                    if (customWaveArray[i] > maxValue)
                        maxValue = customWaveArray[i];
                    arrayPoint += arrayStep;
                }
                for (let i = 0; i < 64; i++) {
                    customWaveArray[i] -= minValue;
                    customWaveArray[i] /= (maxValue - minValue);
                    customWaveArray[i] *= 48.0;
                    customWaveArray[i] -= 24.0;
                    customWaveArray[i] = Math.ceil(customWaveArray[i]);
                    this._customWaveDrawCanvas.newArray[i] = customWaveArray[i];
                }
                this._doc.record(new ChangeCustomWave(this._doc, customWaveArray));
                this._doc.record(new ChangeVolume(this._doc, +this._instrumentVolumeSlider.input.value, -Config.volumeRange / 2 + Math.round(Math.sqrt(Config.chipWaves[index].expression) * Config.volumeRange / 2)));
                this._customWavePresetDrop.selectedIndex = 0;
                this._doc.notifier.changed();
                this._doc.savePreferences();
            };
            this._doc.notifier.watch(this.whenUpdated);
            window.addEventListener("resize", this.whenUpdated);
            
window.requestAnimationFrame(this._animate);

            if (!("share" in navigator)) {
                this._fileMenu.removeChild(this._fileMenu.querySelector("[value='shareUrl']"));
            }
            this._scaleSelect.appendChild(optgroup({ label: "Edit" }, option$6({ value: "forceScale" }, "Snap Notes To Scale")));
            this._keySelect.appendChild(optgroup({ label: "Edit" }, option$6({ value: "detectKey" }, "Detect Key")));
            this._rhythmSelect.appendChild(optgroup({ label: "Edit" }, option$6({ value: "forceRhythm" }, "Snap Notes To Rhythm")));
            this._vibratoSelect.appendChild(option$6({ hidden: true, value: 5 }, "custom"));
            this._unisonSelect.appendChild(option({ hidden: true, value: Config.unisons.length }, "custom"));
            this._showModSliders = new Array(Config.modulators.length);
            this._modSliderValues = new Array(Config.modulators.length);
            this._phaseModGroup.appendChild(div$d({ class: "selectRow", style: `color: ${ColorConfig.secondaryText}; height: 1em; margin-top: 0.5em;` }, div$d({ style: "margin-right: .1em; visibility: hidden;" }, 1 + "."), div$d({ style: "width: 3em; margin-right: .3em;", class: "tip", onclick: () => this._openPrompt("operatorFrequency") }, "Freq:"), div$d({ class: "tip", onclick: () => this._openPrompt("operatorVolume") }, "Volume:")));
            for (let i = 0; i < Config.operatorCount; i++) {
                const operatorIndex = i;
                const operatorNumber = div$d({ style: "margin-right: 0px; color: " + ColorConfig.secondaryText + ";" }, i + 1 + "");
                const frequencySelect = buildOptions(select$6({ style: "width: 100%;", title: "Frequency" }), Config.operatorFrequencies.map(freq => freq.name));
                const amplitudeSlider = new Slider(input$8({ type: "range", min: "0", max: Config.operatorAmplitudeMax, value: "0", step: "1", title: "Volume" }), this._doc, (oldValue, newValue) => new ChangeOperatorAmplitude(this._doc, operatorIndex, oldValue, newValue), false);
                const waveformSelect = buildOptions(select$6({ style: "width: 100%;", title: "Waveform" }), Config.operatorWaves.map(wave => wave.name));
                const waveformDropdown = button$d({ style: "margin-left:0em; margin-right: 2px; height:1.5em; width: 8px; max-width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(4, i) }, "▼");
                const waveformDropdownHint = span$4({ class: "tip", style: "margin-left: 10px;", onclick: () => this._openPrompt("operatorWaveform") }, "Wave:");
                const waveformPulsewidthSlider = new Slider(input$8({ style: "margin-left: 10px; width: 85%;", type: "range", min: "0", max: Config.pwmOperatorWaves.length - 1, value: "0", step: "1", title: "Pulse Width" }), this._doc, (oldValue, newValue) => new ChangeOperatorPulseWidth(this._doc, operatorIndex, oldValue, newValue), true);
                const waveformDropdownRow = div$d({ class: "selectRow" }, waveformDropdownHint, waveformPulsewidthSlider.container, div$d({ class: "selectContainer", style: "width: 6em; margin-left: .3em;" }, waveformSelect));
                const waveformDropdownGroup = div$d({ class: "operatorRow" }, waveformDropdownRow);
                const row = div$d({ class: "selectRow" }, operatorNumber, waveformDropdown, div$d({ class: "selectContainer", style: "width: 3em; margin-right: .3em;" }, frequencySelect), amplitudeSlider.container);
                this._phaseModGroup.appendChild(row);
                this._operatorRows[i] = row;
                this._operatorAmplitudeSliders[i] = amplitudeSlider;
                this._operatorFrequencySelects[i] = frequencySelect;
                this._operatorDropdowns[i] = waveformDropdown;
                this._operatorWaveformHints[i] = waveformDropdownHint;
                this._operatorWaveformSelects[i] = waveformSelect;
                this._operatorWaveformPulsewidthSliders[i] = waveformPulsewidthSlider;
                this._operatorDropdownRows[i] = waveformDropdownRow;
                this._phaseModGroup.appendChild(waveformDropdownGroup);
                this._operatorDropdownGroups[i] = waveformDropdownGroup;
                this._openOperatorDropdowns[i] = false;
                waveformSelect.addEventListener("change", () => {
                    this._doc.record(new ChangeOperatorWaveform(this._doc, operatorIndex, waveformSelect.selectedIndex));
                });
                frequencySelect.addEventListener("change", () => {
                    this._doc.record(new ChangeOperatorFrequency(this._doc, operatorIndex, frequencySelect.selectedIndex));
                });
            }
            this._drumsetGroup.appendChild(div$d({ class: "selectRow" }, span$4({ class: "tip", onclick: () => this._openPrompt("drumsetEnvelope") }, "Envelope:"), span$4({ class: "tip", onclick: () => this._openPrompt("drumsetSpectrum") }, "Spectrum:")));
            for (let i = Config.drumCount - 1; i >= 0; i--) {
                const drumIndex = i;
                const spectrumEditor = new SpectrumEditor(this._doc, drumIndex);
                spectrumEditor.container.addEventListener("mousedown", this.refocusStage);
                this._drumsetSpectrumEditors[i] = spectrumEditor;
                const envelopeSelect = buildOptions(select$6({ style: "width: 100%;", title: "Filter Envelope" }), Config.envelopes.map(envelope => envelope.name));
                this._drumsetEnvelopeSelects[i] = envelopeSelect;
                envelopeSelect.addEventListener("change", () => {
                    this._doc.record(new ChangeDrumsetEnvelope(this._doc, drumIndex, envelopeSelect.selectedIndex));
                });
                const row = div$d({ class: "selectRow" }, div$d({ class: "selectContainer", style: "width: 5em; margin-right: .3em;" }, envelopeSelect), this._drumsetSpectrumEditors[i].container);
                this._drumsetGroup.appendChild(row);
            }
            this._modNameRows = [];
            this._modChannelBoxes = [];
            this._modInstrumentBoxes = [];
            this._modSetRows = [];
            this._modSetBoxes = [];
            this._modFilterRows = [];
            this._modFilterBoxes = [];
            this._modTargetIndicators = [];
            for (let mod = 0; mod < Config.modCount; mod++) {
                let modChannelBox = select$6({ style: "width: 100%; color: currentColor; text-overflow:ellipsis;" });
                let modInstrumentBox = select$6({ style: "width: 100%; color: currentColor;" });
                let modNameRow = div$d({ class: "operatorRow", style: "height: 1em; margin-bottom: 0.65em;" }, div$d({ class: "tip", style: "width: 10%; max-width: 5.4em;", id: "modChannelText" + mod, onclick: () => this._openPrompt("modChannel") }, "Ch:"), div$d({ class: "selectContainer", style: 'width: 35%;' }, modChannelBox), div$d({ class: "tip", style: "width: 1.2em; margin-left: 0.8em;", id: "modInstrumentText" + mod, onclick: () => this._openPrompt("modInstrument") }, "Ins:"), div$d({ class: "selectContainer", style: "width: 10%;" }, modInstrumentBox));
                let modSetBox = select$6();
                let modFilterBox = select$6();
                let modSetRow = div$d({ class: "selectRow", id: "modSettingText" + mod, style: "margin-bottom: 0.9em; color: currentColor;" }, span$4({ class: "tip", onclick: () => this._openPrompt("modSet") }, "Setting: "), div$d({ class: "selectContainer" }, modSetBox));
                let modFilterRow = div$d({ class: "selectRow", id: "modFilterText" + mod, style: "margin-bottom: 0.9em; color: currentColor;" }, span$4({ class: "tip", onclick: () => this._openPrompt("modFilter") }, "Target: "), div$d({ class: "selectContainer" }, modFilterBox));
                let modTarget = SVG.svg({ style: "transform: translate(0px, 1px);", width: "1.5em", height: "1em", viewBox: "0 0 200 200" }, [
                    SVG.path({ d: "M90 155 l0 -45 -45 0 c-25 0 -45 -4 -45 -10 0 -5 20 -10 45 -10 l45 0 0 -45 c0 -25 5 -45 10 -45 6 0 10 20 10 45 l0 45 45 0 c25 0 45 5 45 10 0 6 -20 10 -45 10 l -45 0 0 45 c0 25 -4 45 -10 45 -5 0 -10 -20 -10 -45z" }),
                    SVG.path({ d: "M42 158 c-15 -15 -16 -38 -2 -38 6 0 10 7 10 15 0 8 7 15 15 15 8 0 15 5 15 10 0 14 -23 13 -38 -2z" }),
                    SVG.path({ d: "M120 160 c0 -5 7 -10 15 -10 8 0 15 -7 15 -15 0 -8 5 -15 10 -15 14 0 13 23 -2 38 -15 15 -38 16 -38 2z" }),
                    SVG.path({ d: "M32 58 c3 -23 48 -40 48 -19 0 6 -7 11 -15 11 -8 0 -15 7 -15 15 0 8 -5 15 -11 15 -6 0 -9 -10 -7 -22z" }),
                    SVG.path({ d: "M150 65 c0 -8 -7 -15 -15 -15 -8 0 -15 -4 -15 -10 0 -14 23 -13 38 2 15 15 16 38 2 38 -5 0 -10 -7 -10 -15z" })
                ]);
                this._modNameRows.push(modNameRow);
                this._modChannelBoxes.push(modChannelBox);
                this._modInstrumentBoxes.push(modInstrumentBox);
                this._modSetRows.push(modSetRow);
                this._modSetBoxes.push(modSetBox);
                this._modFilterRows.push(modFilterRow);
                this._modFilterBoxes.push(modFilterBox);
                this._modTargetIndicators.push(modTarget);
                this._modulatorGroup.appendChild(div$d({ style: "margin: 3px 0; font-weight: bold; margin-bottom: 0.7em; text-align: center; color: " + ColorConfig.secondaryText + "; background: " + ColorConfig.uiWidgetBackground + ";" }, ["Modulator " + (mod + 1), modTarget]));
                this._modulatorGroup.appendChild(modNameRow);
                this._modulatorGroup.appendChild(modSetRow);
                this._modulatorGroup.appendChild(modFilterRow);
            }
            this._pitchShiftSlider.container.style.setProperty("transform", "translate(0px, 3px)");
            this._pitchShiftSlider.container.style.setProperty("width", "100%");
            this._fileMenu.addEventListener("change", this._fileMenuHandler);
            this._editMenu.addEventListener("change", this._editMenuHandler);
            this._optionsMenu.addEventListener("change", this._optionsMenuHandler);
            this._customWavePresetDrop.addEventListener("change", this._customWavePresetHandler);
            this._tempoStepper.addEventListener("change", this._whenSetTempo);
            this._scaleSelect.addEventListener("change", this._whenSetScale);
            this._keySelect.addEventListener("change", this._whenSetKey);
            
            this._ringModWaveSelect.addEventListener("change", this._whenSetRingModChipWave);
            
            this._useChipWaveAdvancedLoopControlsBox.addEventListener("input", this._whenSetUseChipWaveAdvancedLoopControls);
this._chipWaveLoopModeSelect.addEventListener("change", this._whenSetChipWaveLoopMode);
this._chipWaveLoopStartStepper.addEventListener("change", this._whenSetChipWaveLoopStart);
this._chipWaveLoopEndStepper.addEventListener("change", this._whenSetChipWaveLoopEnd);
this._setChipWaveLoopEndToEndButton.addEventListener("click", this._whenSetChipWaveLoopEndToEnd);
this._chipWaveStartOffsetStepper.addEventListener("change", this._whenSetChipWaveStartOffset);
this._chipWavePlayBackwardsBox.addEventListener("input", this._whenSetChipWavePlayBackwards);
            
            this._rhythmSelect.addEventListener("change", this._whenSetRhythm);
            this._algorithmSelect.addEventListener("change", this._whenSetAlgorithm);
            this._instrumentsButtonBar.addEventListener("click", this._whenSelectInstrument);
            this._feedbackTypeSelect.addEventListener("change", this._whenSetFeedbackType);
            this._chipWaveSelect.addEventListener("change", this._whenSetChipWave);
            this._chipNoiseSelect.addEventListener("change", this._whenSetNoiseWave);
            this._transitionSelect.addEventListener("change", this._whenSetTransition);
            this._effectsSelect.addEventListener("change", this._whenSetEffects);
            this._unisonSelect.addEventListener("change", this._whenSetUnison);
            this._chordSelect.addEventListener("change", this._whenSetChord);
            this._vibratoSelect.addEventListener("change", this._whenSetVibrato);
            this._vibratoTypeSelect.addEventListener("change", this._whenSetVibratoType);
            this._playButton.addEventListener("click", this._togglePlay);
this._stopButton.addEventListener("click", this._toggleRecord);
this._recordButton.addEventListener("click", this._toggleRecord);
this._stopButton.addEventListener("click", this._toggleRecord);
this._recordButton.addEventListener("contextmenu", (event) => {
	if (event.ctrlKey) {
		event.preventDefault();
		this._toggleRecord();
	}
});
this._stopButton.addEventListener("contextmenu", (event) => {
	if (event.ctrlKey) {
		event.preventDefault();
		this._toggleRecord();
	}
});

       
            this._prevBarButton.addEventListener("click", this._whenPrevBarPressed);
            this._nextBarButton.addEventListener("click", this._whenNextBarPressed);
            this._volumeSlider.input.addEventListener("input", this._setVolumeSlider);
            this._zoomInButton.addEventListener("click", this._zoomIn);
            this._zoomOutButton.addEventListener("click", this._zoomOut);
            this._patternArea.addEventListener("mousedown", this._refocusStageNotEditing);
            this._trackArea.addEventListener("mousedown", this.refocusStage);
            this._volumeSlider.container.style.setProperty("flex-grow", "1");
            this._volumeSlider.container.style.setProperty("display", "flex");
            this._volumeBarContainer.style.setProperty("flex-grow", "1");
            this._volumeBarContainer.style.setProperty("display", "flex");
            this._volumeSlider.container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
            this._volumeSlider.container.style.setProperty("--mod-border-radius", "50%");
            this._instrumentVolumeSlider.container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
            this._instrumentVolumeSlider.container.style.setProperty("--mod-border-radius", "50%");
            this._feedbackAmplitudeSlider.container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
            this._feedbackAmplitudeSlider.container.style.setProperty("--mod-border-radius", "50%");
            for (let i = 0; i < Config.operatorCount; i++) {
                this._operatorAmplitudeSliders[i].container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
                this._operatorAmplitudeSliders[i].container.style.setProperty("--mod-border-radius", "50%");
            }
            let thisRef = this;
            for (let mod = 0; mod < Config.modCount; mod++) {
                this._modChannelBoxes[mod].addEventListener("change", function () { thisRef._whenSetModChannel(mod); });
                this._modInstrumentBoxes[mod].addEventListener("change", function () { thisRef._whenSetModInstrument(mod); });
                this._modSetBoxes[mod].addEventListener("change", function () { thisRef._whenSetModSetting(mod); });
                this._modFilterBoxes[mod].addEventListener("change", function () { thisRef._whenSetModFilter(mod); });
                this._modTargetIndicators[mod].addEventListener("click", function () { thisRef._whenClickModTarget(mod); });
            }
            this._jumpToModIndicator.addEventListener("click", function () { thisRef._whenClickJumpToModTarget(); });
            this._patternArea.addEventListener("mousedown", this.refocusStage);
            this._fadeInOutEditor.container.addEventListener("mousedown", this.refocusStage);
            this._spectrumEditor.container.addEventListener("mousedown", this.refocusStage);
            this._eqFilterEditor.container.addEventListener("mousedown", this.refocusStage);
            this._noteFilterEditor.container.addEventListener("mousedown", this.refocusStage);
            this._harmonicsEditor.container.addEventListener("mousedown", this.refocusStage);
            this._tempoStepper.addEventListener("keydown", this._tempoStepperCaptureNumberKeys, false);
            this._addEnvelopeButton.addEventListener("click", this._addNewEnvelope);
            this._patternArea.addEventListener("contextmenu", this._disableCtrlContextMenu);
            this._trackArea.addEventListener("contextmenu", this._disableCtrlContextMenu);
            this.mainLayer.addEventListener("keydown", this._whenKeyPressed);
            this.mainLayer.addEventListener("keyup", this._whenKeyUp);
            this._instrumentCopyButton.addEventListener("click", this._copyInstrument.bind(this));
            this._instrumentPasteButton.addEventListener("click", this._pasteInstrument.bind(this));
            this._instrumentVolumeSliderInputBox.addEventListener("input", () => { this._doc.record(new ChangeVolume(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].volume, Math.min(25.0, Math.max(-25.0, Math.round(+this._instrumentVolumeSliderInputBox.value))))); });
            this._panSliderInputBox.addEventListener("input", () => { this._doc.record(new ChangePan(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].pan, Math.min(100.0, Math.max(0.0, Math.round(+this._panSliderInputBox.value))))); });
            
this._pitchShiftBox.addEventListener("input", () => {
    const parsed = Number(this._pitchShiftBox.value);
    if (!isNaN(parsed)) {
        const clamped =Math.abs( Math.min(32.0, Math.max(0.0, Math.round(parsed))))
        this._pitchShiftBox.value=clamped
        this._doc.record(new ChangeShift(
            this._doc,
            this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].pitchShift,
            clamped
        ));
    }
});
this._instrumentName .addEventListener("input", () => {
    const parsed = (this._instrumentName.value);
    this._doc.song.channels[this._doc.channel].name=parsed
});
            
            this._detuneSliderInputBox.addEventListener("input", () => { this._doc.record(new ChangeDetune(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].detune, Math.min(Config.detuneMax - Config.detuneCenter, Math.max(Config.detuneMin - Config.detuneCenter, Math.round(+this._detuneSliderInputBox.value))))); });
            
this._unisonVoicesInputBox.addEventListener("input", () => { this._doc.record(new ChangeUnisonVoices(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].unisonVoices, Math.min(Config.unisonVoicesMax, Math.max(Config.unisonVoicesMin, Math.round(+this._unisonVoicesInputBox.value))))); });
this._unisonSpreadInputBox.addEventListener("input", () => { this._doc.record(new ChangeUnisonSpread(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].unisonSpread, Math.min(Config.unisonSpreadMax, Math.max(Config.unisonSpreadMin, +this._unisonSpreadInputBox.value)))); });
this._unisonOffsetInputBox.addEventListener("input", () => { this._doc.record(new ChangeUnisonOffset(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].unisonOffset, Math.min(Config.unisonOffsetMax, Math.max(Config.unisonOffsetMin, +this._unisonOffsetInputBox.value)))); });
this._unisonExpressionInputBox.addEventListener("input", () => { this._doc.record(new ChangeUnisonExpression(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].unisonExpression, Math.min(Config.unisonExpressionMax, Math.max(Config.unisonExpressionMin, +this._unisonExpressionInputBox.value)))); });
this._unisonSignInputBox.addEventListener("input", () => { this._doc.record(new ChangeUnisonSign(this._doc, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].unisonSign, Math.min(Config.unisonSignMax, Math.max(Config.unisonSignMin, +this._unisonSignInputBox.value)))); });
            
            this._customWaveDraw.addEventListener("input", () => { this._doc.record(new ChangeCustomWave(this._doc, this._customWaveDrawCanvas.newArray)); });
            this._twoNoteArpBox.addEventListener("input", () => { this._doc.record(new ChangeFastTwoNoteArp(this._doc, this._twoNoteArpBox.checked)); });
            this._clicklessTransitionBox.addEventListener("input", () => { this._doc.record(new ChangeClicklessTransition(this._doc, this._clicklessTransitionBox.checked)); });
            this._aliasingBox.addEventListener("input", () => { this._doc.record(new ChangeAliasing(this._doc, this._aliasingBox.checked)); });
            this._promptContainer.addEventListener("click", (event) => {
                if (event.target == this._promptContainer) {
                    this._doc.undo();
                }
            });
            if (isMobile) {
                const autoPlayOption = this._optionsMenu.querySelector("[value=autoPlay]");
                autoPlayOption.disabled = true;
                autoPlayOption.setAttribute("hidden", "");
            }
            if (window.screen.availWidth < 0) {
                const layoutOption = this._optionsMenu.querySelector("[value=layout]");
                layoutOption.disabled = true;
                layoutOption.setAttribute("hidden", "");
            }
        }
        _toggleDropdownMenu(dropdown, submenu = 0) {
            let target = this._vibratoDropdown;
            let group = this._vibratoDropdownGroup;
            switch (dropdown) {
                case 0:
                    target = this._vibratoDropdown;
                    this._openVibratoDropdown = this._openVibratoDropdown ? false : true;
                    group = this._vibratoDropdownGroup;
                    break;
                case 1:
                    target = this._panDropdown;
                    this._openPanDropdown = this._openPanDropdown ? false : true;
                    group = this._panDropdownGroup;
                    break;
                case 2:
                    target = this._chordDropdown;
                    this._openChordDropdown = this._openChordDropdown ? false : true;
                    group = this._chordDropdownGroup;
                    break;
                case 3:
                    target = this._transitionDropdown;
                    this._openTransitionDropdown = this._openTransitionDropdown ? false : true;
                    group = this._transitionDropdownGroup;
                    break;
                case 4:
                    target = this._operatorDropdowns[submenu];
                    this._openOperatorDropdowns[submenu] = this._openOperatorDropdowns[submenu] ? false : true;
                    group = this._operatorDropdownGroups[submenu];
                    break;
 case 6: 
	target = this._unisonDropdown;
this._openUnisonDropdown = this._openUnisonDropdown ? false : true;
group = this._unisonDropdownGroup;
break;
case 7:
 target = this._envelopeDropdown;
this._openEnvelopeDropdown = this._openEnvelopeDropdown ? false : true;
group = this._envelopeDropdownGroup;
break;
            }
            if (target.textContent == "▼") {
                let instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                target.textContent = "▲";
                if (group != this._chordDropdownGroup) {
                    group.style.display = "";
                }
                else if (instrument.chord == Config.chords.dictionary["arpeggio"].index) {
                    group.style.display = "";
                }
            }
            else {
                target.textContent = "▼";
                group.style.display = "none";
            }
        }
        _modSliderUpdate() {
            if (!this._doc.synth.playing) {
                this._hasActiveModSliders = false;
                for (let setting = 0; setting < Config.modulators.length; setting++) {
                    if (this._showModSliders[setting] == true) {
                        this._showModSliders[setting] = false;
                        this._newShowModSliders[setting] = false;
                        let slider = this._getSliderForModSetting(setting);
                        if (slider != null) {
                            slider.container.classList.remove("modSlider");
                        }
                    }
                }
            }
            else {
                let instrument = this._doc.getCurrentInstrument();
                const anyModActive = this._doc.synth.isAnyModActive(this._doc.channel, instrument);
                if (anyModActive) {
                    let instrument = this._doc.getCurrentInstrument();
                    function updateModSlider(editor, slider, setting, channel, instrument) {
                        if (editor._doc.synth.isModActive(setting, channel, instrument)) {
                            let currentVal = (editor._doc.synth.getModValue(setting, channel, instrument, false) - Config.modulators[setting].convertRealFactor) / Config.modulators[setting].maxRawVol;
                            if (currentVal != editor._modSliderValues[setting]) {
                                editor._modSliderValues[setting] = currentVal;
                                slider.container.style.setProperty("--mod-position", (currentVal * 96.0 + 2.0) + "%");
                            }
                            return true;
                        }
                        return false;
                    }
                    for (let setting = 0; setting < Config.modulators.length; setting++) {
                        this._newShowModSliders[setting] = this._showModSliders[setting];
                        let slider = this._getSliderForModSetting(setting);
                        if (slider != null) {
                            this._newShowModSliders[setting] = updateModSlider(this, slider, setting, this._doc.channel, instrument);
                        }
                    }
                }
                else if (this._hasActiveModSliders) {
                    for (let setting = 0; setting < Config.modulators.length; setting++) {
                        this._newShowModSliders[setting] = false;
                    }
                }
                if (anyModActive || this._hasActiveModSliders) {
                    let anySliderActive = false;
                    for (let setting = 0; setting < Config.modulators.length; setting++) {
                        if (this._newShowModSliders[setting] != this._showModSliders[setting]) {
                            this._showModSliders[setting] = this._newShowModSliders[setting];
                            let slider = this._getSliderForModSetting(setting);
                            if (slider != null) {
                                if (this._showModSliders[setting] == true) {
                                    slider.container.classList.add("modSlider");
                                }
                                else {
                                    slider.container.classList.remove("modSlider");
                                }
                            }
                        }
                        if (this._newShowModSliders[setting] == true)
                            anySliderActive = true;
                    }
                    this._hasActiveModSliders = anySliderActive;
                }
            }
        }

        _getSliderForModSetting(setting) {
            switch (setting) {
                case Config.modulators.dictionary["pan"].index:
                    return this._panSlider;
                case Config.modulators.dictionary["detune"].index:
                    return this._detuneSlider;
                case Config.modulators.dictionary["fm slider 1"].index:
                    return this._operatorAmplitudeSliders[0];
                case Config.modulators.dictionary["fm slider 2"].index:
                    return this._operatorAmplitudeSliders[1];
                case Config.modulators.dictionary["fm slider 3"].index:
                    return this._operatorAmplitudeSliders[2];
                case Config.modulators.dictionary["fm slider 4"].index:
                    return this._operatorAmplitudeSliders[3];
                case Config.modulators.dictionary["fm feedback"].index:
                    return this._feedbackAmplitudeSlider;
                case Config.modulators.dictionary["pulse width"].index:
                    return this._pulseWidthSlider;
                case Config.modulators.dictionary["reverb"].index:
                    return this._reverbSlider;
               case Config.modulators.dictionary["ring modulation"].index:
	return this._ringModSlider;
case Config.modulators.dictionary["ring mod hertz"].index:
	return this._ringModHzSlider;
case Config.modulators.dictionary["ring pulse mod"].index:
	return this._ringModPulsewidthSlider;
                case Config.modulators.dictionary["distortion"].index:
                    return this._distortionSlider;
                case Config.modulators.dictionary["volume"].index:
                    return this._instrumentVolumeSlider;
                
                case Config.modulators.dictionary["vibrato depth"].index:
                    return this._vibratoDepthSlider;
                case Config.modulators.dictionary["vibrato speed"].index:
                    return this._vibratoSpeedSlider;
                case Config.modulators.dictionary["vibrato delay"].index:
                    return this._vibratoDelaySlider;
                case Config.modulators.dictionary["arp speed"].index:
                    return this._arpeggioSpeedSlider;
                case Config.modulators.dictionary["pan delay"].index:
                    return this._panDelaySlider;
                case Config.modulators.dictionary["tempo"].index:
                    return this._tempoSlider;
                case Config.modulators.dictionary["song volume"].index:
                    return this._volumeSlider;
                 
	                   
                case Config.modulators.dictionary["eq filt cut"].index:
                    return this._eqFilterSimpleCutSlider;
                case Config.modulators.dictionary["eq filt peak"].index:
                    return this._eqFilterSimplePeakSlider;
                case Config.modulators.dictionary["note filt cut"].index:
                    return this._noteFilterSimpleCutSlider;
                case Config.modulators.dictionary["note filt peak"].index:
                    return this._noteFilterSimplePeakSlider;
                case Config.modulators.dictionary["bit crush"].index:
                    return this._bitcrusherQuantizationSlider;
                case Config.modulators.dictionary["freq crush"].index:
                    return this._bitcrusherFreqSlider;
                case Config.modulators.dictionary["pitch shift"].index:
                    return this._pitchShiftSlider;
                case Config.modulators.dictionary["chorus"].index:
                    return this._chorusSlider;
                case Config.modulators.dictionary["echo"].index:
                    return this._echoSustainSlider;
                case Config.modulators.dictionary["echo delay"].index:
                    return this._echoDelaySlider;
                case Config.modulators.dictionary["sustain"].index:
                    return this._stringSustainSlider;
                default:
                    return null;
            }
        }
        changeInstrument(index) {
        }
        _openPrompt(promptName) {
            this._doc.openPrompt(promptName);
            this._setPrompt(promptName);
        }
        _setPrompt(promptName) {
            if (this._currentPromptName == promptName)
                return;
            this._currentPromptName = promptName;
            if (this.prompt) {
                if (this._wasPlaying && !(this.prompt instanceof TipPrompt || this.prompt instanceof LimiterPrompt || this.prompt instanceof CustomChipPrompt || this.prompt instanceof CustomFilterPrompt)) {
                    this._play();
                }
                this._wasPlaying = false;
                this._promptContainer.style.display = "none";
                this._promptContainer.removeChild(this.prompt.container);
                this.prompt.cleanUp();
                this.prompt = null;
                this.refocusStage();
            }
            if (promptName) {
                switch (promptName) {
                    case "export":
                        this.prompt = new ExportPrompt(this._doc);
                        break;
                    case "import":
                        this.prompt = new ImportPrompt(this._doc);
                        break;
                    case "barCount":
                        this.prompt = new SongDurationPrompt(this._doc);
                        break;
					case "songRecovery":
                        this.prompt = new SongRecoveryPrompt(this._doc);
                        break;
                    case "beatsPerBar":
                        this.prompt = new BeatsPerBarPrompt(this._doc);
                        break;
                    case "moveNotesSideways":
                        this.prompt = new MoveNotesSidewaysPrompt(this._doc);
                        break;
                    case "channelSettings":
                        this.prompt = new ChannelSettingsPrompt(this._doc);
                        break;
                    case "limiterSettings":
                        this.prompt = new LimiterPrompt(this._doc, this);
                        break;
                    case "customChipSettings":
                        this.prompt = new CustomChipPrompt(this._doc, this);
                        break;
                    case "customEQFilterSettings":
                        this.prompt = new CustomFilterPrompt(this._doc, this, false);
                        break;
                    case "customNoteFilterSettings":
                        this.prompt = new CustomFilterPrompt(this._doc, this, true);
                        break;
                    case "theme":
                        this.prompt = new ThemePrompt(this._doc);
                        break;
                    case "layout":
                        this.prompt = new LayoutPrompt(this._doc);
                        break;
case "recordingSetup":
this.prompt = new RecordingSetupPrompt(this._doc);
break;

case "visualLoopControls":
this.prompt = new VisualLoopControlsPrompt(this._doc, this);
break;
                    default:
                        this.prompt = new TipPrompt(this._doc, promptName);
                        break;
                }
                if (this.prompt) {
                    if (!(this.prompt instanceof TipPrompt || this.prompt instanceof LimiterPrompt || this.prompt instanceof CustomChipPrompt || this.prompt instanceof CustomFilterPrompt)) {
                        this._wasPlaying = this._doc.synth.playing;
                        this._pause();
                    }
                    this._promptContainer.style.display = "";
                    this._promptContainer.appendChild(this.prompt.container);
                }
            }
        }
        changeBarScrollPos(offset) {
            this._barScrollBar.changePos(offset);
        }
        _renderInstrumentBar(channel, instrumentIndex, colors) {
            if (this._doc.song.layeredInstruments || this._doc.song.patternInstruments) {
                this._instrumentsButtonRow.style.display = "";
                this._instrumentsButtonBar.style.setProperty("--text-color-lit", colors.primaryNote);
                this._instrumentsButtonBar.style.setProperty("--text-color-dim", colors.secondaryNote);
                this._instrumentsButtonBar.style.setProperty("--background-color-lit", colors.primaryChannel);
                this._instrumentsButtonBar.style.setProperty("--background-color-dim", colors.secondaryChannel);
                const maxInstrumentsPerChannel = this._doc.song.getMaxInstrumentsPerChannel();
                while (this._instrumentButtons.length < channel.instruments.length) {
                    const instrumentButton = button$d(String(this._instrumentButtons.length + 1));
                    this._instrumentButtons.push(instrumentButton);
                    this._instrumentsButtonBar.insertBefore(instrumentButton, this._instrumentRemoveButton);
                }
                for (let i = this._renderedInstrumentCount; i < channel.instruments.length; i++) {
                    this._instrumentButtons[i].style.display = "";
                }
                for (let i = channel.instruments.length; i < this._renderedInstrumentCount; i++) {
                    this._instrumentButtons[i].style.display = "none";
                }
                this._renderedInstrumentCount = channel.instruments.length;
                while (this._instrumentButtons.length > maxInstrumentsPerChannel) {
                    this._instrumentsButtonBar.removeChild(this._instrumentButtons.pop());
                }
                this._instrumentRemoveButton.style.display = (channel.instruments.length > Config.instrumentCountMin) ? "" : "none";
                this._instrumentAddButton.style.display = (channel.instruments.length < maxInstrumentsPerChannel) ? "" : "none";
                if (channel.instruments.length < maxInstrumentsPerChannel) {
                    this._instrumentRemoveButton.classList.remove("last-button");
                }
                else {
                    this._instrumentRemoveButton.classList.add("last-button");
                }
                if (channel.instruments.length > 1) {
                    if (this._highlightedInstrumentIndex != instrumentIndex) {
                        const oldButton = this._instrumentButtons[this._highlightedInstrumentIndex];
                        if (oldButton != null)
                            oldButton.classList.remove("selected-instrument");
                        const newButton = this._instrumentButtons[instrumentIndex];
                        newButton.classList.add("selected-instrument");
                        this._highlightedInstrumentIndex = instrumentIndex;
                    }
                }
                else {
                    const oldButton = this._instrumentButtons[this._highlightedInstrumentIndex];
                    if (oldButton != null)
                        oldButton.classList.remove("selected-instrument");
                    this._highlightedInstrumentIndex = -1;
                }
                if (this._doc.song.layeredInstruments && this._doc.song.patternInstruments && (this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)) {
                    for (let i = 0; i < channel.instruments.length; i++) {
                        if (this._doc.recentPatternInstruments[this._doc.channel].indexOf(i) != -1) {
                            this._instrumentButtons[i].classList.remove("deactivated");
                        }
                        else {
                            this._instrumentButtons[i].classList.add("deactivated");
                        }
                    }
                    this._deactivatedInstruments = true;
                }
                else if (this._deactivatedInstruments || (this._doc.channel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)) {
                    for (let i = 0; i < channel.instruments.length; i++) {
                        this._instrumentButtons[i].classList.remove("deactivated");
                    }
                    this._deactivatedInstruments = false;
                }
            }
            else {
                this._instrumentsButtonRow.style.display = "none";
            }
        }
        updatePlayButton() {
        	 
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.textContent = "";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.textContent = "";
            }
 
 
	
	if (this._doc.showRecordButton) {
	this._recordButton.style.display = "";
}
if (this._doc.synth.recording) {
	this._playButton.style.display = "none";
	 this._recordButton.style.display = "none";
	this._stopButton.style.display = "";
	this._prevBarButton.style.display = "none";
	this._nextBarButton.style.display = "none";
	this._patternEditorRow.style.pointerEvents = "none";
	this._octaveScrollBar.container.style.pointerEvents = "none";
	this._octaveScrollBar.container.style.opacity = "0.5";
	this._trackContainer.style.pointerEvents = "none";
	this._loopEditor.container.style.opacity = "0.5";
	this._instrumentSettingsArea.style.pointerEvents = "none";
	this._instrumentSettingsArea.style.opacity = "0.5";
/*	this._menuArea.style.pointerEvents = "none";
	this._menuArea.style.opacity = "0.5";
/*	this._songSettingsArea.style.pointerEvents = "none";
	this._songSettingsArea.style.opacity = "0.5";*/
}else{
	this._playButton.style.display = "";
this._recordButton.style.display = "";
this._stopButton.style.display = "none";
this._prevBarButton.style.display = "";
this._nextBarButton.style.display = "";
this._patternEditorRow.style.pointerEvents = "";
this._octaveScrollBar.container.style.pointerEvents = "";
this._octaveScrollBar.container.style.opacity = "1";
this._trackContainer.style.pointerEvents = "";
this._loopEditor.container.style.opacity = "1";
this._instrumentSettingsArea.style.pointerEvents = "";
this._instrumentSettingsArea.style.opacity = "1";
/*this._menuArea.style.pointerEvents = "";
this._menuArea.style.opacity = "1";
/*this._songSettingsArea.style.pointerEvents = "";
this._songSettingsArea.style.opacity = "1";*/
}


window.requestAnimationFrame(() => this.updatePlayButton());

        }
        _usageCheck(channelIndex, instrumentIndex) {
            var instrumentUsed = false;
            var patternUsed = false;
            var modUsed = false;
            const channel = this._doc.song.channels[channelIndex];
            if (channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                for (let modChannelIdx = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; modChannelIdx < this._doc.song.channels.length; modChannelIdx++) {
                    const modChannel = this._doc.song.channels[modChannelIdx];
                    const patternIdx = modChannel.bars[this._doc.bar];
                    if (patternIdx > 0) {
                        const modInstrumentIdx = modChannel.patterns[patternIdx - 1].instruments[0];
                        const modInstrument = modChannel.instruments[modInstrumentIdx];
                        for (let mod = 0; mod < Config.modCount; mod++) {
                            if (modInstrument.modChannels[mod] == channelIndex && (modInstrument.modInstruments[mod] == instrumentIndex || modInstrument.modInstruments[mod] >= channel.instruments.length)) {
                                modUsed = true;
                            }
                        }
                    }
                }
            }
            if (channel.bars[this._doc.bar] != 0) {
                let lowestSelX = Math.min(this._doc.selection.boxSelectionX0, this._doc.selection.boxSelectionX1);
                let highestSelX = Math.max(this._doc.selection.boxSelectionX0, this._doc.selection.boxSelectionX1);
                let lowestSelY = Math.min(this._doc.selection.boxSelectionY0, this._doc.selection.boxSelectionY1);
                let highestSelY = Math.max(this._doc.selection.boxSelectionY0, this._doc.selection.boxSelectionY1);
                for (let i = 0; i < this._doc.song.barCount; i++) {
                    if (channel.bars[i] == channel.bars[this._doc.bar] && i != this._doc.bar &&
                        (i < lowestSelX || i > highestSelX || this._doc.channel < lowestSelY || this._doc.channel > highestSelY)) {
                        patternUsed = true;
                        i = this._doc.song.barCount;
                    }
                }
                for (let i = 0; i < this._doc.song.barCount; i++) {
                    if (channel.bars[i] != 0 && channel.bars[i] != channel.bars[this._doc.bar] &&
                        channel.patterns[channel.bars[i] - 1].instruments.includes(instrumentIndex) && i != this._doc.bar &&
                        (i < lowestSelX || i > highestSelX || this._doc.channel < lowestSelY || this._doc.channel > highestSelY)) {
                        instrumentUsed = true;
                        i = this._doc.song.barCount;
                    }
                }
            }
            if (patternUsed) {
                this._usedPatternIndicator.style.setProperty("fill", ColorConfig.indicatorPrimary);
            }
            else {
                this._usedPatternIndicator.style.setProperty("fill", ColorConfig.indicatorSecondary);
            }
            if (instrumentUsed) {
                this._usedInstrumentIndicator.style.setProperty("fill", ColorConfig.indicatorPrimary);
            }
            else {
                this._usedInstrumentIndicator.style.setProperty("fill", ColorConfig.indicatorSecondary);
            }
            if (modUsed) {
                this._jumpToModIndicator.style.setProperty("display", "");
                this._jumpToModIndicator.style.setProperty("fill", ColorConfig.indicatorPrimary);
                this._jumpToModIndicator.classList.add("modTarget");
            }
            else if (channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                this._jumpToModIndicator.style.setProperty("display", "");
                this._jumpToModIndicator.style.setProperty("fill", ColorConfig.indicatorSecondary);
                this._jumpToModIndicator.classList.remove("modTarget");
            }
            else {
                this._jumpToModIndicator.style.setProperty("display", "none");
            }
        }
        _copyTextToClipboard(text) {
            let nav;
            nav = navigator;
            if (nav.clipboard && nav.clipboard.writeText) {
                nav.clipboard.writeText(text).catch(() => {
                    window.prompt("Copy to clipboard:", text);
                });
                return;
            }
            const textField = document.createElement("textarea");
            textField.textContent = text;
            document.body.appendChild(textField);
            textField.select();
            const succeeded = document.execCommand("copy");
            textField.remove();
            this.refocusStage();
            if (!succeeded)
                window.prompt("Copy this:", text);
        }
        _play() {
            this._doc.synth.play();
           this.updatePlayButton();
            window.requestAnimationFrame(this._animate);
        }
        _pause() {
            this._doc.synth.pause();
            this._doc.synth.resetEffects();
            if (this._doc.autoFollow) {
                this._doc.synth.goToBar(this._doc.bar);
            }
            this._doc.synth.snapToBar();
            this.updatePlayButton();
            window.clearInterval(this._modSliderHandle);
            window.clearInterval(this._volumeHandle);
            window.clearInterval(this._barScrollbarHandle);
           window.requestAnimationFrame(this._animate);
            this.outVolumeHistoricCap = 0;
        }
        _animateVolume(outVolumeCap, historicOutCap) {
            this._outVolumeBar.setAttribute("width", "" + Math.min(144, outVolumeCap * 144));
            this._outVolumeCap.setAttribute("x", "" + (8 + Math.min(144, historicOutCap * 144)));
        }
        _switchEQFilterType(toSimple) {
            const channel = this._doc.song.channels[this._doc.channel];
            const instrument = channel.instruments[this._doc.getCurrentInstrument()];
            if (instrument.eqFilterType != toSimple) {
                this._doc.record(new ChangeEQFilterType(this._doc, instrument, toSimple));
            }
        }
        _switchNoteFilterType(toSimple) {
            const channel = this._doc.song.channels[this._doc.channel];
            const instrument = channel.instruments[this._doc.getCurrentInstrument()];
            if (instrument.noteFilterType != toSimple) {
                this._doc.record(new ChangeNoteFilterType(this._doc, instrument, toSimple));
            }
        }
        _randomPreset() {
            const isNoise = this._doc.song.getChannelIsNoise(this._doc.channel);
            this._doc.record(new ChangePreset(this._doc, pickRandomPresetValue(isNoise)));
        }
        _randomGenerated() {
            this._doc.record(new ChangeRandomGeneratedInstrument(this._doc));
        }
        _setPreset(preset) {
            if (isNaN(preset)) {
                switch (preset) {
                    case "copyInstrument":
                        this._copyInstrument();
                        break;
                    case "pasteInstrument":
                        this._pasteInstrument();
                        break;
                    case "randomPreset":
                        this._randomPreset();
                        break;
                    case "randomGenerated":
                        this._randomGenerated();
                        break;
                }
                this._doc.notifier.changed();
            }
            else {
                this._doc.record(new ChangePreset(this._doc, parseInt(preset)));
            }
        }
    }

    class Selection {
        constructor(_doc) {
            this._doc = _doc;
            
            this.micStream=null
            this.audioctx24 = new (window.AudioContext || window.webkitAudioContext)()
            this.boxSelectionX0 = 0;
            this.boxSelectionY0 = 0;
            this.boxSelectionX1 = 0;
            this.boxSelectionY1 = 0;
            this.digits = "";
            this.instrumentDigits = "";
            this.patternSelectionStart = 0;
            this.patternSelectionEnd = 0;
            this.patternSelectionActive = false;
            this._changeTranspose = null;
            this._changeTrack = null;
            this._changeInstrument = null;
            this._changeReorder = null;
        }
        toJSON() {
            return {
                "x0": this.boxSelectionX0,
                "x1": this.boxSelectionX1,
                "y0": this.boxSelectionY0,
                "y1": this.boxSelectionY1,
                "start": this.patternSelectionStart,
                "end": this.patternSelectionEnd,
            };
        }
        
closeMic() {
	if (this.micStream) {
		this.micStream.getTracks().forEach(track => track.stop());
		this.micStream = null;
		if (mediaSource) mediaSource.disconnect();
		if (analyser) analyser.disconnect();
	}
}
erasePatternInBar(group, channelIndex, bar) {
	   
	const removedPattern = this._doc.song.channels[channelIndex].bars[bar];
	if (removedPattern != 0) {
		group.append(new ChangePatternNumbers(this._doc, 0, bar, channelIndex, 1, 1));
		if (this._patternIndexIsUnused(channelIndex, removedPattern)) {
			this._doc.song.channels[channelIndex].patterns[removedPattern - 1].notes.length = 0;
		}
	}
}
        fromJSON(json) {
            if (json == null)
                return;
            this.boxSelectionX0 = +json["x0"];
            this.boxSelectionX1 = +json["x1"];
            this.boxSelectionY0 = +json["y0"];
            this.boxSelectionY1 = +json["y1"];
            this.patternSelectionStart = +json["start"];
            this.patternSelectionEnd = +json["end"];
            this.digits = "";
            this.instrumentDigits = "";
            this.patternSelectionActive = this.patternSelectionStart < this.patternSelectionEnd;
        }
        selectionUpdated() {
            this._doc.notifier.changed();
            this.digits = "";
            this.instrumentDigits = "";
        }
        get boxSelectionBar() {
            return Math.min(this.boxSelectionX0, this.boxSelectionX1);
        }
        get boxSelectionChannel() {
            return Math.min(this.boxSelectionY0, this.boxSelectionY1);
        }
        get boxSelectionWidth() {
            return Math.abs(this.boxSelectionX0 - this.boxSelectionX1) + 1;
        }
        get boxSelectionHeight() {
            return Math.abs(this.boxSelectionY0 - this.boxSelectionY1) + 1;
        }
        scrollToSelection() {
            this._doc.barScrollPos = Math.min(this._doc.barScrollPos, this.boxSelectionX1);
            this._doc.barScrollPos = Math.max(this._doc.barScrollPos, this.boxSelectionX1 - (this._doc.trackVisibleBars - 1));
            this._doc.channelScrollPos = Math.min(this._doc.channelScrollPos, this.boxSelectionY1);
            this._doc.channelScrollPos = Math.max(this._doc.channelScrollPos, this.boxSelectionY1 - (this._doc.trackVisibleChannels - 1));
        }
        setChannelBar(channelIndex, bar) {
            if (channelIndex == this._doc.channel && bar == this._doc.bar)
                return;
            const canReplaceLastChange = this._doc.lastChangeWas(this._changeTrack);
            this._changeTrack = new ChangeGroup();
            this._changeTrack.append(new ChangeChannelBar(this._doc, channelIndex, bar));
            if (!this._doc.hasRedoHistory()) {
                this._doc.record(this._changeTrack, canReplaceLastChange);
            }
            this.selectionUpdated();
        }
        setPattern(pattern) {
            this._doc.record(new ChangePatternNumbers(this._doc, pattern, this.boxSelectionBar, this.boxSelectionChannel, this.boxSelectionWidth, this.boxSelectionHeight));
        }
        nextDigit(digit, forInstrument, forRhythms) {
            if (forRhythms) {
                if (digit == "3") {
                    this._doc.record(new ChangeRhythm(this._doc, 0));
                }
                else if (digit == "4") {
                    this._doc.record(new ChangeRhythm(this._doc, 1));
                }
                else if (digit == "6") {
                    this._doc.record(new ChangeRhythm(this._doc, 2));
                }
                else if (digit == "8") {
                    this._doc.record(new ChangeRhythm(this._doc, 3));
                }
                else if (digit == "0" || digit == "1") {
                    this._doc.record(new ChangeRhythm(this._doc, 4));
                }
            }
            else if (forInstrument) {
                this.instrumentDigits += digit;
                var parsed = parseInt(this.instrumentDigits);
                var pattern = this._doc.getCurrentPattern();
                if (pattern != null && parsed != 0 && parsed <= this._doc.song.channels[this._doc.channel].instruments.length) {
                    this.selectInstrument(parsed - 1);
                    return;
                }
                this.instrumentDigits = digit;
                parsed = parseInt(this.instrumentDigits);
                if (pattern != null && parsed != 0 && parsed <= this._doc.song.channels[this._doc.channel].instruments.length) {
                    this.selectInstrument(parsed - 1);
                    return;
                }
                this.instrumentDigits = "";
            }
            else {
                this.digits += digit;
                let parsed = parseInt(this.digits);
                if (parsed <= this._doc.song.patternsPerChannel) {
                    this.setPattern(parsed);
                    return;
                }
                this.digits = digit;
                parsed = parseInt(this.digits);
                if (parsed <= this._doc.song.patternsPerChannel) {
                    this.setPattern(parsed);
                    return;
                }
                this.digits = "";
            }
        }
        setModChannel(mod, index) {
            this._doc.record(new ChangeModChannel(this._doc, mod, index));
        }
        setModInstrument(mod, instrument) {
            this._doc.record(new ChangeModInstrument(this._doc, mod, instrument));
        }
        setModSetting(mod, text) {
            this._doc.record(new ChangeModSetting(this._doc, mod, text));
        }
        setModFilter(mod, type) {
            this._doc.record(new ChangeModFilter(this._doc, mod, type));
        }
        insertBars() {
            this._doc.record(new ChangeInsertBars(this._doc, this.boxSelectionBar + this.boxSelectionWidth, this.boxSelectionWidth));
            const width = this.boxSelectionWidth;
            this.boxSelectionX0 += width;
            this.boxSelectionX1 += width;
        }
        insertChannel() {
            const group = new ChangeGroup();
            const insertIndex = this.boxSelectionChannel + this.boxSelectionHeight;
            const isNoise = this._doc.song.getChannelIsNoise(insertIndex - 1);
            const isMod = this._doc.song.getChannelIsMod(insertIndex - 1);
            group.append(new ChangeAddChannel(this._doc, insertIndex, isNoise, isMod));
            if (!group.isNoop()) {
                this.boxSelectionY0 = this.boxSelectionY1 = insertIndex;
                group.append(new ChangeChannelBar(this._doc, insertIndex, this._doc.bar));
                this._doc.record(group);
            }
        }
        deleteBars() {
            const group = new ChangeGroup();
            if (this._doc.selection.patternSelectionActive) {
                if (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1) {
                    group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
                }
                for (const channelIndex of this._eachSelectedChannel()) {
                    for (const pattern of this._eachSelectedPattern(channelIndex)) {
                        group.append(new ChangeNoteTruncate(this._doc, pattern, this._doc.selection.patternSelectionStart, this._doc.selection.patternSelectionEnd));
                    }
                }
                group.append(new ChangePatternSelection(this._doc, 0, 0));
            }
            else {
                group.append(new ChangeDeleteBars(this._doc, this.boxSelectionBar, this.boxSelectionWidth));
                const width = this.boxSelectionWidth;
                this.boxSelectionX0 = Math.max(0, this.boxSelectionX0 - width);
                this.boxSelectionX1 = Math.max(0, this.boxSelectionX1 - width);
            }
            this._doc.record(group);
        }
        deleteChannel() {
            this._doc.record(new ChangeRemoveChannel(this._doc, this.boxSelectionChannel, this.boxSelectionChannel + this.boxSelectionHeight - 1));
            this.boxSelectionY0 = this.boxSelectionY1 = this._doc.channel;
            ColorConfig.resetColors();
        }
        *_eachSelectedChannel() {
            for (let channelIndex = this.boxSelectionChannel; channelIndex < this.boxSelectionChannel + this.boxSelectionHeight; channelIndex++) {
                yield channelIndex;
            }
        }
        *_eachSelectedBar() {
            for (let bar = this.boxSelectionBar; bar < this.boxSelectionBar + this.boxSelectionWidth; bar++) {
                yield bar;
            }
        }
        *_eachSelectedPattern(channelIndex) {
            const handledPatterns = {};
            for (const bar of this._eachSelectedBar()) {
                const currentPatternIndex = this._doc.song.channels[channelIndex].bars[bar];
                if (currentPatternIndex == 0)
                    continue;
                if (handledPatterns[String(currentPatternIndex)])
                    continue;
                handledPatterns[String(currentPatternIndex)] = true;
                const pattern = this._doc.song.getPattern(channelIndex, bar);
                if (pattern == null)
                    throw new Error();
                yield pattern;
            }
        }
        _parseCopiedInstrumentArray(patternCopy, channelIndex) {
            const instruments = Array.from(patternCopy["instruments"]).map(i => i >>> 0);
            discardInvalidPatternInstruments(instruments, this._doc.song, channelIndex);
            return instruments;
        }
        _patternIndexIsUnused(channelIndex, patternIndex) {
            for (let i = 0; i < this._doc.song.barCount; i++) {
                if (this._doc.song.channels[channelIndex].bars[i] == patternIndex) {
                    return false;
                }
            }
            return true;
        }
        copy() {
            const channels = [];
            for (const channelIndex of this._eachSelectedChannel()) {
                const patterns = {};
                const bars = [];
                for (const bar of this._eachSelectedBar()) {
                    const patternNumber = this._doc.song.channels[channelIndex].bars[bar];
                    bars.push(patternNumber);
                    if (patterns[String(patternNumber)] == undefined) {
                        const pattern = this._doc.song.getPattern(channelIndex, bar);
                        let instruments = this._doc.recentPatternInstruments[channelIndex];
                        let notes = [];
                        if (pattern != null) {
                            instruments = pattern.instruments.concat();
                            if (this.patternSelectionActive) {
                                for (const note of pattern.cloneNotes()) {
                                    if (note.end <= this.patternSelectionStart)
                                        continue;
                                    if (note.start >= this.patternSelectionEnd)
                                        continue;
                                    note.start -= this.patternSelectionStart;
                                    note.end -= this.patternSelectionStart;
                                    if (note.start < 0 || note.end > this.patternSelectionEnd - this.patternSelectionStart) {
                                        new ChangeNoteLength(null, note, Math.max(note.start, 0), Math.min(this.patternSelectionEnd - this.patternSelectionStart, note.end));
                                    }
                                    notes.push(note);
                                }
                            }
                            else {
                                notes = pattern.notes;
                            }
                        }
                        patterns[String(patternNumber)] = { "instruments": instruments, "notes": notes };
                    }
                }
                const channelCopy = {
                    "isNoise": this._doc.song.getChannelIsNoise(channelIndex),
                    "isMod": this._doc.song.getChannelIsMod(channelIndex),
                    "patterns": patterns,
                    "bars": bars,
                };
                channels.push(channelCopy);
            }
            const selectionCopy = {
                "partDuration": this.patternSelectionActive ? this.patternSelectionEnd - this.patternSelectionStart : this._doc.song.beatsPerBar * Config.partsPerBeat,
                "channels": channels,
            };
            window.localStorage.setItem("selectionCopy", JSON.stringify(selectionCopy));
            new ChangePatternSelection(this._doc, 0, 0);
        }
        pasteNotes() {
            const selectionCopy = JSON.parse(String(window.localStorage.getItem("selectionCopy")));
            if (selectionCopy == null)
                return;
            const channelCopies = selectionCopy["channels"] || [];
            const copiedPartDuration = selectionCopy["partDuration"] >>> 0;
            const group = new ChangeGroup();
            const fillSelection = (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1);
            const pasteHeight = fillSelection ? this.boxSelectionHeight : Math.min(channelCopies.length, this._doc.song.getChannelCount() - this.boxSelectionChannel);
            for (let pasteChannel = 0; pasteChannel < pasteHeight; pasteChannel++) {
                const channelCopy = channelCopies[pasteChannel % channelCopies.length];
                const channelIndex = this.boxSelectionChannel + pasteChannel;
                const isNoise = !!channelCopy["isNoise"];
                const isMod = !!channelCopy["isMod"];
                const patternCopies = channelCopy["patterns"] || {};
                const copiedBars = channelCopy["bars"] || [];
                if (copiedBars.length == 0)
                    continue;
                if (isNoise != this._doc.song.getChannelIsNoise(channelIndex))
                    continue;
                if (isMod != this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                const pasteWidth = fillSelection ? this.boxSelectionWidth : Math.min(copiedBars.length, this._doc.song.barCount - this.boxSelectionBar);
                if (!fillSelection && copiedBars.length == 1 && channelCopies.length == 1) {
                    const copiedPatternIndex = copiedBars[0] >>> 0;
                    const bar = this.boxSelectionBar;
                    const currentPatternIndex = this._doc.song.channels[channelIndex].bars[bar];
                    if (copiedPatternIndex == 0 && currentPatternIndex == 0)
                        continue;
                    const patternCopy = patternCopies[String(copiedPatternIndex)];
                    const instrumentsCopy = this._parseCopiedInstrumentArray(patternCopy, channelIndex);
                    if (currentPatternIndex == 0) {
                        const existingPattern = this._doc.song.channels[channelIndex].patterns[copiedPatternIndex - 1];
                        if (existingPattern != undefined &&
                            !this.patternSelectionActive &&
                            ((comparePatternNotes(patternCopy["notes"], existingPattern.notes) && patternsContainSameInstruments(instrumentsCopy, existingPattern.instruments)) ||
                                this._patternIndexIsUnused(channelIndex, copiedPatternIndex))) {
                            group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                        }
                        else {
                            group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                        }
                    }
                    const pattern = this._doc.song.getPattern(channelIndex, bar);
                    if (pattern == null)
                        throw new Error();
                    group.append(new ChangePaste(this._doc, pattern, patternCopy["notes"], this.patternSelectionActive ? this.patternSelectionStart : 0, this.patternSelectionActive ? this.patternSelectionEnd : Config.partsPerBeat * this._doc.song.beatsPerBar, copiedPartDuration));
                    if (currentPatternIndex == 0)
                        group.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instrumentsCopy, pattern));
                }
                else if (this.patternSelectionActive) {
                    const reusablePatterns = {};
                    const usedPatterns = {};
                    group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, pasteWidth, this.boxSelectionChannel, pasteHeight));
                    for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                        const bar = this.boxSelectionBar + pasteBar;
                        const copiedPatternIndex = copiedBars[pasteBar % copiedBars.length] >>> 0;
                        const currentPatternIndex = this._doc.song.channels[channelIndex].bars[bar];
                        const reusedIndex = [copiedPatternIndex, currentPatternIndex].join(",");
                        if (copiedPatternIndex == 0 && currentPatternIndex == 0)
                            continue;
                        if (reusablePatterns[reusedIndex] != undefined) {
                            group.append(new ChangePatternNumbers(this._doc, reusablePatterns[reusedIndex], bar, channelIndex, 1, 1));
                            continue;
                        }
                        if (currentPatternIndex == 0) {
                            group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                            const patternCopy = patternCopies[String(copiedPatternIndex)];
                            const instrumentsCopy = this._parseCopiedInstrumentArray(patternCopy, channelIndex);
                            const pattern = this._doc.song.getPattern(channelIndex, bar);
                            group.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instrumentsCopy, pattern));
                        }
                        else {
                            const pattern = this._doc.song.getPattern(channelIndex, bar);
                            if (pattern == null)
                                throw new Error();
                            if (!usedPatterns[String(currentPatternIndex)]) {
                                usedPatterns[String(currentPatternIndex)] = true;
                            }
                            else {
                                group.append(new ChangePatternNumbers(this._doc, 0, bar, channelIndex, 1, 1));
                                group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                                const newPattern = this._doc.song.getPattern(channelIndex, bar);
                                if (newPattern == null)
                                    throw new Error();
                                for (const note of pattern.cloneNotes()) {
                                    group.append(new ChangeNoteAdded(this._doc, newPattern, note, newPattern.notes.length, false));
                                }
                            }
                        }
                        const pattern = this._doc.song.getPattern(channelIndex, bar);
                        if (pattern == null)
                            throw new Error();
                        if (copiedPatternIndex == 0) {
                            group.append(new ChangeNoteTruncate(this._doc, pattern, this.patternSelectionStart, this.patternSelectionEnd));
                        }
                        else {
                            const patternCopy = patternCopies[String(copiedPatternIndex)];
                            group.append(new ChangePaste(this._doc, pattern, patternCopy["notes"], this.patternSelectionStart, this.patternSelectionEnd, copiedPartDuration));
                        }
                        reusablePatterns[reusedIndex] = this._doc.song.channels[channelIndex].bars[bar];
                    }
                }
                else {
                    for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                        const bar = this.boxSelectionBar + pasteBar;
                        const removedPattern = this._doc.song.channels[channelIndex].bars[bar];
                        if (removedPattern != 0) {
                            group.append(new ChangePatternNumbers(this._doc, 0, bar, channelIndex, 1, 1));
                            if (this._patternIndexIsUnused(channelIndex, removedPattern)) {
                                this._doc.song.channels[channelIndex].patterns[removedPattern - 1].notes.length = 0;
                            }
                        }
                    }
                    const reusablePatterns = {};
                    for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                        const bar = this.boxSelectionBar + pasteBar;
                        const copiedPatternIndex = copiedBars[pasteBar % copiedBars.length] >>> 0;
                        const reusedIndex = String(copiedPatternIndex);
                        if (copiedPatternIndex == 0)
                            continue;
                        if (reusablePatterns[reusedIndex] != undefined) {
                            group.append(new ChangePatternNumbers(this._doc, reusablePatterns[reusedIndex], bar, channelIndex, 1, 1));
                            continue;
                        }
                        const patternCopy = patternCopies[String(copiedPatternIndex)];
                        const instrumentsCopy = this._parseCopiedInstrumentArray(patternCopy, channelIndex);
                        const existingPattern = this._doc.song.channels[channelIndex].patterns[copiedPatternIndex - 1];
                        if (existingPattern != undefined &&
                            copiedPartDuration == Config.partsPerBeat * this._doc.song.beatsPerBar &&
                            comparePatternNotes(patternCopy["notes"], existingPattern.notes) &&
                            patternsContainSameInstruments(instrumentsCopy, existingPattern.instruments)) {
                            group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                        }
                        else {
                            if (existingPattern != undefined && this._patternIndexIsUnused(channelIndex, copiedPatternIndex)) {
                                group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                            }
                            else {
                                group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                            }
                            const pattern = this._doc.song.getPattern(channelIndex, bar);
                            if (pattern == null)
                                throw new Error();
                            group.append(new ChangePaste(this._doc, pattern, patternCopy["notes"], this.patternSelectionActive ? this.patternSelectionStart : 0, this.patternSelectionActive ? this.patternSelectionEnd : Config.partsPerBeat * this._doc.song.beatsPerBar, copiedPartDuration));
                            group.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instrumentsCopy, pattern));
                        }
                        reusablePatterns[reusedIndex] = this._doc.song.channels[channelIndex].bars[bar];
                    }
                }
            }
            this._doc.record(group);
        }
        pasteNumbers() {
            const selectionCopy = JSON.parse(String(window.localStorage.getItem("selectionCopy")));
            if (selectionCopy == null)
                return;
            const channelCopies = selectionCopy["channels"] || [];
            const group = new ChangeGroup();
            const fillSelection = (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1);
            const pasteHeight = fillSelection ? this.boxSelectionHeight : Math.min(channelCopies.length, this._doc.song.getChannelCount() - this.boxSelectionChannel);
            for (let pasteChannel = 0; pasteChannel < pasteHeight; pasteChannel++) {
                const channelCopy = channelCopies[pasteChannel % channelCopies.length];
                const channelIndex = this.boxSelectionChannel + pasteChannel;
                const copiedBars = channelCopy["bars"] || [];
                if (copiedBars.length == 0)
                    continue;
                const pasteWidth = fillSelection ? this.boxSelectionWidth : Math.min(copiedBars.length, this._doc.song.barCount - this.boxSelectionBar);
                for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                    const copiedPatternIndex = copiedBars[pasteBar % copiedBars.length] >>> 0;
                    const bar = this.boxSelectionBar + pasteBar;
                    if (copiedPatternIndex > this._doc.song.patternsPerChannel) {
                        group.append(new ChangePatternsPerChannel(this._doc, copiedPatternIndex));
                    }
                    group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                }
            }
            this._doc.record(group);
        }
        selectAll() {
            new ChangePatternSelection(this._doc, 0, 0);
            if (this.boxSelectionBar == 0 &&
                this.boxSelectionChannel == 0 &&
                this.boxSelectionWidth == this._doc.song.barCount &&
                this.boxSelectionHeight == this._doc.song.getChannelCount()) {
                this.setTrackSelection(this._doc.bar, this._doc.bar, this._doc.channel, this._doc.channel);
            }
            else {
                this.setTrackSelection(0, this._doc.song.barCount - 1, 0, this._doc.song.getChannelCount() - 1);
            }
            this.selectionUpdated();
        }
selectMore() {
let oo = new SelectMoreContainer();
oo.ondone = ( x2, y2) => {
	new ChangePatternSelection(this._doc, 0, 0);
	 this._doc.selection.setTrackSelection(this._doc.selection.boxSelectionX0, x2-1, this._doc.selection.boxSelectionY0, y2-1);
  this._doc.selection.selectionUpdated();
	this.selectionUpdated();
}
 oo.show();
}
whistleRecord() {
 let oo = new WhistleRecordContainer(document.body, this._doc);

  
 oo.show();
 oo.ondone = (params) => {
this._doc.synth.STABLE_N      = params.STABLE_N;
this._doc.synth.SILENCE_N     = params.SILENCE_N;
this._doc.synth.MIN_NOTE_MS   = params.MIN_NOTE_MS;
this._doc.synth.CHANGE_HOLD_MS= params.CHANGE_HOLD_MS;
this._doc.synth.SHIFT= params.Shift;
this._doc.synth.TOLERANCE= params.TOLERANCE;
this._doc.synth.NOTE_HOLD_EXTRA= params.NOTE_HOLD_EXTRA;
this._doc.synth.Db   = params.DB;
if (this._doc.synth.playing) {
 this._doc.performance.pause();
 this._doc.synth.isRecordingWhistle = false
 this._doc.performance.record();
this._doc.synth.isRecordingWhistle = true
}
else {
 this._doc.performance.record();
 this._doc.synth.isRecordingWhistle = true
}

 
let analyser, mediaSource, isRecording3 = false, startTs = 0
let playing = false, playingSources2 = [], timeouts = []
let currentNote = null, currentStart = 0
let stableBuf = [], silenceStreak = 0
let pendingNote = null, pendingSince = 0
var STABLE_N = this._doc.synth.STABLE_N, SILENCE_N = this._doc.synth.SILENCE_N  , MIN_NOTE_MS = this._doc.synth.MIN_NOTE_MS , CHANGE_HOLD_MS = this._doc.synth.CHANGE_HOLD_MS, DB = this._doc.synth.Db, Shift = this._doc.synth.SHIFT, TOLERANCE= this._doc.synth.TOLERANCE, NOTE_HOLD_EXTRA= this._doc.synth.NOTE_HOLD_EXTRA;
let frameDuration = 1000 / 60;
let currNote={text:""}
let semitoneShift = params.Shift || -12
const baseFrequencies2 = {
  'c': 261.63, 'c#': 277.18, 'd': 293.66, 'd#': 311.13, 'e': 329.63,
  'f': 349.23, 'f#': 369.99, 'g': 392, 'g#': 415.3, 'a': 440,
  'a#': 466.16, 'h': 493.88
}
const order = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','h']
const octaves = [1,2,3,4,5,6,7]
const bank = buildNoteBank()
let sensitivityDb = DB||70;
function steps(value, step) {
  return ((value % step) + step) % step
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max)
}
function buildNoteBank() {
  const rows = []
  for (const o of octaves) {
    for (const n of order) {
      const f = baseFrequencies2[n] * Math.pow(2, o - 4)
      rows.push({ name: n, oct: o, f })
    }
  }
  rows.sort((a, b) => a.f - b.f)
  for (let i = 0; i < rows.length; i++) {
    const prev = rows[i - 1]?.f || rows[i].f / Math.pow(2, 1 / 12)
    const next = rows[i + 1]?.f || rows[i].f * Math.pow(2, 1 / 12)
    rows[i].lo = (prev + rows[i].f) / 2
    rows[i].hi = (rows[i].f + next) / 2
  }
  return rows
}
function quantize(freq) {
  for (const r of bank) {
    const tolerance = r.f * TOLERANCE|| 0.008; 
    if (freq >= r.lo + tolerance && freq < r.hi - tolerance) return r
  }
  return null
}
  

const self = this; 
async function initMic() {
    try {
        self.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        self.mediaSource = self.audioctx24.createMediaStreamSource(self.micStream);
        self.analyser = self.audioctx24.createAnalyser();
        self.analyser.fftSize = 1024;
        self.mediaSource.connect(self.analyser);
        console.log("Mikrofon podłączony");
    } catch (e) {
        console.error(e);
        POPUP(
            innerWidth / 2 - 150,
            innerHeight / 2 - 100 + window.scrollY,
            "Microphone Access Error",
            "<text style='color:black'>You must open FruityBox App and allow microphone access.</text>",
            "#00afdf"
        );
    }
}



function detectPitch() {
  const N = self.analyser.fftSize
  const buf = new Float32Array(N)
  self.analyser.getFloatTimeDomainData(buf)
  let rms = 0
  for (let i = 0; i < N; i++) rms += buf[i] * buf[i]
  rms = Math.sqrt(rms / N)
  let db = 20 * Math.log10(rms + 1e-12)
  db = Math.max(0, Math.min(100, db + 100))
  if (db < sensitivityDb) return { freq: null, clarity: 0, db }

  let minLag = Math.floor(self.audioctx24.sampleRate / 2000)
  let maxLag = Math.floor(self.audioctx24.sampleRate / 150)
  let bestLag = -1, bestCorr = 0
  let sumSq = 0
  for (let i = 0; i < N; i++) sumSq += buf[i] * buf[i]
  for (let lag = minLag; lag <= maxLag; lag++) {
    let corr = 0, energy = 0
    for (let i = 0; i < N - lag; i++) {
      corr += buf[i] * buf[i + lag]
      energy += buf[i + lag] * buf[i + lag]
    }
    const norm = corr / Math.sqrt(sumSq * energy || 1)
    if (norm > bestCorr) { bestCorr = norm; bestLag = lag }
  }
  if (bestLag < 0 || bestCorr < 0.6) return { freq: null, clarity: bestCorr, db }

  const c1 = xcorrAt(buf, bestLag - 1), c2 = xcorrAt(buf, bestLag), c3 = xcorrAt(buf, bestLag + 1)
  const shift = (c3 - c1) / (2 * (2 * c2 - c1 - c3) || 1)
  const refinedLag = bestLag + shift
  const freq = self.audioctx24.sampleRate / refinedLag
  return { freq, clarity: bestCorr, db }
}

function xcorrAt(buf, lag) {
  let N = buf.length, c = 0, ss1 = 0, ss2 = 0
  for (let i = 0; i < N - lag; i++) {
    c += buf[i] * buf[i + lag]
    ss1 += buf[i] * buf[i]
    ss2 += buf[i + lag] * buf[i + lag]
  }
  return c / Math.sqrt(ss1 * ss2 || 1)
}
function getNote(noteObj) {
  if (!noteObj) return;
  if (noteObj.dur < MIN_NOTE_MS) return;

  const shiftedF = noteObj.f * Math.pow(2, semitoneShift / 12);
  const label = quantize(shiftedF);

  if (label) {
    return {
      text: label.name + label.oct,
      freq: noteObj.f / Math.pow(2, semitoneShift / 12),
      dur: noteObj.dur  
    };
  }
}
const _doc = this._doc;

let lastDrawnNote = null
let repeatCount = 0;
let heldNote = null;

function loop() {
    if (!isRecording3) return;

    let currnote2 = currNote ? currNote.text : "";
    _doc.performance.currNote = currnote2.charAt(0).toUpperCase() + currnote2.slice(1).toLowerCase();
if (_doc.performance.isRecordingWhistle) {
	let dirty = _doc.performance._updateRecordedNotes();
	_doc.performance.updatePerformedNote(_doc.performance.currNote);
	dirty = true;
	if (dirty) _doc.performance._doc.notifier.notifyWatchers();
}
		 
		
    const { freq, db } = detectPitch();
    let q = null;
    if (freq && db >= sensitivityDb) {
        const shiftedFreq = freq * Math.pow(2, semitoneShift / 12);
        q = quantize(shiftedFreq);
    }

    if (q) {
        stableBuf.push(q);
        if (stableBuf.length > STABLE_N) stableBuf.shift();
        const same = stableBuf.every(x => x && x.name === stableBuf[0].name && x.oct === stableBuf[0].oct);

        if (!currentNote && same) {
            currentNote = { name: q.name, oct: q.oct, f: q.f, start: performance.now() };
            silenceStreak = 0;
            pendingNote = null;
        } else if (currentNote && (currentNote.name !== q.name || currentNote.oct !== q.oct) && same) {
            if (!pendingNote) {
                pendingNote = { name: q.name, oct: q.oct, f: q.f, start: performance.now() };
                pendingSince = performance.now();
            } else if (performance.now() - pendingSince > CHANGE_HOLD_MS) {
                currNote = { ...getNote(currentNote) };
                heldNote = { ...currNote, holdUntil: performance.now() + NOTE_HOLD_EXTRA };
                currentNote = pendingNote;
                pendingNote = null;
            }
        } else {
            pendingNote = null;
            silenceStreak = 0;
        }
    } else {
        stableBuf = [];
        pendingNote = null;
        silenceStreak++;
        if (currentNote && silenceStreak >= SILENCE_N) {
    const now = performance.now();
    const duration = now - currentNote.start;
    const noteObj = getNote({ ...currentNote, dur: duration });
    if (noteObj) {
        noteObj.dur = Math.max(duration, NOTE_HOLD_EXTRA);
        currNote = noteObj;
        heldNote = { ...noteObj, holdUntil: now + NOTE_HOLD_EXTRA };
    }
    currentNote = null;
}
}

    if (heldNote && performance.now() < heldNote.holdUntil) {
        currNote = heldNote;
    } else if (heldNote && performance.now() >= heldNote.holdUntil) {
        heldNote = null;
        currNote = { text: "" };
    }

    lastDrawnNote = currNote ? currNote.text : "";

    if (_doc.synth.isRecordingWhistle) setTimeout(loop, frameDuration);
}


let loopRunning = false;
(async () => {
  await self.audioctx24.resume()
  await initMic()
  isRecording3 = true
  currentNote = null
  startTs = performance.now()
  stableBuf = []
  silenceStreak = 0
  pendingNote = null
  if (!loopRunning) {
 	loopRunning = true
 	loop()
}
})();
function hasOverlap(existingNotes, startTick, endTick) {
  			return existingNotes.some(note => {
  				const nStart = note.points[0].tick;
  				const nEnd = note.points[1].tick;
  				return (startTick < nEnd && endTick > nStart);
});
}
let maxEndTick = 0;
  	function freqToPitchIndex(freq) {
  		const midi = 69 + 12 * Math.log2(freq / 440);
  		const pitch = Math.round(midi - 12);
  		if (pitch < 0 || pitch > 95*2) return null;
  		return pitch;
}

}
}
        selectChannel() {
            new ChangePatternSelection(this._doc, 0, 0);
            if (this.boxSelectionBar == 0 && this.boxSelectionWidth == this._doc.song.barCount) {
                this.setTrackSelection(this._doc.bar, this._doc.bar, this.boxSelectionY0, this.boxSelectionY1);
            }
            else {
                this.setTrackSelection(0, this._doc.song.barCount - 1, this.boxSelectionY0, this.boxSelectionY1);
            }
            this.selectionUpdated();
        }
        duplicatePatterns() {
            this._doc.record(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
        }
        muteChannels(allChannels) {
            if (allChannels) {
                let anyMuted = false;
                for (let channelIndex = 0; channelIndex < this._doc.song.channels.length; channelIndex++) {
                    if (this._doc.song.channels[channelIndex].muted) {
                        anyMuted = true;
                        break;
                    }
                }
                for (let channelIndex = 0; channelIndex < this._doc.song.channels.length; channelIndex++) {
                    this._doc.song.channels[channelIndex].muted = !anyMuted;
                }
            }
            else {
                let anyUnmuted = false;
                for (const channelIndex of this._eachSelectedChannel()) {
                    if (!this._doc.song.channels[channelIndex].muted) {
                        anyUnmuted = true;
                        break;
                    }
                }
                for (const channelIndex of this._eachSelectedChannel()) {
                    this._doc.song.channels[channelIndex].muted = anyUnmuted;
                }
            }
            this._doc.notifier.changed();
        }
        soloChannels(invert) {
            let alreadySoloed = true;
            for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                const shouldBeMuted = (channelIndex < this.boxSelectionChannel || channelIndex >= this.boxSelectionChannel + this.boxSelectionHeight) ? !invert : invert;
                if (this._doc.song.channels[channelIndex].muted != shouldBeMuted) {
                    alreadySoloed = false;
                    break;
                }
            }
            if (alreadySoloed) {
                for (let channelIndex = 0; channelIndex < this._doc.song.channels.length; channelIndex++) {
                    this._doc.song.channels[channelIndex].muted = false;
                }
            }
            else {
                for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                    this._doc.song.channels[channelIndex].muted = (channelIndex < this.boxSelectionChannel || channelIndex >= this.boxSelectionChannel + this.boxSelectionHeight) ? !invert : invert;
                }
            }
            this._doc.notifier.changed();
        }
        forceRhythm() {
            const group = new ChangeGroup();
            if (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1) {
                group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
            }
            for (const channelIndex of this._eachSelectedChannel()) {
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    group.append(new ChangePatternRhythm(this._doc, pattern));
                }
            }
            this._doc.record(group);
        }
        forceScale() {
            const group = new ChangeGroup();
            if (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1) {
                group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
            }
            const scaleFlags = [true, false, false, false, false, false, false, false, false, false, false, false];
            for (const channelIndex of this._eachSelectedChannel()) {
                if (this._doc.song.getChannelIsNoise(channelIndex) || this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    unionOfUsedNotes(pattern, scaleFlags);
                }
            }
            const scaleMap = generateScaleMap(scaleFlags, this._doc.song.scale);
            for (const channelIndex of this._eachSelectedChannel()) {
                if (this._doc.song.getChannelIsNoise(channelIndex) || this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    group.append(new ChangePatternScale(this._doc, pattern, scaleMap));
                }
            }
            this._doc.record(group);
        }
        setTrackSelection(newX0, newX1, newY0, newY1) {
            const canReplaceLastChange = true;
            this._changeTrack = new ChangeGroup();
            this._changeTrack.append(new ChangeTrackSelection(this._doc, newX0, newX1, newY0, newY1));
            this._doc.record(this._changeTrack, canReplaceLastChange);
        }
        transpose(upward, octave) {
            const canReplaceLastChange = this._doc.lastChangeWas(this._changeTranspose);
            this._changeTranspose = new ChangeGroup();
            if (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1) {
                this._changeTranspose.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
            }
            for (const channelIndex of this._eachSelectedChannel()) {
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    this._changeTranspose.append(new ChangeTranspose(this._doc, channelIndex, pattern, upward, this._doc.notesOutsideScale, octave));
                }
            }
            this._doc.record(this._changeTranspose, canReplaceLastChange);
        }
        swapChannels(offset) {
            const possibleSectionBoundaries = [
                this._doc.song.pitchChannelCount,
                this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount,
                this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount + this._doc.song.modChannelCount,
                this._doc.song.getChannelCount(),
            ];
            let channelSectionMin = 0;
            let channelSectionMax = 0;
            for (const nextBoundary of possibleSectionBoundaries) {
                if ((this.boxSelectionChannel < nextBoundary && offset < 0) || (this.boxSelectionChannel + this.boxSelectionHeight <= nextBoundary)) {
                    channelSectionMax = nextBoundary - 1;
                    break;
                }
                channelSectionMin = nextBoundary;
            }
            const newSelectionMin = Math.max(this.boxSelectionChannel, channelSectionMin);
            const newSelectionMax = Math.min(this.boxSelectionChannel + this.boxSelectionHeight - 1, channelSectionMax);
            offset = Math.max(offset, channelSectionMin - newSelectionMin);
            offset = Math.min(offset, channelSectionMax - newSelectionMax);
            if (offset != 0) {
                const canReplaceLastChange = this._doc.lastChangeWas(this._changeReorder);
                this._changeReorder = new ChangeGroup();
                this.boxSelectionY0 = newSelectionMin + offset;
                this.boxSelectionY1 = newSelectionMax + offset;
                this._changeReorder.append(new ChangeChannelOrder(this._doc, newSelectionMin, newSelectionMax, offset));
                this._changeReorder.append(new ChangeChannelBar(this._doc, Math.max(this.boxSelectionY0, Math.min(this.boxSelectionY1, this._doc.channel + offset)), this._doc.bar));
                this.selectionUpdated();
                this._doc.record(this._changeReorder, canReplaceLastChange);
            }
        }
        selectInstrument(instrument) {
            if (this._doc.viewedInstrument[this._doc.channel] == instrument) {
                if (this._doc.song.layeredInstruments && this._doc.song.patternInstruments && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                    const canReplaceLastChange = this._doc.lastChangeWas(this._changeInstrument);
                    this._changeInstrument = new ChangeGroup();
                    const instruments = this._doc.recentPatternInstruments[this._doc.channel];
                    if (instruments.indexOf(instrument) == -1) {
                        instruments.push(instrument);
                        const maxLayers = this._doc.song.getMaxInstrumentsPerPattern(this._doc.channel);
                        if (instruments.length > maxLayers) {
                            instruments.splice(0, instruments.length - maxLayers);
                        }
                    }
                    else {
                        instruments.splice(instruments.indexOf(instrument), 1);
                        if (instruments.length == 0)
                            instruments[0] = 0;
                    }
                    if (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1) {
                        this._changeInstrument.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
                    }
                    for (const channelIndex of this._eachSelectedChannel()) {
                        for (const pattern of this._eachSelectedPattern(channelIndex)) {
                            this._changeInstrument.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instruments, pattern));
                        }
                    }
                    this._doc.record(this._changeInstrument, canReplaceLastChange);
                }
            }
            else {
                const canReplaceLastChange = this._doc.lastChangeWas(this._changeInstrument);
                this._changeInstrument = new ChangeGroup();
                this._changeInstrument.append(new ChangeViewInstrument(this._doc, instrument));
                if (!this._doc.song.layeredInstruments && this._doc.song.patternInstruments) {
                    if (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1) {
                        this._changeInstrument.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight));
                    }
                    const instruments = [instrument];
                    for (const channelIndex of this._eachSelectedChannel()) {
                        for (const pattern of this._eachSelectedPattern(channelIndex)) {
                            this._changeInstrument.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instruments, pattern));
                        }
                    }
                    this._doc.record(this._changeInstrument, canReplaceLastChange);
                }
                else if (!this._doc.hasRedoHistory()) {
                    this._doc.record(this._changeInstrument, canReplaceLastChange);
                }
            }
        }
        resetBoxSelection() {
            this.boxSelectionX0 = this.boxSelectionX1 = this._doc.bar;
            this.boxSelectionY0 = this.boxSelectionY1 = this._doc.channel;
        }
    }

    class ChangeNotifier {
        constructor() {
            this._watchers = [];
            this._dirty = false;
        }
        watch(watcher) {
            if (this._watchers.indexOf(watcher) == -1) {
                this._watchers.push(watcher);
            }
        }
        unwatch(watcher) {
            const index = this._watchers.indexOf(watcher);
            if (index != -1) {
                this._watchers.splice(index, 1);
            }
        }
        changed() {
            this._dirty = true;
        }
        notifyWatchers() {
            if (!this._dirty)
                return;
            this._dirty = false;
            for (const watcher of this._watchers.concat()) {
                watcher();
            }
        }
    }
     
class KeyboardLayout {
    static keyPosToPitch(doc, x, y, keyboardLayout) {
        let pitchOffset = null;
        let forcedKey = null;
        switch (keyboardLayout) {
            case "wickiHayden":
                pitchOffset = y * 5 + x * 2 - 2;
                break;
            case "songScale":
                const scaleFlags =  Config.scales[doc.song.scale].flags;
                const scaleIndices = scaleFlags.map((flag, index) => flag ? index : null).filter((index) => index != null);
                pitchOffset = (y - 1 + Math.floor(x / scaleIndices.length)) * Config.pitchesPerOctave + scaleIndices[(x + scaleIndices.length) % scaleIndices.length];
                break;
            case "pianoAtC":
                pitchOffset = KeyboardLayout._pianoAtC[y][x];
                forcedKey = Config.keys.dictionary["C"].basePitch;
                break;
            case "pianoAtA":
                pitchOffset = KeyboardLayout._pianoAtA[y][x];
                forcedKey = Config.keys.dictionary["A"].basePitch;
                break;
            case "pianoTransposingC":
                pitchOffset = KeyboardLayout._pianoAtC[y][x];
                break;
            case "pianoTransposingA":
                pitchOffset = KeyboardLayout._pianoAtA[y][x];
                break;
        }
        if (pitchOffset == null)
            return null;
        const octaveOffset = Math.max(0, doc.song.channels[doc.channel].octave - 1) * Config.pitchesPerOctave;
        let keyOffset = 0;
        if (forcedKey != null) {
            const keyBasePitch = Config.keys[doc.song.key].basePitch;
            keyOffset = (forcedKey - keyBasePitch + 144) % 12;
        }
        const pitch = octaveOffset + keyOffset + pitchOffset;
        if (pitch < 0 || pitch > Config.maxPitch)
            return null;
        return pitch;
    }
    constructor(_doc) {
        this._doc = _doc;
        this._possiblyPlayingPitchesFromKeyboard = false;
        this._onWindowBlur = (event) => {
            if (this._possiblyPlayingPitchesFromKeyboard) {
                this._doc.performance.clearAllPitches();
                this._doc.performance._lastWhistlePitch = null;
                this._possiblyPlayingPitchesFromKeyboard = false;
            }
        };
        window.addEventListener("blur", this._onWindowBlur);
    }
    handleKeyEvent(event, pressed) {
        switch (event.code) {
            case "Backquote":
                this.handleKey(-1, 3, pressed);
                break;
            case "Digit1":
                this.handleKey(0, 3, pressed);
                break;
            case "Digit2":
                this.handleKey(1, 3, pressed);
                break;
            case "Digit3":
                this.handleKey(2, 3, pressed);
                break;
            case "Digit4":
                this.handleKey(3, 3, pressed);
                break;
            case "Digit5":
                this.handleKey(4, 3, pressed);
                break;
            case "Digit6":
                this.handleKey(5, 3, pressed);
                break;
            case "Digit7":
                this.handleKey(6, 3, pressed);
                break;
            case "Digit8":
                this.handleKey(7, 3, pressed);
                break;
            case "Digit9":
                this.handleKey(8, 3, pressed);
                break;
            case "Digit0":
                this.handleKey(9, 3, pressed);
                break;
            case "Minus":
                this.handleKey(10, 3, pressed);
                break;
            case "Equal":
                this.handleKey(11, 3, pressed);
                break;
            case "IntlYen":
                this.handleKey(12, 3, pressed);
                break;
            case "KeyQ":
                this.handleKey(0, 2, pressed);
                break;
            case "KeyW":
                this.handleKey(1, 2, pressed);
                break;
            case "KeyE":
                this.handleKey(2, 2, pressed);
                break;
            case "KeyR":
                this.handleKey(3, 2, pressed);
                break;
            case "KeyT":
                this.handleKey(4, 2, pressed);
                break;
            case "KeyY":
                this.handleKey(5, 2, pressed);
                break;
            case "KeyU":
                this.handleKey(6, 2, pressed);
                break;
            case "KeyI":
                this.handleKey(7, 2, pressed);
                break;
            case "KeyO":
                this.handleKey(8, 2, pressed);
                break;
            case "KeyP":
                this.handleKey(9, 2, pressed);
                break;
            case "BracketLeft":
                this.handleKey(10, 2, pressed);
                break;
            case "BracketRight":
                this.handleKey(11, 2, pressed);
                break;
            case "Backslash":
                if (event.key == "\\" || event.key == "|") {
                    this.handleKey(12, 2, pressed);
                }
                else {
                    this.handleKey(11, 1, pressed);
                }
                break;
            case "KeyA":
                this.handleKey(0, 1, pressed);
                break;
            case "KeyS":
                this.handleKey(1, 1, pressed);
                break;
            case "KeyD":
                this.handleKey(2, 1, pressed);
                break;
            case "KeyF":
                this.handleKey(3, 1, pressed);
                break;
            case "KeyG":
                this.handleKey(4, 1, pressed);
                break;
            case "KeyH":
                this.handleKey(5, 1, pressed);
                break;
            case "KeyJ":
                this.handleKey(6, 1, pressed);
                break;
            case "KeyK":
                this.handleKey(7, 1, pressed);
                break;
            case "KeyL":
                this.handleKey(8, 1, pressed);
                break;
            case "Semicolon":
                this.handleKey(9, 1, pressed);
                break;
            case "Quote":
                this.handleKey(10, 1, pressed);
                break;
            case "IntlHash":
                this.handleKey(11, 1, pressed);
                break;
            case "IntlBackslash":
                this.handleKey(-1, 0, pressed);
                break;
            case "KeyZ":
                this.handleKey(0, 0, pressed);
                break;
            case "KeyX":
                this.handleKey(1, 0, pressed);
                break;
            case "KeyC":
                this.handleKey(2, 0, pressed);
                break;
            case "KeyV":
                this.handleKey(3, 0, pressed);
                break;
            case "KeyB":
                this.handleKey(4, 0, pressed);
                break;
            case "KeyN":
                this.handleKey(5, 0, pressed);
                break;
            case "KeyM":
                this.handleKey(6, 0, pressed);
                break;
            case "Comma":
                this.handleKey(7, 0, pressed);
                break;
            case "Period":
                this.handleKey(8, 0, pressed);
                break;
            case "Slash":
                this.handleKey(9, 0, pressed);
                break;
            case "IntlRo":
                this.handleKey(10, 0, pressed);
                break;
            default: return;
        }
        event.preventDefault();
    }
    handleKey(x, y, pressed) {
        const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
        if (isDrum) {
            if (x >= 0 && x < Config.drumCount) {
                if (pressed) {
                    this._doc.synth.preferLowerLatency = true;
                    this._doc.performance.addPerformedPitch(x);
                    this._possiblyPlayingPitchesFromKeyboard = true;
                }
                else {
                    this._doc.performance.removePerformedPitch(x);
                }
            }
            return;
        }
        const pitch = KeyboardLayout.keyPosToPitch(this._doc, x, y, this._doc.keyboardLayout);
        if (pitch != null) {
            if (pressed) {
                this._doc.synth.preferLowerLatency = true;
                this._doc.performance.addPerformedPitch(pitch);
                this._possiblyPlayingPitchesFromKeyboard = true;
            }
            else {
                this._doc.performance.removePerformedPitch(pitch);
            }
        }
    }
}
KeyboardLayout._pianoAtC = [
    [0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17],
    [null, 1, 3, null, 6, 8, 10, null, 13, 15, null, 18],
    [12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33],
    [null, 13, 15, null, 18, 20, 22, null, 25, 27, null, 30, 32],
];
KeyboardLayout._pianoAtA = [
    [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17],
    [-1, 1, null, 4, 6, null, 9, 11, 13, null, 16, 18],
    [12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32],
    [11, 13, null, 16, 18, null, 21, 23, 25, null, 28, 30, null],
];
 class SongPerformance {
    constructor(_doc) {
        this._doc = _doc;
        this._channelIsDrum = false;
        this._channelOctave = -1;
        this._songKey = -1;
        this._pitchesAreTemporary = false;
        this._bassPitchesAreTemporary = false;
        this._recentlyAddedPitches = [];
        this._recentlyAddedBassPitches = [];
        this._songLengthWhenRecordingStarted = -1;
        this._playheadPart = -1;
        this._bassPlayheadPart = -1;
        this._playheadPattern = null;
        this._bassPlayheadPattern = null;
        this._pitchesChanged = false;
        this._bassPitchesChanged = false;
        this._lastNote = null;
        this._lastBassNote = null;
        this._recordingChange = null;
this.isRecordingWhistle = this._doc.synth.isRecordingWhistle ;
this.currNote = "";
this._onAnimationFrame = () => {
	this.isRecordingWhistle = this._doc.synth.isRecordingWhistle ;
	window.requestAnimationFrame(this._onAnimationFrame);
	if (this._doc.synth.recording && !this.isRecordingWhistle) {
		let dirty = this._updateRecordedNotes();
		dirty = this._updateRecordedBassNotes() ? true : dirty;
		if (dirty) this._doc.notifier.notifyWatchers();
	}
};


        this._documentChanged = () => {
            const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
            const octave = this._doc.song.channels[this._doc.channel].octave;
            if (this._doc.synth.liveInputChannel != this._doc.channel || this._doc.synth.liveBassInputChannel != this._getBassOffsetChannel() || this._channelIsDrum != isDrum || this._channelOctave != octave || this._songKey != this._doc.song.key) {
                this._doc.synth.liveInputChannel = this._doc.channel;
                this._doc.synth.liveBassInputChannel = this._getBassOffsetChannel();
                this._channelIsDrum = isDrum;
                this._channelOctave = octave;
                this._songKey = this._doc.song.key;
                
                this.clearAllPitches();
                this._lastWhistlePitch = null;
               
                this.clearAllBassPitches();
            }
            
            this._doc.synth.liveInputInstruments = this._doc.recentPatternInstruments[this._doc.channel];
            this._doc.synth.liveBassInputInstruments = this._doc.recentPatternInstruments[this._doc.synth.liveBassInputChannel];
        };
        
        this._doc.notifier.watch(this._documentChanged);
        
        this._documentChanged();
         
        window.requestAnimationFrame(this._onAnimationFrame);
    }
    play() {
        this._doc.synth.play();
        this._doc.synth.enableMetronome = false;
        this._doc.synth.countInMetronome = false;
        this._doc.synth.maintainLiveInput();
    }
 
noteToMidi(note) {
    const notes = { C:0, 'C#':1, D:2, 'D#':3, E:4, F:5, 'F#':6, G:7, 'G#':8, A:9, 'A#':10, B:11 };
    const regex = /^([A-G]#?)(\d)$/;
    const match = note.match(regex);
    if (!match) return 60; 
    const [ , n, octave ] = match;
    return notes[n] + ((parseInt(octave) + 1) * 12)-12; 
}
updatePerformedNote(note) {
 if (!note) {
  if (this._lastWhistlePitch !== null) {
   this.clearAllPitches();
   this._lastWhistlePitch = null;
   this._lastWhistlePitch = null;
  }
  return;
 }
 const midiPitch = this.noteToMidi(note);
 if (this._lastWhistlePitch !== midiPitch) {
  this.setTemporaryPitches([midiPitch], Number.MAX_SAFE_INTEGER);
  this._lastWhistlePitch = midiPitch;
 }
}
    pause() {
        this.clearAllPitches();
        this.clearAllBassPitches();
        this._lastWhistlePitch = null;
        if (this._recordingChange != null) {
            if (this._doc.song.barCount > this._songLengthWhenRecordingStarted && !this._lastBarHasPatterns()) {
                new ChangeDeleteBars(this._doc, this._doc.song.barCount - 1, 1);
                new ChangeChannelBar(this._doc, this._doc.channel, this._doc.song.barCount - 1);
            }
            if (!this._recordingChange.isNoop()) {
                this._doc.record(this._recordingChange);
                this._recordingChange = null;
            }
            this._lastNote = null;
        }
        this._doc.synth.pause();
        this._doc.synth.resetEffects();
        this._doc.synth.enableMetronome = false;
        this._doc.synth.countInMetronome = false;
        if (this._doc.autoFollow) {
            this._doc.synth.goToBar(this._doc.bar);
        }
        this._doc.synth.snapToBar();
    }
    record() {
        this._doc.synth.snapToBar();
        const playheadBar = Math.floor(this._doc.synth.playhead);
        if (playheadBar != this._doc.bar) {
            new ChangeChannelBar(this._doc, this._doc.channel, playheadBar);
        }
        if (this._pitchesAreTemporary) {
            this.clearAllPitches();
            this._lastWhistlePitch = null;
            this._pitchesAreTemporary = false;
        }
        if (this._bassPitchesAreTemporary) {
            this.clearAllBassPitches();
            this._bassPitchesAreTemporary = false;
        }
        this._doc.synth.enableMetronome = this._doc.metronomeWhileRecording;
        this._doc.synth.countInMetronome = this._doc.metronomeCountIn;
        this._doc.synth.startRecording();
        this._doc.synth.maintainLiveInput();
        this._songLengthWhenRecordingStarted = this._doc.song.barCount;
        this._playheadPart = this._getCurrentPlayheadPart();
        this._bassPlayheadPart = this._getCurrentPlayheadPart();
        this._playheadPattern = null;
        this._bassPlayheadPattern = null;
        this._pitchesChanged = false;
        this._bassPitchesChanged = false;
        this._lastNote = null;
        this._lastBassNote = null;
        this._recentlyAddedPitches.length = 0;
        this._recentlyAddedBassPitches.length = 0;
        this._recordingChange = new ChangeGroup();
        this._doc.setProspectiveChange(this._recordingChange);
    }
    abortRecording() {
        this._recordingChange = null;
        this.pause();
    }
    pitchesAreTemporary() {
        return this._pitchesAreTemporary;
    }
    bassPitchesAreTemporary() {
        return this._bassPitchesAreTemporary;
    }
    _getBassOffsetChannel() {
        if (this._doc.channel >= this._doc.song.pitchChannelCount)
            return this._doc.channel;
        return Math.max(0, Math.min(this._doc.song.pitchChannelCount - 1, this._doc.channel + this._doc.bassOffset));
    }
    _getMinDivision() {
        if (this._doc.snapRecordedNotesToRhythm) {
            return Config.partsPerBeat / Config.rhythms[this._doc.song.rhythm].stepsPerBeat;
        }
        else {
            return 1;
        }
    }
    _getCurrentPlayheadPart() {
        const currentPart = this._doc.synth.playhead * this._doc.song.beatsPerBar * Config.partsPerBeat;
        if (this._doc.snapRecordedNotesToRhythm) {
            const minDivision = this._getMinDivision();
            return Math.round(currentPart / minDivision) * minDivision;
        }
        return Math.round(currentPart);
    }
    _lastBarHasPatterns() {
        for (let channelIndex = 0; channelIndex < this._doc.song.getChannelCount(); channelIndex++) {
            if (this._doc.song.channels[channelIndex].bars[this._doc.song.barCount - 1] != 0)
                return true;
        }
        return false;
    }
    _updateRecordedNotes() {
        if (this._recordingChange == null)
            return false;
        if (!this._doc.lastChangeWas(this._recordingChange)) {
            this.abortRecording();
            return false;
        }
        if (this._doc.synth.countInMetronome) {
            this._recentlyAddedPitches.length = 0;
            this._pitchesChanged = false;
            return false;
        }
        const partsPerBar = this._doc.song.beatsPerBar * Config.partsPerBeat;
        const oldPart = this._playheadPart % partsPerBar;
        const oldBar = Math.floor(this._playheadPart / partsPerBar);
        const oldPlayheadPart = this._playheadPart;
        this._playheadPart = this._getCurrentPlayheadPart();
        const newPart = this._playheadPart % partsPerBar;
        const newBar = Math.floor(this._playheadPart / partsPerBar);
        if (oldPart == newPart && oldBar == newBar)
            return false;
        if (this._playheadPart < oldPlayheadPart) {
            this._lastNote = null;
            this._playheadPattern = null;
            return false;
        }
        let dirty = false;
        for (let bar = oldBar; bar <= newBar; bar++) {
            if (bar != oldBar) {
                this._playheadPattern = null;
            }
            const startPart = (bar == oldBar) ? oldPart : 0;
            const endPart = (bar == newBar) ? newPart : partsPerBar;
            if (startPart == endPart)
                break;
                
            if (this._lastNote != null && !this._pitchesChanged && startPart > 0 && this._doc.synth.liveInputPitches.length > 0) {
                this._recordingChange.append(new ChangePinTime(this._doc, this._lastNote, 1, endPart, this._lastNote.continuesLastPattern));
                this._doc.currentPatternIsDirty = true;
            }
            else {
                if (this._lastNote != null) {
                    this._lastNote = null;
                }
                
                let noteStartPart = startPart;
                let noteEndPart = endPart;
                while (noteStartPart < endPart) {
                    let addedAlreadyReleasedPitch = false;
                    if (this._recentlyAddedPitches.length > 0 || this._doc.synth.liveInputPitches.length > 0) {
                    	
                        if (this._playheadPattern == null) {
                            this._doc.selection.erasePatternInBar(this._recordingChange, this._doc.synth.liveInputChannel, bar);
                            this._recordingChange.append(new ChangeEnsurePatternExists(this._doc, this._doc.synth.liveInputChannel, bar));
                            this._playheadPattern = this._doc.song.getPattern(this._doc.synth.liveInputChannel, bar);
                        }
                        if (this._playheadPattern == null)
                            throw new Error();
                        this._lastNote = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, this._doc.song.getChannelIsNoise(this._doc.synth.liveInputChannel));
                        this._lastNote.continuesLastPattern = (noteStartPart == 0 && !this._pitchesChanged);
                        this._lastNote.pitches.length = 0;
                        while (this._recentlyAddedPitches.length > 0) {
                            if (this._lastNote.pitches.length >= Config.maxChordSize)
                                break;
                            const recentPitch = this._recentlyAddedPitches.shift();
                            if (this._doc.synth.liveInputPitches.indexOf(recentPitch) == -1) {
                                this._lastNote.pitches.push(recentPitch);
                                addedAlreadyReleasedPitch = true;
                            }
                        }
                        for (let i = 0; i < this._doc.synth.liveInputPitches.length; i++) {
                            if (this._lastNote.pitches.length >= Config.maxChordSize)
                                break;
                            this._lastNote.pitches.push(this._doc.synth.liveInputPitches[i]);
                        }
                        this._recordingChange.append(new ChangeNoteAdded(this._doc, this._playheadPattern, this._lastNote, this._playheadPattern.notes.length));
                        if (addedAlreadyReleasedPitch) {
                            noteEndPart = noteStartPart + this._getMinDivision();
                            new ChangeNoteLength(this._doc, this._lastNote, this._lastNote.start, noteEndPart);
                            this._lastNote = null;
                        }
                        dirty = true;
                    }
                    this._pitchesChanged = addedAlreadyReleasedPitch;
                    noteStartPart = noteEndPart;
                    noteEndPart = endPart;
                }
            }
            if (bar == this._doc.song.barCount - 1) {
                if (this._lastBarHasPatterns()) {
                    new ChangeInsertBars(this._doc, this._doc.song.barCount, 1);
                    this._doc.bar--;
                    dirty = true;
                }
            }
        }
        return dirty;
    }
    _updateRecordedBassNotes() {
        if (this._recordingChange == null)
            return false;
        if (!this._doc.lastChangeWas(this._recordingChange)) {
            this.abortRecording();
            return false;
        }
        if (this._doc.synth.countInMetronome) {
            this._recentlyAddedBassPitches.length = 0;
            this._bassPitchesChanged = false;
            return false;
        }
        const partsPerBar = this._doc.song.beatsPerBar * Config.partsPerBeat;
        const oldPart = this._bassPlayheadPart % partsPerBar;
        const oldBar = Math.floor(this._bassPlayheadPart / partsPerBar);
        const oldPlayheadPart = this._bassPlayheadPart;
        this._bassPlayheadPart = this._getCurrentPlayheadPart();
        const newPart = this._bassPlayheadPart % partsPerBar;
        const newBar = Math.floor(this._bassPlayheadPart / partsPerBar);
        if (oldPart == newPart && oldBar == newBar)
            return false;
        if (this._bassPlayheadPart < oldPlayheadPart) {
            this._lastBassNote = null;
            this._bassPlayheadPattern = null;
            return false;
        }
        let dirty = false;
        for (let bar = oldBar; bar <= newBar; bar++) {
            if (bar != oldBar) {
                this._bassPlayheadPattern = null;
            }
            const startPart = (bar == oldBar) ? oldPart : 0;
            const endPart = (bar == newBar) ? newPart : partsPerBar;
            if (startPart == endPart)
                break;
            if (this._lastBassNote != null && !this._bassPitchesChanged && startPart > 0 && this._doc.synth.liveBassInputPitches.length > 0) {
                this._recordingChange.append(new ChangePinTime(this._doc, this._lastBassNote, 1, endPart, this._lastBassNote.continuesLastPattern));
                this._doc.currentPatternIsDirty = true;
            }
            else {
                if (this._lastBassNote != null) {
                    this._lastBassNote = null;
                }
                let noteStartPart = startPart;
                let noteEndPart = endPart;
                while (noteStartPart < endPart) {
                    let addedAlreadyReleasedPitch = false;
                    if (this._recentlyAddedBassPitches.length > 0 || this._doc.synth.liveBassInputPitches.length > 0) {
                        if (this._bassPlayheadPattern == null) {
                        	 
                            this._doc.selection.erasePatternInBar(this._recordingChange, this._doc.synth.liveBassInputChannel, bar);
                            this._recordingChange.append(new ChangeEnsurePatternExists(this._doc, this._doc.synth.liveBassInputChannel, bar));
                            this._bassPlayheadPattern = this._doc.song.getPattern(this._doc.synth.liveBassInputChannel, bar);
                        }
                        if (this._bassPlayheadPattern == null)
                            throw new Error();
                        this._lastBassNote = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, this._doc.song.getChannelIsNoise(this._doc.synth.liveBassInputChannel));
                        this._lastBassNote.continuesLastPattern = (noteStartPart == 0 && !this._bassPitchesChanged);
                        this._lastBassNote.pitches.length = 0;
                        while (this._recentlyAddedBassPitches.length > 0) {
                            if (this._lastBassNote.pitches.length >= Config.maxChordSize)
                                break;
                            const recentPitch = this._recentlyAddedBassPitches.shift();
                            if (this._doc.synth.liveBassInputPitches.indexOf(recentPitch) == -1) {
                                this._lastBassNote.pitches.push(recentPitch);
                                addedAlreadyReleasedPitch = true;
                            }
                        }
                        for (let i = 0; i < this._doc.synth.liveBassInputPitches.length; i++) {
                            if (this._lastBassNote.pitches.length >= Config.maxChordSize)
                                break;
                            this._lastBassNote.pitches.push(this._doc.synth.liveBassInputPitches[i]);
                        }
                        this._recordingChange.append(new ChangeNoteAdded(this._doc, this._bassPlayheadPattern, this._lastBassNote, this._bassPlayheadPattern.notes.length));
                        if (addedAlreadyReleasedPitch) {
                            noteEndPart = noteStartPart + this._getMinDivision();
                            new ChangeNoteLength(this._doc, this._lastBassNote, this._lastBassNote.start, noteEndPart);
                            this._lastBassNote = null;
                        }
                        dirty = true;
                    }
                    this._bassPitchesChanged = addedAlreadyReleasedPitch;
                    noteStartPart = noteEndPart;
                    noteEndPart = endPart;
                }
            }
            if (bar == this._doc.song.barCount - 1) {
                if (this._lastBarHasPatterns()) {
                    new ChangeInsertBars(this._doc, this._doc.song.barCount, 1);
                    this._doc.bar--;
                    dirty = true;
                }
            }
        }
        return dirty;
    }
    setTemporaryPitches(pitches, duration) {
        this._updateRecordedNotes();
        for (let i = 0; i < pitches.length; i++) {
            this._doc.synth.liveInputPitches[i] = pitches[i];
        }
        this._doc.synth.liveInputPitches.length = Math.min(pitches.length, Config.maxChordSize);
        this._doc.synth.liveInputDuration = duration;
        this._doc.synth.liveInputStarted = true;
        this._pitchesAreTemporary = true;
        this._pitchesChanged = true;
    }
    setTemporaryBassPitches(pitches, duration) {
        this._updateRecordedBassNotes();
        for (let i = 0; i < pitches.length; i++) {
            this._doc.synth.liveBassInputPitches[i] = pitches[i];
        }
        this._doc.synth.liveBassInputPitches.length = Math.min(pitches.length, Config.maxChordSize);
        this._doc.synth.liveBassInputDuration = duration;
        this._doc.synth.liveBassInputStarted = true;
        this._bassPitchesAreTemporary = true;
        this._bassPitchesChanged = true;
    }
addPerformedNote(note) {
    if (!note) return;
    
    const midiPitch = this.noteToMidi(note);
    this._doc.synth.maintainLiveInput();
    if (midiPitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
        this._updateRecordedNotes();
        if (this._pitchesAreTemporary) {
            this.clearAllPitches();
            this._lastWhistlePitch = null;
            this._pitchesAreTemporary = false;
        }
        if (this._doc.synth.liveInputPitches.indexOf(midiPitch) === -1) {
            this._doc.synth.liveInputPitches.push(midiPitch);
        }
        this._doc.synth.liveInputDuration = Number.MAX_SAFE_INTEGER;
        this._doc.synth.liveInputStarted = true;
        this._pitchesAreTemporary = true;
        this._pitchesChanged = true;
        if (this._recordingChange != null) {
            const recentIndex = this._recentlyAddedPitches.indexOf(midiPitch);
            if (recentIndex !== -1) this._recentlyAddedPitches.splice(recentIndex, 1);
            this._recentlyAddedPitches.push(midiPitch);
            while (this._recentlyAddedPitches.length > Config.maxChordSize * 4) this._recentlyAddedPitches.shift();
        }
    } else {
        this._updateRecordedBassNotes();
        if (this._bassPitchesAreTemporary) {
            this.clearAllBassPitches();
            this._bassPitchesAreTemporary = false;
        }
        if (this._doc.synth.liveBassInputPitches.indexOf(midiPitch) === -1) {
            this._doc.synth.liveBassInputPitches.push(midiPitch);
        }
        this._doc.synth.liveBassInputDuration = Number.MAX_SAFE_INTEGER;
        this._doc.synth.liveBassInputStarted = true;
        this._bassPitchesAreTemporary = true;
        this._bassPitchesChanged = true;
        if (this._recordingChange != null) {
            const recentIndex = this._recentlyAddedBassPitches.indexOf(midiPitch);
            if (recentIndex !== -1) this._recentlyAddedBassPitches.splice(recentIndex, 1);
            this._recentlyAddedBassPitches.push(midiPitch);
            while (this._recentlyAddedBassPitches.length > Config.maxChordSize * 4) this._recentlyAddedBassPitches.shift();
        }
    }
}

    addPerformedPitch(pitch) {
this.isRecordingWhistle = this._doc.synth.isRecordingWhistle;
console.log(this.isRecordingWhistle)
if (this.isRecordingWhistle) return;

        this._doc.synth.maintainLiveInput();
        
        if (pitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
            this._updateRecordedNotes();
            if (this._pitchesAreTemporary) {
                this.clearAllPitches();
                this._pitchesAreTemporary = false;
            }
            if (this._doc.ignorePerformedNotesNotInScale && !Config.scales[this._doc.song.scale].flags[pitch % Config.pitchesPerOctave]) {
                return;
            }
            if (this._doc.synth.liveInputPitches.indexOf(pitch) == -1) {
                this._doc.synth.liveInputPitches.push(pitch);
                this._pitchesChanged = true;
                while (this._doc.synth.liveInputPitches.length > Config.maxChordSize) {
                    this._doc.synth.liveInputPitches.shift();
                }
                this._doc.synth.liveInputDuration = Number.MAX_SAFE_INTEGER;
                if (this._recordingChange != null) {
                    const recentIndex = this._recentlyAddedPitches.indexOf(pitch);
                    if (recentIndex != -1) {
                        this._recentlyAddedPitches.splice(recentIndex, 1);
                    }
                    this._recentlyAddedPitches.push(pitch);
                    while (this._recentlyAddedPitches.length > Config.maxChordSize * 4) {
                        this._recentlyAddedPitches.shift();
                    }
                }
            }
        }
        else {
            this._updateRecordedBassNotes();
            if (this._bassPitchesAreTemporary) {
                this.clearAllBassPitches();
                this._bassPitchesAreTemporary = false;
            }
            if (this._doc.ignorePerformedNotesNotInScale && !Config.scales[this._doc.song.scale].flags[pitch % Config.pitchesPerOctave]) {
                return;
            }
            if (this._doc.synth.liveBassInputPitches.indexOf(pitch) == -1) {
                this._doc.synth.liveBassInputPitches.push(pitch);
                this._bassPitchesChanged = true;
                while (this._doc.synth.liveBassInputPitches.length > Config.maxChordSize) {
                    this._doc.synth.liveBassInputPitches.shift();
                }
                this._doc.synth.liveBassInputDuration = Number.MAX_SAFE_INTEGER;
                if (this._recordingChange != null) {
                    const recentIndex = this._recentlyAddedPitches.indexOf(pitch);
                    if (recentIndex != -1) {
                        this._recentlyAddedBassPitches.splice(recentIndex, 1);
                    }
                    this._recentlyAddedBassPitches.push(pitch);
                    while (this._recentlyAddedBassPitches.length > Config.maxChordSize * 4) {
                        this._recentlyAddedBassPitches.shift();
                    }
                }
            }
        }
    }
    removePerformedPitch(pitch) {
        if (pitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
            this._updateRecordedNotes();
            for (let i = 0; i < this._doc.synth.liveInputPitches.length; i++) {
                if (this._doc.synth.liveInputPitches[i] == pitch) {
                    this._doc.synth.liveInputPitches.splice(i, 1);
                    this._pitchesChanged = true;
                    i--;
                }
            }
        }
        else {
            this._updateRecordedBassNotes();
            for (let i = 0; i < this._doc.synth.liveBassInputPitches.length; i++) {
                if (this._doc.synth.liveBassInputPitches[i] == pitch) {
                    this._doc.synth.liveBassInputPitches.splice(i, 1);
                    this._bassPitchesChanged = true;
                    i--;
                }
            }
        }
    }
    clearAllPitches() {
        this._updateRecordedNotes();
        
        this._doc.synth.liveInputPitches.length = 0;
        
        this._pitchesChanged = true;
    }
    clearAllBassPitches() {
        this._updateRecordedBassNotes();
        
        this._doc.synth.liveBassInputPitches.length = 0;
        
        this._bassPitchesChanged = true;
    }
}

    class SongDocument {
        constructor() {
            this.notifier = new ChangeNotifier();
            this.selection = new Selection(this);
            this.channel = 0;
            this.muteEditorChannel = 0;
            this.bar = 0;
            this.alwaysFineNoteVol = false;
            this.alwaysShowSettings = true;
            this.displayVolumeBar = true;
            this.notesFlashWhenPlayed=false;
            this.volume = 75;
            this.visibleOctaves = SongDocument.defaultVisibleOctaves;
            this.recentPatternInstruments = [];
            this.viewedInstrument = [];
            this.trackVisibleBars = 16;
            this.trackVisibleChannels = 4;
            this.barScrollPos = 0;
            this.channelScrollPos = 0;
            this.prompt = null;
            this.addedEffect = false;
            this.addedEnvelope = false;
            this._recentChange = null;
            this._sequenceNumber = 0;
			this._recovery = new SongRecovery();
            this._lastSequenceNumber = 0;
            this._stateShouldBePushed = false;
            this._recordedNewSong = false;
            this._waitingToUpdateState = false;
            this._whenHistoryStateChanged = () => {
                if (window.history.state == null && window.location.hash != "") {
                    this._sequenceNumber++;
                    this._resetSongRecoveryUid();
                    const state = { canUndo: true, sequenceNumber: this._sequenceNumber, bar: this.bar, channel: this.channel, instrument: this.viewedInstrument[this.channel], recoveryUid: this._recoveryUid, prompt: null, selection: this.selection.toJSON() };
                    new ChangeSong(this, window.location.hash);
                    this.prompt = state.prompt;
                    if (this.displayBrowserUrl) {
                        this._replaceState(state, this.song.toBase64String());
                    }
                    else {
                        this._pushState(state, this.song.toBase64String());
                    }
                    this.forgetLastChange();
                    this.notifier.notifyWatchers();
                    return;
                }
                const state = this._getHistoryState();
                if (state == null)
                    throw new Error("History state is null.");
                if (state.sequenceNumber == this._sequenceNumber)
                    return;
                this.bar = state.bar;
                this.channel = state.channel;
                this.viewedInstrument[this.channel] = state.instrument;
                this._sequenceNumber = state.sequenceNumber;
                this.prompt = state.prompt;
                new ChangeSong(this, this._getHash());
                this._recoveryUid = state.recoveryUid;
                this.selection.fromJSON(state.selection);
                this.forgetLastChange();
                this.notifier.notifyWatchers();
            };
            this._cleanDocument = () => {
                this.notifier.notifyWatchers();
            };
            this._validateDocState = () => {
                const channelCount = this.song.getChannelCount();
                for (let i = this.recentPatternInstruments.length; i < channelCount; i++) {
                    this.recentPatternInstruments[i] = [0];
                }
                this.recentPatternInstruments.length = channelCount;
                for (let i = 0; i < channelCount; i++) {
                    if (i == this.channel) {
                        if (this.song.patternInstruments) {
                            const pattern = this.song.getPattern(this.channel, this.bar);
                            if (pattern != null) {
                                this.recentPatternInstruments[i] = pattern.instruments.concat();
                            }
                        }
                        else {
                            const channel = this.song.channels[this.channel];
                            for (let j = 0; j < channel.instruments.length; j++) {
                                this.recentPatternInstruments[i][j] = j;
                            }
                            this.recentPatternInstruments[i].length = channel.instruments.length;
                        }
                    }
                    discardInvalidPatternInstruments(this.recentPatternInstruments[i], this.song, i);
                }
                for (let i = this.viewedInstrument.length; i < channelCount; i++) {
                    this.viewedInstrument[i] = 0;
                }
                this.viewedInstrument.length = channelCount;
                for (let i = 0; i < channelCount; i++) {
                    if (this.song.patternInstruments && !this.song.layeredInstruments && i == this.channel) {
                        const pattern = this.song.getPattern(this.channel, this.bar);
                        if (pattern != null) {
                            this.viewedInstrument[i] = pattern.instruments[0];
                        }
                    }
                    this.viewedInstrument[i] = Math.min(this.viewedInstrument[i] | 0, this.song.channels[i].instruments.length - 1);
                }
                const highlightedPattern = this.getCurrentPattern();
                if (highlightedPattern != null && this.song.patternInstruments) {
                    this.recentPatternInstruments[this.channel] = highlightedPattern.instruments.concat();
                }
                if ((!this.synth.playing && (this.bar < this.selection.boxSelectionBar || this.selection.boxSelectionBar + this.selection.boxSelectionWidth <= this.bar)) ||
                    this.channel < this.selection.boxSelectionChannel ||
                    this.selection.boxSelectionChannel + this.selection.boxSelectionHeight <= this.channel ||
                    this.song.barCount < this.selection.boxSelectionBar + this.selection.boxSelectionWidth ||
                    channelCount < this.selection.boxSelectionChannel + this.selection.boxSelectionHeight ||
                    (this.selection.boxSelectionWidth == 1 && this.selection.boxSelectionHeight == 1)) {
                    this.selection.resetBoxSelection();
                }
            };
            this._updateHistoryState = () => {
                this._waitingToUpdateState = false;
                let hash;
                try {
                    hash = this.song.toBase64String();
                }
                catch (error) {
                    window.alert("Whoops, the song data appears to have been corrupted! Please try to recover the last working version of the song from the \"Recover Recent Song...\" option in BeepBox's \"File\" menu.");
                    return;
                }
                if (this._stateShouldBePushed)
                    this._sequenceNumber++;
                if (this._recordedNewSong) {
                    this._resetSongRecoveryUid();
                }
                else {
                    this._recovery.saveVersion(this._recoveryUid, this.song.title, hash);
                }
                let state = { canUndo: true, sequenceNumber: this._sequenceNumber, bar: this.bar, channel: this.channel, instrument: this.viewedInstrument[this.channel], recoveryUid: this._recoveryUid, prompt: this.prompt, selection: this.selection.toJSON() };
                if (this._stateShouldBePushed) {
                    this._pushState(state, hash);
                }
                else {
                    this._replaceState(state, hash);
                }
                this._stateShouldBePushed = false;
                this._recordedNewSong = false;
            };
            this.notifier.watch(this._validateDocState);
            this.autoPlay = window.localStorage.getItem("autoPlay") == "true";
            this.showRecordButton = window.localStorage.getItem("showRecordButton") == "true";
            this.keyboardLayout = window.localStorage.getItem("keyboardLayout") || "pianoTransposingC";
            this.autoFollow = window.localStorage.getItem("autoFollow") == "true";
            this.enableNotePreview = window.localStorage.getItem("enableNotePreview") == "true";
            this.showFifth = window.localStorage.getItem("showFifth") == "true";
            this.notesOutsideScale = window.localStorage.getItem("notesOutsideScale") == "true";
            this.showLetters = window.localStorage.getItem("showLetters") == "true";
            this.showChannels = window.localStorage.getItem("showChannels") == "true";
            this.pressControlForShortcuts = window.localStorage.getItem("pressControlForShortcuts") == "true";
            this.snapRecordedNotesToRhythm = window.localStorage.getItem("snapRecordedNotesToRhythm") == "true";
            this.showScrollBar = window.localStorage.getItem("showScrollBar") == "true";
            this.differentMod = window.localStorage.getItem("differentMod") == "true";
            this.alwaysFineNoteVol = window.localStorage.getItem("alwaysFineNoteVol") == "true";
            this.enableChannelMuting = window.localStorage.getItem("enableChannelMuting") == "true";
            this.displayBrowserUrl = window.localStorage.getItem("displayBrowserUrl") != "false";
            this.displayVolumeBar = window.localStorage.getItem("displayVolumeBar") != "false";
            this.showDescription = window.localStorage.getItem("showDescription") != "false";
            this.showPlugins = window.localStorage.getItem("showPlugins") != "false";
            this.increaseAllPins = window.localStorage.getItem("increaseAllPins") != "false";
            this.notesFlashWhenPlayed = window.localStorage.getItem("notesFlashWhenPlayed") != "false";
            this.layout = window.localStorage.getItem("layout") || "small";
            this.bassOffset = (+window.localStorage.getItem("bassOffset")) || 0;
            this.colorTheme = window.localStorage.getItem("colorTheme") || "paandorasbox";
            this.visibleOctaves = (window.localStorage.getItem("visibleOctaves") >>> 0) || SongDocument.defaultVisibleOctaves;
            const defaultScale = Config.scales.dictionary[window.localStorage.getItem("defaultScale")];
            this.defaultScale = (defaultScale != undefined) ? defaultScale.index : 0;
            if (window.localStorage.getItem("volume") != null) {
                this.volume = Math.min(window.localStorage.getItem("volume") >>> 0, 75);
            }
            if (window.localStorage.getItem("fullScreen") != null) {
                if (window.localStorage.getItem("fullScreen") == "true")
                    this.layout = "long";
                window.localStorage.removeItem("fullScreen");
            }
            ColorConfig.setTheme(this.colorTheme);
            Layout.setLayout(this.layout);
            if (window.sessionStorage.getItem("currentUndoIndex") == null) {
                window.sessionStorage.setItem("currentUndoIndex", "0");
                window.sessionStorage.setItem("oldestUndoIndex", "0");
                window.sessionStorage.setItem("newestUndoIndex", "0");
            }
            let songString = window.location.hash;
            if (songString == "") {
                songString = this._getHash();
            }
            this.song = new Song(songString);
            if (songString == "" || songString == undefined) {
                setDefaultInstruments(this.song);
                this.song.scale = this.defaultScale;
            }
            songString = this.song.toBase64String();
            this.synth = new Synth(this.song);
            this.synth.volume = this._calcVolume();
            let state = this._getHistoryState();
            if (state == null) {
                state = { canUndo: false, sequenceNumber: 0, bar: 0, channel: 0, instrument: 0, recoveryUid: generateUid(), prompt: null, selection: this.selection.toJSON() };
            }
            if (state.recoveryUid == undefined)
                state.recoveryUid = generateUid();
            this._replaceState(state, songString);
            window.addEventListener("hashchange", this._whenHistoryStateChanged);
            window.addEventListener("popstate", this._whenHistoryStateChanged);
            this.bar = state.bar | 0;
            this.channel = state.channel | 0;
            for (let i = 0; i <= this.channel; i++)
                this.viewedInstrument[i] = 0;
            this.viewedInstrument[this.channel] = state.instrument | 0;
            this._recoveryUid = state.recoveryUid;
            this.prompt = state.prompt;
            this.selection.fromJSON(state.selection);
            for (const eventName of ["input", "change", "click", "keyup", "keydown", "mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "touchcancel"]) {
                window.addEventListener(eventName, this._cleanDocument);
            }
            this._validateDocState();
            this.performance = new SongPerformance(this);
        }
        toggleDisplayBrowserUrl() {
            const state = this._getHistoryState();
            this.displayBrowserUrl = !this.displayBrowserUrl;
            this._replaceState(state, this.song.toBase64String());
        }
        _getHistoryState() {
            if (this.displayBrowserUrl) {
                return window.history.state;
            }
            else {
                const json = JSON.parse(window.sessionStorage.getItem(window.sessionStorage.getItem("currentUndoIndex")));
                return json == null ? null : json.state;
            }
        }
        _getHash() {
            if (this.displayBrowserUrl) {
                return window.location.hash;
            }
            else {
                const json = JSON.parse(window.sessionStorage.getItem(window.sessionStorage.getItem("currentUndoIndex")));
                return json == null ? "" : json.hash;
            }
        }
        _replaceState(state, hash) {
            if (this.displayBrowserUrl) {
                window.history.replaceState(state, "", "#" + hash);
            }
            else {
                window.sessionStorage.setItem(window.sessionStorage.getItem("currentUndoIndex") || "0", JSON.stringify({ state, hash }));
                window.history.replaceState(null, "", location.pathname);
            }
        }
        _pushState(state, hash) {
            if (this.displayBrowserUrl) {
                window.history.pushState(state, "", "#" + hash);
            }
            else {
                let currentIndex = Number(window.sessionStorage.getItem("currentUndoIndex"));
                let oldestIndex = Number(window.sessionStorage.getItem("oldestUndoIndex"));
                currentIndex = (currentIndex + 1) % SongDocument._maximumUndoHistory;
                window.sessionStorage.setItem("currentUndoIndex", String(currentIndex));
                window.sessionStorage.setItem("newestUndoIndex", String(currentIndex));
                if (currentIndex == oldestIndex) {
                    oldestIndex = (oldestIndex + 1) % SongDocument._maximumUndoHistory;
                    window.sessionStorage.setItem("oldestUndoIndex", String(oldestIndex));
                }
                window.sessionStorage.setItem(String(currentIndex), JSON.stringify({ state, hash }));
                window.history.replaceState(null, "", location.pathname);
            }
            this._lastSequenceNumber = state.sequenceNumber;
        }
        hasRedoHistory() {
            return this._lastSequenceNumber > this._sequenceNumber;
        }
        _forward() {
            if (this.displayBrowserUrl) {
                window.history.forward();
            }
            else {
                let currentIndex = Number(window.sessionStorage.getItem("currentUndoIndex"));
                let newestIndex = Number(window.sessionStorage.getItem("newestUndoIndex"));
                if (currentIndex != newestIndex) {
                    currentIndex = (currentIndex + 1) % SongDocument._maximumUndoHistory;
                    window.sessionStorage.setItem("currentUndoIndex", String(currentIndex));
                    setTimeout(this._whenHistoryStateChanged);
                }
            }
        }
        _back() {
            if (this.displayBrowserUrl) {
                window.history.back();
            }
            else {
                let currentIndex = Number(window.sessionStorage.getItem("currentUndoIndex"));
                let oldestIndex = Number(window.sessionStorage.getItem("oldestUndoIndex"));
                if (currentIndex != oldestIndex) {
                    currentIndex = (currentIndex + SongDocument._maximumUndoHistory - 1) % SongDocument._maximumUndoHistory;
                    window.sessionStorage.setItem("currentUndoIndex", String(currentIndex));
                    setTimeout(this._whenHistoryStateChanged);
                }
            }
        }
        record(change, replace = false, newSong = false) {
            if (change.isNoop()) {
                this._recentChange = null;
                if (replace)
                    this._back();
            }
            else {
                change.commit();
                this._recentChange = change;
                this._stateShouldBePushed = this._stateShouldBePushed || !replace;
                this._recordedNewSong = this._recordedNewSong || newSong;
                if (!this._waitingToUpdateState) {
                    window.requestAnimationFrame(this._updateHistoryState);
                    this._waitingToUpdateState = true;
                }
            }
        }
        _resetSongRecoveryUid() {
            this._recoveryUid = generateUid();
        }
        openPrompt(prompt) {
            this.prompt = prompt;
            const hash = this.song.toBase64String();
            this._sequenceNumber++;
            const state = { canUndo: true, sequenceNumber: this._sequenceNumber, bar: this.bar, channel: this.channel, instrument: this.viewedInstrument[this.channel], recoveryUid: this._recoveryUid, prompt: this.prompt, selection: this.selection.toJSON() };
            this._pushState(state, hash);
        }
        undo() {
            const state = this._getHistoryState();
            if (state.canUndo)
                this._back();
        }
        redo() {
            this._forward();
        }
        setProspectiveChange(change) {
            this._recentChange = change;
        }
        forgetLastChange() {
            this._recentChange = null;
        }
        lastChangeWas(change) {
            return change != null && change == this._recentChange;
        }
        goBackToStart() {
            this.channel = 0;
            this.bar = 0;
            this.barScrollPos = 0;
            this.notifier.changed();
            this.synth.snapToStart();
            this.notifier.changed();
        }
         
        savePreferences() {
        	 
        	
window.localStorage.setItem("showRecordButton", this.showRecordButton ? "true" : "false");
            window.localStorage.setItem("autoPlay", this.autoPlay ? "true" : "false");
            window.localStorage.setItem("autoFollow", this.autoFollow ? "true" : "false");
            window.localStorage.setItem("enableNotePreview", this.enableNotePreview ? "true" : "false");
            window.localStorage.setItem("showFifth", this.showFifth ? "true" : "false");
            
               
window.localStorage.setItem("showDescription", this.showDescription ? "true" : "false");
window.localStorage.setItem("showPlugins", this.showPlugins ? "true" : "false");
window.localStorage.setItem("increaseAllPins", this.increaseAllPins ? "true" : "false");
 
window.localStorage.setItem("snapRecordedNotesToRhythm", this.snapRecordedNotesToRhythm ? "true" : "false");
            window.localStorage.setItem("notesOutsideScale", this.notesOutsideScale ? "true" : "false");
            window.localStorage.setItem("defaultScale", Config.scales[this.defaultScale].name);
            window.localStorage.setItem("showLetters", this.showLetters ? "true" : "false");
            window.localStorage.setItem("showChannels", this.showChannels ? "true" : "false");
            window.localStorage.setItem("showScrollBar", this.showScrollBar ? "true" : "false");
            window.localStorage.setItem("differentMod", this.differentMod ? "true" : "false");
            window.localStorage.setItem("alwaysFineNoteVol", this.alwaysFineNoteVol ? "true" : "false");
            window.localStorage.setItem("enableChannelMuting", this.enableChannelMuting ? "true" : "false");
            
            window.localStorage.setItem("pressControlForShortcuts", this.pressControlForShortcuts ? "true" : "false");
            
            window.localStorage.setItem("displayBrowserUrl", this.displayBrowserUrl ? "true" : "false");
            window.localStorage.setItem("displayVolumeBar", this.displayVolumeBar ? "true" : "false");
            window.localStorage.setItem("layout", this.layout);
            window.localStorage.setItem("colorTheme", this.colorTheme);
            window.localStorage.setItem("notesFlashWhenPlayed", this.notesFlashWhenPlayed ? "true" : "false");
            window.localStorage.setItem("volume", String(this.volume));
            window.localStorage.setItem("visibleOctaves", String(this.visibleOctaves));
            window.localStorage.setItem("keyboardLayout", this.keyboardLayout);
        }
        setVolume(val) {
            this.volume = val;
            this.savePreferences();
            this.synth.volume = this._calcVolume();
        }
        _calcVolume() {
            return Math.min(1.0, Math.pow(this.volume / 50.0, 0.5)) * Math.pow(2.0, (this.volume - 75.0) / 25.0);
        }
        getCurrentPattern(barOffset = 0) {
            return this.song.getPattern(this.channel, this.bar + barOffset);
        }
        getCurrentInstrument(barOffset = 0) {
            if (barOffset == 0) {
                return this.viewedInstrument[this.channel];
            }
            else {
                const pattern = this.getCurrentPattern(barOffset);
                return pattern == null ? 0 : pattern.instruments[0];
            }
        }
        getMobileLayout() {
            return (this.layout == "wide") ? window.innerWidth <= 1000 : window.innerWidth <= 71;
        }
        getBarWidth() {
            return (!this.getMobileLayout() && this.enableChannelMuting && (!this.getFullScreen() || this.layout == "wide")) ? 30 : 32;
        }
        getChannelHeight() {
            const squashed = this.getMobileLayout() || this.song.getChannelCount() > 4 || (this.song.barCount > this.trackVisibleBars && this.song.getChannelCount() > 3);
            const megaSquashed = !this.getMobileLayout() && (((this.layout != "wide") && this.song.getChannelCount() > 11) || this.song.getChannelCount() > 22);
            return megaSquashed ? 23 : (squashed ? 27 : 32);
        }
        getFullScreen() {
            return !this.getMobileLayout() && (this.layout != "small");
        }
        getVisibleOctaveCount() {
            return this.getFullScreen() ? this.visibleOctaves : SongDocument.defaultVisibleOctaves;
        }
        getVisiblePitchCount() {
            return this.getVisibleOctaveCount() * Config.pitchesPerOctave + 1;
        }
        getBaseVisibleOctave(channel) {
            const visibleOctaveCount = this.getVisibleOctaveCount();
            return Math.max(0, Math.min(Config.pitchOctaves - visibleOctaveCount, Math.ceil(this.song.channels[channel].octave - visibleOctaveCount * 0.5)));
        }
    }
    SongDocument.defaultVisibleOctaves = 3;
    SongDocument._maximumUndoHistory = 300;

    const doc = new SongDocument();
    const editor = new SongEditor(doc);
    updateThemes()
    const beepboxEditorContainer = document.getElementById("beepboxEditorContainer");
    beepboxEditorContainer.appendChild(editor.mainLayer);
    editor.whenUpdated();
    editor.mainLayer.className += " load";
    editor.mainLayer.getElementsByClassName("pattern-area")[0].className += " load";
    editor.mainLayer.getElementsByClassName("settings-area")[0].className += " load";
    editor.mainLayer.getElementsByClassName("editor-song-settings")[0].className += " load";
    editor.mainLayer.getElementsByClassName("instrument-settings-area")[0].className += " load";
    editor.mainLayer.getElementsByClassName("trackAndMuteContainer")[0].className += " load";
    editor.mainLayer.getElementsByClassName("barScrollBar")[0].className += " load";
    $('#pitchPresetSelect').select2({ dropdownAutoWidth: true });
    $('#drumPresetSelect').select2({ dropdownAutoWidth: true });
    $("body").on('click', '.select2-container--open .select2-results__group', function () {
        $(this).siblings().toggle();
    });
    $("#pitchPresetSelect").on('select2:open', function () {
        $('.select2-dropdown--below').css('opacity', 0);
        $('.select2-dropdown').css('opacity', 1);
        $('#pitchPresetSelect');
        setTimeout(() => {
            let groups = $('.select2-container--open .select2-results__group');
            let options = $('.select2-container--open .select2-results__option');
            $.each(groups, (index, v) => {
                $(v).siblings().hide();
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(doc.song, doc.channel).primaryNote + ";");
            });
            $.each(options, (index, v) => {
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(doc.song, doc.channel).primaryNote + ";");
            });
            $('.select2-dropdown--below').css('opacity', 1);
        }, 0);
    });
    $("#drumPresetSelect").on('select2:open', function () {
        $('.select2-dropdown--below').css('opacity', 0);
        $('.select2-dropdown').css('opacity', 1);
        $('#drumPresetSelect');
        setTimeout(() => {
            let groups = $('.select2-container--open .select2-results__group');
            let options = $('.select2-container--open .select2-results__option');
            $.each(groups, (index, v) => {
                $(v).siblings().hide();
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(doc.song, doc.channel).primaryNote + ";");
            });
            $.each(options, (index, v) => {
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(doc.song, doc.channel).primaryNote + ";");
            });
            $('.select2-dropdown--below').css('opacity', 1);
        }, 0);
    });
    $('#pitchPresetSelect').on("change", editor._whenSetPitchedPreset);
    $('#pitchPresetSelect').on("select2:close", editor._refocus);
    $('#drumPresetSelect').on("change", editor._whenSetDrumPreset);
    $('#drumPresetSelect').on("select2:close", editor._refocus);
    editor.mainLayer.focus();
    if (!isMobile && doc.autoPlay) {
        function autoplay() {
            if (!document.hidden) {
                doc.synth.play();
               editor.updatePlayButton();
                window.removeEventListener("visibilitychange", autoplay);
            }
        }
        if (document.hidden) {
            window.addEventListener("visibilitychange", autoplay);
        }
        else {
            autoplay();
        }
    }
    if ("scrollRestoration" in history)
        history.scrollRestoration = "manual";
   editor.updatePlayButton();
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/service_worker.js", { updateViaCache: "all", scope: "/" }).catch(() => { });
    }

    exports.ChangePreset = ChangePreset;
    exports.Channel = Channel;
    exports.ColorConfig = ColorConfig;
    exports.Config = Config;
    exports.EditorConfig = EditorConfig;
    exports.ExportPrompt = ExportPrompt;
    exports.Instrument = Instrument;
    exports.Note = Note;
    exports.Pattern = Pattern;
    exports.SongDocument = SongDocument;
    exports.SongEditor = SongEditor;
    exports.Synth = Synth;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}));
}catch (error){
    alert(error)
}
},800);
