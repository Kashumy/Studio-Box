var beepbox
function RUNBEEPBOX(){
	if(runned)return;runned=1
try {
    function readNBitsPerChar(source, charIndex, bitsPerChar, bitCount) {
  let value = 0;
  let bitsRead = 0;
  const baseCharCodeToInt = bitsPerChar === 6 ? base64CharCodeToInt : base128CharCodeToInt;
  while (bitsRead < bitCount) {
    const val = baseCharCodeToInt[source.charCodeAt(charIndex++)];
    value = (value << bitsPerChar) | val;
    bitsRead += bitsPerChar;
  }
 const extraBits = bitsRead - bitCount;
  if (extraBits > 0) {
    value = value >>> extraBits;
  }
  return { value, charIndex };
}
 beepbox = (function(exports) {
   'use strict';
    /*! Copyright (c) 2012-2022 John Nesky and contributing authors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
    var __awaiter$1 = (exports && exports.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var _a$1;
    const TypePresets = ["chip", "FM", "noise", "spectrum", "drumset", "harmonics", "pulse width", "picked string", "supersaw", "chip (custom)", "mod", "FM (6-op)","ADV FM (8-op)"];
    function getSampleLoadingStatusName(status) {
        switch (status) {
            case 0: return "loading";
            case 1: return "loaded";
            case 2: return "error";
        }
    }
    
    const sampleLoadEvents = new SampleLoadEvents(); 
    function startLoadingSample(url, chipWaveIndex, presetSettings, rawLoopOptions, customSampleRate) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const sampleLoaderAudioContext = new AudioContext({ sampleRate: customSampleRate });
            let closedSampleLoaderAudioContext = false;
            const chipWave = Config.chipWaves[chipWaveIndex];
            const rawChipWave = Config.rawChipWaves[chipWaveIndex];
            const rawRawChipWave = Config.rawRawChipWaves[chipWaveIndex];
            if (OFFLINE) {
                if (url.slice(0, 5) === "file:") {
                    const dirname = yield getDirname();
                    const joined = yield pathJoin(dirname, url.slice(5));
                    url = joined;
                }
            }
            fetch(url).then((response) => { 
                if (!response.ok) {
                    sampleLoadingState.statusTable[chipWaveIndex] = 2;
                    return Promise.reject(new Error("Couldn't load sample"));
                }
                return response.arrayBuffer();
            }).then((arrayBuffer) => {
                return sampleLoaderAudioContext.decodeAudioData(arrayBuffer);
            }).then((audioBuffer) => {
                const samples = centerWave(Array.from(audioBuffer.getChannelData(0)));
                const integratedSamples = performIntegral(samples);
                chipWave.samples = integratedSamples;
                rawChipWave.samples = samples;
                rawRawChipWave.samples = samples;
                if (rawLoopOptions["isUsingAdvancedLoopControls"]) {
                    presetSettings["chipWaveLoopStart"] = rawLoopOptions["chipWaveLoopStart"] != null ? rawLoopOptions["chipWaveLoopStart"] : 0;
                    presetSettings["chipWaveLoopEnd"] = rawLoopOptions["chipWaveLoopEnd"] != null ? rawLoopOptions["chipWaveLoopEnd"] : samples.length - 1;
                    presetSettings["chipWaveLoopMode"] = rawLoopOptions["chipWaveLoopMode"] != null ? rawLoopOptions["chipWaveLoopMode"] : 0;
                    presetSettings["chipWavePlayBackwards"] = rawLoopOptions["chipWavePlayBackwards"];
                    presetSettings["chipWaveStartOffset"] = rawLoopOptions["chipWaveStartOffset"] != null ? rawLoopOptions["chipWaveStartOffset"] : 0;
                }
                sampleLoadingState.samplesLoaded++;
                sampleLoadingState.statusTable[chipWaveIndex] = 1;
                sampleLoadEvents.dispatchEvent(new SampleLoadedEvent(sampleLoadingState.totalSamples, sampleLoadingState.samplesLoaded));
                if (!closedSampleLoaderAudioContext) {
                    closedSampleLoaderAudioContext = true;
                    sampleLoaderAudioContext.close();
                }
            }).catch((error) => {
                sampleLoadingState.statusTable[chipWaveIndex] = 2;
                POPUP(innerWidth/2-150, innerHeight/2-100 + window.scrollY,"Warning", "Failed to load " + url + ":\n" + error, "#00afdf");
                if (!closedSampleLoaderAudioContext) {
                    closedSampleLoaderAudioContext = true;
                    sampleLoaderAudioContext.close();
                }
            });
        });
    }
    function getLocalStorageItem(key, defaultValue) {
        let value = localStorage.getItem(key);
        if (value == null || value === "null" || value === "undefined") {
            value = defaultValue;
        }
        return value;
    }
 
    function drawNoiseSpectrum(wave, waveLength, lowOctave, highOctave, lowPower, highPower, overallSlope) {
        const referenceOctave = 11;
        const referenceIndex = 1 << referenceOctave;
        const lowIndex = Math.pow(2, lowOctave) | 0;
        const highIndex = Math.min(waveLength >> 1, Math.pow(2, highOctave) | 0);
        const retroWave = getDrumWave(0, null, null);
        let combinedAmplitude = 0.0;
        for (let i = lowIndex; i < highIndex; i++) {
            let lerped = lowPower + (highPower - lowPower) * (Math.log2(i) - lowOctave) / (highOctave - lowOctave);
            let amplitude = Math.pow(2, (lerped - 1) * 7 + 1) * lerped;
            amplitude *= Math.pow(i / referenceIndex, overallSlope);
            combinedAmplitude += amplitude;
            amplitude *= retroWave[i];
            const radians = 0.61803398875 * i * i * Math.PI * 2.0;
            wave[i] = Math.cos(radians) * amplitude;
            wave[waveLength - i] = Math.sin(radians) * amplitude;
        }
        return combinedAmplitude;
    }
    function getArpeggioPitchIndex(pitchCount, useFastTwoNoteArp, arpeggio) {
        let arpeggioPattern = Config.arpeggioPatterns[pitchCount - 1];
        if (arpeggioPattern != null) {
            if (pitchCount == 2 && useFastTwoNoteArp == false) {
                arpeggioPattern = [0, 0, 1, 1];
            }
            return arpeggioPattern[arpeggio % arpeggioPattern.length];
        }
        else {
            return arpeggio % pitchCount;
        }
    }
    updateSampledWaves();
    function toNameMap(array) {
    	const dictionary = {};
    	for (let i = 0; i < array.length; i++) {
    		const value = array[i];
    		value.index = i;
    		dictionary[value.name] = value;
    	}
    	const result = array;
    	result.dictionary = dictionary;
    	return result;
    }
    function effectsIncludeTransition(effects) {
        return (effects & (1 << 10)) != 0;
    }
    function effectsIncludeChord(effects) {
        return (effects & (1 << 11)) != 0;
    }
    function effectsIncludePitchShift(effects) {
        return (effects & (1 << 7)) != 0;
    }
    function effectsIncludeDetune(effects) {
        return (effects & (1 << 8)) != 0;
    }
    function effectsIncludeVibrato(effects) {
        return (effects & (1 << 9)) != 0;
    }
    function effectsIncludeNoteFilter(effects) {
        return (effects & (1 << 5)) != 0;
    }
    function effectsIncludeDistortion(effects) {
        return (effects & (1 << 3)) != 0;
    }
    function effectsIncludeBitcrusher(effects) {
        return (effects & (1 << 4)) != 0;
    }
    function effectsIncludePanning(effects) {
        return (effects & (1 << 2)) != 0;
    }
    function effectsIncludeChorus(effects) {
        return (effects & (1 << 1)) != 0;
    }
    function effectsIncludeEcho(effects) {
        return (effects & (1 << 6)) != 0;
    }
    function effectsIncludeReverb(effects) {
        return (effects & (1 << 0)) != 0;
    }
    function effectsIncludeRingModulation(effects) {
        return (effects & (1 << 13)) != 0;
    }
    function effectsIncludeGranular(effects) {
        return (effects & (1 << 14)) != 0;
    }
    function effectsIncludeOctaveShift(effects) { 
       	return (effects & (1 << 15)) != 0;
    }
    function effectsIncludePhaser(effects) { 
      	return (effects & (1 << 16)) != 0;
    }
    function effectsIncludeFunction(effects) {
        return (effects & (1 << 17)) != 0;
    }
    function calculateRingModHertz(sliderHz, sliderHzOffset = 0) {
        if (sliderHz == 0)
            return 0;
        if (sliderHz > 0)
            sliderHz -= 1 / Config.ringModHzRange;
        if (sliderHz > 1 / Config.ringModHzRange)
            sliderHz += 1 / Config.ringModHzRange;
        return Math.floor(Config.ringModMinHz * Math.pow(Config.ringModMaxHz / Config.ringModMinHz, sliderHz));
    }
    
function rawChipToIntegrated(raw) {
	const newArray = new Array(raw.length);
	const dictionary = {};
	for (let i = 0; i < newArray.length; i++) {
		newArray[i] = Object.assign([], raw[i]);
		const value = newArray[i];
		value.index = i;
		dictionary[value.name] = value;
	}
	for (let key in dictionary) {
		dictionary[key].samples = performIntegral(dictionary[key].samples);
	}
	const result = newArray;
	result.dictionary = dictionary;
	return result;
}
function rawChipToIntegrated2(raw) {
	const newArray = new Array(raw.length);
	const dictionary = {};
	for (let i = 0; i < newArray.length; i++) {
		newArray[i] = Object.assign([], raw[i]);
		const value = newArray[i];
		value.index = i;
		dictionary[value.name] = value;
	}
	for (let key in dictionary) {
		dictionary[key].samples = performIntegral(dictionary[key].samples);
	}
	const result = raw;
	result.dictionary = dictionary;
	return result;
}
    function prettyNumber(value) {
        return value.toFixed(2).replace(/\.?0*$/, "");
    }
   


    var __values$1 = (exports && exports.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = (exports && exports.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (exports && exports.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    function applyElementArgs(element, args) {
        var e_1, _a, e_2, _b, e_3, _c;
        try {
            for (var args_1 = __values$1(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                if (arg instanceof Node) {
                    element.appendChild(arg);
                }
                else if (typeof arg === "string") {
                    element.appendChild(document.createTextNode(arg));
                }
                else if (typeof arg === "function") {
                    applyElementArgs(element, [arg()]);
                }
                else if (Array.isArray(arg)) {
                    applyElementArgs(element, arg);
                }
                else if (arg && typeof Symbol !== "undefined" && typeof arg[Symbol.iterator] === "function") {
                    applyElementArgs(element, __spread(arg));
                }
                else if (arg && arg.constructor === Object && element instanceof Element) {
                    try {
                        for (var _d = (e_2 = void 0, __values$1(Object.keys(arg))), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var key = _e.value;
                            var value = arg[key];
                            if (key === "class") {
                                if (typeof value === "string") {
                                    element.setAttribute("class", value);
                                }
                                else if (Array.isArray(arg) || (value && typeof Symbol !== "undefined" && typeof value[Symbol.iterator] === "function")) {
                                    element.setAttribute("class", __spread(value).join(" "));
                                }
                                else {
                                    console.warn("Invalid " + key + " value \"" + value + "\" on " + element.tagName + " element.");
                                }
                            }
                            else if (key === "style") {
                                if (value && value.constructor === Object) {
                                    try {
                                        for (var _f = (e_3 = void 0, __values$1(Object.keys(value))), _g = _f.next(); !_g.done; _g = _f.next()) {
                                            var styleKey = _g.value;
                                            if (styleKey in element.style) {
                                                element.style[styleKey] = value[styleKey];
                                            }
                                            else {
                                                element.style.setProperty(styleKey, value[styleKey]);
                                            }
                                        }
                                    }
                                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                    finally {
                                        try {
                                            if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                                        }
                                        finally { if (e_3) throw e_3.error; }
                                    }
                                }
                                else {
                                    element.setAttribute(key, value);
                                }
                            }
                            else if (typeof (value) === "function") {
                                element[key] = value;
                            }
                            else if (typeof (value) === "boolean") {
                                if (value)
                                    element.setAttribute(key, "");
                                else
                                    element.removeAttribute(key);
                            }
                            else {
                                element.setAttribute(key, value);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                else {
                    element.appendChild(document.createTextNode(arg));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return element;
    }
    var svgNS = "http://www.w3.org/2000/svg";
    function parseHTML() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return document.createRange().createContextualFragment(args.join());
    }
    function parseSVG() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var fragment = document.createDocumentFragment();
        var svgParser = new DOMParser().parseFromString("<svg xmlns=\"http://www.w3.org/2000/svg\">" + args.join() + "</svg>", "image/svg+xml").documentElement;
        while (svgParser.firstChild !== null) {
            document.importNode(svgParser.firstChild, true);
            fragment.appendChild(svgParser.firstChild);
        }
        return fragment;
    }

    var __values = (exports && exports.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a, e_2, _b;
    var HTML = parseHTML;
    var SVG = parseSVG;
    var _loop_1 = function (name_1) {
        HTML[name_1] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return applyElementArgs(document.createElement(name_1), args);
        };
    };
    try {
        for (var _c = __values("a abbr address area article aside audio b base bdi bdo blockquote br button canvas caption cite code col colgroup datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hr i iframe img input ins kbd label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td template textarea tfoot th thead time title tr track u ul var video wbr".split(" ")), _d = _c.next(); !_d.done; _d = _c.next()) {
            var name_1 = _d.value;
            _loop_1(name_1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_2 = function (name_2) {
        SVG[name_2] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return applyElementArgs(document.createElementNS(svgNS, name_2), args);
        };
        if (/-/.test(name_2)) {
            var snakeCaseName = name_2.replace(/-/g, "_");
            SVG[snakeCaseName] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return applyElementArgs(document.createElementNS(svgNS, name_2), args);
            };
        }
    };
    try {
        for (var _e = __values("a altGlyph altGlyphDef altGlyphItem animate animateMotion animateTransform circle clipPath color-profile cursor defs desc discard ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence filter font font-face font-face-format font-face-name font-face-src font-face-uri foreignObject g glyph glyphRef hkern image line linearGradient marker mask metadata missing-glyph mpath path pattern polygon polyline radialGradient rect script set stop style svg switch symbol text textPath title tref tspan use view vkern".split(" ")), _f = _e.next(); !_f.done; _f = _e.next()) {
            var name_2 = _f.value;
            _loop_2(name_2);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
updateThemes = function() {
	if (CustomThemes) {
		ColorConfig.themes = { ...ColorConfig.themes, ...CustomThemes };
		if(!skipsamplesLoading){
		const colorTheme = getLocalStorageItem("colorTheme");
ColorConfig.setTheme(colorTheme === null ? ColorConfig.defaultTheme : colorTheme);
}
	}
}
updateThemes()
    const scrollBarTest = document.body.appendChild(HTML.div({ style: "width:30px; height:30px; overflow: auto;" }, HTML.div({ style: "width:100%;height:40px" })));
    if (scrollBarTest.firstChild.clientWidth < 30) {
        document.documentElement.classList.add("obtrusive-scrollbars");
    }
    document.body.removeChild(scrollBarTest);
    document.head.appendChild(HTML.style({ type: "text/css" }, `
body::selection {
  -webkit-text-fill-color: #ffe08a;
  -webkit-text-stroke: 0px;    
  background: rgba(0,0,1,0.5); 
}
.selectRow {
  height: auto !important;
}

/* Note: "#" symbols need to be encoded as "%23" in SVG data urls, otherwise they are interpreted as fragment identifiers! */
:root {
	--button-size: 26px;
	--settings-area-width: 192px;
	--internal-play-symbol: var(--play-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M -5 -8 L -5 8 L 8 0 z" fill="gray"/></svg>'));
	--internal-pause-symbol: var(--pause-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="-5" y="-7" width="4" height="14" fill="gray"/><rect x="3" y="-7" width="4" height="14" fill="gray"/></svg>'));
	--internal-record-symbol: var(--record-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><circle cx="0" cy="0" r="6" fill="gray"/></svg>'));
	--internal-stop-symbol: var(--stop-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="-6" y="-6" width="12" height="12" fill="gray"/></svg>'));
	--internal-prev-bar-symbol: var(--prev-bar-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="-6" y="-6" width="2" height="12" fill="gray"/><path d="M 6 -6 L 6 6 L -3 0 z" fill="gray"/></svg>'));
	--internal-next-bar-symbol: var(--next-bar-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><rect x="4" y="-6" width="2" height="12" fill="gray"/><path d="M -6 -6 L -6 6 L 3 0 z" fill="gray"/></svg>'));
	--internal-volume-symbol: var(--volume-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"><path d="M 4 16 L 4 10 L 8 10 L 13 5 L 13 21 L 8 16 z M 15 11 L 16 10 A 7.2 7.2 0 0 1 16 16 L 15 15 A 5.8 5.8 0 0 0 15 12 z M 18 8 L 19 7 A 11.5 11.5 0 0 1 19 19 L 18 18 A 10.1 10.1 0 0 0 18 8 z" fill="gray"/></svg>'));
	--internal-unmuted-symbol: var(--unmuted-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="3 3 20 20"><path d="M 4 16 L 4 10 L 8 10 L 13 5 L 13 21 L 8 16 z M 15 11 L 16 10 A 7.2 7.2 0 0 1 16 16 L 15 15 A 5.8 5.8 0 0 0 15 12 z M 18 8 L 19 7 A 11.5 11.5 0 0 1 19 19 L 18 18 A 10.1 10.1 0 0 0 18 8 z" fill="gray"/></svg>'));
	--internal-muted-symbol: var(--muted-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="3 3 20 20"><path d="M 4 16 L 4 10 L 8 10 L 13 5 L 13 21 L 8 16 z" fill="gray"/></svg>'));
	--internal-menu-down-symbol: var(--menu-down-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M -4 -2 L 4 -2 L 0 3 z" fill="gray"/></svg>'));
	--internal-select-arrows-symbol: var(--select-arrows-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M -4 -3 L 4 -3 L 0 -8 z M -4 3 L 4 3 L 0 8 z" fill="gray"/></svg>'));
	--internal-file-page-symbol: var(--file-page-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-5 -21 26 26"><path d="M 2 0 L 2 -16 L 10 -16 L 14 -12 L 14 0 z M 3 -1 L 13 -1 L 13 -11 L 9 -11 L 9 -15 L 3 -15 z" fill="gray"/></svg>'));
	--internal-edit-pencil-symbol: var(--edit-pencil-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-5 -21 26 26"><path d="M 0 0 L 1 -4 L 4 -1 z M 2 -5 L 10 -13 L 13 -10 L 5 -2 zM 11 -14 L 13 -16 L 14 -16 L 16 -14 L 16 -13 L 14 -11 z" fill="gray"/></svg>'));
	--internal-preferences-gear-symbol: var(--preferences-gear-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M 5.78 -1.6 L 7.93 -0.94 L 7.93 0.94 L 5.78 1.6 L 4.85 3.53 L 5.68 5.61 L 4.21 6.78 L 2.36 5.52 L 0.27 5.99 L -0.85 7.94 L -2.68 7.52 L -2.84 5.28 L -4.52 3.95 L -6.73 4.28 L -7.55 2.59 L -5.9 1.07 L -5.9 -1.07 L -7.55 -2.59 L -6.73 -4.28 L -4.52 -3.95 L -2.84 -5.28 L -2.68 -7.52 L -0.85 -7.94 L 0.27 -5.99 L 2.36 -5.52 L 4.21 -6.78 L 5.68 -5.61 L 4.85 -3.53 M 2.92 0.67 L 2.92 -0.67 L 2.35 -1.87 L 1.3 -2.7 L 0 -3 L -1.3 -2.7 L -2.35 -1.87 L -2.92 -0.67 L -2.92 0.67 L -2.35 1.87 L -1.3 2.7 L -0 3 L 1.3 2.7 L 2.35 1.87 z" fill="gray"/></svg>'));  
	--internal-customize-dial-symbol: var(--customize-dial-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"> \
			<g transform="translate(0,1)" fill="gray"> \
				<circle cx="0" cy="0" r="6.5" stroke="gray" stroke-width="1" fill="none"/> \
				<rect x="-1" y="-5" width="2" height="4" transform="rotate(30)"/> \
				<circle cx="-7.79" cy="4.5" r="0.75"/> \
				<circle cx="-9" cy="0" r="0.75"/> \
				<circle cx="-7.79" cy="-4.5" r="0.75"/> \
				<circle cx="-4.5" cy="-7.79" r="0.75"/> \
				<circle cx="0" cy="-9" r="0.75"/> \
				<circle cx="4.5" cy="-7.79" r="0.75"/> \
				<circle cx="7.79" cy="-4.5" r="0.75"/> \
				<circle cx="9" cy="0" r="0.75"/> \
				<circle cx="7.79" cy="4.5" r="0.75"/> \
			</g> \
		</svg>'));
	--internal-instrument-copy-symbol: var(--instrument-copy-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-5 -21 26 26"><path d="M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z" fill="currentColor"></path></svg>'));
	--internal-instrument-paste-symbol: var(--instrument-paste-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"><path d="M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z" stroke="currentColor" fill="none"></path><path d="M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z" fill="currentColor"></path></svg>'));
	--internal-export-symbol: var(--export-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -8 3 L -8 8 L 8 8 L 8 3 L 6 3 L 6 6 L -6 6 L -6 3 z M 0 2 L -4 -2 L -1 -2 L -1 -8 L 1 -8 L 1 -2 L 4 -2 z"/></svg>'));
	--internal-close-symbol: var(--close-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -7.07 -5.66 L -5.66 -7.07 L 0 -1.4 L 5.66 -7.07 L 7.07 -5.66 L 1.4 0 L 7.07 5.66 L 5.66 7.07 L 0 1.4 L -5.66 7.07 L -7.07 5.66 L -1.4 0 z"/></svg>'));
	--internal-add-symbol: var(--add-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -8 -1 L -1 -1 L -1 -8  L 1 -8 L 1 -1 L 8 -1 L 8 1 L 1 1 L 1 8 L -1 8 L -1 1 L -8 1 z"/></svg>'));
	--internal-zoom-in-symbol: var(--zoom-in-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="-10 -10 20 20"><circle cx="-1" cy="-1" r="6" stroke-width="2" stroke="gray" fill="none"></circle><path stroke="gray" stroke-width="2" d="M 3 3 L 7 7 M -1 -4 L -1 2 M -4 -1 L 2 -1" fill="none"></path></svg>'));
	--internal-zoom-out-symbol: var(--zoom-out-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="-10 -10 20 20"><circle cx="-1" cy="-1" r="6" stroke-width="2" stroke="gray" fill="none"></circle><path stroke="gray" stroke-width="2" d="M 3 3 L 7 7 M -4 -1 L 2 -1" fill="none"></path></svg>'));
	--internal-checkmark-symbol: var(--checkmark-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -9 -2 L -8 -3 L -3 2 L 9 -8 L 10 -7 L -3 8 z"/></svg>'));
	--internal-drum-symbol: var(--drum-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="40" viewBox="0 0 32 40"> \
			<defs> \
				<linearGradient id="gold1" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="%237e3302"/> \
					<stop offset="40%" stop-color="%23ffec6b"/> \
					<stop offset="100%" stop-color="%237e3302"/> \
				</linearGradient> \
				<linearGradient id="gold2" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="%23faaf7d"/> \
					<stop offset="15%" stop-color="%23fffba9"/> \
					<stop offset="40%" stop-color="%23ffffe3"/> \
					<stop offset="65%" stop-color="%23fffba9"/> \
					<stop offset="100%" stop-color="%23faaf7d"/> \
				</linearGradient> \
				<radialGradient id="gold3" cx="0%" cy="0%" r="100%"> \
					<stop offset="0%" stop-color="%23ffffe3"/> \
					<stop offset="50%" stop-color="%23ffec6b"/> \
					<stop offset="100%" stop-color="%237e3302"/> \
				</radialGradient> \
				<linearGradient id="red" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="%23641919"/> \
					<stop offset="40%" stop-color="%23cd2c2c"/> \
					<stop offset="100%" stop-color="%23641919"/> \
				</linearGradient> \
				<radialGradient id="membrane"> \
					<stop offset="10%" stop-color="%23cccccc" /> \
					<stop offset="90%" stop-color="%23f6f6f7" /> \
					<stop offset="100%" stop-color="%23999" /> \
				</radialGradient> \
			</defs> \
			<ellipse cx="16" cy="26" rx="16" ry="14" fill="rgba(0,0,0,0.5)"/> \
			<ellipse cx="16" cy="25" rx="16" ry="14" fill="url(%23gold1)"/> \
			<rect x="0" y="23" width="32" height="2" fill="url(%23gold1)"/> \
			<ellipse cx="16" cy="23" rx="16" ry="14" fill="url(%23gold2)"/> \
			<ellipse cx="16" cy="23" rx="15" ry="13" fill="url(%23red)"/> \
			<rect x="1" y="17" width="30" height="6" fill="url(%23red)"/> \
			<rect x="5" y="27" width="1" height="5" rx="0.5" fill="rgba(0,0,0,0.5)"/> \
			<rect x="15" y="31" width="2" height="5" rx="1" fill="rgba(0,0,0,0.5)"/> \
			<rect x="26" y="27" width="1" height="5" rx="0.5" fill="rgba(0,0,0,0.5)"/> \
			<rect x="5" y="26" width="1" height="5" rx="0.5" fill="url(%23gold3)"/> \
			<rect x="15" y="30" width="2" height="5" rx="1" fill="url(%23gold3)"/> \
			<rect x="26" y="26" width="1" height="5" rx="0.5" fill="url(%23gold3)"/> \
			<ellipse cx="16" cy="18" rx="15" ry="13" fill="rgba(0,0,0,0.5)"/> \
			<ellipse cx="16" cy="16" rx="16" ry="14" fill="url(%23gold1)"/> \
			<rect x="0" y="14" width="32" height="2" fill="url(%23gold1)"/> \
			<ellipse cx="16" cy="14" rx="16" ry="14" fill="url(%23gold2)"/> \
			<ellipse cx="16" cy="14" rx="15" ry="13" fill="url(%23membrane)"/> \
		</svg>'));
	--internal-piano-key-symbol: var(--piano-key-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="15" preserveAspectRatio="none" viewBox="0 -1 32 15"> \
			<defs> \
				<linearGradient id="shadow" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="rgba(0,0,0,0.5)"/> \
					<stop offset="100%" stop-color="transparent"/> \
				</linearGradient> \
			</defs> \
			<rect x="-1" y="1" width="31" height="1" rx="0.6" fill="rgba(255,255,255,0.4)"/> \
			<path d="M -1 11 L 30 11 L 30 2 L 33 -1 L 33 14 L -1 14 z" fill="rgba(0,0,0,0.7)"/> \
			<rect x="-1" y="-1" width="19" height="15" fill="url(%23shadow)"/> \
		</svg>'));
  --internal-mod-key-symbol: var(--mod-key-symbol, url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="80" preserveAspectRatio="none" viewBox="0 -1 32 80"> \
			<defs> \
				<linearGradient id="shadow" x1="0%" y1="0%" x2="100%" y2="0%"> \
					<stop offset="0%" stop-color="rgba(0,0,0,0.4)"/> \
					<stop offset="100%" stop-color="transparent"/> \
				</linearGradient> \
			</defs> \
			<rect x="-1" y="1" width="31" height="1" rx="0.6" fill="rgba(255,255,255,0.2)"/> \
			<path d="M -1 76 L 30 76 L 30 1 L 33 -1 L 33 80 L -1 80 z" fill="rgba(0,0,0,0.7)"/> \
			<rect x="-1" y="-1" width="19" height="80" fill="url(%23shadow)"/> \
		</svg>'));
}


html {
	scrollbar-color: var(--scrollbar-color, ${ColorConfig.uiWidgetBackground}) var(--scrollbar-background, ${ColorConfig.editorBackground});
}
input[type=file]{
	outline:none; border:none;
}
.obtrusive-scrollbars, .obtrusive-scrollbars * {
	scrollbar-width: thin;
}
.obtrusive-scrollbars::-webkit-scrollbar, .obtrusive-scrollbars *::-webkit-scrollbar {
	width: 12px; 
}
.obtrusive-scrollbars::-webkit-scrollbar-track, .obtrusive-scrollbars *::-webkit-scrollbar-track {
	background: ${ColorConfig.editorBackground};
}
.obtrusive-scrollbars::-webkit-scrollbar-thumb, .obtrusive-scrollbars *::-webkit-scrollbar-thumb {
	background-color: ${ColorConfig.uiWidgetBackground};
	border: 3px solid ${ColorConfig.editorBackground};
}

.beepboxEditor {
	display: grid;
    grid-template-columns: minmax(0, 1fr) max-content;
    grid-template-rows: max-content 1fr; /* max-content minmax(0, 1fr); Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */
    grid-template-areas: "pattern-area settings-area" "track-area settings-area";
	grid-column-gap: 6px;
	grid-row-gap: 6px;
	position: relative;
	touch-action: manipulation;
	cursor: default;
	font-size: 13px;
	overflow: hidden;
	color: ${ColorConfig.primaryText};
	background: ${ColorConfig.editorBackground};
    opacity: 0;
    -webkit-transition: opacity 0.2s ease-in;
    -moz-transition: opacity 0.2s ease-in;
    -o-transition: opacity 0.2s ease-in;
    -ms-transition: opacity 0.2s ease-in;
    transition: opacity 0.2s ease-in;
    transition-delay: 0s;
}

.beepboxEditor .operatorRow {
	margin: 2px 0;
	height: 2em;
	display: flex;
	flex-direction: row;
	align-items: center;
}

.beepboxEditor .operatorRow > * {
	flex-grow: 1;
	flex-shrink: 1;
}
 
.pattern-area {
     opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0s;
}

.settings-area {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.15s;
}

.editor-song-settings {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.35s;
}

.instrument-settings-area {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.45s;
}

.trackAndMuteContainer {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.4s;
}

.barScrollBar {
    opacity: 0;
    -webkit-transition: opacity 0.5s ease-in;
    -moz-transition: opacity 0.5s ease-in;
    -o-transition: opacity 0.5s ease-in;
    -ms-transition: opacity 0.5s ease-in;
    transition: opacity 0.5s ease-in;
    transition-delay: 0.5s;
}



.load {
    opacity: 1;
}

.beepboxEditor .noSelection {
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}

.beepboxEditor div {
	margin: 0;
	padding: 0;
}

.beepboxEditor .pattern-area {
	grid-area: pattern-area;
	height: 481px;
	display: flex;
	flex-direction: row;
	position: relative;
}

.beepboxEditor .track-area {
	grid-area: track-area;
	background-image: url(${getLocalStorageItem("customTheme2", "")});
}

.beepboxEditor .loopEditor {
	height: 20px;
	position: sticky;
	bottom: 0;
	padding: 5px 0;
	background-color: ${ColorConfig.editorBackground};
}

.beepboxEditor .settings-area {
	grid-area: settings-area;
	display: grid;
    grid-template-columns: auto;
    grid-template-rows: min-content min-content min-content min-content min-content;
    grid-template-areas: "version-area" "play-pause-area" "menu-area" "song-settings-area" "instrument-settings-area";
	grid-column-gap: 6px;
}

.beepboxEditor .version-area{ grid-area: version-area; }
.beepboxEditor .play-pause-area{ grid-area: play-pause-area; }
.beepboxEditor .menu-area{ grid-area: menu-area; }
.beepboxEditor .song-settings-area{ grid-area: song-settings-area; }
.beepboxEditor .instrument-settings-area{ grid-area: instrument-settings-area; }

.beepboxEditor .tip {
	cursor: help;
	color: ${ColorConfig.secondaryText};
	text-decoration: none;
}

.beepboxEditor .tip:hover {
	color: ${ColorConfig.linkAccent};
	text-decoration: underline;
}
.beepboxEditor .tip:active {
	color: ${ColorConfig.primaryText};
}

.beepboxEditor .volume-speaker {
	flex-shrink: 0;
	width: var(--button-size);
	height: var(--button-size);
	background: ${ColorConfig.secondaryText};
	-webkit-mask-image: var(--internal-volume-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-volume-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .drum-button {
	flex: 1;
	background-color: transparent;
	background-image: var(--internal-drum-symbol);
	background-repeat: no-repeat;
	background-position: center;
}

.beepboxEditor .modulator-button {
	flex: 1;
	position: relative;
	display: flex;
	align-items: center;
}
.beepboxEditor .modulator-button::before {
	content: "";
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-image: var(--internal-mod-key-symbol);
	background-repeat: no-repeat;
	background-position: center;
	background-size: 100% 102%;
}

.beepboxEditor .piano-button {
	flex: 1;
	position: relative;
	display: flex;
	align-items: center;
}
.beepboxEditor .piano-button::before {
	content: "";
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-image: var(--internal-piano-key-symbol);
	background-repeat: no-repeat;
	background-position: center;
	background-size: 100% 115.38%;
}
.beepboxEditor .piano-button.disabled::after {
	content: "";
	position: absolute;
	right: 0;
	top: 0;
	width: 70%;
	height: 100%;
	pointer-events: none;
	background: ${ColorConfig.editorBackground};
	-webkit-mask-image: linear-gradient(90deg, transparent 0%, gray 70%, gray 100%);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: linear-gradient(90deg, transparent 0%, gray 70%, gray 100%);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .piano-button.pressed, .beepboxEditor .drum-button.pressed {
	filter: brightness(0.5);
}

.beepboxEditor .customize-instrument {
	margin: 2px 0;
}
.beepboxEditor .customize-instrument::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-customize-dial-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-customize-dial-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .instrumentCopyPasteRow {
	gap: 2px;
}

.beepboxEditor .copy-instrument {
	margin: 2px 0;
	flex-grow: 1;
}
.beepboxEditor .copy-instrument::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-instrument-copy-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-instrument-copy-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .paste-instrument {
	margin: 2px 0;
	flex-grow: 1;
}
.beepboxEditor .paste-instrument::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-instrument-paste-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-instrument-paste-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .envelopeEditor {
	display: flex;
	flex-direction: column;
}

.beepboxEditor .envelope-row {
	display: flex;
	margin: 2px 0;
	gap: 2px;
}

.beepboxEditor .add-envelope {
	width: var(--button-size);
}
.beepboxEditor .add-envelope::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-add-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-add-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .add-envelope:disabled {
	visibility: hidden;
}

.beepboxEditor .effects-menu {
	width: var(--button-size);
	position: relative;
}
.beepboxEditor .effects-menu::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-menu-down-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-menu-down-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .zoomInButton, .beepboxEditor .zoomOutButton {
	width: var(--button-size);
	position: absolute;
	right: 10px;
}
.beepboxEditor .zoomInButton {
	top: 10px;
}
.beepboxEditor .zoomOutButton {
	top: 50px;
}
.beepboxEditor .zoomInButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-zoom-in-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-zoom-in-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .zoomOutButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-zoom-out-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-zoom-out-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .delete-envelope {
	width: var(--button-size);
	flex-shrink: 0;
	flex-grow: 0;
}
.beepboxEditor .delete-envelope::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .delete-envelope:disabled {
	visibility: hidden;
}

.beepboxEditor .envelope-settings {
	width: var(--button-size);
	flex-shrink: 0;
	flex-grow: 0;
}
.beepboxEditor .envelope-settings::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-add-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-add-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}
.beepboxEditor .envelope-settings:disabled {
	visibility: hidden;
}

.beepboxEditor .menu.file::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-file-page-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-file-page-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .menu.edit::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-edit-pencil-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-edit-pencil-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .menu.preferences::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-preferences-gear-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-preferences-gear-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor .mute-button {
	background: transparent;
	border: none;
  padding-right: 0px;
  padding-left: 0px;
  box-shadow: none;
}

.beepboxEditor .mute-button:focus {
  background: transparent;
	border: none;
}

.beepboxEditor .mute-button::before {
	content: "";
	pointer-events: none;
	width: 100%;
	height: 100%;
	display: inline-block;
  background: var(--mute-button-normal);
	-webkit-mask-image: var(--internal-unmuted-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	-webkit-mask-size: cover;
  mask-repeat: no-repeat;
	mask-position: center;
	mask-size: cover;
  mask-image: var(--internal-unmuted-symbol);
}

.beepboxEditor .mute-button.muted::before {
  background: var(--ui-widget-background);
	-webkit-mask-image: var(--internal-muted-symbol);
  mask-image: var(--internal-muted-symbol);
}

.beepboxEditor .mute-button.modMute.muted::before {
  background: var(--ui-widget-background);
	-webkit-mask-image: var(--internal-muted-symbol);
  mask-image: var(--internal-muted-symbol);
}

.beepboxEditor .mute-button.modMute::before {
  background: var(--mute-button-mod);
}


html .promptContainer {
	position: fixed ;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: 100;
}


.promptContainer input[type=text], .promptContainer input[type=number] {
	font-size: inherit;
	font-weight: inherit;
	font-family: inherit;
	background: transparent;
	text-align: center;
	border: 1px solid ${ColorConfig.inputBoxOutline};
	color: ${ColorConfig.primaryText};
}

 

.promptContainer input[type=checkbox] {
  transform: scale(1.5);
}

.promptContainer input[type=range] {
	-webkit-appearance: none;
	color: inherit;
	width: 100%;
	height: var(--button-size);
	font-size: inherit;
	margin: 0;
	cursor: pointer;
	background: none;
	touch-action: pan-y;
  position: relative;
}
.promptContainer input[type=range]:focus {
	outline: none;
}
.promptContainer input[type=range]::-webkit-slider-runnable-track {
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
}


.promptContainer input[type=range]::-webkit-slider-thumb {
height: var(--button-size);
width: 6px;
border-radius: 3px;
background: currentColor;
cursor: pointer;
-webkit-appearance: none;
margin-top: -10px;
}
.promptContainer input[type=range]:focus::-webkit-slider-runnable-track {
background: ${ColorConfig.uiWidgetFocus};
}
.promptContainer input[type=range]::-moz-range-track {
width: 100%;
height: 6px;
cursor: pointer;
background: ${ColorConfig.uiWidgetBackground};
}
.promptContainer input[type=range]:focus::-moz-range-track {
background: ${ColorConfig.uiWidgetFocus};
}
.promptContainer input[type=range]::-moz-range-thumb {
height: var(--button-size);
width: 6px;
border-radius: 3px;
border: none;
background: currentColor;
cursor: pointer;
}
.promptContainer input[type=range]::-ms-track {
width: 100%;
height: 6px;
cursor: pointer;
background: ${ColorConfig.uiWidgetBackground};
border-color: transparent;
}
.promptContainer input[type=range]:focus::-ms-track {
background: ${ColorConfig.uiWidgetFocus};
}
.promptContainer input[type=range]::-ms-thumb {
height: var(--button-size);
width: 6px;
border-radius: 3px;
background: currentColor;
cursor: pointer;
}

html .prompt { 
position: absolute;
	margin: auto;
	text-align: center;
	background: ${ColorConfig.editorBackground};
	border-radius: 15px;
	border: 4px solid ${ColorConfig.uiWidgetBackground};
	color: ${ColorConfig.primaryText};
	padding: 20px;
	display: flex;
	flex-direction: column;
	max-height:80vh; overflow: hidden scroll;
	max-width:90vw;
	top: 50vh;
	left: 50vw;
	transform: translate(-50%,-50%);
	z-index: 101;
	box-shadow: 5px 5px 20px 10px rgba(0,0,0,0.5);
}

html .prompt > *:not(:first-child):not(.cancelButton) {
	margin-top: 8px;
}

html .prompt h2 {
	font-size: 2em;
	margin: 0 16px;
	font-weight: normal;
}

html .prompt p {
	text-align: left;
	margin: 1em 0;
}

html .prompt label {
	cursor: pointer;
}

.promptContainer .prompt.recordingSetupPrompt p {
	margin-top: 0.75em;
	margin-bottom: 0;
}

html .prompt.recordingSetupPrompt > label:not(:first-child):not(.cancelButton) {
	margin: 2px 0;
}

.promptContainer button {
	margin: 0;
	position: relative;
	height: var(--button-size);
	border: none;
	border-radius: 5px;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit;
	font-size: inherit;
	font-family: inherit;
	font-weight: inherit;
	cursor: pointer;
}
.promptContainer button:focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}

.promptContainer button.cancelButton {
	float: right;
	width: var(--button-size);
	position: absolute;
	top: 8px;
	right: 8px;
}

.promptContainer .playback-bar-controls {
	display: grid;
	grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
	grid-template-rows: min-content;
	grid-column-gap: 4px;
}

.promptContainer button.playButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-play-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-play-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.promptContainer button.pauseButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-pause-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-pause-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.promptContainer button.recordButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-record-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-record-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.promptContainer button.stopButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-stop-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-stop-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.promptContainer button.prevBarButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-prev-bar-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-prev-bar-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.promptContainer button.nextBarButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-next-bar-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-next-bar-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.promptContainer button.playButton, .promptContainer button.pauseButton, .promptContainer button.recordButton, .promptContainer button.stopButton, .promptContainer button.okayButton, .promptContainer button.exportButton {
	padding-left: var(--button-size);
}
.promptContainer button.playButton, .promptContainer button.pauseButton, .promptContainer button.recordButton {
	grid-column-start: 1;
	grid-column-end: 3;
}
.promptContainer button.stopButton {
	grid-column-start: 1;
	grid-column-end: 5;
}
.promptContainer button.prevBarButton {
	grid-column-start: 3;
	grid-column-end: 4;
}
.promptContainer button.nextBarButton {
	grid-column-start: 4;
	grid-column-end: 5;
}

.promptContainer button.playButton.shrunk, .promptContainer button.recordButton.shrunk {
	padding: 0;
}
.promptContainer button.playButton.shrunk::before, .promptContainer button.recordButton.shrunk::before {
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
}
.promptContainer button.playButton.shrunk span, .promptContainer button.recordButton.shrunk span {
	display: none;
}
.promptContainer button.playButton.shrunk {
	grid-column-start: 1;
	grid-column-end: 2;
}
.promptContainer button.recordButton.shrunk {
	grid-column-start: 2;
	grid-column-end: 3;
}

.promptContainer button.cancelButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.promptContainer button.okayButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	-webkit-mask-image: var(--internal-checkmark-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-checkmark-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}


 .promptContainer{  
	display: grid;
    grid-template-columns: minmax(0, 1fr) max-content;
    grid-template-rows: max-content 1fr; /* max-content minmax(0, 1fr); Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */
    grid-template-areas: "pattern-area settings-area" "track-area settings-area";
	grid-column-gap: 6px;
	grid-row-gap: 6px;
	position: relative;
	touch-action: manipulation;
	cursor: default;
	font-size: 13px;
	overflow: hidden;
	color: ${ColorConfig.primaryText};
    -webkit-transition: opacity 0.2s ease-in;
    -moz-transition: opacity 0.2s ease-in;
    -o-transition: opacity 0.2s ease-in;
    -ms-transition: opacity 0.2s ease-in;
    transition: opacity 0.2s ease-in;
    transition-delay: 0s;
}
 
.promptContainer .operatorRow {
	margin: 2px 0;
	height: 2em;
	display: flex;
	flex-direction: row;
	align-items: center;
}

.promptContainer .operatorRow > * {
	flex-grow: 1;
	flex-shrink: 1;
}
.promptContainer .layout-option {
	display: flex;
	flex-direction: column;
	cursor: pointer;
	color: ${ColorConfig.secondaryText};
	width: 25%;
}
.promptContainer .layout-option input:checked ~ * {
	color: ${ ColorConfig.primaryText };
}
.promptContainer .layout-option input {
	display: none;
}


.beepboxEditor .layout-option {
	display: flex;
	flex-direction: column;
	cursor: pointer;
	color: ${ColorConfig.secondaryText};
	width: 25%;
}

.beepboxEditor .layout-option input {
	display: none;
}

.beepboxEditor .layout-option input:checked ~ * {
	color: ${ColorConfig.primaryText};
}
.beepboxEditor select.invalidSetting {
	border: solid 1px red;
}
.beepboxEditor .selectContainer {
	position: relative;
}
.beepboxEditor .selectContainer:not(.menu)::after {
	content: "";
	flex-shrink: 0;
	position: absolute;
	right: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: 14px;
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-select-arrows-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-select-arrows-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor .selectContainer.menu::after {
	content: "";
	flex-shrink: 0;
	position: absolute;
	right: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-menu-down-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-menu-down-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor select {
	margin: 0;
	padding: 0 4px;
	display: block;
	height: var(--button-size);
	border: none;
	border-radius: 5px;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit;
	font-size: inherit;
	cursor: pointer;
	font-family: inherit;
	font-weight: inherit;

	-webkit-appearance:none;
	-moz-appearance: none;
	appearance: none;
}
.beepboxEditor select option:disabled {
	color: ${ColorConfig.linkAccent};
	font-weight: bold;
}

.select2-container .select2-selection--single {
  height: auto;
}

.select2-container {
  width: -moz-available !important;
  width: -webkit-fill-available !important;
}
@media (min-width: 711px) {
	.select2 {
	  width: calc(var(--settings-area-width) * 0.625) !important;
	}
}

.select2-container--default .select2-selection--single{
  border-radius: 0px;
  border: 0px;
  background-color: transparent;
  outline: none;
}

.select2-selection__rendered:not(.menu)::before {
	content: "";
	position: absolute;
	right: 0.3em;
	top: 0.4em;
	border-bottom: 0.4em solid currentColor;
	border-left: 0.3em solid transparent;
	border-right: 0.3em solid transparent;
	pointer-events: none;
}
.select2-selection__rendered:not(.menu)::after {
	content: "";
	position: absolute;
	right: 0.3em;
	bottom: 0.4em;
	border-top: 0.4em solid currentColor;
	border-left: 0.3em solid transparent;
	border-right: 0.3em solid transparent;
	pointer-events: none;
}
.select2-selection__rendered {
	margin: 0;
	padding: 0 0.3em;
	display: block;
	height: 2em;
	border: none;
	border-radius: 0.4em;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit !important;
	font-size: inherit;
	cursor: pointer;
	font-family: inherit;
	-webkit-appearance:none;
	-moz-appearance: none;
	appearance: none;
}
.select2-selection__arrow b{
    display:none !important;
}

.select2-selection__rendered--focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}
.select2-search__field {
    background: ${ColorConfig.uiWidgetBackground};
    color: inherit !important;
    font-size: small;
    font-family: inherit;
    border: 0px !important;
    padding: 1px !important;
}
.select2-dropdown {
    box-sizing: border-box;
    display: inline-block;
    margin: 0;
    font-size: small;
    position: relative;
    vertical-align: middle;
    background-color: ${ColorConfig.uiWidgetFocus};
}

.select2-container--default .select2-results>.select2-results__options {
    max-height: 430px;
    overflow-x: hidden;
}
.select2-container--default .select2-results__group {
    cursor: default;
    display: block;
    padding: 1px;
    background: ${ColorConfig.select2OptGroup};
}
.select2-results__option {
    padding: 2px;
    user-select: none;
    -webkit-user-select: none;
}
.select2-container--default .select2-results__option .select2-results__option {
    padding-left: 0.1em;
}
.select2-container--default .select2-results__option[aria-selected=true] {
  background-color: transparent !important;
}

.select2-results__option--highlighted[aria-selected] {
	color: white !important;
}

.beepboxEditor .menu select {
	padding: 0 var(--button-size);
}
.beepboxEditor select:focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}
.beepboxEditor .menu select {
	text-align: center;
	text-align-last: center;
}
.beepboxEditor .settings-area select {
       width: 100%;
}

/* This makes it look better in firefox on my computer... What about others?
@-moz-document url-prefix() {
	.beepboxEditor select { padding: 0 2px; }
}
*/
.beepboxEditor button {
	margin: 0;
	position: relative;
	height: var(--button-size);
	border: none;
	border-radius: 5px;
	background: ${ColorConfig.uiWidgetBackground};
	color: inherit;
	font-size: inherit;
	font-family: inherit;
	font-weight: inherit;
	cursor: pointer;
}
.beepboxEditor button:focus {
	background: ${ColorConfig.uiWidgetFocus};
	outline: none;
}

.beepboxEditor button.cancelButton {
	float: right;
	width: var(--button-size);
	position: absolute;
	top: 8px;
	right: 8px;
}

.beepboxEditor .playback-bar-controls {
	display: grid;
	grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr) minmax(0, 1fr);
	grid-template-rows: min-content;
	grid-column-gap: 4px;
}

.beepboxEditor button.playButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-play-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-play-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor button.pauseButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-pause-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-pause-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor button.recordButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-record-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-record-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}
.beepboxEditor button.stopButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 0;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-stop-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-stop-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.prevBarButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-prev-bar-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-prev-bar-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.nextBarButton::before {
	content: "";
	flex-shrink: 0;
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	pointer-events: none;
	width: var(--button-size);
	height: var(--button-size);
	background: currentColor;
	-webkit-mask-image: var(--internal-next-bar-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-next-bar-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.playButton, .beepboxEditor button.pauseButton, .beepboxEditor button.recordButton, .beepboxEditor button.stopButton, .beepboxEditor button.okayButton, .beepboxEditor button.exportButton {
	padding-left: var(--button-size);
}
.beepboxEditor button.playButton, .beepboxEditor button.pauseButton, .beepboxEditor button.recordButton {
	grid-column-start: 1;
	grid-column-end: 3;
}
.beepboxEditor button.stopButton {
	grid-column-start: 1;
	grid-column-end: 5;
}
.beepboxEditor button.prevBarButton {
	grid-column-start: 3;
	grid-column-end: 4;
}
.beepboxEditor button.nextBarButton {
	grid-column-start: 4;
	grid-column-end: 5;
}

.beepboxEditor button.playButton.shrunk, .beepboxEditor button.recordButton.shrunk {
	padding: 0;
}
.beepboxEditor button.playButton.shrunk::before, .beepboxEditor button.recordButton.shrunk::before {
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
}
.beepboxEditor button.playButton.shrunk span, .beepboxEditor button.recordButton.shrunk span {
	display: none;
}
.beepboxEditor button.playButton.shrunk {
	grid-column-start: 1;
	grid-column-end: 2;
}
.beepboxEditor button.recordButton.shrunk {
	grid-column-start: 2;
	grid-column-end: 3;
}

.beepboxEditor button.cancelButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor button.okayButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	-webkit-mask-image: var(--internal-checkmark-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: var(--internal-checkmark-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
}

.beepboxEditor button.exportButton::before {
	content: "";
	position: absolute;
	width: var(--button-size);
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-export-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-export-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .instrument-bar {
	display: flex;
	gap: 2px;
}

.beepboxEditor .instrument-bar button {
	flex-grow: 1;
	min-width: 0;
	padding: 0;
	flex-basis: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	color: var(--text-color-lit);
}

.beepboxEditor .instrument-bar .remove-instrument, .beepboxEditor .instrument-bar .add-instrument {
	max-width: var(--button-size);
}

.beepboxEditor .instrument-bar > :not(:first-child) {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}

.beepboxEditor .instrument-bar > :not(.last-button) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
	border-bottom: inset;
	border-color: var(--background-color-dim);
}

.beepboxEditor .instrument-bar .selected-instrument {
	background: var(--background-color-lit);
	color: ${ColorConfig.invertedText};
}

.beepboxEditor .instrument-bar .deactivated {
	background: ${ColorConfig.editorBackground};
	color: var(--text-color-dim);
	border-bottom: unset;
}

.beepboxEditor .instrument-bar .deactivated.selected-instrument {
	background: var(--background-color-dim);
	color: ${ColorConfig.invertedText};
}

.beepboxEditor .instrument-bar .remove-instrument {
	border-bottom: unset;
}

.beepboxEditor .instrument-bar .remove-instrument::before {
	content: "";
	position: absolute;
	width: 100%;
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-close-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-close-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor .instrument-bar .add-instrument {
	border-bottom: unset;
}

.beepboxEditor .instrument-bar .no-underline {
	border-bottom: unset;
}

.beepboxEditor .instrument-bar .add-instrument::before {
	content: "";
	position: absolute;
	width: 100%;
	height: var(--button-size);
	left: 0;
	top: 0;
	pointer-events: none;
	background: currentColor;
	mask-image: var(--internal-add-symbol);
	mask-repeat: no-repeat;
	mask-position: center;
	-webkit-mask-image: var(--internal-add-symbol);
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
}

.beepboxEditor canvas {
	overflow: hidden;
	position: absolute;
	display: block;
  cursor: crosshair;
}

@keyframes dash-animation {
  to {
    stroke-dashoffset: -100;
  }
}

.beepboxEditor .dash-move {
  animation: dash-animation 20s infinite linear;
}

.beepboxEditor .trackContainer {
	flex-grow: 1;
}

.beepboxEditor .trackAndMuteContainer {
	display: flex;
	align-items: flex-start;
	width: 100%;
	min-height: 0;
	flex: 1;
	overflow-x: hidden;
	position: relative;
}

.beepboxEditor .channelRow {
	display: flex;
}
.beepboxEditor .channelBox {
	display: flex;
	text-align: center;
	align-items: center;
	justify-content: center;
	box-sizing: border-box;
	padding-top: 1px;
}
.beepboxEditor .channelBoxLabel {
	font-size: 20px;
	font-family: sans-serif;
	font-weight: bold;
}
.beepboxEditor .dropFader {
	opacity: 0;
	-webkit-transition:opacity 0.17s linear;
    -moz-transition:opacity 0.17s linear;
    -o-transition:opacity 0.17s linear;
    -ms-transition:opacity 0.17s linear; 
    transition:opacity 0.17s linear;
}

.beepboxEditor .muteEditor {
	width: 32px;
	flex-shrink: 0;
	display: flex;
	flex-direction: column;
	align-items: stretch;
	position: sticky;
	left: 0;
	z-index: 1;
	background: ${ColorConfig.editorBackground};
}

.beepboxEditor .selectRow, .beepboxEditor .instrumentCopyPasteRow {
	margin: 2px 0;
	height: var(--button-size);
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: space-between;
}

.beepboxEditor .selectRow > :last-child {
	width: 62.5%;
	flex-shrink: 0;
}

.beepboxEditor .menu-area {
	display: flex;
	flex-direction: column;
}
.beepboxEditor .menu-area > * {
	margin: 2px 0;
}
.beepboxEditor .menu-area > button {
	padding: 0 var(--button-size);
	white-space: nowrap;
}

.beepboxEditor .song-settings-area {
	display: flex;
	flex-direction: column;
}

.beepboxEditor .editor-controls {
	flex-shrink: 0;
	display: flex;
	flex-direction: column;
}

.beepboxEditor .instrument-settings-area {
	display: flex;
	flex-direction: column;
}

.beepboxEditor .editor-right-side-top > *, .beepboxEditor .editor-right-side-bottom > * {
	flex-shrink: 0;
}

.beepboxEditor .pitchShiftMarkerContainer {
	box-sizing: border-box;
	display: flex;
	height: 100%;
	left: 3px;
	right: 3px;
	position: absolute;
	align-items: center;
	pointer-events: none;
}

.beepboxEditor .pitchShiftMarker {
	width: 0;
	height: 0;
	position: absolute;
}

.beepboxEditor .pitchShiftMarker::before {
	content: "";
	width: 2px;
	height: 20px;
	transform: translate(-50%, -50%);
	position: absolute;
	background: currentColor;
	border-radius: 3px;
}

.beepboxEditor input[type=text], .beepboxEditor input[type=number] {
	font-size: inherit;
	font-weight: inherit;
	font-family: inherit;
	background: transparent;
	text-align: center;
	border: 1px solid ${ColorConfig.inputBoxOutline};
	color: ${ColorConfig.primaryText};
}

 
.beepboxEditor input[type=checkbox] {
  transform: scale(1.5);
}

.beepboxEditor input[type=range] {
	-webkit-appearance: none;
	color: inherit;
	width: 100%;
	height: var(--button-size);
	font-size: inherit;
	margin: 0;
	cursor: pointer;
	background: none;
	touch-action: pan-y;
  position: relative;
}
.beepboxEditor input[type=range]:focus {
	outline: none;
}
.beepboxEditor input[type=range]::-webkit-slider-runnable-track { 
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
}

.modTarget:hover {
	fill: ${ColorConfig.hoverPreview} !important;
}

.beepboxEditor span.midTick:after {
    content: "";
    display:inline-block;
    position: absolute;
    background: currentColor;
    width: 2%;
    left: 49%;
    height: 0.5em;
    top: 32%;
    z-index: 1;
		pointer-events: none;
}
.beepboxEditor span.modSlider {
	--mod-position: 20%;
	--mod-color: ${ColorConfig.overwritingModSlider};
  --mod-border-radius: 0%;
}
.beepboxEditor span.modSlider:before {
	content: "";
    display:inline-block;
    position: absolute;
    background: var(--mod-color);
    width: 4%;
    left: var(--mod-position);
    height: 0.8em;
    top: 28%;
    z-index: 2;
		transform: translate(-50%, 0%);
		pointer-events: none;
		border: 40%;
		border-radius: var(--mod-border-radius);
}
.beepboxEditor input[type=range]::-webkit-slider-thumb {
	height: var(--button-size);
	width: 6px;
	border-radius: 3px;
	background: currentColor;
	cursor: pointer;
	-webkit-appearance: none;
	margin-top: -10px;
}
.beepboxEditor input[type=range]:focus::-webkit-slider-runnable-track {
	background: ${ColorConfig.uiWidgetFocus};
}
.beepboxEditor input[type=range]::-moz-range-track {
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
}
.beepboxEditor input[type=range]:focus::-moz-range-track {
	background: ${ColorConfig.uiWidgetFocus};
}
.beepboxEditor input[type=range]::-moz-range-thumb {
	height: var(--button-size);
	width: 6px;
	border-radius: 3px;
	border: none;
	background: currentColor;
	cursor: pointer;
}
.beepboxEditor input[type=range]::-ms-track {
	width: 100%;
	height: 6px;
	cursor: pointer;
	background: ${ColorConfig.uiWidgetBackground};
	border-color: transparent;
}
.beepboxEditor input[type=range]:focus::-ms-track {
	background: ${ColorConfig.uiWidgetFocus};
}
.beepboxEditor input[type=range]::-ms-thumb {
	height: var(--button-size);
	width: 6px;
	border-radius: 3px;
	background: currentColor;
	cursor: pointer;
}

li.select2-results__option[role=group] > strong:hover {
  background-color: #516fbb;
}

/* wide screen */
@media (min-width: 711px) {
	#beepboxEditorContainer {
		background-image: url(${getLocalStorageItem("customTheme2", "")});
		display: table;
	}
	.beepboxEditor {
		flex-direction: row;
	}
	.beepboxEditor:focus-within {
		outline: 3px solid ${ColorConfig.uiWidgetBackground};
	}
	.beepboxEditor .trackAndMuteContainer {
		width: 512px;
	}
	.beepboxEditor .trackSelectBox {
		display: none;
	}
    .beepboxEditor .muteButtonSelectBox {
		display: none;
	}
	.beepboxEditor .play-pause-area {
		display: flex;
		flex-direction: column;
	}
	.beepboxEditor .playback-bar-controls {
		margin: 2px 0;
	}
	.beepboxEditor .playback-volume-controls {
		display: flex;
		flex-direction: row;
		margin: 2px 0;
		align-items: center;
	}
	.beepboxEditor .settings-area {
		width: var(--settings-area-width);
	}
}
			@media (min-width: 711px) {
				.beepboxEditor.load {
    	height:100% !important;
    }
			}
/* narrow screen */
@media (max-width: 710px) {
	.beepboxEditor {
		grid-template-columns: minmax(0, 1fr);
		grid-template-rows: min-content 6px min-content min-content;
		grid-template-areas: "pattern-area" "." "track-area" "settings-area";
		grid-row-gap: 0;
	}
	.beepboxEditor .settings-area {
		grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
		grid-template-rows: min-content min-content 1fr min-content;
		grid-template-areas:
			"play-pause-area play-pause-area"
			"menu-area instrument-settings-area"
			"song-settings-area instrument-settings-area"
			"version-area version-area";
		grid-column-gap: 8px;
		margin: 0 4px;
	}
	.beepboxEditor:focus-within {
		outline: none;
	}
	.beepboxEditor .pattern-area {
		max-height: 75vh;
	}
	.beepboxEditor .trackAndMuteContainer {
		overflow-x: auto;
	}
	.beepboxEditor .barScrollBar {
		display: none;
	}
	.beepboxEditor .play-pause-area {
		display: grid;
		grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
		grid-column-gap: 8px;
		margin: 2px 0;
	}
	.beepboxEditor .playback-bar-controls {
		flex-grow: 1;
	}
	.beepboxEditor .playback-volume-controls {
		display: flex;
		flex-direction: row;
		align-items: center;
		flex-grow: 1;
	}
	
	.beepboxEditor .soundIcon {
	  background: ${ColorConfig.editorBackground};
	  display: inline-block;
	  height: 10px;
	  margin-left: 0px;
	  margin-top: 8px;
		position: relative;
		width: 10px;
	}
	.beepboxEditor .soundIcon:before {
	  border-bottom: 6px solid transparent;
	  border-top: 6px solid transparent;
	  border-right: 10px solid ${ColorConfig.editorBackground};
	  content: "";
	  height: 10px;
	  left: 6px;
	  position: absolute;
	  top: -6px;
	  width: 0;
	}
}

`));

    function scaleElementsByFactor(array, factor) {
        for (let i = 0; i < array.length; i++) {
            array[i] *= factor;
        }
    }
    function isPowerOf2(n) {
        return !!n && !(n & (n - 1));
    }
    function countBits(n) {
        if (!isPowerOf2(n))
            throw new Error("FFT array length must be a power of 2.");
        return Math.round(Math.log(n) / Math.log(2));
    }
    function reverseIndexBits(array, fullArrayLength) {
        const bitCount = countBits(fullArrayLength);
        if (bitCount > 16)
            throw new Error("FFT array length must not be greater than 2^16.");
        const finalShift = 16 - bitCount;
        for (let i = 0; i < fullArrayLength; i++) {
            let j;
            j = ((i & 0xaaaa) >> 1) | ((i & 0x5555) << 1);
            j = ((j & 0xcccc) >> 2) | ((j & 0x3333) << 2);
            j = ((j & 0xf0f0) >> 4) | ((j & 0x0f0f) << 4);
            j = ((j >> 8) | ((j & 0xff) << 8)) >> finalShift;
            if (j > i) {
                let temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
    function inverseRealFourierTransform(array, fullArrayLength) {
        const totalPasses = countBits(fullArrayLength);
        if (fullArrayLength < 4)
            throw new Error("FFT array length must be at least 4.");
        for (let pass = totalPasses - 1; pass >= 2; pass--) {
            const subStride = 1 << pass;
            const midSubStride = subStride >> 1;
            const stride = subStride << 1;
            const radiansIncrement = Math.PI * 2.0 / stride;
            const cosIncrement = Math.cos(radiansIncrement);
            const sinIncrement = Math.sin(radiansIncrement);
            const oscillatorMultiplier = 2.0 * cosIncrement;
            for (let startIndex = 0; startIndex < fullArrayLength; startIndex += stride) {
                const startIndexA = startIndex;
                const midIndexA = startIndexA + midSubStride;
                const startIndexB = startIndexA + subStride;
                const midIndexB = startIndexB + midSubStride;
                const stopIndex = startIndexB + subStride;
                const realStartA = array[startIndexA];
                const imagStartB = array[startIndexB];
                array[startIndexA] = realStartA + imagStartB;
                array[midIndexA] *= 2;
                array[startIndexB] = realStartA - imagStartB;
                array[midIndexB] *= 2;
                let c = cosIncrement;
                let s = -sinIncrement;
                let cPrev = 1.0;
                let sPrev = 0.0;
                for (let index = 1; index < midSubStride; index++) {
                    const indexA0 = startIndexA + index;
                    const indexA1 = startIndexB - index;
                    const indexB0 = startIndexB + index;
                    const indexB1 = stopIndex - index;
                    const real0 = array[indexA0];
                    const real1 = array[indexA1];
                    const imag0 = array[indexB0];
                    const imag1 = array[indexB1];
                    const tempA = real0 - real1;
                    const tempB = imag0 + imag1;
                    array[indexA0] = real0 + real1;
                    array[indexA1] = imag1 - imag0;
                    array[indexB0] = tempA * c - tempB * s;
                    array[indexB1] = tempB * c + tempA * s;
                    const cTemp = oscillatorMultiplier * c - cPrev;
                    const sTemp = oscillatorMultiplier * s - sPrev;
                    cPrev = c;
                    sPrev = s;
                    c = cTemp;
                    s = sTemp;
                }
            }
        }
        for (let index = 0; index < fullArrayLength; index += 4) {
            const index1 = index + 1;
            const index2 = index + 2;
            const index3 = index + 3;
            const real0 = array[index];
            const real1 = array[index1] * 2;
            const imag2 = array[index2];
            const imag3 = array[index3] * 2;
            const tempA = real0 + imag2;
            const tempB = real0 - imag2;
            array[index] = tempA + real1;
            array[index1] = tempA - real1;
            array[index2] = tempB + imag3;
            array[index3] = tempB - imag3;
        }
        reverseIndexBits(array, fullArrayLength);
    }

    class EventManager {
        constructor() {
            this.activeEvents = [];
            this.listeners = {};
            this.activeEvents = [];
            this.listeners = {};
        }
        raise(eventType, eventData, extraEventData) {
            if (this.listeners[eventType] == undefined) {
                return;
            }
            this.activeEvents.push(eventType);
            for (let i = 0; i < this.listeners[eventType].length; i++) {
                this.listeners[eventType][i](eventData, extraEventData);
            }
            this.activeEvents.pop();
        }
        listen(eventType, callback) {
            if (this.listeners[eventType] == undefined) {
                this.listeners[eventType] = [];
            }
            this.listeners[eventType].push(callback);
        }
        unlisten(eventType, callback) {
            if (this.listeners[eventType] == undefined) {
                return;
            }
            const lisen = this.listeners[eventType].indexOf(callback);
            if (lisen != -1) {
                this.listeners[eventType].splice(lisen, 1);
            }
        }
        unlistenAll(eventType) {
            if (this.listeners[eventType] == undefined) {
                return;
            }
            this.listeners[eventType] = [];
        }
    }
    events = new EventManager();
    function warpInfinityToNyquist(radians) {
        return 2.0 * Math.atan(radians * 0.5);
    }

    const PRIME32_1 = 2654435761;
    const PRIME32_2 = 2246822519;
    const PRIME32_3 = 3266489917;
    const PRIME32_4 = 668265263;
    const PRIME32_5 = 374761393;
    let encoder;
    /**
     *
     * @param input - byte array or string
     * @param seed - optional seed (32-bit unsigned);
     */
    function xxHash32(input, seed = 0) {
        const buffer = typeof input === 'string' ? (encoder ??= new TextEncoder()).encode(input) : input;
        const b = buffer;
        /*
            Step 1. Initialize internal accumulators
            Each accumulator gets an initial value based on optional seed input. Since the seed is optional, it can be 0.

            ```
                u32 acc1 = seed + PRIME32_1 + PRIME32_2;
                u32 acc2 = seed + PRIME32_2;
                u32 acc3 = seed + 0;
                u32 acc4 = seed - PRIME32_1;
            ```
            Special case : input is less than 16 bytes
            When input is too small (< 16 bytes), the algorithm will not process any stripe. Consequently, it will not
            make use of parallel accumulators.

            In which case, a simplified initialization is performed, using a single accumulator :

            u32 acc  = seed + PRIME32_5;
            The algorithm then proceeds directly to step 4.
        */
        let acc = (seed + PRIME32_5) & 0xffffffff;
        let offset = 0;
        if (b.length >= 16) {
            const accN = [
                (seed + PRIME32_1 + PRIME32_2) & 0xffffffff,
                (seed + PRIME32_2) & 0xffffffff,
                (seed + 0) & 0xffffffff,
                (seed - PRIME32_1) & 0xffffffff,
            ];
            /*
                Step 2. Process stripes
                A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 lanes, of 4 bytes each.
                The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.

                Each lane read its associated 32-bit value using little-endian convention.

                For each {lane, accumulator}, the update process is called a round, and applies the following formula :

                ```
                accN = accN + (laneN * PRIME32_2);
                accN = accN <<< 13;
                accN = accN * PRIME32_1;
                ```

                This shuffles the bits so that any bit from input lane impacts several bits in output accumulator.
                All operations are performed modulo 2^32.

                Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume
                the whole input, except the last remaining bytes which cannot form a stripe (< 16 bytes). When that
                happens, move to step 3.
            */
            const b = buffer;
            const limit = b.length - 16;
            let lane = 0;
            for (offset = 0; (offset & 0xfffffff0) <= limit; offset += 4) {
                const i = offset;
                const laneN0 = b[i + 0] + (b[i + 1] << 8);
                const laneN1 = b[i + 2] + (b[i + 3] << 8);
                const laneNP = laneN0 * PRIME32_2 + ((laneN1 * PRIME32_2) << 16);
                let acc = (accN[lane] + laneNP) & 0xffffffff;
                acc = (acc << 13) | (acc >>> 19);
                const acc0 = acc & 0xffff;
                const acc1 = acc >>> 16;
                accN[lane] = (acc0 * PRIME32_1 + ((acc1 * PRIME32_1) << 16)) & 0xffffffff;
                lane = (lane + 1) & 0x3;
            }
            /*
                Step 3. Accumulator convergence
                All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator
                of same width (32-bit). The associated formula is as follows :

                ```
                acc = (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18);
                ```
            */
            acc =
                (((accN[0] << 1) | (accN[0] >>> 31)) +
                    ((accN[1] << 7) | (accN[1] >>> 25)) +
                    ((accN[2] << 12) | (accN[2] >>> 20)) +
                    ((accN[3] << 18) | (accN[3] >>> 14))) &
                    0xffffffff;
        }
        /*
            Step 4. Add input length
            The input total length is presumed known at this stage. This step is just about adding the length to
            accumulator, so that it participates to final mixing.

            ```
            acc = acc + (u32)inputLength;
            ```
        */
        acc = (acc + buffer.length) & 0xffffffff;
        /*
            Step 5. Consume remaining input
            There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according
            to following pseudo-code :
            ```
            while (remainingLength >= 4) {
                lane = read_32bit_little_endian(input_ptr);
                acc = acc + lane * PRIME32_3;
                acc = (acc <<< 17) * PRIME32_4;
                input_ptr += 4; remainingLength -= 4;
            }
            ```
            This process ensures that all input bytes are present in the final mix.
        */
        const limit = buffer.length - 4;
        for (; offset <= limit; offset += 4) {
            const i = offset;
            const laneN0 = b[i + 0] + (b[i + 1] << 8);
            const laneN1 = b[i + 2] + (b[i + 3] << 8);
            const laneP = laneN0 * PRIME32_3 + ((laneN1 * PRIME32_3) << 16);
            acc = (acc + laneP) & 0xffffffff;
            acc = (acc << 17) | (acc >>> 15);
            acc = ((acc & 0xffff) * PRIME32_4 + (((acc >>> 16) * PRIME32_4) << 16)) & 0xffffffff;
        }
        /*
            ```
            while (remainingLength >= 1) {
                lane = read_byte(input_ptr);
                acc = acc + lane * PRIME32_5;
                acc = (acc <<< 11) * PRIME32_1;
                input_ptr += 1; remainingLength -= 1;
            }
            ```
        */
        for (; offset < b.length; ++offset) {
            const lane = b[offset];
            acc = acc + lane * PRIME32_5;
            acc = (acc << 11) | (acc >>> 21);
            acc = ((acc & 0xffff) * PRIME32_1 + (((acc >>> 16) * PRIME32_1) << 16)) & 0xffffffff;
        }
        /*
            Step 6. Final mix (avalanche)
            The final mix ensures that all input bits have a chance to impact any bit in the output digest,
            resulting in an unbiased distribution. This is also called avalanche effect.
            ```
            acc = acc xor (acc >> 15);
            acc = acc * PRIME32_2;
            acc = acc xor (acc >> 13);
            acc = acc * PRIME32_3;
            acc = acc xor (acc >> 16);
            ```
        */
        acc = acc ^ (acc >>> 15);
        acc = (((acc & 0xffff) * PRIME32_2) & 0xffffffff) + (((acc >>> 16) * PRIME32_2) << 16);
        acc = acc ^ (acc >>> 13);
        acc = (((acc & 0xffff) * PRIME32_3) & 0xffffffff) + (((acc >>> 16) * PRIME32_3) << 16);
        acc = acc ^ (acc >>> 16);
        // turn any negatives back into a positive number;
        return acc < 0 ? acc + 4294967296 : acc;
    }

    const epsilon = (1.0e-24);
    function clamp(min, max, val) {
        max = max - 1;
        if (val <= max) {
            if (val >= min)
                return val;
            else
                return min;
        }
        else {
            return max;
        }
    }
    function validateRange(min, max, val) {
        if (min <= val && val <= max)
            return val;
        throw new Error(`Value ${val} not in range [${min}, ${max}]`);
    }
    function parseFloatWithDefault(s, defaultValue) {
        let result = parseFloat(s);
        if (Number.isNaN(result))
            result = defaultValue;
        return result;
    }
    function parseIntWithDefault(s, defaultValue) {
        let result = parseInt(s);
        if (Number.isNaN(result))
            result = defaultValue;
        return result;
    }
    function encode32BitNumber(buffer, x) {
        buffer.push(base64IntToCharCode[(x >>> (6 * 5)) & 0x3]);
        buffer.push(base64IntToCharCode[(x >>> (6 * 4)) & 0x3f]);
        buffer.push(base64IntToCharCode[(x >>> (6 * 3)) & 0x3f]);
        buffer.push(base64IntToCharCode[(x >>> (6 * 2)) & 0x3f]);
        buffer.push(base64IntToCharCode[(x >>> (6 * 1)) & 0x3f]);
        buffer.push(base64IntToCharCode[(x >>> (6 * 0)) & 0x3f]);
    }
    function writeSequenceB64(buffer, value, chars) {
    for (let i = chars - 1; i >= 0; i--) {
        buffer.push(base64IntToCharCode[(value >> (i * 6)) & 63]);
    }
}
function readSequenceB64(str, index, chars) {
    let value = 0;
    for (let i = 0; i < chars; i++) {
        value = (value << 6) | base64CharCodeToInt[str.charCodeAt(index + i)];
    }
    return value;
}
    function decode32BitNumber(compressed, charIndex) {
        let x = 0;
        x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 5);
        x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 4);
        x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 3);
        x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 2);
        x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 1);
        x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 0);
        return x;
    }
    function encodeUnisonSettings(buffer, v, s, o, e, i) {
        buffer.push(base64IntToCharCode[v]);
        buffer.push(base64IntToCharCode[Number((s > 0))]);
        let cleanS = Math.round(Math.abs(s) * 1000);
        let cleanSDivided = Math.floor(cleanS / 63);
        buffer.push(base64IntToCharCode[cleanS % 63], base64IntToCharCode[cleanSDivided % 63], base64IntToCharCode[Math.floor(cleanSDivided / 63)]);
        buffer.push(base64IntToCharCode[Number((o > 0))]);
        let cleanO = Math.round(Math.abs(o) * 1000);
        let cleanODivided = Math.floor(cleanO / 63);
        buffer.push(base64IntToCharCode[cleanO % 63], base64IntToCharCode[cleanODivided % 63], base64IntToCharCode[Math.floor(cleanODivided / 63)]);
        buffer.push(base64IntToCharCode[Number((e > 0))]);
        let cleanE = Math.round(Math.abs(e) * 1000);
        buffer.push(base64IntToCharCode[cleanE % 63], base64IntToCharCode[Math.floor(cleanE / 63)]);
        buffer.push(base64IntToCharCode[Number((i > 0))]);
        let cleanI = Math.round(Math.abs(i) * 1000);
        buffer.push(base64IntToCharCode[cleanI % 63], base64IntToCharCode[Math.floor(cleanI / 63)]);
    }
    function convertLegacyKeyToKeyAndOctave(rawKeyIndex) {
        let key = clamp(0, Config.keys.length, rawKeyIndex);
        let octave = 0;
        if (rawKeyIndex === 12) {
            key = 0;
            octave = 1;
        }
        else if (rawKeyIndex === 13) {
            key = 6;
            octave = -1;
        }
        else if (rawKeyIndex === 14) {
            key = 0;
            octave = -1;
        }
        else if (rawKeyIndex === 15) {
            key = 5;
            octave = -1;
        }
        return [key, octave];
    }
    const base64IntToCharCode = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 95];
    const base64CharCodeToInt = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 63, 0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0, 0, 0, 0, 0];
    function makeNotePin(interval, time, size) {
        return { interval: interval, time: time, size: size };
    }
    Song._format = Config.jsonFormat;
    Song._oldestBeepboxVersion = 2;
    Song._latestBeepboxVersion = 9;
    Song._oldestJummBoxVersion = 1;
    Song._latestJummBoxVersion = 6;
    Song._oldestGoldBoxVersion = 1;
    Song._latestGoldBoxVersion = 4;
    Song._oldestUltraBoxVersion = 1;
    Song._latestUltraBoxVersion = 5;
    Song._oldestSlarmoosBoxVersion = 1;
    Song._latestSlarmoosBoxVersion = 5;
    Song._variant = 0x74; 
    Synth.tempFilterStartCoefficients = new FilterCoefficients();
    Synth.tempFilterEndCoefficients = new FilterCoefficients();
    Synth.fmSynthFunctionCache = {};
    Synth.fm6SynthFunctionCache = {};
    Synth.effectsFunctionCache = Array(1 << 7).fill(undefined);
    Synth.pickedStringFunctionCache = Array(3).fill(undefined);
    Synth.spectrumFunctionCache = [];
    Synth.noiseFunctionCache = [];
    Synth.drumFunctionCache = [];
    Synth.chipFunctionCache = [];
    Synth.pulseFunctionCache = [];
    Synth.supersawFunctionCache = [];
    Synth.harmonicsFunctionCache = [];
    Synth.loopableChipFunctionCache = Array(Config.unisonVoicesMax + 1).fill(undefined);
    Synth.fmSourceTemplate = (`
		const data = synth.tempMonoInstrumentSampleBuffer;
		const sineWave = Config.sineWave;
			
		// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.
		let operator#Phase       = +((tone.phases[#] - (tone.phases[#] | 0)) + 1000) * ` + Config.sineWaveLength + `;
		let operator#PhaseDelta  = +tone.phaseDeltas[#] * ` + Config.sineWaveLength + `;
		let operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];
		let operator#OutputMult  = +tone.operatorExpressions[#];
		const operator#OutputDelta = +tone.operatorExpressionDeltas[#];
		let operator#Output      = +tone.feedbackOutputs[#];
        const operator#Wave      = tone.operatorWaves[#].samples;
		let feedbackMult         = +tone.feedbackMult;
		const feedbackDelta        = +tone.feedbackDelta;
        let expression = +tone.expression;
		const expressionDelta = +tone.expressionDelta;
		
		const filters = tone.noteFilters;
		const filterCount = tone.noteFilterCount|0;
		let initialFilterInput1 = +tone.initialNoteFilterInput1;
		let initialFilterInput2 = +tone.initialNoteFilterInput2;
		const applyFilters = Synth.applyFilters;
		
		const stopIndex = bufferIndex + roundedSamplesPerTick;
		for (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {
				// INSERT OPERATOR COMPUTATION HERE
				const fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS
				
			const inputSample = fmOutput;
			const sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);
			initialFilterInput2 = initialFilterInput1;
			initialFilterInput1 = inputSample;
				
				feedbackMult += feedbackDelta;
				operator#OutputMult += operator#OutputDelta;
				operator#Phase += operator#PhaseDelta;
			operator#PhaseDelta *= operator#PhaseDeltaScale;
			
			const output = sample * expression;
			expression += expressionDelta;

			data[sampleIndex] += output;
			}
			
			tone.phases[#] = operator#Phase / ` + Config.sineWaveLength + `;
			tone.phaseDeltas[#] = operator#PhaseDelta / ` + Config.sineWaveLength + `;
			tone.operatorExpressions[#] = operator#OutputMult;
		    tone.feedbackOutputs[#] = operator#Output;
		    tone.feedbackMult = feedbackMult;
		    tone.expression = expression;
			
		synth.sanitizeFilters(filters);
		tone.initialNoteFilterInput1 = initialFilterInput1;
		tone.initialNoteFilterInput2 = initialFilterInput2;
		`).split("\n");
    Synth.operatorSourceTemplate = (`
				const operator#PhaseMix = operator#Phase/* + operator@Scaled*/;
				const operator#PhaseInt = operator#PhaseMix|0;
				const operator#Index    = operator#PhaseInt & ` + Config.sineWaveMask + `;
                const operator#Sample   = operator#Wave[operator#Index];
                operator#Output         = operator#Sample + (operator#Wave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);
				const operator#Scaled   = operator#OutputMult * operator#Output;
		`).split("\n");
 
    const versionPrefix = "songVersion: ";
    const maximumSongCount = 8;
    const maximumWorkPerVersion = 3 * 60 * 1000;
    const minimumWorkPerSpan = 1 * 60 * 1000;
    function keyIsVersion(key) {
        return key.indexOf(versionPrefix) == 0;
    }
    function keyToVersion(key) {
        return JSON.parse(key.substring(versionPrefix.length));
    }
    function versionToKey(version) {
        return versionPrefix + JSON.stringify(version);
    }
    function generateUid() {
        return ((Math.random() * (-1 >>> 0)) >>> 0).toString(32);
    }
    function compareSongs(a, b) {
        return b.versions[0].time - a.versions[0].time;
    }
    function errorAlert(error) {
        console.warn(error);
        showToast("Corrupted Data Err: "+error)
    }
    
    function compareVersions(a, b) {
        return b.time - a.time;
    }
    class SongRecovery {
        constructor() {
            this._song = new Song();
        }
        static getAllRecoveredSongs() {
            const songs = [];
            const songsByUid = {};
            for (let i = 0; i < localStorage.length; i++) {
                const itemKey = localStorage.key(i);
                if (keyIsVersion(itemKey)) {
                    const version = keyToVersion(itemKey);
                    let song = songsByUid[version.uid];
                    if (song == undefined) {
                        song = { versions: [] };
                        songsByUid[version.uid] = song;
                        songs.push(song);
                    }
                    song.versions.push(version);
                }
            }
            for (const song of songs) {
                song.versions.sort(compareVersions);
            }
            songs.sort(compareSongs);
            return songs;
        }
static clearAllRecoveredSongs() {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const itemKey = localStorage.key(i);
        if (keyIsVersion(itemKey)) {
            keysToRemove.push(itemKey);
        }
    }
    for (const key of keysToRemove) {
        localStorage.removeItem(key);
    }
}

        saveVersion(uid, name, songData) {
            const newName = name;
            const newTime = Math.round(Date.now());
            clearTimeout(this._saveVersionTimeoutHandle);
            this._saveVersionTimeoutHandle = setTimeout(() => {
                try {
                    this._song.fromBase64String(songData);
                }
                catch (error) {
                    errorAlert(error);
                    return;
                }
                const songs = SongRecovery.getAllRecoveredSongs();
                let currentSong = null;
                for (const song of songs) {
                    if (song.versions[0].uid == uid) {
                        currentSong = song;
                    }
                }
                if (currentSong == null) {
                    currentSong = { versions: [] };
                    songs.unshift(currentSong);
                }
                let versions = currentSong.versions;
                let newWork = 1000;
                if (versions.length > 0) {
                    const mostRecentTime = versions[0].time;
                    const mostRecentWork = versions[0].work;
                    newWork = mostRecentWork + Math.min(maximumWorkPerVersion, newTime - mostRecentTime);
                }
                const newVersion = { uid: uid, name: newName, time: newTime, work: newWork };
                const newKey = versionToKey(newVersion);
                versions.unshift(newVersion);
                localStorage.setItem(newKey, songData);
                let minSpan = minimumWorkPerSpan;
                const spanMult = Math.pow(2, 1 / 2);
                for (var i = 1; i < versions.length; i++) {
                    const currentWork = versions[i].work;
                    const olderWork = (i == versions.length - 1) ? 0.0 : versions[i + 1].work;
                    if (currentWork - olderWork < minSpan) {
                        let indexToDiscard = i;
                        if (i < versions.length - 1) {
                            const currentTime = versions[i].time;
                            const newerTime = versions[i - 1].time;
                            const olderTime = versions[i + 1].time;
                            if ((currentTime - olderTime) < 0.5 * (newerTime - currentTime)) {
                                indexToDiscard = i + 1;
                            }
                        }
                        localStorage.removeItem(versionToKey(versions[indexToDiscard]));
                        break;
                    }
                    minSpan *= spanMult;
                }
                while (songs.length > maximumSongCount) {
                    let leastImportantSong = null;
                    let leastImportance = Number.POSITIVE_INFINITY;
                    for (let i = Math.round(maximumSongCount / 2); i < songs.length; i++) {
                        const song = songs[i];
                        const timePassed = newTime - song.versions[0].time;
                        const timeScale = 1.0 / ((timePassed / (12 * 60 * 60 * 1000)) + 1.0);
                        const adjustedWork = song.versions[0].work + 5 * 60 * 1000;
                        const weight = adjustedWork * timeScale;
                        if (leastImportance > weight) {
                            leastImportance = weight;
                            leastImportantSong = song;
                        }
                    }
                    for (const version of leastImportantSong.versions) {
                        localStorage.removeItem(versionToKey(version));
                    }
                    songs.splice(songs.indexOf(leastImportantSong), 1);
                }
            }, 750);
        }
    }

    class Layout {
        static setLayout(layout) {
            this._styleElement.textContent = this._layoutMap[layout];
        }
    }
    Layout._layoutMap = {
        "small": "",
        "long": `\

			/* long layout */
			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
					padding-top: 0px;
				}
				.beepboxEditor {
					width: 100%;
					height: 100vh;
					grid-template-columns: minmax(0, 1fr) 390px; /* minmax(0, 1fr) min-content; Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */
					grid-template-rows: minmax(481px, 1fr) minmax(0, min-content);
					grid-template-areas: "pattern-area settings-area" "track-area track-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					display: flex;
					flex-direction: column;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 1;
					overflow: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				.beepboxEditor .song-settings-area {
					overflow-y: auto;
				}
				
				.beepboxEditor .settings-area {
					width: 390px;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
					grid-template-rows: auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"instrument-settings-area version-area"
						"instrument-settings-area play-pause-area"
						"instrument-settings-area menu-area"
						"instrument-settings-area song-settings-area";
				}
				
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor.selectRow {
					height: 2em;
				}
				.beepboxEditor .trackAndMuteContainer {
					max-height: 446px;
				}

				.beepboxEditor .trackContainer {
					overflow: visible;
				}
			 .beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,
        "tall": `\
			/* tall layout */
			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
					padding-top: 0px;
				}
				.beepboxEditor {
					width: 100%;
					height: 100vh;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) 192px;
					grid-template-rows: 1fr;
					grid-template-areas: "track-area pattern-area settings-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					height: 100%;
					display: flex;
					flex-direction: column;
					justify-content: center;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 0;
					overflow: auto;
					flex-basis: initial;
					flex-grow: 0;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				
				.beepboxEditor .settings-area {
					width: 192px;
					position: relative;
					overflow-y: auto;
					grid-template-columns: minmax(0, 1fr);
					grid-template-rows: auto auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"version-area"
						"play-pause-area"
						"menu-area"
						"song-settings-area"
						"instrument-settings-area";
				}
				.beepboxEditor .version-area {
					position: sticky;
					top: 0;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .play-pause-area {
					position: sticky;
					top: 22px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .menu-area {
					position: sticky;
					top: 82px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor .trackContainer {
					overflow: visible;
				}
				.beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,
        "wide": `\
			/* wide (JB) layout */
			@media (min-width: 1001px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
					padding-top: 0px;
				}
				.beepboxEditor {
					width: 100%;
					height: 100vh;
					grid-template-columns: 512px minmax(0, 1fr) 30em;
					grid-template-rows: minmax(481px, 1fr) min-content;
					grid-template-areas: "track-area pattern-area settings-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					height: 100%;
					max-height: 100%
				}
				.beepboxEditor .editor-widget-column {
					flex: 0;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					flex: 0;
					flex-basis: initial;
					flex-grow: 0;
					overflow-y: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				
				.beepboxEditor .song-settings-area {
					overflow-y: auto;
				}
				
				.beepboxEditor .settings-area {
					width: 30em;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
					grid-template-rows: auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"instrument-settings-area version-area"
						"instrument-settings-area play-pause-area"
						"instrument-settings-area menu-area"
						"instrument-settings-area song-settings-area";
				}
				.beepboxEditor .version-area {
					position: sticky;
					top: 0;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .play-pause-area {
					position: sticky;
					top: 22px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .menu-area {
					position: sticky;
					top: 82px;
					z-index: 1;
					background: ${ColorConfig.editorBackground};
				}
				
				.beepboxEditor .trackContainer {
					overflow: visible;
				}
			}
		`,
        "flipped long": `\

            	/* AB Special layout */
			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
					padding-top: 0px;
				}
				.beepboxEditor {
					width: 100%;
					height: 100vh;
					grid-template-columns: 390px minmax(0, 1fr);
					grid-template-rows: minmax(481px, 1fr) minmax(0, min-content);
					grid-template-areas: "settings-area pattern-area" "track-area track-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					width: 100%;
					display: flex;
					flex-direction: column;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 1;
					overflow: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				.beepboxEditor .song-settings-area {
					overflow-y: auto;
				}
				
				.beepboxEditor .settings-area {
					width: 30em;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
					grid-template-rows: auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"version-area instrument-settings-area"
						"play-pause-area instrument-settings-area"
						"menu-area instrument-settings-area"
						"song-settings-area instrument-settings-area";
				}
				
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor.selectRow {
					height: 2em;
				}
				.beepboxEditor .trackAndMuteContainer {
					max-height: 446px;
				}

				.beepboxEditor .trackContainer {
					overflow: visible;
				}
				.beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,
        "wide long": `\

			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
					padding-top: 0px;
				}
				.beepboxEditor {
					width: 100%;
					height: 100vh;
					grid-template-columns: minmax(0, 1fr) 390px; /* minmax(0, 1fr) min-content; Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */
					grid-template-rows: minmax(481px, 1fr) minmax(0, min-content);
					grid-template-areas: "pattern-area settings-area" "track-area settings-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					display: flex;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 1;
					overflow: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				
				.beepboxEditor .song-settings-area {
					overflow-y: auto;
				}
				
				.beepboxEditor .settings-area {
					width: 30em;
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
					grid-template-rows: auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"instrument-settings-area version-area"
						"instrument-settings-area play-pause-area"
						"instrument-settings-area menu-area"
						"instrument-settings-area song-settings-area";
				}				
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor.selectRow {
					height: 2em;
				}
				.beepboxEditor .trackAndMuteContainer {
					max-height: 446px;
				}

				.beepboxEditor .trackContainer {
					overflow: visible;
				}
			 .beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,
        "focused long": `\

			/* focused long layout */
			@media (min-width: 711px) {
				#beepboxEditorContainer {
					max-width: initial;
					height: 100vh;
					padding-top: 0px;
				}
				.beepboxEditor {
					width: 100%;
					height: 100vh;
					grid-template-columns: minmax(0, 1fr) 190px; 
					grid-template-rows: minmax(481px, 1fr) minmax(0, min-content);
					grid-template-areas: "pattern-area settings-area" "track-area settings-area";
				}
				.beepboxEditor .pattern-area {
					width: 100%;
					height: 100%;
				}
				.beepboxEditor .track-area {
					display: flex;
				}
				.beepboxEditor .trackAndMuteContainer {
					width: 100%;
					min-height: 0;
					flex: 1;
					overflow: auto;
					max-height: 97.5vh;
				}
				.beepboxEditor .instrument-settings-area {
					overflow-y: auto;
					position: relative;
				}
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}
				
				.beepboxEditor .instrument-settings-area > .editor-controls {
					position: absolute;
					width: 100%;
				}

				.beepboxEditor .settings-area {
					width: 100%;
					position: relative;
					overflow-y: auto;
					grid-template-columns: minmax(0, 1fr);
					grid-template-rows: auto auto auto auto minmax(0, 1fr);
					grid-template-areas:
						"version-area"
						"play-pause-area"
						"menu-area"
						"song-settings-area"
						"instrument-settings-area";
				}
				.beepboxEditor .barScrollBar {
					display: none;
				}
				.beepboxEditor.selectRow {
					height: 2em;
				}
				.beepboxEditor .trackAndMuteContainer {
					max-height: 446px;
				}

				.beepboxEditor .trackContainer {
					overflow: visible;
				}
				.beepboxEditor .trackAndMuteContainer {
					scrollbar-width: auto;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {
					width: 20px;
					height: 20px;
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {
					background: ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {
					background-color: ${ColorConfig.uiWidgetBackground};
					border: 3px solid ${ColorConfig.editorBackground};
				}
				.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {
					background-color: ${ColorConfig.editorBackground};
				}
			}
		`,
    };
    Layout._styleElement = document.head.appendChild(HTML.style({ type: "text/css" }));

    class Change {
        constructor() {
            this._noop = true;
        }
        _didSomething() {
            this._noop = false;
        }
        isNoop() {
            return this._noop;
        }
        commit() { }
    }
    class UndoableChange extends Change {
        constructor(reversed) {
            super();
            this._reversed = reversed;
            this._doneForwards = !reversed;
        }
        undo() {
            if (this._reversed) {
                this._doForwards();
                this._doneForwards = true;
            }
            else {
                this._doBackwards();
                this._doneForwards = false;
            }
        }
        redo() {
            if (this._reversed) {
                this._doBackwards();
                this._doneForwards = false;
            }
            else {
                this._doForwards();
                this._doneForwards = true;
            }
        }
        _isDoneForwards() {
            return this._doneForwards;
        }
        _doForwards() {
            throw new Error("Change.doForwards(): Override me.");
        }
        _doBackwards() {
            throw new Error("Change.doBackwards(): Override me.");
        }
    }
    class ChangeGroup extends Change {
        constructor() {
            super();
        }
        append(change) {
            if (change.isNoop())
                return;
            this._didSomething();
        }
    }
    class ChangeSequence extends UndoableChange {
        constructor(changes) {
            super(false);
            if (changes == undefined) {
                this._changes = [];
            }
            else {
                this._changes = changes.concat();
            }
            this._committed = false;
        }
        checkFirst() {
            if (this._changes.length > 0)
                return this._changes[0];
            return null;
        }
        append(change) {
            if (change.isNoop())
                return;
            this._changes[this._changes.length] = change;
            this._didSomething();
        }
        _doForwards() {
            for (let i = 0; i < this._changes.length; i++) {
                this._changes[i].redo();
            }
        }
        _doBackwards() {
            for (let i = this._changes.length - 1; i >= 0; i--) {
                this._changes[i].undo();
            }
        }
        isCommitted() {
            return this._committed;
        }
        commit() {
            this._committed = true;
        }
    }

    function patternsContainSameInstruments(pattern1Instruments, pattern2Instruments) {
        const pattern2Has1Instruments = pattern1Instruments.every(instrument => pattern2Instruments.indexOf(instrument) != -1);
        const pattern1Has2Instruments = pattern2Instruments.every(instrument => pattern1Instruments.indexOf(instrument) != -1);
        return pattern2Has1Instruments && pattern1Has2Instruments && pattern2Instruments.length == pattern1Instruments.length;
    }
    function discardInvalidPatternInstruments(instruments, song, channelIndex) {
        const uniqueInstruments = new Set(instruments);
        instruments.length = 0;
        instruments.push(...uniqueInstruments);
        for (let i = 0; i < instruments.length; i++) {
            if (instruments[i] >= song.channels[channelIndex].instruments.length) {
                instruments.splice(i, 1);
                i--;
            }
        }
        if (instruments.length > song.getMaxInstrumentsPerPattern(channelIndex)) {
            instruments.length = song.getMaxInstrumentsPerPattern(channelIndex);
        }
        if (instruments.length <= 0) {
            instruments[0] = 0;
        }
    }
    function unionOfUsedNotes(pattern, flags) {
        for (const note of pattern.notes) {
            for (const pitch of note.pitches) {
                for (const pin of note.pins) {
                    const key = (pitch + pin.interval) % 12;
                    if (!flags[key]) {
                        flags[key] = true;
                    }
                }
            }
        }
    }
    function generateScaleMap(oldScaleFlags, newScaleValue, customScaleFlags) {
        const newScaleFlags = newScaleValue == Config.scales["dictionary"]["Custom"].index ? customScaleFlags : Config.scales[newScaleValue].flags;
        const oldScale = [];
        const newScale = [];
        for (let i = 0; i < 12; i++) {
            if (oldScaleFlags[i])
                oldScale.push(i);
            if (newScaleFlags[i])
                newScale.push(i);
        }
        const largerToSmaller = oldScale.length > newScale.length;
        const smallerScale = largerToSmaller ? newScale : oldScale;
        const largerScale = largerToSmaller ? oldScale : newScale;
        const roles = ["root", "second", "second", "third", "third", "fourth", "tritone", "fifth", "sixth", "sixth", "seventh", "seventh", "root"];
        let bestScore = Number.MAX_SAFE_INTEGER;
        let bestIndexMap = [];
        const stack = [[0]];
        while (stack.length > 0) {
            const indexMap = stack.pop();
            if (indexMap.length == smallerScale.length) {
                let score = 0;
                for (let i = 0; i < indexMap.length; i++) {
                    score += Math.abs(smallerScale[i] - largerScale[indexMap[i]]);
                    if (roles[smallerScale[i]] != roles[largerScale[indexMap[i]]]) {
                        score += 0.75;
                    }
                }
                if (bestScore > score) {
                    bestScore = score;
                    bestIndexMap = indexMap;
                }
            }
            else {
                const lowIndex = indexMap[indexMap.length - 1] + 1;
                const highIndex = largerScale.length - smallerScale.length + indexMap.length;
                for (let i = lowIndex; i <= highIndex; i++) {
                    stack.push(indexMap.concat(i));
                }
            }
        }
        const sparsePitchMap = [];
        for (let i = 0; i < bestIndexMap.length; i++) {
            const smallerScalePitch = smallerScale[i];
            const largerScalePitch = largerScale[bestIndexMap[i]];
            sparsePitchMap[i] = largerToSmaller
                ? [largerScalePitch, smallerScalePitch]
                : [smallerScalePitch, largerScalePitch];
        }
        sparsePitchMap.push([12, 12]);
        newScale.push(12);
        let sparseIndex = 0;
        const fullPitchMap = [];
        for (let i = 0; i < 12; i++) {
            const oldLow = sparsePitchMap[sparseIndex][0];
            const newLow = sparsePitchMap[sparseIndex][1];
            const oldHigh = sparsePitchMap[sparseIndex + 1][0];
            const newHigh = sparsePitchMap[sparseIndex + 1][1];
            if (i == oldHigh - 1)
                sparseIndex++;
            const transformedPitch = (i - oldLow) * (newHigh - newLow) / (oldHigh - oldLow) + newLow;
            let nearestPitch = 0;
            let nearestPitchDistance = Number.MAX_SAFE_INTEGER;
            for (const newPitch of newScale) {
                let distance = Math.abs(newPitch - transformedPitch);
                if (roles[newPitch] != roles[i]) {
                    distance += 0.1;
                }
                if (nearestPitchDistance > distance) {
                    nearestPitchDistance = distance;
                    nearestPitch = newPitch;
                }
            }
            fullPitchMap[i] = nearestPitch;
        }
        return fullPitchMap;
    }
    function removeRedundantPins(pins) {
        for (let i = 1; i < pins.length - 1;) {
            if (pins[i - 1].interval == pins[i].interval &&
                pins[i].interval == pins[i + 1].interval &&
                pins[i - 1].size == pins[i].size &&
                pins[i].size == pins[i + 1].size) {
                pins.splice(i, 1);
            }
            else {
                i++;
            }
        }
    }
    function projectNoteIntoBar(oldNote, timeOffset, noteStartPart, noteEndPart, newNotes) {
        const newNote = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, false);
        newNote.pins.length = 0;
        newNote.pitches.length = 0;
        const newNoteLength = noteEndPart - noteStartPart;
        for (const pitch of oldNote.pitches) {
            newNote.pitches.push(pitch);
        }
        for (let pinIndex = 0; pinIndex < oldNote.pins.length; pinIndex++) {
            const pin = oldNote.pins[pinIndex];
            const newPinTime = pin.time + timeOffset;
            if (newPinTime < 0) {
                if (pinIndex + 1 >= oldNote.pins.length)
                    throw new Error("Error converting pins in note overflow.");
                const nextPin = oldNote.pins[pinIndex + 1];
                const nextPinTime = nextPin.time + timeOffset;
                if (nextPinTime > 0) {
                    const ratio = (-newPinTime) / (nextPinTime - newPinTime);
                    newNote.pins.push(makeNotePin(Math.round(pin.interval + ratio * (nextPin.interval - pin.interval)), 0, Math.round(pin.size + ratio * (nextPin.size - pin.size))));
                }
            }
            else if (newPinTime <= newNoteLength) {
                newNote.pins.push(makeNotePin(pin.interval, newPinTime, pin.size));
            }
            else {
                if (pinIndex < 1)
                    throw new Error("Error converting pins in note overflow.");
                const prevPin = oldNote.pins[pinIndex - 1];
                const prevPinTime = prevPin.time + timeOffset;
                if (prevPinTime < newNoteLength) {
                    const ratio = (newNoteLength - prevPinTime) / (newPinTime - prevPinTime);
                    newNote.pins.push(makeNotePin(Math.round(prevPin.interval + ratio * (pin.interval - prevPin.interval)), newNoteLength, Math.round(prevPin.size + ratio * (pin.size - prevPin.size))));
                }
            }
        }
        const offsetInterval = newNote.pins[0].interval;
        for (let pitchIdx = 0; pitchIdx < newNote.pitches.length; pitchIdx++) {
            newNote.pitches[pitchIdx] += offsetInterval;
        }
        for (let pinIdx = 0; pinIdx < newNote.pins.length; pinIdx++) {
            newNote.pins[pinIdx].interval -= offsetInterval;
        }
        let joinedWithPrevNote = false;
        if (newNote.start == 0) {
            newNote.continuesLastPattern = (timeOffset < 0 || oldNote.continuesLastPattern);
        }
        else {
            newNote.continuesLastPattern = false;
            if (newNotes.length > 0 && oldNote.continuesLastPattern) {
                const prevNote = newNotes[newNotes.length - 1];
                if (prevNote.end == newNote.start && Synth.adjacentNotesHaveMatchingPitches(prevNote, newNote)) {
                    joinedWithPrevNote = true;
                    const newIntervalOffset = prevNote.pins[prevNote.pins.length - 1].interval;
                    const newTimeOffset = prevNote.end - prevNote.start;
                    for (let pinIndex = 1; pinIndex < newNote.pins.length; pinIndex++) {
                        const tempPin = newNote.pins[pinIndex];
                        const transformedPin = makeNotePin(tempPin.interval + newIntervalOffset, tempPin.time + newTimeOffset, tempPin.size);
                        prevNote.pins.push(transformedPin);
                        prevNote.end = prevNote.start + transformedPin.time;
                    }
                    removeRedundantPins(prevNote.pins);
                }
            }
        }
        if (!joinedWithPrevNote) {
            newNotes.push(newNote);
        }
    }
    function mod(a, b) {
        return (a % b + b) % b;
    }
    function sigma(a, b, c) {
        let result = 0;
        for (let i = c; i <= a; i++) {
            result += b(i);
        }
        return result;
    }
    function randomSineWave(wave) {
        let randomRoundWave = new Float32Array(64);
        let waveLength = 64;
        let foundNonZero = false;
        const roundedWaveType = (Math.random() * 2 + 1) | 0;
        if (roundedWaveType == 1 || roundedWaveType == 3) {
            let randomNumber1 = Math.random() * 2 + 0.5;
            let randomNumber2 = Math.random() * 13 + 3;
            let randomNumber3 = Math.random() * 48 - 24;
            for (let i = 0; i < waveLength; i++) {
                randomRoundWave[i] = clamp(-24, 24 + 1, Math.round(mod(randomNumber3 + ((Math.sin((i + randomNumber3) / randomNumber2) * 24) + i * randomNumber1), 48) - 24));
            }
        }
        else if (roundedWaveType == 2) {
            let randomNumber1 = Math.random() * 0.19 + 0.06;
            let randomNumber2 = Math.random() * 2 + 1;
            let randomNumber3 = Math.random() * 48 - 24;
            let randomNumber4 = Math.random() * 2 - 1;
            for (let i = 0; i < waveLength; i++) {
                randomRoundWave[i] = clamp(-24, 24 + 1, Math.round(randomNumber4 * Math.abs(2 * Math.floor((Math.sin((i / randomNumber2) * randomNumber1 + randomNumber3) * Math.cos((i * randomNumber2) * (randomNumber1 / 2)) * 24))) - randomNumber4 * 24));
            }
        }
        for (let i = 0; i < waveLength; i++) {
            wave[i] = randomRoundWave[i];
            let minimum = Infinity;
            let maximum = -Infinity;
            for (let i = 0; i < waveLength; i++) {
                minimum = Math.min(minimum, wave[i]);
                maximum = Math.max(maximum, wave[i]);
            }
            const distance = maximum - minimum;
            if (distance >= 7) {
                foundNonZero = true;
            }
        }
        if (!foundNonZero)
            randomSineWave(wave);
    }
    function randomPulses(wave) {
        let randomPulse = new Float32Array(64);
        let waveLength = 64;
        let foundNonZero = false;
        let randomNumber2 = Math.round(Math.random() * 15 + 15);
        let randomNumber3 = Math.round(Math.random() * 3 + 1);
        let randomNumber4 = Math.round(Math.random() * 13 + 2);
        for (let i = 0; i < waveLength; i++) {
            let randomNumber1 = sigma(mod(i, randomNumber2), (i) => 1, randomNumber4);
            randomPulse[i] = clamp(-24, 24 + 1, Math.round(mod(24 * (sigma(i, (i) => randomNumber1, Math.round(randomNumber2 / randomNumber3))), 24.0000000000001)));
        }
        for (let i = 0; i < waveLength; i++) {
            wave[i] = randomPulse[i];
            let minimum = Infinity;
            let maximum = -Infinity;
            for (let i = 0; i < waveLength; i++) {
                minimum = Math.min(minimum, wave[i]);
                maximum = Math.max(maximum, wave[i]);
            }
            const distance = maximum - minimum;
            if (distance >= 7) {
                foundNonZero = true;
            }
        }
        if (!foundNonZero)
            randomPulses(wave);
    }
    function randomChipWave(wave) {
        let randomChip = new Float32Array(64);
        let waveLength = 64;
        let foundNonZero = false;
        const chipType = (Math.random() * 2 + 1) | 0;
        if (chipType == 1) {
            let randomNumber1 = Math.random() * 3;
            let randomNumber2 = Math.random() * 0.99 - 1;
            let randomNumber3 = Math.random() * 9 + 2;
            let randomNumber4 = Math.random() * 2 - 1;
            for (let i = 0; i < waveLength; i++) {
                randomChip[i] = clamp(-24, 24 + 1, (Math.round(Math.abs(randomNumber4 * mod(((randomNumber2 / randomNumber3) * randomNumber3) + (sigma(i / (randomNumber1 * randomNumber1), (i) => randomNumber3, randomNumber1 * -randomNumber2)) * randomNumber4, 24)))) * 2 - 24);
            }
        }
        else if (chipType == 2) {
            let randomNumber1 = Math.random() * 3;
            let randomNumber2 = Math.random() * 2 - 1;
            let randomNumber3 = Math.random() * 100;
            for (let i = 0; i < waveLength; i++) {
                randomChip[i] = clamp(-24, 24 + 1, mod(Math.round(mod((sigma(i / randomNumber1, (i) => (randomNumber1 * randomNumber3), 0)), 25 + randomNumber2) * 24), 48) - 24);
            }
        }
        for (let i = 0; i < waveLength; i++) {
            wave[i] = randomChip[i];
            let minimum = Infinity;
            let maximum = -Infinity;
            for (let i = 0; i < waveLength; i++) {
                minimum = Math.min(minimum, wave[i]);
                maximum = Math.max(maximum, wave[i]);
            }
            const distance = maximum - minimum;
            if (distance >= 7) {
                foundNonZero = true;
            }
        }
        if (!foundNonZero)
            randomChipWave(wave);
    }
    function biasedFullyRandom(wave) {
        let fullyRandomWave = new Float32Array(64);
        let waveLength = 64;
        let foundNonZero = false;
        for (let i = 0; i < waveLength; i++) {
            const v = Math.random() * 2 - 1;
            const bias = 6;
            const biased = v > 0 ? Math.pow(v, bias) : -Math.pow(-v, bias);
            fullyRandomWave[i] = clamp(-24, 24 + 1, Math.floor(biased * 24));
        }
        for (let i = 0; i < waveLength; i++) {
            wave[i] = fullyRandomWave[i];
            let minimum = Infinity;
            let maximum = -Infinity;
            for (let i = 0; i < waveLength; i++) {
                minimum = Math.min(minimum, wave[i]);
                maximum = Math.max(maximum, wave[i]);
            }
            const distance = maximum - minimum;
            if (distance >= 7) {
                foundNonZero = true;
            }
        }
        if (!foundNonZero)
            biasedFullyRandom(wave);
    }
    function fullyRandom(wave) {
        let fullyRandomWave = new Float32Array(64);
        let waveLength = 64;
        for (let i = 0; i < waveLength; i++) {
            fullyRandomWave[i] = clamp(-24, 24 + 1, ((Math.random() * 48) | 0) - 24);
        }
        for (let i = 0; i < waveLength; i++) {
            wave[i] = fullyRandomWave[i];
        }
    }
    class ChangeMoveAndOverflowNotes extends ChangeGroup {
        constructor(doc, newBeatsPerBar, partsToMove) {
            super();
            const pitchChannels = [];
            const noiseChannels = [];
            const modChannels = [];
            for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                const oldChannel = doc.song.channels[channelIndex];
                const newChannel = new Channel();
                if (channelIndex < doc.song.pitchChannelCount) {
                    pitchChannels.push(newChannel);
                }
                else if (channelIndex < doc.song.pitchChannelCount + doc.song.noiseChannelCount) {
                    noiseChannels.push(newChannel);
                }
                else {
                    modChannels.push(newChannel);
                }
                newChannel.muted = oldChannel.muted;
                newChannel.octave = oldChannel.octave;
                newChannel.name = oldChannel.name;
                for (const instrument of oldChannel.instruments) {
                    newChannel.instruments.push(instrument);
                }
                const oldPartsPerBar = Config.partsPerBeat * doc.song.beatsPerBar;
                const newPartsPerBar = Config.partsPerBeat * newBeatsPerBar;
                let currentBar = -1;
                let pattern = null;
                for (let oldBar = 0; oldBar < doc.song.barCount; oldBar++) {
                    const oldPattern = doc.song.getPattern(channelIndex, oldBar);
                    if (oldPattern != null) {
                        const oldBarStart = oldBar * oldPartsPerBar;
                        for (const oldNote of oldPattern.notes) {
                            const absoluteNoteStart = oldNote.start + oldBarStart + partsToMove;
                            const absoluteNoteEnd = oldNote.end + oldBarStart + partsToMove;
                            const startBar = Math.floor(absoluteNoteStart / newPartsPerBar);
                            const endBar = Math.ceil(absoluteNoteEnd / newPartsPerBar);
                            for (let bar = startBar; bar < endBar; bar++) {
                                const barStartPart = bar * newPartsPerBar;
                                const noteStartPart = Math.max(0, absoluteNoteStart - barStartPart);
                                const noteEndPart = Math.min(newPartsPerBar, absoluteNoteEnd - barStartPart);
                                if (noteStartPart < noteEndPart) {
                                    if (currentBar < bar || pattern == null) {
                                        currentBar++;
                                        while (currentBar < bar) {
                                            newChannel.bars[currentBar] = 0;
                                            currentBar++;
                                        }
                                        pattern = new Pattern();
                                        newChannel.patterns.push(pattern);
                                        newChannel.bars[currentBar] = newChannel.patterns.length;
                                        pattern.instruments.length = 0;
                                        pattern.instruments.push(...oldPattern.instruments);
                                    }
                                    pattern = newChannel.patterns[newChannel.bars[bar] - 1];
                                    projectNoteIntoBar(oldNote, absoluteNoteStart - barStartPart - noteStartPart, noteStartPart, noteEndPart, pattern.notes);
                                }
                            }
                        }
                    }
                }
            }
            removeDuplicatePatterns(pitchChannels);
            removeDuplicatePatterns(noiseChannels);
            removeDuplicatePatterns(modChannels);
            this.append(new ChangeReplacePatterns(doc, pitchChannels, noiseChannels, modChannels));
        }
    }
    class ChangePins extends UndoableChange {
        constructor(_doc, _note) {
            super(false);
            this._doc = _doc;
            this._note = _note;
            this._oldStart = this._note.start;
            this._oldEnd = this._note.end;
            this._newStart = this._note.start;
            this._newEnd = this._note.end;
            this._oldPins = this._note.pins;
            this._newPins = [];
            this._oldPitches = this._note.pitches;
            this._newPitches = [];
            this._oldContinuesLastPattern = this._note.continuesLastPattern;
            this._newContinuesLastPattern = this._note.continuesLastPattern;
        }
        _finishSetup(continuesLastPattern) {
            for (let i = 0; i < this._newPins.length - 1;) {
                if (this._newPins[i].time >= this._newPins[i + 1].time) {
                    this._newPins.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            removeRedundantPins(this._newPins);
            const firstInterval = this._newPins[0].interval;
            const firstTime = this._newPins[0].time;
            for (let i = 0; i < this._oldPitches.length; i++) {
                this._newPitches[i] = this._oldPitches[i] + firstInterval;
            }
            for (let i = 0; i < this._newPins.length; i++) {
                this._newPins[i].interval -= firstInterval;
                this._newPins[i].time -= firstTime;
            }
            this._newStart = this._oldStart + firstTime;
            this._newEnd = this._newStart + this._newPins[this._newPins.length - 1].time;
            if (continuesLastPattern != undefined) {
                this._newContinuesLastPattern = continuesLastPattern;
            }
            if (this._newStart != 0) {
                this._newContinuesLastPattern = false;
            }
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._note.pins = this._newPins;
            this._note.pitches = this._newPitches;
            this._note.start = this._newStart;
            this._note.end = this._newEnd;
            this._note.continuesLastPattern = this._newContinuesLastPattern;
            if (this._doc != null)
                this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pins = this._oldPins;
            this._note.pitches = this._oldPitches;
            this._note.start = this._oldStart;
            this._note.end = this._oldEnd;
            this._note.continuesLastPattern = this._oldContinuesLastPattern;
            if (this._doc != null)
                this._doc.notifier.changed();
        }
    }
    class ChangeCustomWave extends Change {
        constructor(doc, newArray) {
            super();
            const oldArray = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].customChipWave;
            var comparisonResult = true;
            for (let i = 0; i < oldArray.length; i++) {
                if (oldArray[i] != newArray[i]) {
                    comparisonResult = false;
                    i = oldArray.length;
                }
            }
            if (comparisonResult == false) {
                let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
                for (let i = 0; i < newArray.length; i++) {
                    instrument.customChipWave[i] = newArray[i];
                }
                let sum = 0.0;
                for (let i = 0; i < instrument.customChipWave.length; i++) {
                    sum += instrument.customChipWave[i];
                }
                const average = sum / instrument.customChipWave.length;
                let cumulative = 0;
                let wavePrev = 0;
                for (let i = 0; i < instrument.customChipWave.length; i++) {
                    cumulative += wavePrev;
                    wavePrev = instrument.customChipWave[i] - average;
                    instrument.customChipWaveIntegral[i] = cumulative;
                }
                instrument.customChipWaveIntegral[64] = 0.0;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeCustomAlgorythmorFeedback extends Change {
    	constructor(doc, newArray, carry, mode) {
    		super();
    		if (mode == "algorithm") {
    			const oldArray = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].customAlgorithm.modulatedBy;
    			const oldCarriercount = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].customAlgorithm.carrierCount;
    			var comparisonResult = true;
    			if (carry != oldCarriercount) {
    				comparisonResult = false;
    			}
    			else {
    				for (let i = 0; i < oldArray.length; i++) {
    					if (oldArray[i].length != newArray[i].length) {
    						comparisonResult = false;
    						break;
    					}
    					else {
    						for (let j = 0; j < oldArray[i].length; j++) {
    							if (oldArray[i][j] != newArray[i][j]) {
    								comparisonResult = false;
    								break;
    							}
    						}
    					}
    				}
    			}
    			if (comparisonResult == false) {
    				let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
    				instrument.customAlgorithm.set(carry, newArray);
    				instrument.algorithm6Op = 0;
    				doc.notifier.changed();
    				this._didSomething();
    			}
    		}
    		else if (mode == "feedback") {
    			const oldArray = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].customFeedbackType.indices;
    			var comparisonResult = true;
    			for (let i = 0; i < oldArray.length; i++) {
    				if (oldArray[i].length != newArray[i].length) {
    					comparisonResult = false;
    					break;
    				}
    				else {
    					for (let j = 0; j < oldArray[i].length; j++) {
    						if (oldArray[i][j] != newArray[i][j]) {
    							comparisonResult = false;
    							break;
    						}
    					}
    				}
    			}
    			if (!comparisonResult) {
    				let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()]; 
    				instrument.customFeedbackType.set(newArray);
    				instrument.feedbackType6Op = 0;
    				doc.notifier.changed();
    				this._didSomething();
    			}
    		}
    	}
    }


    class ChangePreset extends Change {
        constructor(doc, newValue) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.preset;
            if (oldValue != newValue) {
                const preset1 = EditorConfig.instrumentToPreset(newValue);
                const preset = preset1 !== null && preset1 !== void 0 ? preset1 : EditorConfig.valueToPreset(newValue);
                if (preset != null) {
                    if (preset.customType != undefined) {
                        instrument.type = preset.customType;
                        if (!Config.instrumentTypeHasSpecialInterval[instrument.type] && Config.chords[instrument.chord].customInterval) {
                            instrument.chord = 0;
                        }
                        instrument.clearInvalidEnvelopeTargets();
                    }
                    else if (preset.settings != undefined) {
                        const tempVolume = instrument.volume;
                        const tempPan = instrument.pan;
                        const tempPanDelay = instrument.panDelay;
                        instrument.fromJsonObject(preset.settings, doc.song.getChannelIsNoise(doc.channel), doc.song.getChannelIsMod(doc.channel), doc.song.rhythm == 0 || doc.song.rhythm == 2, doc.song.rhythm >= 2);
                        instrument.volume = tempVolume;
                        instrument.pan = tempPan;
                        instrument.panDelay = tempPanDelay;
                        instrument.effects = (instrument.effects | (1 << 2));
                    }
                } 
                instrument.preset = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeRandomGeneratedInstrument extends Change {
        constructor(doc, usesCurrentInstrumentType) {
            super();
            function selectWeightedRandom(entries) {
                let total = 0;
                for (const entry of entries) {
                    total += entry.weight;
                }
                let random = Math.random() * total;
                for (const entry of entries) {
                    random -= entry.weight;
                    if (random <= 0.0)
                        return entry.item;
                }
                return entries[(Math.random() * entries.length) | 0].item;
            }
            function selectCurvedDistribution(min, max, peak, width) {
                const entries = [];
                for (let i = min; i <= max; i++) {
                    entries.push({ item: i, weight: 1.0 / (Math.pow((i - peak) / width, 2.0) + 1.0) });
                }
                return selectWeightedRandom(entries);
            }
            class PotentialFilterPoint {
                constructor(chance, type, minFreq, maxFreq, centerHz, centerGain) {
                    this.chance = chance;
                    this.type = type;
                    this.minFreq = minFreq;
                    this.maxFreq = maxFreq;
                    this.centerHz = centerHz;
                    this.centerGain = centerGain;
                }
                ;
            }
            function applyFilterPoints(filter, potentialPoints) {
                filter.reset();
                const usedFreqs = [];
                for (const potentialPoint of potentialPoints) {
                    if (Math.random() > potentialPoint.chance)
                        continue;
                    const point = new FilterControlPoint();
                    point.type = potentialPoint.type;
                    point.freq = selectCurvedDistribution(potentialPoint.minFreq, potentialPoint.maxFreq, FilterControlPoint.getRoundedSettingValueFromHz(potentialPoint.centerHz), 1.0 / Config.filterFreqStep);
                    point.gain = selectCurvedDistribution(0, Config.filterGainRange - 1, Config.filterGainCenter + potentialPoint.centerGain, 2.0 / Config.filterGainStep);
                    if (point.type == 2 && point.gain == Config.filterGainCenter)
                        continue;
                    if (usedFreqs.includes(point.freq))
                        continue;
                    usedFreqs.push(point.freq);
                    filter.controlPoints[filter.controlPointCount] = point;
                    filter.controlPointCount++;
                }
            }
            const isNoise = doc.song.getChannelIsNoise(doc.channel);
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.effects = 1 << 2;
            instrument.aliases = false;
            instrument.envelopeCount = 0;
            const midFreq = FilterControlPoint.getRoundedSettingValueFromHz(700.0);
            const maxFreq = Config.filterFreqRange - 1;
            applyFilterPoints(instrument.eqFilter, [
                new PotentialFilterPoint(0.8, 0, midFreq, maxFreq, 4000.0, -1),
                new PotentialFilterPoint(0.4, 1, 0, midFreq - 1, 250.0, -1),
                new PotentialFilterPoint(0.5, 2, 0, maxFreq, 2000.0, 0),
                new PotentialFilterPoint(0.4, 2, 0, maxFreq, 1400.0, 0),
                new PotentialFilterPoint(0.3, 2, 0, maxFreq, 1000.0, 0),
                new PotentialFilterPoint(0.2, 2, 0, maxFreq, 500.0, 0),
            ]);
            if (isNoise) {
                const type = usesCurrentInstrumentType ? instrument.type :
                    selectWeightedRandom([
                        { item: 2, weight: 3 },
                        { item: 3, weight: 3 },
                        { item: 4, weight: 1 },
                    ]);
                instrument.preset = instrument.type = type;
                if (type != 4) {
                    instrument.fadeIn = (Math.random() < 0.8) ? 0 : selectCurvedDistribution(0, Config.fadeInRange - 1, 0, 2);
                    instrument.fadeOut = selectCurvedDistribution(0, Config.fadeOutTicks.length - 1, Config.fadeOutNeutral, 2);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 10;
                    instrument.transition = Config.transitions.dictionary[selectWeightedRandom([
                        { item: "normal", weight: 30 },
                        { item: "interrupt", weight: 1 },
                        { item: "slide", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.2) {
                    instrument.effects |= 1 << 11;
                    instrument.chord = Config.chords.dictionary[selectWeightedRandom([
                        { item: "strum", weight: 2 },
                        { item: "arpeggio", weight: 1 },
                    ])].index;
                }
                if (Math.random() < 0.1) {
                    instrument.pitchShift = selectCurvedDistribution(0, Config.pitchShiftRange - 1, Config.pitchShiftCenter, 2);
                    if (instrument.pitchShift != Config.pitchShiftCenter) {
                        instrument.effects |= 1 << 7;
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["pitchShift"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 1 },
                            { item: "random", weight: 2 },
                            { item: "flare", weight: 2 },
                            { item: "twang", weight: 16 },
                            { item: "swell", weight: 2 },
                            { item: "lfo", weight: 1 },
                            { item: "decay", weight: 4 },
                            { item: "blip", weight: 8 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 50, 13)]);
                    }
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 9;
                    instrument.vibrato = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.vibrato = Config.vibratos.dictionary[selectWeightedRandom([
                        { item: "light", weight: 2 },
                        { item: "delayed", weight: 2 },
                        { item: "heavy", weight: 1 },
                        { item: "shaky", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.8) {
                    instrument.effects |= 1 << 5;
                    applyFilterPoints(instrument.noteFilter, [
                        new PotentialFilterPoint(1.0, 0, midFreq, maxFreq, 8000.0, -1),
                    ]);
                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteFilterAllFreqs"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                        { item: "note size", weight: 2 },
                        { item: "pitch", weight: 2 },
                        { item: "punch", weight: 4 },
                        { item: "flare", weight: 4 },
                        { item: "twang", weight: 16 },
                        { item: "swell", weight: 4 },
                        { item: "lfo", weight: 8 },
                        { item: "decay", weight: 8 },
                        { item: "wibble", weight: 4 },
                        { item: "linear", weight: 4 },
                        { item: "fall", weight: 4 },
                    ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 30, 30)]);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 3;
                    instrument.distortion = selectCurvedDistribution(1, Config.distortionRange - 1, Config.distortionRange - 1, 2);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 4;
                    instrument.bitcrusherFreq = selectCurvedDistribution(0, Config.bitcrusherFreqRange - 1, Config.bitcrusherFreqRange >> 1, 2);
                    instrument.bitcrusherQuantization = selectCurvedDistribution(0, Config.bitcrusherQuantizationRange - 1, Config.bitcrusherQuantizationRange >> 1, 2);
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 1;
                    instrument.chorus = selectCurvedDistribution(1, Config.chorusRange - 1, Config.chorusRange - 1, 1);
                }
                if (Math.random() < 0.1) {
                    instrument.echoSustain = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.echoDelay = selectCurvedDistribution(0, Config.echoDelayRange - 1, Config.echoDelayRange >> 1, 2);
                    if (instrument.echoSustain != 0 || instrument.echoDelay != 0) {
                        instrument.effects |= 1 << 6;
                    }
                }
                if (Math.random() < 0.5) {
                    instrument.effects |= 1 << 0;
                    instrument.reverb = selectCurvedDistribution(1, Config.reverbRange - 1, 1, 1);
                }
                if (type == 2 || type == 3) {
                    instrument.unison = Config.unisons.dictionary[selectWeightedRandom([
                        { item: "none", weight: 100 },
                        { item: "shimmer", weight: 10 },
                        { item: "hum", weight: 8 },
                        { item: "honky tonk", weight: 6 },
                        { item: "dissonant", weight: 2 },
                        { item: "fifth", weight: 4 },
                        { item: "octave", weight: 5 },
                        { item: "bowed", weight: 4 },
                        { item: "piano", weight: 10 },
                        { item: "warbled", weight: 5 },
                        { item: "hecking gosh", weight: 3 },
                        { item: "spinner", weight: 6 },
                        { item: "detune", weight: 4 },
                        { item: "rising", weight: 2 },
                        { item: "vibrate", weight: 3 },
                        { item: "bass", weight: 2 },
                        { item: "recurve", weight: 3 },
                        { item: "inject", weight: 2 },
                        { item: "FART", weight: 1 },
                        { item: "augmented", weight: 1 },
                        { item: "diminished", weight: 1 },
                        { item: "chorus", weight: 2 },
                        { item: "block", weight: 1 },
                        { item: "bow", weight: 2 },
                    ])].index;
                    if (instrument.unison != Config.unisons.dictionary["none"].index && Math.random() > 0.4)
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["unison"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 2 },
                            { item: "pitch", weight: 2 },
                            { item: "twang", weight: 6 },
                            { item: "swell", weight: 1 },
                            { item: "decay", weight: 6 },
                            { item: "wibble", weight: 4 },
                            { item: "linear", weight: 6 },
                            { item: "rise", weight: 2 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 57, 6)]);
                }
                function normalize(harmonics) {
                    let max = 0;
                    for (const value of harmonics) {
                        if (value > max)
                            max = value;
                    }
                    for (let i = 0; i < harmonics.length; i++) {
                        harmonics[i] = Config.harmonicsMax * harmonics[i] / max;
                    }
                }
                switch (type) {
                    case 2:
                        {
                            instrument.chipNoise = (Math.random() * Config.chipNoises.length) | 0;
                        }
                        break;
                    case 3:
                        {
                            const spectrumGenerators = [
                                () => {
                                    const spectrum = [];
                                    for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                        spectrum[i] = (Math.random() < 0.5) ? Math.random() : 0.0;
                                    }
                                    return spectrum;
                                },
                                () => {
                                    let current = 1.0;
                                    const spectrum = [current];
                                    for (let i = 1; i < Config.spectrumControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.52);
                                        spectrum[i] = current;
                                    }
                                    return spectrum;
                                },
                                () => {
                                    let current = 1.0;
                                    const spectrum = [current];
                                    for (let i = 1; i < Config.spectrumControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.52);
                                        spectrum[i] = current * Math.random();
                                    }
                                    return spectrum;
                                },
                            ];
                            const generator = spectrumGenerators[(Math.random() * spectrumGenerators.length) | 0];
                            const spectrum = generator();
                            normalize(spectrum);
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                instrument.spectrumWave.spectrum[i] = Math.round(spectrum[i]);
                            }
                            instrument.spectrumWave.markCustomWaveDirty();
                        }
                        break;
                    case 4:
                        {
                            for (let i = 0; i < Config.drumCount; i++) {
                                instrument.drumsetEnvelopes[i] = Math.floor(Math.random() * Config.envelopes.length);
                                const spectrum = [];
                                let randomFactor = Math.floor(Math.random() * 3);
                                for (let j = 0; j < Config.spectrumControlPoints; j++) {
                                    if (randomFactor == 0 || randomFactor == 3)
                                        spectrum[j] = Math.pow(Math.random(), 3) * 0.25;
                                    else if (randomFactor == 1)
                                        spectrum[j] = Math.pow(Math.random(), ((i / 8) + 1));
                                    else if (randomFactor == 2)
                                        spectrum[j] = (Math.pow(Math.random(), 2)) * ((i / 3) + 1);
                                    else
                                        spectrum[j] = Math.pow(Math.random(), 3) * 0.25;
                                }
                                normalize(spectrum);
                                for (let j = 0; j < Config.spectrumControlPoints; j++) {
                                    instrument.drumsetSpectrumWaves[i].spectrum[j] = Math.round(spectrum[j]);
                                }
                                instrument.drumsetSpectrumWaves[i].markCustomWaveDirty();
                            }
                        }
                        break;
                    default: throw new Error("Unhandled noise instrument type in random generator.");
                }
            }
            else {
                const type = usesCurrentInstrumentType ? instrument.type :
                    selectWeightedRandom([
                        { item: 0, weight: 2 },
                        { item: 6, weight: 2 },
                        { item: 8, weight: 2 },
                        { item: 9, weight: 2 },
                        { item: 5, weight: 2 },
                        { item: 7, weight: 2 },
                        { item: 3, weight: 2 },
                        { item: 1, weight: 2 },
                        { item: 11, weight: 2 },
                    ]);
                instrument.preset = instrument.type = type;
                instrument.fadeIn = (Math.random() < 0.5) ? 0 : selectCurvedDistribution(0, Config.fadeInRange - 1, 0, 2);
                instrument.fadeOut = selectCurvedDistribution(0, Config.fadeOutTicks.length - 1, Config.fadeOutNeutral, 2);
                if (type == 0 || type == 5 || type == 7 || type == 9 || type == 6 || type == 3) {
                    instrument.unison = Config.unisons.dictionary[selectWeightedRandom([
                        { item: "none", weight: 100 },
                        { item: "shimmer", weight: 10 },
                        { item: "hum", weight: 8 },
                        { item: "honky tonk", weight: 6 },
                        { item: "dissonant", weight: 2 },
                        { item: "fifth", weight: 4 },
                        { item: "octave", weight: 5 },
                        { item: "bowed", weight: 4 },
                        { item: "piano", weight: 10 },
                        { item: "warbled", weight: 5 },
                        { item: "hecking gosh", weight: 3 },
                        { item: "spinner", weight: 6 },
                        { item: "detune", weight: 4 },
                        { item: "rising", weight: 2 },
                        { item: "vibrate", weight: 3 },
                        { item: "bass", weight: 2 },
                        { item: "recurve", weight: 3 },
                        { item: "inject", weight: 2 },
                        { item: "FART", weight: 1 },
                        { item: "augmented", weight: 1 },
                        { item: "diminished", weight: 1 },
                        { item: "chorus", weight: 2 },
                        { item: "block", weight: 1 },
                        { item: "bow", weight: 2 },
                    ])].index;
                    instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                    instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                    instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                    instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                    instrument.unisonSign = Config.unisons[instrument.unison].sign;
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 10;
                    instrument.transition = Config.transitions.dictionary[selectWeightedRandom([
                        { item: "interrupt", weight: 1 },
                        { item: "slide", weight: 2 },
                        { item: "continue", weight: 1 },
                    ])].index;
                }
                if (Math.random() < 0.2) {
                    instrument.effects |= 1 << 11;
                    instrument.chord = Config.chords.dictionary[selectWeightedRandom([
                        { item: "strum", weight: 2 },
                        { item: "arpeggio", weight: 1 },
                    ])].index;
                }
                if (Math.random() < 0.05) {
                    instrument.pitchShift = selectCurvedDistribution(0, Config.pitchShiftRange - 1, Config.pitchShiftCenter, 1);
                    if (instrument.pitchShift != Config.pitchShiftCenter) {
                        instrument.effects |= 1 << 7;
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["pitchShift"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 2 },
                            { item: "pitch", weight: 2 },
                            { item: "random", weight: 3 },
                            { item: "flare", weight: 4 },
                            { item: "twang", weight: 20 },
                            { item: "decay", weight: 6 },
                            { item: "linear", weight: 1 },
                            { item: "blip", weight: 10 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 50, 13)]);
                    }
                }
                if (Math.random() < 0.25) {
                    instrument.effects |= 1 << 9;
                    instrument.vibrato = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.vibrato = Config.vibratos.dictionary[selectWeightedRandom([
                        { item: "light", weight: 2 },
                        { item: "delayed", weight: 2 },
                        { item: "heavy", weight: 1 },
                        { item: "shaky", weight: 2 },
                    ])].index;
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 3;
                    instrument.distortion = selectCurvedDistribution(1, Config.distortionRange - 1, Config.distortionRange - 1, 2);
                    if (Math.random() < 0.3) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["distortion"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 3 },
                            { item: "pitch", weight: 4 },
                            { item: "random", weight: 1 },
                            { item: "punch", weight: 2 },
                            { item: "flare", weight: 3 },
                            { item: "twang", weight: 10 },
                            { item: "swell", weight: 8 },
                            { item: "lfo", weight: 7 },
                            { item: "decay", weight: 5 },
                            { item: "wibble", weight: 5 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 8 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 45, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 2 }, { item: 2, weight: 5 }]));
                    }
                }
                if (effectsIncludeDistortion(instrument.effects) && Math.random() < 0.8) {
                    instrument.effects |= 1 << 5;
                    applyFilterPoints(instrument.noteFilter, [
                        new PotentialFilterPoint(1.0, 0, midFreq, maxFreq, 2000.0, -1),
                        new PotentialFilterPoint(0.9, 1, 0, midFreq - 1, 500.0, -1),
                        new PotentialFilterPoint(0.4, 2, 0, maxFreq, 1400.0, 0),
                    ]);
                }
                else if (Math.random() < 0.5) {
                    instrument.effects |= 1 << 5;
                    applyFilterPoints(instrument.noteFilter, [
                        new PotentialFilterPoint(1.0, 0, midFreq, maxFreq, 8000.0, -1),
                    ]);
                    let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                    let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                    if (envelopeLowerBound >= envelopeUpperBound) {
                        envelopeLowerBound = 0;
                        envelopeUpperBound = 1;
                    }
                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteFilterAllFreqs"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                        { item: "note size", weight: 2 },
                        { item: "pitch", weight: 2 },
                        { item: "punch", weight: 6 },
                        { item: "flare", weight: 3 },
                        { item: "twang", weight: 7 },
                        { item: "swell", weight: 8 },
                        { item: "lfo", weight: 12 },
                        { item: "decay", weight: 3 },
                        { item: "wibble", weight: 5 },
                        { item: "linear", weight: 4 },
                        { item: "rise", weight: 8 },
                        { item: "fall", weight: 2 },
                    ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 30, 30)], envelopeLowerBound, envelopeUpperBound, 2, 2, selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 4 }, { item: 3, weight: 2 }, { item: 1, weight: 1 }]));
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 4;
                    instrument.bitcrusherFreq = selectCurvedDistribution(0, Config.bitcrusherFreqRange - 1, 0, 2);
                    instrument.bitcrusherQuantization = selectCurvedDistribution(0, Config.bitcrusherQuantizationRange - 1, Config.bitcrusherQuantizationRange >> 1, 2);
                    let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                    let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                    if (envelopeLowerBound >= envelopeUpperBound) {
                        envelopeLowerBound = 0;
                        envelopeUpperBound = 1;
                    }
                    if (Math.random() < 0.3) {
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["bitcrusherFrequency"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 4 },
                            { item: "pitch", weight: 3 },
                            { item: "random", weight: 12 },
                            { item: "flare", weight: 3 },
                            { item: "twang", weight: 7 },
                            { item: "swell", weight: 4 },
                            { item: "lfo", weight: 12 },
                            { item: "decay", weight: 2 },
                            { item: "wibble", weight: 1 },
                            { item: "linear", weight: 6 },
                            { item: "rise", weight: 5 },
                            { item: "blip", weight: 12 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 20, 34)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 3 }, { item: 2, weight: 1 }]));
                    }
                    if (Math.random() < 0.5) {
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["bitcrusherQuantization"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 8 },
                            { item: "pitch", weight: 3 },
                            { item: "random", weight: 12 },
                            { item: "flare", weight: 3 },
                            { item: "twang", weight: 7 },
                            { item: "swell", weight: 4 },
                            { item: "lfo", weight: 12 },
                            { item: "decay", weight: 2 },
                            { item: "wibble", weight: 1 },
                            { item: "linear", weight: 6 },
                            { item: "rise", weight: 5 },
                            { item: "blip", weight: 12 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 20, 34)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 3 }, { item: 2, weight: 1 }]));
                    }
                    else if (type == 3) {
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteVolume"].index, 0, Config.newEnvelopes.dictionary["note size"].index, true);
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["bitcrusherQuantization"].index, 0, Config.newEnvelopes.dictionary["note size"].index, true);
                    }
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 1;
                    instrument.chorus = selectCurvedDistribution(1, Config.chorusRange - 1, Config.chorusRange - 1, 1);
                    if (Math.random() < 0.1) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["chorus"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 3 },
                            { item: "pitch", weight: 4 },
                            { item: "random", weight: 1 },
                            { item: "punch", weight: 2 },
                            { item: "flare", weight: 3 },
                            { item: "twang", weight: 10 },
                            { item: "swell", weight: 8 },
                            { item: "lfo", weight: 7 },
                            { item: "decay", weight: 5 },
                            { item: "wibble", weight: 5 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 8 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 45, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 2 }, { item: 2, weight: 5 }]));
                    }
                }
                if (Math.random() < 0.1) {
                    instrument.echoSustain = selectCurvedDistribution(0, Config.echoSustainRange - 1, Config.echoSustainRange >> 1, 2);
                    instrument.echoDelay = selectCurvedDistribution(0, Config.echoDelayRange - 1, Config.echoDelayRange >> 1, 2);
                    if (instrument.echoSustain != 0 || instrument.echoDelay != 0) {
                        instrument.effects |= 1 << 6;
                        if (Math.random() < 0.04) {
                            let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                            let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                            if (envelopeLowerBound >= envelopeUpperBound) {
                                envelopeLowerBound = 0;
                                envelopeUpperBound = 1;
                            }
                            instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["echoDelay"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                { item: "note size", weight: 4 },
                                { item: "pitch", weight: 8 },
                                { item: "random", weight: 7 },
                                { item: "twang", weight: 3 },
                                { item: "swell", weight: 3 },
                                { item: "lfo", weight: 4 },
                                { item: "decay", weight: 1 },
                                { item: "wibble", weight: 1 },
                                { item: "linear", weight: 2 },
                                { item: "rise", weight: 1 },
                                { item: "fall", weight: 2 },
                            ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 45, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }]));
                        }
                    }
                }
                if (Math.random() < 0.07) {
                    instrument.ringModulation = selectCurvedDistribution(1, Config.ringModRange - 1, Config.ringModRange / 2, Config.ringModRange / 2);
                    instrument.ringModulationHz = selectCurvedDistribution(1, Config.ringModHzRange - 1, Config.ringModHzRange / 2, Config.ringModHzRange / 2);
                    if (instrument.ringModulation != 0 || instrument.ringModulationHz != 0) {
                        instrument.effects |= 1 << 13;
                        instrument.ringModWaveformIndex = 0;
                        if (Math.random() < 0.1) {
                            let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                            let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                            if (envelopeLowerBound >= envelopeUpperBound) {
                                envelopeLowerBound = 0;
                                envelopeUpperBound = 1;
                            }
                            instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["ringModulation"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                { item: "note size", weight: 4 },
                                { item: "pitch", weight: 8 },
                                { item: "random", weight: 7 },
                                { item: "punch", weight: 1 },
                                { item: "flare", weight: 1 },
                                { item: "twang", weight: 8 },
                                { item: "swell", weight: 6 },
                                { item: "lfo", weight: 6 },
                                { item: "decay", weight: 4 },
                                { item: "wibble", weight: 2 },
                                { item: "linear", weight: 4 },
                                { item: "rise", weight: 3 },
                                { item: "fall", weight: 4 },
                            ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 25, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }]));
                        }
                        if (Math.random() < 0.3) {
                            let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                            let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                            if (envelopeLowerBound >= envelopeUpperBound) {
                                envelopeLowerBound = 0;
                                envelopeUpperBound = 1;
                            }
                            instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["ringModulationHz"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                { item: "note size", weight: 4 },
                                { item: "pitch", weight: 8 },
                                { item: "random", weight: 7 },
                                { item: "punch", weight: 1 },
                                { item: "flare", weight: 4 },
                                { item: "twang", weight: 8 },
                                { item: "swell", weight: 6 },
                                { item: "lfo", weight: 6 },
                                { item: "decay", weight: 4 },
                                { item: "wibble", weight: 2 },
                                { item: "linear", weight: 4 },
                                { item: "rise", weight: 3 },
                                { item: "fall", weight: 4 },
                            ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 25, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }, { item: 1, weight: 1 }]));
                        }
                    }
                }
                if (Math.random() < 0.5) {
                    instrument.effects |= 1 << 0;
                    instrument.reverb = selectCurvedDistribution(1, Config.reverbRange - 1, 1, 1);
                    if (Math.random() < 0.03) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["reverb"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 3 },
                            { item: "pitch", weight: 4 },
                            { item: "random", weight: 1 },
                            { item: "punch", weight: 2 },
                            { item: "flare", weight: 3 },
                            { item: "twang", weight: 10 },
                            { item: "swell", weight: 8 },
                            { item: "lfo", weight: 7 },
                            { item: "decay", weight: 5 },
                            { item: "wibble", weight: 5 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 8 },
                            { item: "fall", weight: 2 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 45, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 2 }, { item: 2, weight: 5 }]));
                    }
                }
                if (Math.random() < 0.1) {
                    instrument.effects |= 1 << 14;
                    instrument.granular = selectCurvedDistribution(1, Config.granularRange - 1, Config.granularRange / 2, Config.granularRange / 3);
                    instrument.grainAmounts = selectCurvedDistribution(1, Config.grainAmountsMax - 1, Config.grainAmountsMax - 2, 3);
                    instrument.grainSize = selectCurvedDistribution(Config.grainSizeMin / Config.grainSizeStep, Config.grainSizeMax / Config.grainSizeStep, Config.grainSizeMax / Config.grainSizeStep, Config.grainSizeMax / Config.grainSizeStep / 2);
                    instrument.grainRange = selectCurvedDistribution(0, Config.grainRangeMax / Config.grainSizeStep, Config.grainRangeMax / Config.grainSizeStep / 2, Config.grainSizeMax / Config.grainSizeStep / 2);
                    if (Math.random() < 0.2) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["granular"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 10 },
                            { item: "pitch", weight: 8 },
                            { item: "random", weight: 2 },
                            { item: "twang", weight: 8 },
                            { item: "swell", weight: 6 },
                            { item: "lfo", weight: 4 },
                            { item: "decay", weight: 4 },
                            { item: "wibble", weight: 2 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 3 },
                            { item: "fall", weight: 4 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 25, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }, { item: 1, weight: 1 }]));
                    }
                    if (Math.random() < 0.3) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["grainFreq"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 10 },
                            { item: "pitch", weight: 8 },
                            { item: "random", weight: 7 },
                            { item: "flare", weight: 1 },
                            { item: "twang", weight: 8 },
                            { item: "swell", weight: 6 },
                            { item: "lfo", weight: 6 },
                            { item: "decay", weight: 4 },
                            { item: "wibble", weight: 3 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 3 },
                            { item: "fall", weight: 4 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 25, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }, { item: 1, weight: 1 }]));
                    }
                    if (Math.random() < 0.3) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["grainSize"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 10 },
                            { item: "pitch", weight: 8 },
                            { item: "random", weight: 7 },
                            { item: "punch", weight: 1 },
                            { item: "flare", weight: 1 },
                            { item: "twang", weight: 5 },
                            { item: "swell", weight: 8 },
                            { item: "lfo", weight: 6 },
                            { item: "decay", weight: 3 },
                            { item: "wibble", weight: 2 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 6 },
                            { item: "fall", weight: 4 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 25, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }, { item: 1, weight: 1 }]));
                    }
                    if (Math.random() < 0.05) {
                        let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                        if (envelopeLowerBound >= envelopeUpperBound) {
                            envelopeLowerBound = 0;
                            envelopeUpperBound = 1;
                        }
                        instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["grainRange"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                            { item: "note size", weight: 10 },
                            { item: "pitch", weight: 8 },
                            { item: "random", weight: 7 },
                            { item: "punch", weight: 1 },
                            { item: "flare", weight: 1 },
                            { item: "twang", weight: 8 },
                            { item: "swell", weight: 6 },
                            { item: "lfo", weight: 6 },
                            { item: "decay", weight: 4 },
                            { item: "wibble", weight: 2 },
                            { item: "linear", weight: 4 },
                            { item: "rise", weight: 3 },
                            { item: "fall", weight: 4 },
                        ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 25, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 3 }, { item: 1, weight: 1 }]));
                    }
                }
                if (Math.random() < 0.2) {
                    let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                    let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                    if (envelopeLowerBound >= envelopeUpperBound) {
                        envelopeLowerBound = 0;
                        envelopeUpperBound = 1; 
                    }
                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["noteVolume"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                        { item: "pitch", weight: 1 },
                        { item: "random", weight: 4 },
                        { item: "punch", weight: 6 },
                        { item: "flare", weight: 3 },
                        { item: "twang", weight: 13 },
                        { item: "swell", weight: 7 },
                        { item: "lfo", weight: 2 },
                        { item: "decay", weight: 4 },
                        { item: "wibble", weight: 3 },
                        { item: "linear", weight: 4 },
                        { item: "rise", weight: 4 },
                        { item: "fall", weight: 3 },
                    ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 40, 20)], envelopeLowerBound, envelopeUpperBound, selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 1, weight: 2 }]));
                }
                function normalize(harmonics) {
                    let max = 0;
                    for (const value of harmonics) {
                        if (value > max)
                            max = value;
                    }
                    for (let i = 0; i < harmonics.length; i++) {
                        harmonics[i] = Config.harmonicsMax * harmonics[i] / max;
                    }
                }
                switch (type) {
                    case 0:
                        {
                            instrument.chipWave = (Math.random() * Config.chipWaves.length) | 0;
                            instrument.isUsingAdvancedLoopControls = false;
                            instrument.chipWaveLoopStart = 0;
                            instrument.chipWaveLoopEnd = Config.rawRawChipWaves[instrument.chipWave].samples.length - 1;
                            instrument.chipWaveLoopMode = 0;
                            instrument.chipWavePlayBackwards = false;
                            instrument.chipWaveStartOffset = 0;
                        }
                        break;
                    case 6:
                    case 8:
                        {
                            if (type == 8) {
                                instrument.supersawDynamism = selectCurvedDistribution(0, Config.supersawDynamismMax, Config.supersawDynamismMax, 2);
                                instrument.supersawSpread = selectCurvedDistribution(0, Config.supersawSpreadMax, Math.ceil(Config.supersawSpreadMax / 3), 4);
                                instrument.supersawShape = selectCurvedDistribution(0, Config.supersawShapeMax, 0, 4);
                            }
                            instrument.pulseWidth = selectCurvedDistribution(0, Config.pulseWidthRange - 1, Config.pulseWidthRange - 1, 2);
                            instrument.decimalOffset = 0;
                            if (Math.random() < 0.6) {
                                instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["pulseWidth"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                    { item: "note size", weight: 2 },
                                    { item: "pitch", weight: 1 },
                                    { item: "random", weight: 3 },
                                    { item: "punch", weight: 6 },
                                    { item: "flare", weight: 3 },
                                    { item: "twang", weight: 6 },
                                    { item: "swell", weight: 8 },
                                    { item: "lfo", weight: 6 },
                                    { item: "decay", weight: 2 },
                                    { item: "wibble", weight: 6 },
                                    { item: "linear", weight: 3 },
                                    { item: "rise", weight: 5 },
                                    { item: "blip", weight: 10 },
                                    { item: "fall", weight: 4 },
                                ])].index, false, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 40, 20)], selectWeightedRandom([
                                    { item: 0, weight: 8 },
                                    { item: 0.1, weight: 4 },
                                    { item: 0.2, weight: 3 },
                                    { item: 0.3, weight: 1 },
                                    { item: 0.4, weight: 2 },
                                    { item: 0.5, weight: 6 },
                                ]), selectWeightedRandom([
                                    { item: 0.6, weight: 1 },
                                    { item: 0.7, weight: 2 },
                                    { item: 0.8, weight: 3 },
                                    { item: 0.9, weight: 5 },
                                    { item: 1, weight: 8 }
                                ]), selectCurvedDistribution(2, 16, 2, 6), selectCurvedDistribution(1, 63, 32, 31), selectWeightedRandom([{ item: 0, weight: 8 }, { item: 1, weight: 2 }]));
                            }
                        }
                        break;
                    case 7:
                    case 5:
                        {
                            if (type == 7) {
                                instrument.stringSustain = (Math.random() * Config.stringSustainRange) | 0;
                            }
                            const harmonicGenerators = [
                                () => {
                                    const harmonics = [];
                                    for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                                        harmonics[i] = (Math.random() < 0.4) ? Math.random() : 0.0;
                                    }
                                    harmonics[(Math.random() * 8) | 0] = Math.pow(Math.random(), 0.25);
                                    return harmonics;
                                },
                                () => {
                                    let current = 1.0;
                                    const harmonics = [current];
                                    for (let i = 1; i < Config.harmonicsControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.55);
                                        harmonics[i] = current;
                                    }
                                    return harmonics;
                                },
                                () => {
                                    let current = 1.0;
                                    const harmonics = [current];
                                    for (let i = 1; i < Config.harmonicsControlPoints; i++) {
                                        current *= Math.pow(2, Math.random() - 0.55);
                                        harmonics[i] = current * Math.random();
                                    }
                                    return harmonics;
                                },
                            ];
                            const generator = harmonicGenerators[(Math.random() * harmonicGenerators.length) | 0];
                            const harmonics = generator();
                            normalize(harmonics);
                            for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                                instrument.harmonicsWave.harmonics[i] = Math.round(harmonics[i]);
                            }
                            instrument.harmonicsWave.markCustomWaveDirty();
                        }
                        break;
                    case 3:
                        {
                            const spectrum = [];
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                const isHarmonic = i == 0 || i == 7 || i == 11 || i == 14 || i == 16 || i == 18 || i == 21;
                                if (isHarmonic) {
                                    spectrum[i] = Math.pow(Math.random(), 0.25);
                                }
                                else {
                                    spectrum[i] = Math.pow(Math.random(), 3) * 0.5;
                                }
                            }
                            normalize(spectrum);
                            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                                instrument.spectrumWave.spectrum[i] = Math.round(spectrum[i]);
                            }
                            instrument.spectrumWave.markCustomWaveDirty();
                        }
                        break;
                    case 11:
                    	case 12:
                    case 1:
                        {
                            if (type == 1) {
                                instrument.algorithm = (Math.random() * Config.algorithms.length) | 0;
                                instrument.feedbackType = (Math.random() * Config.feedbacks.length) | 0;
                            }
                            else {
                                
                                if(type!==12){
                               	instrument.algorithm6Op = (Math.random() * (Config.algorithms6Op.length - 1) + 1) | 0;
                                instrument.customAlgorithm.fromPreset(instrument.algorithm6Op,6);
                                instrument.feedbackType6Op = (Math.random() * (Config.feedbacks6Op.length - 1) + 1) | 0;
                                instrument.customFeedbackType.fromPreset(instrument.feedbackType6Op,6);
                                }else{
                                instrument.algorithm6Op = (Math.random() * (Config.algorithms8Op.length - 1) + 1) | 0;
                                instrument.customAlgorithm.fromPreset(instrument.algorithm6Op,8);
                                instrument.feedbackType6Op = (Math.random() * (Config.feedbacks8Op.length - 1) + 1) | 0;
                                instrument.customFeedbackType.fromPreset(instrument.feedbackType6Op,8);
                                }
                                
                            } 
                            const algorithm = type == 1 ? Config.algorithms[instrument.algorithm] : type == 12 ?
                            Config.algorithms8Op[instrument.algorithm6Op] : Config.algorithms6Op[instrument.algorithm6Op];
                            for (let i = 0; i < algorithm.carrierCount; i++) {
                                instrument.operators[i].frequency = selectCurvedDistribution(0, Config.operatorFrequencies.length - 1, 0, 3);
                                instrument.operators[i].amplitude = selectCurvedDistribution(0, Config.operatorAmplitudeMax, Config.operatorAmplitudeMax - 1, 2);
                                instrument.operators[i].waveform = Config.operatorWaves.dictionary[selectWeightedRandom([
                                    { item: "sine", weight: 10 },
                                    { item: "triangle", weight: 6 },
                                    { item: "pulse width", weight: 6 },
                                    { item: "sawtooth", weight: 3 },
                                    { item: "ramp", weight: 3 },
                                    { item: "trapezoid", weight: 4 },
                                    { item: "quasi-sine", weight: 2 },
                                    { item: "exp wave", weight: 6 },
                                ])].index;
                                if (instrument.operators[i].waveform == 2) {
                                    instrument.operators[i].pulseWidth = selectWeightedRandom([
                                        { item: 0, weight: 3 },
                                        { item: 1, weight: 5 },
                                        { item: 2, weight: 7 },
                                        { item: 3, weight: 10 },
                                        { item: 4, weight: 15 },
                                        { item: 5, weight: 25 },
                                        { item: 6, weight: 15 },
                                        { item: 7, weight: 10 },
                                        { item: 8, weight: 7 },
                                        { item: 9, weight: 5 },
                                        { item: 9, weight: 3 },
                                    ]);
                                }
                            }
                            for (let i = algorithm.carrierCount; i < Config.operatorCount + (type == 11 ? 2 : type == 12 ? 4 :0); i++) {
                                instrument.operators[i].frequency = selectCurvedDistribution(3, Config.operatorFrequencies.length - 1, 0, 3);
                                instrument.operators[i].amplitude = (Math.pow(Math.random(), 2) * Config.operatorAmplitudeMax) | 0;
                                if (instrument.envelopeCount < Config.maxEnvelopeCount && Math.random() < 0.4) {
                                    let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                                    let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                                    if (envelopeLowerBound >= envelopeUpperBound) {
                                        envelopeLowerBound = 0;
                                        envelopeUpperBound = 1;
                                    }
                                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["operatorAmplitude"].index, i, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                        { item: "punch", weight: 2 },
                                        { item: "pitch", weight: 1 },
                                        { item: "flare", weight: 3 },
                                        { item: "twang", weight: 4 },
                                        { item: "swell", weight: 4 },
                                        { item: "lfo", weight: 6 },
                                        { item: "decay", weight: 2 },
                                        { item: "wibble", weight: 5 },
                                        { item: "linear", weight: 3 },
                                        { item: "rise", weight: 5 },
                                        { item: "fall", weight: 2 },
                                    ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 30, 30)], envelopeLowerBound, envelopeUpperBound, 2, 2, selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 4 }, { item: 3, weight: 2 }, { item: 1, weight: 1 }]));
                                }
                                if (instrument.envelopeCount < Config.maxEnvelopeCount && Math.random() < 0.15) {
                                    let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                                    let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                                    if (envelopeLowerBound >= envelopeUpperBound) {
                                        envelopeLowerBound = 0;
                                        envelopeUpperBound = 1;
                                    }
                                    instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["operatorFrequency"].index, i, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                        { item: "punch", weight: 2 },
                                        { item: "pitch", weight: 1 },
                                        { item: "flare", weight: 3 },
                                        { item: "twang", weight: 10 },
                                        { item: "swell", weight: 5 },
                                        { item: "lfo", weight: 6 },
                                        { item: "decay", weight: 2 },
                                        { item: "wibble", weight: 5 },
                                        { item: "linear", weight: 3 },
                                        { item: "rise", weight: 5 },
                                        { item: "fall", weight: 2 },
                                    ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 30, 30)], envelopeLowerBound, envelopeUpperBound, 2, 2, selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 4 }, { item: 3, weight: 4 }, { item: 1, weight: 1 }]));
                                }
                                instrument.operators[i].waveform = Config.operatorWaves.dictionary[selectWeightedRandom([
                                    { item: "sine", weight: 10 },
                                    { item: "triangle", weight: 6 },
                                    { item: "pulse width", weight: 6 },
                                    { item: "sawtooth", weight: 3 },
                                    { item: "ramp", weight: 3 },
                                    { item: "trapezoid", weight: 4 },
                                    { item: "quasi-sine", weight: 2 },
                                    { item: "exp wave", weight: 6 },
                                ])].index;
                                if (instrument.operators[i].waveform == 2) {
                                    instrument.operators[i].pulseWidth = selectWeightedRandom([
                                        { item: 0, weight: 3 },
                                        { item: 1, weight: 5 },
                                        { item: 2, weight: 7 },
                                        { item: 3, weight: 10 },
                                        { item: 4, weight: 15 },
                                        { item: 5, weight: 25 },
                                        { item: 6, weight: 15 },
                                        { item: 7, weight: 10 },
                                        { item: 8, weight: 7 },
                                        { item: 9, weight: 5 },
                                        { item: 9, weight: 3 },
                                    ]);
                                }
                            }
                            instrument.feedbackAmplitude = (Math.pow(Math.random(), 3) * Config.operatorAmplitudeMax) | 0;
                            if (instrument.envelopeCount < Config.maxEnvelopeCount && Math.random() < 0.4) {
                                let envelopeLowerBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                                let envelopeUpperBound = selectCurvedDistribution(0, 20, 8, 5) / 10;
                                if (envelopeLowerBound >= envelopeUpperBound) {
                                    envelopeLowerBound = 0;
                                    envelopeUpperBound = 1;
                                }
                                instrument.addEnvelope(Config.instrumentAutomationTargets.dictionary["feedbackAmplitude"].index, 0, Config.newEnvelopes.dictionary[selectWeightedRandom([
                                    { item: "note size", weight: 4 },
                                    { item: "punch", weight: 2 },
                                    { item: "pitch", weight: 1 },
                                    { item: "flare", weight: 2 },
                                    { item: "twang", weight: 2 },
                                    { item: "swell", weight: 4 },
                                    { item: "lfo", weight: 3 },
                                    { item: "decay", weight: 3 },
                                    { item: "wibble", weight: 3 },
                                    { item: "linear", weight: 2 },
                                    { item: "rise", weight: 3 },
                                    { item: "fall", weight: 3 },
                                ])].index, true, 0, -1, selectWeightedRandom([{ item: false, weight: 8 }, { item: true, weight: 1 }]), Config.perEnvelopeSpeedIndices[selectCurvedDistribution(1, 63, 30, 30)], envelopeLowerBound, envelopeUpperBound, 2, 2, selectWeightedRandom([{ item: 0, weight: 8 }, { item: 2, weight: 4 }, { item: 3, weight: 2 }, { item: 1, weight: 1 }]));
                            }
                        }
                        break;
                    case 9:
                        {
                            let randomGeneratedArray = new Float32Array(64);
                            let randomGeneratedArrayIntegral = new Float32Array(65);
                            const algorithmFunction = selectWeightedRandom([
                                { item: randomSineWave, weight: 4 },
                                { item: randomPulses, weight: 4 },
                                { item: randomChipWave, weight: 3 },
                                { item: biasedFullyRandom, weight: 2 },
                                { item: fullyRandom, weight: 1 },
                            ]);
                            algorithmFunction(randomGeneratedArray);
                            let sum = 0.0;
                            for (let i = 0; i < randomGeneratedArray.length; i++)
                                sum += randomGeneratedArray[i];
                            const average = sum / randomGeneratedArray.length;
                            let cumulative = 0;
                            let wavePrev = 0;
                            for (let i = 0; i < randomGeneratedArray.length; i++) {
                                cumulative += wavePrev;
                                wavePrev = randomGeneratedArray[i] - average;
                                randomGeneratedArrayIntegral[i] = cumulative;
                            }
                            randomGeneratedArrayIntegral[64] = 0.0;
                            instrument.customChipWave = randomGeneratedArray;
                            instrument.customChipWaveIntegral = randomGeneratedArrayIntegral;
                        }
                        break;
                    default: throw new Error("Unhandled pitched instrument type in random generator.");
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeTransition extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.transition;
            if (oldValue != newValue) {
                this._didSomething();
                instrument.transition = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
            }
        }
    }
    class ChangeToggleEffects extends Change {
        constructor(doc, toggleFlag, useInstrument) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (useInstrument != null)
                instrument = useInstrument;
            const oldValue = instrument.effects;
            const wasSelected = ((oldValue & (1 << toggleFlag)) != 0);
            const newValue = wasSelected ? (oldValue & (~(1 << toggleFlag))) : (oldValue | (1 << toggleFlag));
            instrument.effects = newValue;
            if (toggleFlag != 2)
                instrument.preset = instrument.type;
            if (toggleFlag == 3 && wasSelected)
                instrument.aliases = false;
            if (wasSelected)
                instrument.clearInvalidEnvelopeTargets();
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangePatternNumbers extends Change {
        constructor(doc, value, startBar, startChannel, width, height) {
            super();
            if (value > doc.song.patternsPerChannel)
                throw new Error("invalid pattern");
            for (let bar = startBar; bar < startBar + width; bar++) {
                for (let channelIndex = startChannel; channelIndex < startChannel + height; channelIndex++) {
                    if (doc.song.channels[channelIndex].bars[bar] != value) {
                        doc.song.channels[channelIndex].bars[bar] = value;
                        this._didSomething();
                    }
                }
            }
            if (startChannel >= doc.song.pitchChannelCount + doc.song.noiseChannelCount) {
                const pattern = doc.getCurrentPattern();
                if (pattern != null) {
                    doc.viewedInstrument[startChannel] = pattern.instruments[0];
                }
                else {
                    doc.viewedInstrument[startChannel] = 0;
                }
            }
            doc.notifier.changed();
        }
    }
    class ChangeBarCount extends Change {
        constructor(doc, newValue, atBeginning) {
            super();
            if (doc.song.barCount != newValue) {
                for (const channel of doc.song.channels) {
                    if (atBeginning) {
                        while (channel.bars.length < newValue) {
                            channel.bars.unshift(0);
                        }
                        if (doc.song.barCount > newValue) {
                            channel.bars.splice(0, doc.song.barCount - newValue);
                        }
                    }
                    else {
                        while (channel.bars.length < newValue) {
                            channel.bars.push(0);
                        }
                        channel.bars.length = newValue;
                    }
                }
                if (atBeginning) {
                    const diff = newValue - doc.song.barCount;
                    doc.bar = Math.max(0, doc.bar + diff);
                    if (diff < 0 || doc.barScrollPos > 0) {
                        doc.barScrollPos = Math.max(0, doc.barScrollPos + diff);
                    }
                    doc.song.loopStart = Math.max(0, doc.song.loopStart + diff);
                }
                doc.bar = Math.min(doc.bar, newValue - 1);
                doc.song.loopLength = Math.min(newValue, doc.song.loopLength);
                doc.song.loopStart = Math.min(newValue - doc.song.loopLength, doc.song.loopStart);
                doc.song.barCount = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeInsertBars extends Change {
        constructor(doc, start, count) {
            super();
            const newLength = Math.min(Config.barCountMax, doc.song.barCount + count);
            count = newLength - doc.song.barCount;
            if (count == 0)
                return;
            for (const channel of doc.song.channels) {
                while (channel.bars.length < newLength) {
                    channel.bars.splice(start, 0, 0);
                }
            }
            doc.song.barCount = newLength;
            doc.bar += count;
            doc.barScrollPos += count;
            if (doc.song.loopStart >= start) {
                doc.song.loopStart += count;
            }
            else if (doc.song.loopStart + doc.song.loopLength >= start) {
                doc.song.loopLength += count;
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeDeleteBars extends Change {
        constructor(doc, start, count) {
            super();
            for (const channel of doc.song.channels) {
                channel.bars.splice(start, count);
                if (channel.bars.length == 0)
                    channel.bars.push(0);
            }
            doc.song.barCount = Math.max(1, doc.song.barCount - count);
            doc.bar = Math.max(0, doc.bar - count);
            doc.barScrollPos = Math.max(0, doc.barScrollPos - count);
            if (doc.song.loopStart >= start) {
                doc.song.loopStart = Math.max(0, doc.song.loopStart - count);
            }
            else if (doc.song.loopStart + doc.song.loopLength > start) {
                doc.song.loopLength -= count;
            }
            doc.song.loopLength = Math.max(1, Math.min(doc.song.barCount - doc.song.loopStart, doc.song.loopLength));
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeLimiterSettings extends Change {
        constructor(doc, limitRatio, compressionRatio, limitThreshold, compressionThreshold, limitRise, limitDecay, masterGain) {
            super();
            doc.song.limitRatio = limitRatio;
            doc.song.compressionRatio = compressionRatio;
            doc.song.limitThreshold = limitThreshold;
            doc.song.compressionThreshold = compressionThreshold;
            doc.song.limitRise = limitRise;
            doc.song.limitDecay = limitDecay;
            doc.song.masterGain = masterGain;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeChannelOrder extends Change {
        constructor(doc, selectionMin, selectionMax, offset) {
            super();
            doc.song.channels.splice(selectionMin + offset, 0, ...doc.song.channels.splice(selectionMin, selectionMax - selectionMin + 1));
            selectionMax = Math.max(selectionMax, selectionMin);
            for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                for (let instrumentIdx = 0; instrumentIdx < doc.song.channels[channelIndex].instruments.length; instrumentIdx++) {
                    let instrument = doc.song.channels[channelIndex].instruments[instrumentIdx];
                    for (let i = 0; i < Config.modCount; i++) {
                        if (instrument.modChannels[i] >= selectionMin && instrument.modChannels[i] <= selectionMax) {
                            instrument.modChannels[i] += offset;
                        }
                        else if (instrument.modChannels[i] >= selectionMin + offset && instrument.modChannels[i] <= selectionMax + offset) {
                            instrument.modChannels[i] -= offset * (selectionMax - selectionMin + 1);
                        }
                    }
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeCustomScale extends Change {
        constructor(doc, flags) {
            super();
            for (let i = 0; i < Config.pitchesPerOctave; i++) {
                doc.song.scaleCustom[i] = flags[i];
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeChannelCount extends Change {
        constructor(doc, newPitchChannelCount, newNoiseChannelCount, newModChannelCount, newOctavecount) {
            super();
            if (doc.song.pitchChannelCount != newPitchChannelCount || doc.song.noiseChannelCount != newNoiseChannelCount || doc.song.modChannelCount != newModChannelCount) {
                const newChannels = [];
                function changeGroup(newCount, oldCount, newStart, oldStart, octave, isNoise, isMod, isOctaves) {
                    for (let i = 0; i < newCount; i++) {
                        const channelIndex = i + newStart;
                        const oldChannel = i + oldStart;
                        if (i < oldCount) {
                            newChannels[channelIndex] = doc.song.channels[oldChannel];
                        }
                        else {
                            newChannels[channelIndex] = new Channel();
                            newChannels[channelIndex].octave = octave;
                            for (let j = 0; j < Config.instrumentCountMin; j++) {
                                const instrument = new Instrument(isNoise, isMod);
                                if (!isMod) {
                                    const presetValue = pickRandomPresetValue(isNoise);
                                    const preset = EditorConfig.valueToPreset(presetValue);
                                    instrument.fromJsonObject(preset.settings, isNoise, isMod, doc.song.rhythm == 0 || doc.song.rhythm == 2, doc.song.rhythm >= 2);
                                    instrument.preset = presetValue;
                                    instrument.effects |= 1 << 2;
                                }
                                else {
                                    instrument.setTypeAndReset(10, isNoise, isMod);
                                }
                                newChannels[channelIndex].instruments[j] = instrument;
                            }
                            for (let j = 0; j < doc.song.patternsPerChannel; j++) {
                                newChannels[channelIndex].patterns[j] = new Pattern();
                            }
                            for (let j = 0; j < doc.song.barCount; j++) {
                                newChannels[channelIndex].bars[j] = 0;
                            }
                        }
                    }
                }
                changeGroup(newPitchChannelCount, doc.song.pitchChannelCount, 0, 0, 3, false, false);
                changeGroup(newNoiseChannelCount, doc.song.noiseChannelCount, newPitchChannelCount, doc.song.pitchChannelCount, 0, true, false);
                changeGroup(newModChannelCount, doc.song.modChannelCount, newNoiseChannelCount + newPitchChannelCount, doc.song.pitchChannelCount + doc.song.noiseChannelCount, 0, false, true);
                let oldPitchCount = doc.song.pitchChannelCount;
                doc.song.pitchChannelCount = newPitchChannelCount;
                doc.song.noiseChannelCount = newNoiseChannelCount;
                doc.song.modChannelCount = newModChannelCount;
                for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                    doc.song.channels[channelIndex] = newChannels[channelIndex];
                }
                doc.song.channels.length = doc.song.getChannelCount();
                doc.channel = Math.min(doc.channel, newPitchChannelCount + newNoiseChannelCount + newModChannelCount - 1);
                for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                    for (let instrumentIdx = 0; instrumentIdx < doc.song.channels[channelIndex].instruments.length; instrumentIdx++) {
                        for (let mod = 0; mod < Config.modCount; mod++) {
                            let instrument = doc.song.channels[channelIndex].instruments[instrumentIdx];
                            let modChannel = instrument.modChannels[mod];
                            if ((modChannel >= doc.song.pitchChannelCount && modChannel < oldPitchCount) || modChannel >= doc.song.pitchChannelCount + doc.song.noiseChannelCount) {
                                instrument.modulators[mod] = Config.modulators.dictionary["none"].index;
                            }
                            if (modChannel >= oldPitchCount && oldPitchCount < newPitchChannelCount) {
                                instrument.modChannels[mod] += newPitchChannelCount - oldPitchCount;
                            }
                        }
                    }
                }
                doc.notifier.changed();
                ColorConfig.resetColors();
                this._didSomething();
            }
        }
    }
    class ChangeAddChannel extends ChangeGroup {
        constructor(doc, index, isNoise, isMod) {
            super();
            const newPitchChannelCount = doc.song.pitchChannelCount + (isNoise || isMod ? 0 : 1);
            const newNoiseChannelCount = doc.song.noiseChannelCount + (!isNoise || isMod ? 0 : 1);
            const newModChannelCount = doc.song.modChannelCount + (isNoise || !isMod ? 0 : 1);
            if (newPitchChannelCount <= Config.pitchChannelCountMax && newNoiseChannelCount <= Config.noiseChannelCountMax && newModChannelCount <= Config.modChannelCountMax) {
                const addedChannelIndex = isMod ? doc.song.pitchChannelCount + doc.song.noiseChannelCount + doc.song.modChannelCount : (isNoise ? doc.song.pitchChannelCount + doc.song.noiseChannelCount : doc.song.pitchChannelCount);
                this.append(new ChangeChannelCount(doc, newPitchChannelCount, newNoiseChannelCount, newModChannelCount));
                if (addedChannelIndex - 1 >= index) {
                    this.append(new ChangeChannelOrder(doc, index, addedChannelIndex - 1, 1));
                }
                doc.synth.computeLatestModValues();
                doc.recalcChannelNames = true;
            }
        }
    }
    class ChangeRemoveChannel extends ChangeGroup {
        constructor(doc, minIndex, maxIndex) {
            super();
            const oldMax = maxIndex;
            for (let modChannel = doc.song.pitchChannelCount + doc.song.noiseChannelCount; modChannel < doc.song.channels.length; modChannel++) {
                for (let instrumentIndex = 0; instrumentIndex < doc.song.channels[modChannel].instruments.length; instrumentIndex++) {
                    const modInstrument = doc.song.channels[modChannel].instruments[instrumentIndex];
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        if (modInstrument.modChannels[mod] >= minIndex && modInstrument.modChannels[mod] <= oldMax) {
                            this.append(new ChangeModChannel(doc, mod, 0, modInstrument));
                        }
                        else if (modInstrument.modChannels[mod] > oldMax) {
                            this.append(new ChangeModChannel(doc, mod, modInstrument.modChannels[mod] - (oldMax - minIndex + 1) + 2, modInstrument));
                        }
                    }
                }
            }
            while (maxIndex >= minIndex) {
                const isNoise = doc.song.getChannelIsNoise(maxIndex);
                const isMod = doc.song.getChannelIsMod(maxIndex);
                doc.song.channels.splice(maxIndex, 1);
                if (isNoise) {
                    doc.song.noiseChannelCount--;
                }
                else if (isMod) {
                    doc.song.modChannelCount--;
                }
                else {
                    doc.song.pitchChannelCount--;
                }
                maxIndex--;
            }
            if (doc.song.pitchChannelCount < Config.pitchChannelCountMin) {
                this.append(new ChangeChannelCount(doc, Config.pitchChannelCountMin, doc.song.noiseChannelCount, doc.song.modChannelCount));
            }
            ColorConfig.resetColors();
            doc.recalcChannelNames = true;
            this.append(new ChangeChannelBar(doc, Math.max(0, minIndex - 1), doc.bar));
            doc.synth.computeLatestModValues();
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangeChannelBar extends Change {
        constructor(doc, newChannel, newBar, silently = false) {
            super();
            const oldChannel = doc.channel;
            const oldBar = doc.bar;
            doc.channel = newChannel;
            doc.bar = newBar;
            if (!silently) {
                doc.selection.scrollToSelectedPattern();
            }
            if (doc.song.getChannelIsMod(doc.channel)) {
                const pattern = doc.song.getPattern(doc.channel, doc.bar);
                if (pattern != null)
                    doc.viewedInstrument[doc.channel] = pattern.instruments[0];
            }
            doc.notifier.changed();
            if (oldChannel != newChannel || oldBar != newBar) {
                this._didSomething();
            }
        }
    }
    class ChangeUnison extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.unison;
            if (oldValue != newValue) {
                instrument.unison = newValue;
                instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                instrument.unisonSign = Config.unisons[instrument.unison].sign;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeUnisonVoices extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevUnison = instrument.unison;
            if (oldValue != newValue || prevUnison != Config.unisons.length) {
                instrument.unisonVoices = newValue;
                instrument.unison = Config.unisons.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeUnisonSpread extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevUnison = instrument.unison;
            if (oldValue != newValue || prevUnison != Config.unisons.length) {
                instrument.unisonSpread = newValue;
                instrument.unison = Config.unisons.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeUnisonOffset extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevUnison = instrument.unison;
            if (oldValue != newValue || prevUnison != Config.unisons.length) {
                instrument.unisonOffset = newValue;
                instrument.unison = Config.unisons.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeUnisonExpression extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevUnison = instrument.unison;
            if (oldValue != newValue || prevUnison != Config.unisons.length) {
                instrument.unisonExpression = newValue;
                instrument.unison = Config.unisons.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeUnisonSign extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevUnison = instrument.unison;
            if (oldValue != newValue || prevUnison != Config.unisons.length) {
                instrument.unisonSign = newValue;
                instrument.unison = Config.unisons.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeChord extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.chord;
            if (oldValue != newValue) {
                this._didSomething();
                instrument.chord = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
            }
        }
    }
    class ChangeVibrato extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.vibrato;
            if (oldValue != newValue) {
                instrument.vibrato = newValue;
                instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;
                instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;
                instrument.vibratoSpeed = 10;
                instrument.vibratoType = Config.vibratos[instrument.vibrato].type;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoDepth extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevVibrato = instrument.vibrato;
            doc.synth.unsetMod(Config.modulators.dictionary["vibrato depth"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoDepth = newValue / 25;
                instrument.vibrato = Config.vibratos.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEnvelopeSpeed extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            doc.synth.unsetMod(Config.modulators.dictionary["envelope speed"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.envelopeSpeed = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoSpeed extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevVibrato = instrument.vibrato;
            doc.synth.unsetMod(Config.modulators.dictionary["vibrato speed"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoSpeed = newValue;
                instrument.vibrato = Config.vibratos.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoDelay extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let prevVibrato = instrument.vibrato;
            doc.synth.unsetMod(Config.modulators.dictionary["vibrato delay"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoDelay = newValue;
                instrument.vibrato = Config.vibratos.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeVibratoType extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.vibratoType;
            let prevVibrato = instrument.vibrato;
            doc.notifier.changed();
            if (oldValue != newValue || prevVibrato != Config.vibratos.length) {
                instrument.vibratoType = newValue;
                instrument.vibrato = Config.vibratos.length;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeArpeggioSpeed extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.arpeggioSpeed = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["arp speed"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.preset = instrument.type;
                this._didSomething();
            }
        }
    }
    class ChangeFastTwoNoteArp extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.fastTwoNoteArp;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.fastTwoNoteArp = newValue;
                instrument.preset = instrument.type;
                this._didSomething();
            }
        }
    }
    class ChangeMonophonicTone extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.monoChordTone;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.monoChordTone = newValue;
                this._didSomething();
            }
        }
    }
    class ChangeClicklessTransition extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.clicklessTransition;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.clicklessTransition = newValue;
                instrument.preset = instrument.type;
                this._didSomething();
            }
        }
    }
    class ChangeAliasing extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.aliases;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.aliases = newValue;
                instrument.preset = instrument.type;
                this._didSomething();
            }
        }
    }
    class ChangeSpectrum extends Change {
        constructor(doc, instrument, spectrumWave) {
            super();
            spectrumWave.markCustomWaveDirty();
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeHarmonics extends Change {
        constructor(doc, instrument, harmonicsWave) {
            super();
            harmonicsWave.markCustomWaveDirty();
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeDrumsetEnvelope extends Change {
        constructor(doc, drumIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.drumsetEnvelopes[drumIndex];
            if (oldValue != newValue) {
                instrument.drumsetEnvelopes[drumIndex] = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeInstrumentSlider extends Change {
        constructor(_doc) {
            super();
            this._doc = _doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
        }
        commit() {
            if (!this.isNoop()) {
                this._instrument.preset = this._instrument.type;
                this._doc.notifier.changed();
            }
        }
    }
    class IndexableChange extends ChangeInstrumentSlider {
        constructor(index, _doc) {
            super(_doc);
            this.index = 0;
            this.index = index;
        }
        getIndex() {
            return this.index;
        }
    }
    class ChangePulseWidth extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.pulseWidth = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["pulse width"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeDecimalOffset extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.decimalOffset = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["decimal offset"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSupersawDynamism extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.supersawDynamism = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["dynamism"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSupersawSpread extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.supersawSpread = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["spread"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSupersawShape extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.supersawShape = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["saw shape"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePitchShift extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.pitchShift = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeOctaveShift extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc); 
            this._instrument.octaveShift = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    } 
    class ChangeFunction extends ChangeInstrumentSlider {
        constructor(doc, index, newValue, oldValue) {
            super(doc); 
            this._instrument.customfunction[index] = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
	             this._didSomething();
        }
    }
    class ChangeDetune extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.detune = newValue + Config.detuneCenter;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["detune"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeRingMod extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.ringModulation = newValue;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["ring modulation"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeRingModHz extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.ringModulationHz = newValue;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["ring mod hertz"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeRingModChipWave extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.ringModWaveformIndex != newValue) {
                instrument.ringModWaveformIndex = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeRingModPulseWidth extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.ringModPulseWidth = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeGranular extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.granular = newValue;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["granular"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeGrainSize extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.grainSize = newValue;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["grain size"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeGrainAmounts extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.grainAmounts = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeGrainRange extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.grainRange = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeDistortion extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.distortion = newValue;
            doc.notifier.changed();
            doc.synth.unsetMod(Config.modulators.dictionary["distortion"].index, doc.channel, doc.getCurrentInstrument());
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeBitcrusherFreq extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.bitcrusherFreq = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["bit crush"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeBitcrusherQuantization extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            doc.synth.unsetMod(Config.modulators.dictionary["freq crush"].index, doc.channel, doc.getCurrentInstrument());
            this._instrument.bitcrusherQuantization = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePhaserMix extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.phaserMix = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    } 
    class ChangePhaserFreq extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.phaserFreq = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePhaserFeedback extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.phaserFeedback = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePhaserStages extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.phaserStages = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeStringSustain extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.stringSustain = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["sustain"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeStringSustainType extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.stringSustainType;
            if (oldValue != newValue) {
                instrument.stringSustainType = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEQFilterType extends Change {
        constructor(doc, instrument, newValue) {
            super();
            instrument.eqFilterType = newValue;
            if (newValue == true) {
                instrument.eqFilter.reset();
                instrument.tmpEqFilterStart = instrument.eqFilter;
                instrument.tmpEqFilterEnd = null;
            }
            else {
                instrument.eqFilter.convertLegacySettings(instrument.eqFilterSimpleCut, instrument.eqFilterSimplePeak, Config.envelopes.dictionary["none"]);
                instrument.tmpEqFilterStart = instrument.eqFilter;
                instrument.tmpEqFilterEnd = null;
            }
            instrument.clearInvalidEnvelopeTargets();
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeNoteFilterType extends Change {
        constructor(doc, instrument, newValue) {
            super();
            instrument.noteFilterType = newValue;
            if (newValue == true) {
                instrument.noteFilter.reset();
                instrument.tmpNoteFilterStart = instrument.noteFilter;
                instrument.tmpNoteFilterEnd = null;
            }
            else {
                instrument.noteFilter.convertLegacySettings(instrument.noteFilterSimpleCut, instrument.noteFilterSimplePeak, Config.envelopes.dictionary["none"]);
                instrument.tmpNoteFilterStart = instrument.noteFilter;
                instrument.tmpNoteFilterEnd = null;
            }
            instrument.clearInvalidEnvelopeTargets();
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeEQFilterSimpleCut extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.eqFilterSimpleCut = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["eq filt cut"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEQFilterSimplePeak extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.eqFilterSimplePeak = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["eq filt peak"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeNoteFilterSimpleCut extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.noteFilterSimpleCut = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["note filt cut"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeNoteFilterSimplePeak extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.noteFilterSimplePeak = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["note filt peak"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSongFilterAddPoint extends UndoableChange {
        constructor(doc, filterSettings, point, index, deletion = false) {
            super(deletion);
            this._doc = doc;
            this._filterSettings = filterSettings;
            this._point = point;
            this._index = index;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._filterSettings.controlPoints.splice(this._index, 0, this._point);
            this._filterSettings.controlPointCount++;
            this._filterSettings.controlPoints.length = this._filterSettings.controlPointCount;
            this._doc.song.tmpEqFilterStart = this._doc.song.eqFilter;
            this._doc.song.tmpEqFilterEnd = null;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._filterSettings.controlPoints.splice(this._index, 1);
            this._filterSettings.controlPointCount--;
            this._filterSettings.controlPoints.length = this._filterSettings.controlPointCount;
            this._doc.song.tmpEqFilterStart = this._doc.song.eqFilter;
            this._doc.song.tmpEqFilterEnd = null;
            this._doc.notifier.changed();
        }
    }
    class ChangeFilterAddPoint extends UndoableChange {
        constructor(doc, filterSettings, point, index, isNoteFilter, deletion = false) {
            super(deletion);
            this._envelopeTargetsAdd = [];
            this._envelopeIndicesAdd = [];
            this._envelopeTargetsRemove = [];
            this._envelopeIndicesRemove = [];
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = deletion ? this._instrument.preset : this._instrument.type;
            this._instrumentPrevPreset = deletion ? this._instrument.type : this._instrument.preset;
            this._filterSettings = filterSettings;
            this._point = point;
            this._index = index;
            for (let envelopeIndex = 0; envelopeIndex < this._instrument.envelopeCount; envelopeIndex++) {
                let target = this._instrument.envelopes[envelopeIndex].target;
                let targetIndex = this._instrument.envelopes[envelopeIndex].index;
                this._envelopeTargetsAdd.push(target);
                this._envelopeIndicesAdd.push(targetIndex);
                if (deletion) {
                    const automationTarget = Config.instrumentAutomationTargets[target];
                    if (automationTarget.isFilter && (automationTarget.effect == 5) == isNoteFilter) {
                        if (automationTarget.maxCount == Config.filterMaxPoints) {
                            if (targetIndex == index) {
                                target = Config.instrumentAutomationTargets.dictionary["none"].index;
                                targetIndex = 0;
                            }
                            else if (targetIndex > index) {
                                targetIndex--;
                            }
                        }
                        else {
                            if (filterSettings.controlPointCount <= 1) {
                                target = Config.instrumentAutomationTargets.dictionary["none"].index;
                                targetIndex = 0;
                            }
                        }
                    }
                }
                this._envelopeTargetsRemove.push(target);
                this._envelopeIndicesRemove.push(targetIndex);
            }
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._filterSettings.controlPoints.splice(this._index, 0, this._point);
            this._filterSettings.controlPointCount++;
            this._filterSettings.controlPoints.length = this._filterSettings.controlPointCount;
            this._instrument.preset = this._instrumentNextPreset;
            for (let envelopeIndex = 0; envelopeIndex < this._instrument.envelopeCount; envelopeIndex++) {
                this._instrument.envelopes[envelopeIndex].target = this._envelopeTargetsAdd[envelopeIndex];
                this._instrument.envelopes[envelopeIndex].index = this._envelopeIndicesAdd[envelopeIndex];
            }
            this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
            this._instrument.tmpEqFilterEnd = null;
            this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
            this._instrument.tmpNoteFilterEnd = null;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._filterSettings.controlPoints.splice(this._index, 1);
            this._filterSettings.controlPointCount--;
            this._filterSettings.controlPoints.length = this._filterSettings.controlPointCount;
            this._instrument.preset = this._instrumentPrevPreset;
            for (let envelopeIndex = 0; envelopeIndex < this._instrument.envelopeCount; envelopeIndex++) {
                this._instrument.envelopes[envelopeIndex].target = this._envelopeTargetsRemove[envelopeIndex];
                this._instrument.envelopes[envelopeIndex].index = this._envelopeIndicesRemove[envelopeIndex];
            }
            this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
            this._instrument.tmpEqFilterEnd = null;
            this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
            this._instrument.tmpNoteFilterEnd = null;
            this._doc.notifier.changed();
        }
    }
    class FilterMoveData {
        constructor(usePoint, useFreq, useGain) {
            this.point = usePoint;
            this.freq = useFreq;
            this.gain = useGain;
        }
    }
    class ChangeSongFilterMovePoint extends UndoableChange {
        constructor(doc, point, oldFreq, newFreq, oldGain, newGain, pointIndex) {
            super(false);
            this._doc = doc;
            this._point = point;
            this._oldFreq = oldFreq;
            this._newFreq = newFreq;
            this._oldGain = oldGain;
            this._newGain = newGain;
            this.pointIndex = pointIndex;
            this.pointType = point.type;
            this._didSomething();
            this.redo();
        }
        getMoveData(beforeChange) {
            if (beforeChange) {
                return new FilterMoveData(this._point, this._oldFreq, this._oldGain);
            }
            return new FilterMoveData(this._point, this._newFreq, this._newGain);
        }
        _doForwards() {
            this._point.freq = this._newFreq;
            this._point.gain = this._newGain;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._point.freq = this._oldFreq;
            this._point.gain = this._oldGain;
            this._doc.notifier.changed();
        }
    }
    class ChangeFilterMovePoint extends UndoableChange {
        constructor(doc, point, oldFreq, newFreq, oldGain, newGain, useNoteFilter, pointIndex) {
            super(false);
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = this._instrument.type;
            this._instrumentPrevPreset = this._instrument.preset;
            this._point = point;
            this._oldFreq = oldFreq;
            this._newFreq = newFreq;
            this._oldGain = oldGain;
            this._newGain = newGain;
            this.useNoteFilter = useNoteFilter;
            this.pointIndex = pointIndex;
            this.pointType = point.type;
            this._didSomething();
            this.redo();
        }
        getMoveData(beforeChange) {
            if (beforeChange) {
                return new FilterMoveData(this._point, this._oldFreq, this._oldGain);
            }
            return new FilterMoveData(this._point, this._newFreq, this._newGain);
        }
        _doForwards() {
            this._point.freq = this._newFreq;
            this._point.gain = this._newGain;
            this._instrument.preset = this._instrumentNextPreset;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._point.freq = this._oldFreq;
            this._point.gain = this._oldGain;
            this._instrument.preset = this._instrumentPrevPreset;
            this._doc.notifier.changed();
        }
    }
    class ChangeSongFilterSettings extends UndoableChange {
        constructor(doc, settings, oldSettings, subFilters = null, oldSubFilters = null) {
            super(false);
            this._doc = doc;
            this._oldSettings = oldSettings;
            this._filterSettings = settings;
            if (subFilters != null && oldSubFilters != null) {
                this._subFilters = subFilters;
                this._oldSubFilters = oldSubFilters;
            }
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._doc.song.eqFilter = this._filterSettings;
            if (this._subFilters != null)
                this._doc.song.eqSubFilters = this._subFilters;
            this._doc.song.tmpEqFilterStart = this._doc.song.eqFilter;
            this._doc.song.tmpEqFilterEnd = null;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._doc.song.eqFilter = this._oldSettings;
            if (this._oldSubFilters != null)
                this._doc.song.eqSubFilters = this._oldSubFilters;
            this._doc.song.tmpEqFilterStart = this._doc.song.eqFilter;
            this._doc.song.tmpEqFilterEnd = null;
            this._doc.notifier.changed();
        }
    }
    class ChangeFilterSettings extends UndoableChange {
        constructor(doc, settings, oldSettings, useNoteFilter, subFilters = null, oldSubFilters = null) {
            super(false);
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = this._instrument.type;
            this._instrumentPrevPreset = this._instrument.preset;
            this._oldSettings = oldSettings;
            this._useNoteFilter = useNoteFilter;
            this._filterSettings = settings;
            if (subFilters != null && oldSubFilters != null) {
                this._subFilters = subFilters;
                this._oldSubFilters = oldSubFilters;
            }
            this._instrument.clearInvalidEnvelopeTargets();
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            if (this._useNoteFilter) {
                this._instrument.noteFilter = this._filterSettings;
                if (this._subFilters != null)
                    this._instrument.noteSubFilters = this._subFilters;
                this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
                this._instrument.tmpNoteFilterEnd = null;
            }
            else {
                this._instrument.eqFilter = this._filterSettings;
                if (this._subFilters != null)
                    this._instrument.eqSubFilters = this._subFilters;
                this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
                this._instrument.tmpEqFilterEnd = null;
            }
            this._instrument.preset = this._instrumentNextPreset;
            this._instrument.clearInvalidEnvelopeTargets();
            this._doc.notifier.changed();
        }
        _doBackwards() {
            if (this._useNoteFilter) {
                this._instrument.noteFilter = this._oldSettings;
                if (this._oldSubFilters != null)
                    this._instrument.noteSubFilters = this._oldSubFilters;
                this._instrument.tmpNoteFilterStart = this._instrument.noteFilter;
                this._instrument.tmpNoteFilterEnd = null;
            }
            else {
                this._instrument.eqFilter = this._oldSettings;
                if (this._oldSubFilters != null)
                    this._instrument.eqSubFilters = this._oldSubFilters;
                this._instrument.tmpEqFilterStart = this._instrument.eqFilter;
                this._instrument.tmpEqFilterEnd = null;
            }
            this._instrument.preset = this._instrumentPrevPreset;
            this._instrument.clearInvalidEnvelopeTargets();
            this._doc.notifier.changed();
        }
    }
    class ChangeFadeInOut extends UndoableChange {
        constructor(doc, fadeIn, fadeOut) {
            super(false);
            this._doc = doc;
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._instrumentNextPreset = this._instrument.type;
            this._instrumentPrevPreset = this._instrument.preset;
            this._oldFadeIn = this._instrument.fadeIn;
            this._oldFadeOut = this._instrument.fadeOut;
            this._newFadeIn = fadeIn;
            this._newFadeOut = fadeOut;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._instrument.fadeIn = this._newFadeIn;
            this._instrument.fadeOut = this._newFadeOut;
            this._instrument.preset = this._instrumentNextPreset;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._instrument.fadeIn = this._oldFadeIn;
            this._instrument.fadeOut = this._oldFadeOut;
            this._instrument.preset = this._instrumentPrevPreset;
            this._doc.notifier.changed();
        }
    }
class ChangeAlgorithm extends Change {
    constructor(doc, newValue) {
        super();
        const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
        if (instrument.algorithm !== newValue) {
            instrument.algorithm = newValue;
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
}

class ChangeFeedbackType extends Change {
    constructor(doc, newValue) {
        super();
        const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
        if (instrument.feedbackType !== newValue) {
            instrument.feedbackType = newValue;
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
}

class Change6OpAlgorithm extends Change {
    constructor(doc, newValue) {
        super();
        const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
        if (instrument.algorithm6Op !== newValue) {
            instrument.algorithm6Op = newValue;
            if (newValue !== 0) {
            	if(instrument.type==12){
            		instrument.customAlgorithm.fromPreset(newValue,8);
            	}else{
              instrument.customAlgorithm.fromPreset(newValue,6);
            	} 
            }
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
}

class Change6OpFeedbackType extends Change {
    constructor(doc, newValue) {
        super();
        const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
        if (instrument.feedbackType6Op !== newValue) {
            instrument.feedbackType6Op = newValue;
            if (newValue !== 0) {
            	if(instrument.type==12){
            		instrument.customFeedbackType.fromPreset(newValue,8);
            	}else{
                instrument.customFeedbackType.fromPreset(newValue,6);
            	}
            }
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
}

class ChangeOperatorWaveform extends Change {
    constructor(doc, operatorIndex, newValue) {
        super();
        const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
        if (instrument.operators[operatorIndex] && instrument.operators[operatorIndex].waveform !== newValue) {
            instrument.operators[operatorIndex].waveform = newValue;
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
}

    class ChangeOperatorPulseWidth extends Change {
        constructor(doc, operatorIndex, oldValue, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.operators[operatorIndex].pulseWidth = newValue;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.preset = instrument.type;
                this._didSomething();
            }
        }
    }
    class ChangeOperatorFrequency extends Change {
        constructor(doc, operatorIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.operators[operatorIndex].frequency;
            if (oldValue != newValue) {
                instrument.operators[operatorIndex].frequency = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeOperatorAmplitude extends ChangeInstrumentSlider {
        constructor(doc, operatorIndex, oldValue, newValue) {
            super(doc);
            this.operatorIndex = 0;
            this.operatorIndex = operatorIndex;
            this._instrument.operators[operatorIndex].amplitude = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeFeedbackAmplitude extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.feedbackAmplitude = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeAddChannelInstrument extends Change {
        constructor(doc) {
            super();
            const channel = doc.song.channels[doc.channel];
            const isNoise = doc.song.getChannelIsNoise(doc.channel);
            const isMod = doc.song.getChannelIsMod(doc.channel);
            const maxInstruments = doc.song.getMaxInstrumentsPerChannel();
            if (channel.instruments.length >= maxInstruments)
                return;
            const presetValue = pickRandomPresetValue(isNoise);
            const preset = EditorConfig.valueToPreset(presetValue);
            const instrument = new Instrument(isNoise, isMod);
            instrument.fromJsonObject(preset.settings, isNoise, isMod, false, false, 1);
            instrument.preset = presetValue;
            instrument.effects |= 1 << 2;
            instrument.volume = 0;
            channel.instruments.push(instrument);
            if (!isMod) {
                doc.viewedInstrument[doc.channel] = channel.instruments.length - 1;
            }
            for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                for (let instrumentIndex = 0; instrumentIndex < doc.song.channels[channelIndex].instruments.length; instrumentIndex++) {
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        let instrument = doc.song.channels[channelIndex].instruments[instrumentIndex];
                        let modInstrument = instrument.modInstruments[mod];
                        let modChannel = instrument.modChannels[mod];
                        if (modChannel == doc.channel && modInstrument >= doc.song.channels[modChannel].instruments.length - 1) {
                            instrument.modInstruments[mod]++;
                        }
                    }
                }
            }
            doc.synth.computeLatestModValues();
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeRemoveChannelInstrument extends Change {
        constructor(doc) {
            super();
            const channel = doc.song.channels[doc.channel];
            if (channel.instruments.length <= Config.instrumentCountMin)
                return;
            const removedIndex = doc.viewedInstrument[doc.channel];
            channel.instruments.splice(removedIndex, 1);
            if (doc.song.patternInstruments) {
                for (const pattern of channel.patterns) {
                    for (let i = 0; i < pattern.instruments.length; i++) {
                        if (pattern.instruments[i] == removedIndex) {
                            pattern.instruments.splice(i, 1);
                            i--;
                        }
                        else if (pattern.instruments[i] > removedIndex) {
                            pattern.instruments[i]--;
                        }
                    }
                    if (pattern.instruments.length <= 0) {
                        pattern.instruments[0] = 0;
                    }
                }
            }
            for (let channelIndex = doc.song.pitchChannelCount + doc.song.noiseChannelCount; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                for (let instrumentIdx = 0; instrumentIdx < doc.song.channels[channelIndex].instruments.length; instrumentIdx++) {
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        let instrument = doc.song.channels[channelIndex].instruments[instrumentIdx];
                        let modInstrument = instrument.modInstruments[mod];
                        let modChannel = instrument.modChannels[mod];
                        if (modChannel == doc.channel) {
                            if (modInstrument > removedIndex) {
                                instrument.modInstruments[mod]--;
                            }
                            else if (modInstrument == removedIndex) {
                                instrument.modInstruments[mod] = 0;
                                instrument.modulators[mod] = 0;
                            }
                        }
                    }
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeViewInstrument extends Change {
        constructor(doc, index) {
            super();
            if (doc.viewedInstrument[doc.channel] != index) {
                doc.viewedInstrument[doc.channel] = index;
                if (doc.channel >= doc.song.pitchChannelCount + doc.song.noiseChannelCount)
                    doc.recentPatternInstruments[doc.channel] = [index];
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeInstrumentsFlags extends Change {
        constructor(doc, newLayeredInstruments, newPatternInstruments) {
            super();
            const oldLayeredInstruments = doc.song.layeredInstruments;
            const oldPatternInstruments = doc.song.patternInstruments;
            if (oldLayeredInstruments == newLayeredInstruments && oldPatternInstruments == newPatternInstruments)
                return;
            doc.song.layeredInstruments = newLayeredInstruments;
            doc.song.patternInstruments = newPatternInstruments;
            for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                const channel = doc.song.channels[channelIndex];
                if (channel.instruments.length > doc.song.getMaxInstrumentsPerChannel()) {
                    channel.instruments.length = doc.song.getMaxInstrumentsPerChannel();
                }
                for (let j = 0; j < doc.song.patternsPerChannel; j++) {
                    const pattern = channel.patterns[j];
                    if (!oldPatternInstruments && newPatternInstruments) {
                        for (let i = 0; i < channel.instruments.length; i++) {
                            pattern.instruments[i] = i;
                        }
                        pattern.instruments.length = channel.instruments.length;
                    }
                    discardInvalidPatternInstruments(pattern.instruments, doc.song, channelIndex);
                }
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeKey extends Change {
        constructor(doc, newValue) {
            super();
            if (doc.song.key != newValue) {
                doc.song.key = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeLoop extends Change {
        constructor(_doc, oldStart, oldLength, newStart, newLength) {
            super();
            this._doc = _doc;
            this.oldStart = oldStart;
            this.oldLength = oldLength;
            this.newStart = newStart;
            this.newLength = newLength;
            this._doc.song.loopStart = this.newStart;
            this._doc.song.loopLength = this.newLength;
            this._doc.notifier.changed();
            if (this.oldStart != this.newStart || this.oldLength != this.newLength) {
                this._didSomething();
            }
        }
    }
    class ChangePitchAdded extends UndoableChange {
        constructor(doc, note, pitch, index, deletion = false) {
            super(deletion);
            this._doc = doc;
            this._note = note;
            this._pitch = pitch;
            this._index = index;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._note.pitches.splice(this._index, 0, this._pitch);
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pitches.splice(this._index, 1);
            this._doc.notifier.changed();
        }
    }
    class ChangeOctave extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            this.oldValue = oldValue;
            doc.song.channels[doc.channel].octave = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeRhythm extends ChangeGroup {
        constructor(doc, newValue) {
            super();
            if (doc.song.rhythm != newValue) {
                doc.song.rhythm = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangePaste extends ChangeGroup {
        constructor(doc, pattern, notes, selectionStart, selectionEnd, oldPartDuration) {
            super();
            this.append(new ChangeNoteTruncate(doc, pattern, selectionStart, selectionEnd, null, true));
            let noteInsertionIndex = 0;
            if (!doc.song.getChannelIsMod(doc.channel)) {
                for (let i = 0; i < pattern.notes.length; i++) {
                    if (pattern.notes[i].start < selectionStart) {
                        if (pattern.notes[i].end > selectionStart)
                            throw new Error();
                        noteInsertionIndex = i + 1;
                    }
                    else if (pattern.notes[i].start < selectionEnd) {
                        throw new Error();
                    }
                }
            }
            else {
                noteInsertionIndex = pattern.notes.length;
            }
            while (selectionStart < selectionEnd) {
                for (const noteObject of notes) {
                    const noteStart = noteObject["start"] + selectionStart;
                    const noteEnd = noteObject["end"] + selectionStart;
                    if (noteStart >= selectionEnd)
                        break;
                    const note = new Note(noteObject["pitches"][0], noteStart, noteEnd, noteObject["pins"][0]["size"], false);
                    note.pitches.length = 0;
                    for (const pitch of noteObject["pitches"]) {
                        note.pitches.push(pitch);
                    }
                    note.pins.length = 0;
                    for (const pin of noteObject["pins"]) {
                        note.pins.push(makeNotePin(pin.interval, pin.time, pin.size));
                    }
                    note.continuesLastPattern = (noteObject["continuesLastPattern"] === true) && (note.start == 0);
                    pattern.notes.splice(noteInsertionIndex++, 0, note);
                    if (note.end > selectionEnd) {
                        this.append(new ChangeNoteLength(doc, note, note.start, selectionEnd));
                    }
                }
                selectionStart += oldPartDuration;
            }
            if (pattern != null && doc.song.getChannelIsMod(doc.channel))
                pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangePasteInstrument extends ChangeGroup {
        constructor(doc, instrument, instrumentCopy) {
            super();
            instrument.fromJsonObject(instrumentCopy, instrumentCopy["isDrum"], instrumentCopy["isMod"], false, false);
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeAppendInstrument extends ChangeGroup {
        constructor(doc, channel, instrument) {
            super();
            let newInstrument = new Instrument(instrument["isDrum"], instrument["isMod"]);
            newInstrument.fromJsonObject(instrument, instrument["isDrum"], instrument["isMod"], false, false);
            channel.instruments.push(newInstrument);
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangeSetPatternInstruments extends Change {
        constructor(doc, channelIndex, instruments, pattern) {
            super();
            if (!patternsContainSameInstruments(instruments, pattern.instruments)) {
                pattern.instruments.length = 0;
                pattern.instruments.push(...instruments);
                discardInvalidPatternInstruments(pattern.instruments, doc.song, channelIndex);
                this._didSomething();
                doc.notifier.changed();
            }
        }
    }
    class ChangeModChannel extends Change {
        constructor(doc, mod, index, useInstrument) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (useInstrument != undefined)
                instrument = useInstrument;
            if (index == 0 || (Config.modulators[instrument.modulators[mod]].forSong && index >= 2) || (!Config.modulators[instrument.modulators[mod]].forSong && index < 2)) {
                instrument.modulators[mod] = Config.modulators.dictionary["none"].index;
            }
            instrument.modChannels[mod] = index - 2;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeModInstrument extends Change {
        constructor(doc, mod, tgtInstrument) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.modInstruments[mod] != tgtInstrument) {
                instrument.modInstruments[mod] = tgtInstrument;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeModSetting extends Change {
        constructor(doc, mod, text) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            let tgtChannel = instrument.modChannels[mod];
            let usedInstruments = [];
            if (tgtChannel >= 0) {
                if (instrument.modInstruments[mod] == doc.song.channels[tgtChannel].instruments.length) {
                    usedInstruments = usedInstruments.concat(doc.song.channels[tgtChannel].instruments);
                }
                else if (instrument.modInstruments[mod] > doc.song.channels[tgtChannel].instruments.length) {
                    let tgtPattern = doc.song.getPattern(tgtChannel, doc.bar);
                    if (tgtPattern != null) {
                        for (let i = 0; i < tgtPattern.instruments.length; i++) {
                            usedInstruments.push(doc.song.channels[tgtChannel].instruments[tgtPattern.instruments[i]]);
                        }
                    }
                }
                else {
                    usedInstruments.push(doc.song.channels[tgtChannel].instruments[instrument.modInstruments[mod]]);
                }
            }
            if (text.startsWith("+ ")) {
                text = text.substr(2);
                for (let i = 0; i < usedInstruments.length; i++) {
                    const tgtInstrument = usedInstruments[i];
                    if (!(tgtInstrument.effects & (1 << Config.modulators.dictionary[text].associatedEffect))) {
                        doc.record(new ChangeToggleEffects(doc, Config.modulators.dictionary[text].associatedEffect, tgtInstrument));
                    }
                }
            }
            let setting = Config.modulators.dictionary[text].index;
            if (instrument.modulators[mod] != setting) {
                instrument.modulators[mod] = setting;
                let cap = Config.modulators[setting].maxRawVol;
                for (let i = 0; i < doc.song.patternsPerChannel; i++) {
                    const pattern = doc.song.channels[doc.channel].patterns[i];
                    if (pattern.instruments[0] == doc.getCurrentInstrument()) {
                        for (let j = 0; j < pattern.notes.length; j++) {
                            const note = pattern.notes[j];
                            if (note.pitches[0] == Config.modCount - mod - 1) {
                                for (let k = 0; k < note.pins.length; k++) {
                                    const pin = note.pins[k];
                                    if (pin.size > cap)
                                        pin.size = cap;
                                }
                            }
                        }
                    }
                }
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeModFilter extends Change {
        constructor(doc, mod, type) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.modFilterTypes[mod] != type) {
                instrument.modFilterTypes[mod] = type;
                let cap = doc.song.getVolumeCapForSetting(true, instrument.modulators[mod], instrument.modFilterTypes[mod]);
                for (let i = 0; i < doc.song.patternsPerChannel; i++) {
                    const pattern = doc.song.channels[doc.channel].patterns[i];
                    if (pattern.instruments[0] == doc.getCurrentInstrument()) {
                        for (let j = 0; j < pattern.notes.length; j++) {
                            const note = pattern.notes[j];
                            if (note.pitches[0] == Config.modCount - mod - 1) {
                                for (let k = 0; k < note.pins.length; k++) {
                                    const pin = note.pins[k];
                                    if (pin.size > cap)
                                        pin.size = cap;
                                }
                            }
                        }
                    }
                }
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeModEnvelope extends Change {
        constructor(doc, mod, envelope) {
            super();
            let instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.modEnvelopeNumbers[mod] != envelope) {
                instrument.modEnvelopeNumbers[mod] = envelope;
                let cap = doc.song.getVolumeCapForSetting(true, instrument.modulators[mod], instrument.modEnvelopeNumbers[mod]);
                for (let i = 0; i < doc.song.patternsPerChannel; i++) {
                    const pattern = doc.song.channels[doc.channel].patterns[i];
                    if (pattern.instruments[0] == doc.getCurrentInstrument()) {
                        for (let j = 0; j < pattern.notes.length; j++) {
                            const note = pattern.notes[j];
                            if (note.pitches[0] == Config.modCount - mod - 1) {
                                for (let k = 0; k < note.pins.length; k++) {
                                    const pin = note.pins[k];
                                    if (pin.size > cap)
                                        pin.size = cap;
                                }
                            }
                        }
                    }
                }
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    
    class ChangeMaxOctaves extends Change {
   	constructor(doc, newValue) {
   		super();
   		if (!isNaN(newValue)&&Config.pitchOctaves) {
   		 Config.pitchOctaves=parseInt(newValue)
   			doc.notifier.changed();
   			this._didSomething();
   		}
   	}
   }
    class ChangePatternsPerChannel extends Change {
        constructor(doc, newValue) {
            super();
            if (doc.song.patternsPerChannel != newValue) {
                for (let i = 0; i < doc.song.getChannelCount(); i++) {
                    const channelBars = doc.song.channels[i].bars;
                    const channelPatterns = doc.song.channels[i].patterns;
                    for (let j = 0; j < channelBars.length; j++) {
                        if (channelBars[j] > newValue)
                            channelBars[j] = 0;
                    }
                    for (let j = channelPatterns.length; j < newValue; j++) {
                        channelPatterns[j] = new Pattern();
                    }
                    channelPatterns.length = newValue;
                }
                doc.song.patternsPerChannel = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEnsurePatternExists extends UndoableChange {
        constructor(doc, channelIndex, bar) {
            super(false);
            this._patternOldNotes = null;
            this._oldPatternInstruments = null;
            const song = doc.song;
            if (song.channels[channelIndex].bars[bar] != 0)
                return;
            this._doc = doc;
            this._bar = bar;
            this._channelIndex = channelIndex;
            this._oldPatternCount = song.patternsPerChannel;
            this._newPatternCount = song.patternsPerChannel;
            if (channelIndex < doc.song.pitchChannelCount + doc.song.noiseChannelCount)
                this._newPatternInstruments = doc.recentPatternInstruments[channelIndex].concat();
            else
                this._newPatternInstruments = [doc.viewedInstrument[channelIndex]];
            let firstEmptyUnusedIndex = null;
            let firstUnusedIndex = null;
            for (let patternIndex = 1; patternIndex <= song.patternsPerChannel; patternIndex++) {
                let used = false;
                for (let barIndex = 0; barIndex < song.barCount; barIndex++) {
                    if (song.channels[channelIndex].bars[barIndex] == patternIndex) {
                        used = true;
                        break;
                    }
                }
                if (used)
                    continue;
                if (firstUnusedIndex == null) {
                    firstUnusedIndex = patternIndex;
                }
                const pattern = song.channels[channelIndex].patterns[patternIndex - 1];
                if (pattern.notes.length == 0) {
                    firstEmptyUnusedIndex = patternIndex;
                    break;
                }
            }
            if (firstEmptyUnusedIndex != null) {
                this._patternIndex = firstEmptyUnusedIndex;
                this._oldPatternInstruments = song.channels[channelIndex].patterns[firstEmptyUnusedIndex - 1].instruments.concat();
            }
            else if (song.patternsPerChannel < song.barCount) {
                this._newPatternCount = song.patternsPerChannel + 1;
                this._patternIndex = song.patternsPerChannel + 1;
            } 
            else if (firstUnusedIndex != null) {
                this._patternIndex = firstUnusedIndex;
                this._patternOldNotes = song.channels[channelIndex].patterns[firstUnusedIndex - 1].notes;
                this._oldPatternInstruments = song.channels[channelIndex].patterns[firstUnusedIndex - 1].instruments.concat();
            }
            else {
                throw new Error();
            }
            this._didSomething();
            this._doForwards();
        }
        _doForwards() {
            const song = this._doc.song;
            for (let j = song.patternsPerChannel; j < this._newPatternCount; j++) {
                for (let i = 0; i < song.getChannelCount(); i++) {
                    song.channels[i].patterns[j] = new Pattern();
                }
            }
            song.patternsPerChannel = this._newPatternCount;
            const pattern = song.channels[this._channelIndex].patterns[this._patternIndex - 1];
            pattern.notes = [];
            pattern.instruments.length = 0;
            pattern.instruments.push(...this._newPatternInstruments);
            song.channels[this._channelIndex].bars[this._bar] = this._patternIndex;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            const song = this._doc.song;
            const pattern = song.channels[this._channelIndex].patterns[this._patternIndex - 1];
            if (this._patternOldNotes != null)
                pattern.notes = this._patternOldNotes;
            if (this._oldPatternInstruments != null) {
                pattern.instruments.length = 0;
                pattern.instruments.push(...this._oldPatternInstruments);
            }
            song.channels[this._channelIndex].bars[this._bar] = 0;
            for (let i = 0; i < song.getChannelCount(); i++) {
                song.channels[i].patterns.length = this._oldPatternCount;
            }
            song.patternsPerChannel = this._oldPatternCount;
            this._doc.notifier.changed();
        }
    }
    class ChangePinTime extends ChangePins {
        constructor(doc, note, pinIndex, shiftedTime, continuesLastPattern) {
            super(doc, note);
            shiftedTime -= this._oldStart;
            const originalTime = this._oldPins[pinIndex].time;
            const skipStart = Math.min(originalTime, shiftedTime);
            const skipEnd = Math.max(originalTime, shiftedTime);
            let setPin = false;
            for (let i = 0; i < this._oldPins.length; i++) {
                const oldPin = note.pins[i];
                const time = oldPin.time;
                if (time < skipStart) {
                    this._newPins.push(makeNotePin(oldPin.interval, time, oldPin.size));
                }
                else if (time > skipEnd) {
                    if (!setPin) {
                        if (this._newPins.length > 0)
                            continuesLastPattern = note.continuesLastPattern;
                        this._newPins.push(makeNotePin(this._oldPins[pinIndex].interval, shiftedTime, this._oldPins[pinIndex].size));
                        setPin = true;
                    }
                    this._newPins.push(makeNotePin(oldPin.interval, time, oldPin.size));
                }
            }
            if (!setPin) {
                continuesLastPattern = note.continuesLastPattern;
                this._newPins.push(makeNotePin(this._oldPins[pinIndex].interval, shiftedTime, this._oldPins[pinIndex].size));
            }
            this._finishSetup(continuesLastPattern);
        }
    }
    class ChangePitchBend extends ChangePins {
        constructor(doc, note, bendStart, bendEnd, bendTo, pitchIndex) {
            super(doc, note);
            bendStart -= this._oldStart;
            bendEnd -= this._oldStart;
            bendTo -= note.pitches[pitchIndex];
            let setStart = false;
            let setEnd = false;
            let prevInterval = 0;
            let prevSize = Config.noteSizeMax;
            let persist = true;
            let i;
            let direction;
            let stop;
            let push;
            if (bendEnd > bendStart) {
                i = 0;
                direction = 1;
                stop = note.pins.length;
                push = (item) => { this._newPins.push(item); };
            }
            else {
                i = note.pins.length - 1;
                direction = -1;
                stop = -1;
                push = (item) => { this._newPins.unshift(item); };
            }
            for (; i != stop; i += direction) {
                const oldPin = note.pins[i];
                const time = oldPin.time;
                for (;;) {
                    if (!setStart) {
                        if (time * direction <= bendStart * direction) {
                            prevInterval = oldPin.interval;
                            prevSize = oldPin.size;
                        }
                        if (time * direction < bendStart * direction) {
                            push(makeNotePin(oldPin.interval, time, oldPin.size));
                            break;
                        }
                        else {
                            push(makeNotePin(prevInterval, bendStart, prevSize));
                            setStart = true;
                        }
                    }
                    else if (!setEnd) {
                        if (time * direction <= bendEnd * direction) {
                            prevInterval = oldPin.interval;
                            prevSize = oldPin.size;
                        }
                        if (time * direction < bendEnd * direction) {
                            break;
                        }
                        else {
                            push(makeNotePin(bendTo, bendEnd, prevSize));
                            setEnd = true;
                        }
                    }
                    else {
                        if (time * direction == bendEnd * direction) {
                            break;
                        }
                        else {
                            if (oldPin.interval != prevInterval)
                                persist = false;
                            push(makeNotePin(persist ? bendTo : oldPin.interval, time, oldPin.size));
                            break;
                        }
                    }
                }
            }
            if (!setEnd) {
                push(makeNotePin(bendTo, bendEnd, prevSize));
            }
            this._finishSetup();
        }
    }
    class ChangePatternRhythm extends ChangeSequence {
        constructor(doc, pattern) {
            super();
            const minDivision = Config.partsPerBeat / Config.rhythms[doc.song.rhythm].stepsPerBeat;
            const changeRhythm = function (oldTime) {
                let thresholds = Config.rhythms[doc.song.rhythm].roundUpThresholds;
                if (thresholds != null) {
                    const beatStart = Math.floor(oldTime / Config.partsPerBeat) * Config.partsPerBeat;
                    const remainder = oldTime - beatStart;
                    let newTime = beatStart;
                    for (const threshold of thresholds) {
                        if (remainder >= threshold) {
                            newTime += minDivision;
                        }
                        else {
                            break;
                        }
                    }
                    return newTime;
                }
                else {
                    return Math.round(oldTime / minDivision) * minDivision;
                }
            };
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (changeRhythm(note.start) >= changeRhythm(note.end)) {
                    this.append(new ChangeNoteAdded(doc, pattern, note, i, true));
                }
                else {
                    this.append(new ChangeRhythmNote(doc, note, changeRhythm));
                    i++;
                }
            }
        }
    }
    class ChangeRhythmNote extends ChangePins {
        constructor(doc, note, changeRhythm) {
            super(doc, note);
            for (const oldPin of this._oldPins) {
                this._newPins.push(makeNotePin(oldPin.interval, changeRhythm(oldPin.time + this._oldStart) - this._oldStart, oldPin.size));
            }
            this._finishSetup();
        }
    }
    class ChangeMoveNotesSideways extends ChangeGroup {
        constructor(doc, beatsToMove, strategy) {
            super();
            let partsToMove = Math.round((beatsToMove % doc.song.beatsPerBar) * Config.partsPerBeat);
            if (partsToMove < 0)
                partsToMove += doc.song.beatsPerBar * Config.partsPerBeat;
            if (partsToMove == 0.0)
                return;
            switch (strategy) {
                case "wrapAround":
                    {
                        const partsPerBar = Config.partsPerBeat * doc.song.beatsPerBar;
                        for (const channel of doc.song.channels) {
                            for (const pattern of channel.patterns) {
                                const newNotes = [];
                                for (let bar = 1; bar >= 0; bar--) {
                                    const barStartPart = bar * partsPerBar;
                                    for (const oldNote of pattern.notes) {
                                        const absoluteNoteStart = oldNote.start + partsToMove;
                                        const absoluteNoteEnd = oldNote.end + partsToMove;
                                        const noteStartPart = Math.max(0, absoluteNoteStart - barStartPart);
                                        const noteEndPart = Math.min(partsPerBar, absoluteNoteEnd - barStartPart);
                                        if (noteStartPart < noteEndPart) {
                                            projectNoteIntoBar(oldNote, absoluteNoteStart - barStartPart - noteStartPart, noteStartPart, noteEndPart, newNotes);
                                        }
                                    }
                                }
                                pattern.notes = newNotes;
                            }
                        }
                    }
                    break;
                case "overflow":
                    {
                        let originalBarCount = doc.song.barCount;
                        let originalLoopStart = doc.song.loopStart;
                        let originalLoopLength = doc.song.loopLength;
                        this.append(new ChangeMoveAndOverflowNotes(doc, doc.song.beatsPerBar, partsToMove));
                        if (beatsToMove < 0) {
                            let firstBarIsEmpty = true;
                            for (const channel of doc.song.channels) {
                                if (channel.bars[0] != 0)
                                    firstBarIsEmpty = false;
                            }
                            if (firstBarIsEmpty) {
                                for (const channel of doc.song.channels) {
                                    channel.bars.shift();
                                }
                                doc.song.barCount--;
                            }
                            else {
                                originalBarCount++;
                                originalLoopStart++;
                                doc.bar++;
                            }
                        }
                        while (doc.song.barCount < originalBarCount) {
                            for (const channel of doc.song.channels) {
                                channel.bars.push(0);
                            }
                            doc.song.barCount++;
                        }
                        doc.song.loopStart = originalLoopStart;
                        doc.song.loopLength = originalLoopLength;
                    }
                    break;
                default: throw new Error("Unrecognized beats-per-bar conversion strategy.");
            }
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeBeatsPerBar extends ChangeGroup {
        constructor(doc, newValue, strategy) {
            super();
            if (doc.song.beatsPerBar != newValue) {
                switch (strategy) {
                    case "splice":
                        {
                            if (doc.song.beatsPerBar > newValue) {
                                const sequence = new ChangeSequence();
                                for (let i = 0; i < doc.song.getChannelCount(); i++) {
                                    for (let j = 0; j < doc.song.channels[i].patterns.length; j++) {
                                        sequence.append(new ChangeNoteTruncate(doc, doc.song.channels[i].patterns[j], newValue * Config.partsPerBeat, doc.song.beatsPerBar * Config.partsPerBeat, null, true));
                                    }
                                }
                            }
                        }
                        break;
                    case "stretch":
                        {
                            const changeRhythm = function (oldTime) {
                                return Math.round(oldTime * newValue / doc.song.beatsPerBar);
                            };
                            for (let channelIndex = 0; channelIndex < doc.song.getChannelCount(); channelIndex++) {
                                for (let patternIndex = 0; patternIndex < doc.song.channels[channelIndex].patterns.length; patternIndex++) {
                                    const pattern = doc.song.channels[channelIndex].patterns[patternIndex];
                                    let noteIndex = 0;
                                    while (noteIndex < pattern.notes.length) {
                                        const note = pattern.notes[noteIndex];
                                        if (changeRhythm(note.start) >= changeRhythm(note.end)) {
                                            this.append(new ChangeNoteAdded(doc, pattern, note, noteIndex, true));
                                        }
                                        else {
                                            this.append(new ChangeRhythmNote(doc, note, changeRhythm));
                                            noteIndex++;
                                        }
                                    }
                                }
                            }
                            this.append(new ChangeTempo(doc, doc.song.tempo, doc.song.tempo * newValue / doc.song.beatsPerBar));
                        }
                        break;
                    case "overflow":
                        {
                            this.append(new ChangeMoveAndOverflowNotes(doc, newValue, 0));
                            doc.song.loopStart = 0;
                            doc.song.loopLength = doc.song.barCount;
                        }
                        break;
                    default: throw new Error("Unrecognized beats-per-bar conversion strategy.");
                }
                doc.song.beatsPerBar = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeScale extends ChangeGroup {
        constructor(doc, newValue) {
            super();
            if (doc.song.scale != newValue) {
                doc.song.scale = newValue;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeDetectKey extends ChangeGroup {
        constructor(doc) {
            super();
            const song = doc.song;
            const basePitch = Config.keys[song.key].basePitch;
            const keyWeights = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (let channelIndex = 0; channelIndex < song.pitchChannelCount; channelIndex++) {
                for (let barIndex = 0; barIndex < song.barCount; barIndex++) {
                    const pattern = song.getPattern(channelIndex, barIndex);
                    if (pattern != null) {
                        for (const note of pattern.notes) {
                            const prevPin = note.pins[0];
                            for (let pinIndex = 1; pinIndex < note.pins.length; pinIndex++) {
                                const nextPin = note.pins[pinIndex];
                                if (prevPin.interval == nextPin.interval) {
                                    let weight = nextPin.time - prevPin.time;
                                    weight += Math.max(0, Math.min(Config.partsPerBeat, nextPin.time + note.start) - (prevPin.time + note.start));
                                    weight *= nextPin.size + prevPin.size;
                                    for (const pitch of note.pitches) {
                                        const key = (basePitch + prevPin.interval + pitch) % 12;
                                        keyWeights[key] += weight;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let bestKey = 0;
            let bestKeyWeight = 0;
            for (let key = 0; key < 12; key++) {
                const keyWeight = keyWeights[key] * (3 * keyWeights[(key + 7) % 12] + keyWeights[(key + 4) % 12] + keyWeights[(key + 3) % 12]);
                if (bestKeyWeight < keyWeight) {
                    bestKeyWeight = keyWeight;
                    bestKey = key;
                }
            }
            if (bestKey != song.key) {
                const diff = song.key - bestKey;
                const absoluteDiff = Math.abs(diff);
                for (let channelIndex = 0; channelIndex < song.pitchChannelCount; channelIndex++) {
                    for (const pattern of song.channels[channelIndex].patterns) {
                        for (let i = 0; i < absoluteDiff; i++) {
                            this.append(new ChangeTranspose(doc, channelIndex, pattern, diff > 0, true));
                        }
                    }
                }
                song.key = bestKey;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    function pickRandomPresetValue(isNoise) {
        const eligiblePresetValues = [];
        for (let categoryIndex = 0; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {
            const category = EditorConfig.presetCategories[categoryIndex];
            if (category.name == "Novelty Presets")
                continue;
            for (let presetIndex = 0; presetIndex < category.presets.length; presetIndex++) {
                const preset = category.presets[presetIndex];
                if (preset.settings != undefined && (preset.isNoise == true) == isNoise) {
                    eligiblePresetValues.push((categoryIndex << 6) + presetIndex);
                }
            }
        }
        return eligiblePresetValues[(Math.random() * eligiblePresetValues.length) | 0];
    }
    function setDefaultInstruments(song) {
        for (let channelIndex = 0; channelIndex < song.channels.length; channelIndex++) {
            for (const instrument of song.channels[channelIndex].instruments) {
                const isNoise = song.getChannelIsNoise(channelIndex);
                const isMod = song.getChannelIsMod(channelIndex);
                const presetValue = (channelIndex == song.pitchChannelCount) ? EditorConfig.nameToPresetValue(Math.random() > 0.5 ? "chip noise" : "standard drumset") : pickRandomPresetValue(isNoise);
                const preset = EditorConfig.valueToPreset(presetValue);
                instrument.fromJsonObject(preset.settings, isNoise, isMod, song.rhythm == 0 || song.rhythm == 2, song.rhythm >= 2, 1);
                instrument.preset = presetValue;
                instrument.effects |= 1 << 2;
            }
        }
    }
    class ChangeSong extends ChangeGroup {
        constructor(doc, newHash, jsonFormat = "auto") {
            super();
            let pitchChannelCount = doc.song.pitchChannelCount;
            let noiseChannelCount = doc.song.noiseChannelCount;
            let modChannelCount = doc.song.modChannelCount;
            doc.song.fromBase64String(newHash, jsonFormat);
            if (pitchChannelCount != doc.song.pitchChannelCount || noiseChannelCount != doc.song.noiseChannelCount || modChannelCount != doc.song.modChannelCount) {
                ColorConfig.resetColors();
            }
            if (newHash == "") {
                this.append(new ChangePatternSelection(doc, 0, 0));
                doc.selection.resetBoxSelection();
                setDefaultInstruments(doc.song);
                doc.song.scale = doc.prefs.defaultScale;
                for (let i = 0; i <= doc.song.channels.length; i++) {
                    doc.viewedInstrument[i] = 0;
                    doc.recentPatternInstruments[i] = [0];
                }
                doc.viewedInstrument.length = doc.song.channels.length;
            }
            else {
                this.append(new ChangeValidateTrackSelection(doc));
            }
            doc.synth.computeLatestModValues();
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeValidateTrackSelection extends Change {
        constructor(doc) {
            super();
            const channelIndex = Math.min(doc.channel, doc.song.getChannelCount() - 1);
            const bar = Math.max(0, Math.min(doc.song.barCount - 1, doc.bar));
            if (doc.channel != channelIndex || doc.bar != bar) {
                doc.bar = bar;
                doc.channel = channelIndex;
                this._didSomething();
            }
            doc.selection.scrollToSelectedPattern();
            doc.notifier.changed();
        }
    }
    class ChangeReplacePatterns extends ChangeGroup {
        constructor(doc, pitchChannels, noiseChannels, modChannels) {
            super();
            const song = doc.song;
            function removeExtraSparseChannels(channels, maxLength) {
                while (channels.length > maxLength) {
                    let sparsestIndex = channels.length - 1;
                    let mostZeroes = 0;
                    for (let channelIndex = 0; channelIndex < channels.length - 1; channelIndex++) {
                        let zeroes = 0;
                        for (const bar of channels[channelIndex].bars) {
                            if (bar == 0)
                                zeroes++;
                        }
                        if (zeroes >= mostZeroes) {
                            sparsestIndex = channelIndex;
                            mostZeroes = zeroes;
                        }
                    }
                    channels.splice(sparsestIndex, 1);
                }
            }
            removeExtraSparseChannels(pitchChannels, Config.pitchChannelCountMax);
            removeExtraSparseChannels(noiseChannels, Config.noiseChannelCountMax);
            removeExtraSparseChannels(modChannels, Config.modChannelCountMax);
            while (pitchChannels.length < Config.pitchChannelCountMin)
                pitchChannels.push(new Channel());
            while (noiseChannels.length < Config.noiseChannelCountMin)
                noiseChannels.push(new Channel());
            while (modChannels.length < Config.modChannelCountMin)
                modChannels.push(new Channel());
            song.barCount = 1;
            song.patternsPerChannel = 100; 
            const combinedChannels = pitchChannels.concat(noiseChannels.concat(modChannels));
            for (let channelIndex = 0; channelIndex < combinedChannels.length; channelIndex++) {
                const channel = combinedChannels[channelIndex];
                song.barCount = Math.max(song.barCount, channel.bars.length);
                song.patternsPerChannel = Math.max(song.patternsPerChannel, channel.patterns.length);
                song.channels[channelIndex] = channel;
            }
            song.channels.length = combinedChannels.length;
            song.pitchChannelCount = pitchChannels.length;
            song.noiseChannelCount = noiseChannels.length;
            song.modChannelCount = modChannels.length;
            song.barCount = Math.min(Config.barCountMax, song.barCount);
            song.patternsPerChannel = Math.min(Config.barCountMax, song.patternsPerChannel);
            for (let channelIndex = 0; channelIndex < song.channels.length; channelIndex++) {
                const channel = song.channels[channelIndex];
                for (let barIndex = 0; barIndex < channel.bars.length; barIndex++) {
                    if (channel.bars[barIndex] > song.patternsPerChannel || channel.bars[barIndex] < 0) {
                        channel.bars[barIndex] = 0;
                    }
                }
                while (channel.bars.length < song.barCount) {
                    channel.bars.push(0);
                }
                channel.bars.length = song.barCount;
                if (channel.instruments.length > song.getMaxInstrumentsPerChannel()) {
                    channel.instruments.length = song.getMaxInstrumentsPerChannel();
                }
                for (const pattern of channel.patterns) {
                    discardInvalidPatternInstruments(pattern.instruments, song, channelIndex);
                }
                while (channel.patterns.length < song.patternsPerChannel) {
                    channel.patterns.push(new Pattern());
                }
                channel.patterns.length = song.patternsPerChannel;
            }
            song.loopStart = Math.max(0, Math.min(song.barCount - 1, song.loopStart));
            song.loopLength = Math.min(song.barCount - song.loopStart, song.loopLength);
            this.append(new ChangeValidateTrackSelection(doc));
            doc.notifier.changed();
            this._didSomething();
            ColorConfig.resetColors();
        }
    }
    function comparePatternNotes(a, b) {
        if (a.length != b.length)
            return false;
        for (let noteIndex = 0; noteIndex < a.length; noteIndex++) {
            const oldNote = a[noteIndex];
            const newNote = b[noteIndex];
            if (newNote.start != oldNote.start || newNote.end != oldNote.end || newNote.pitches.length != oldNote.pitches.length || newNote.pins.length != oldNote.pins.length) {
                return false;
            }
            for (let pitchIndex = 0; pitchIndex < oldNote.pitches.length; pitchIndex++) {
                if (newNote.pitches[pitchIndex] != oldNote.pitches[pitchIndex]) {
                    return false;
                }
            }
            for (let pinIndex = 0; pinIndex < oldNote.pins.length; pinIndex++) {
                if (newNote.pins[pinIndex].interval != oldNote.pins[pinIndex].interval || newNote.pins[pinIndex].time != oldNote.pins[pinIndex].time || newNote.pins[pinIndex].size != oldNote.pins[pinIndex].size) {
                    return false;
                }
            }
        }
        return true;
    }
    function removeDuplicatePatterns(channels) {
        for (const channel of channels) {
            const newPatterns = [];
            for (let bar = 0; bar < channel.bars.length; bar++) {
                if (channel.bars[bar] == 0)
                    continue;
                const oldPattern = channel.patterns[channel.bars[bar] - 1];
                let foundMatchingPattern = false;
                for (let newPatternIndex = 0; newPatternIndex < newPatterns.length; newPatternIndex++) {
                    const newPattern = newPatterns[newPatternIndex];
                    if (!patternsContainSameInstruments(oldPattern.instruments, newPattern.instruments) || newPattern.notes.length != oldPattern.notes.length) {
                        continue;
                    }
                    if (comparePatternNotes(oldPattern.notes, newPattern.notes)) {
                        foundMatchingPattern = true;
                        channel.bars[bar] = newPatternIndex + 1;
                        break;
                    }
                }
                if (!foundMatchingPattern) {
                    newPatterns.push(oldPattern);
                    channel.bars[bar] = newPatterns.length;
                }
            }
            for (let patternIndex = 0; patternIndex < newPatterns.length; patternIndex++) {
                channel.patterns[patternIndex] = newPatterns[patternIndex];
            }
            channel.patterns.length = newPatterns.length;
        }
    }
    class ChangeKeyOctave extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.octave = Math.max(Config.octaveMin, Math.min(Config.octaveMax, Math.round(newValue)));
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeTempo extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.tempo = Math.max(Config.tempoMin, Math.min(Config.tempoMax, Math.round(newValue)));
            doc.synth.unsetMod(Config.modulators.dictionary["tempo"].index);
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEchoDelay extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.echoDelay = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["echo delay"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeEchoSustain extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.echoSustain = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["echo"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeChorus extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.chorus = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["chorus"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeReverb extends ChangeInstrumentSlider {
        constructor(doc, oldValue, newValue) {
            super(doc);
            this._instrument.reverb = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["reverb"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeNoteAdded extends UndoableChange {
        constructor(doc, pattern, note, index, deletion = false) {
            super(deletion);
            this._doc = doc;
            this._pattern = pattern;
            this._note = note;
            this._index = index;
            this._didSomething();
            this.redo();
        }
        _doForwards() {
            this._pattern.notes.splice(this._index, 0, this._note);
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._pattern.notes.splice(this._index, 1);
            this._doc.notifier.changed();
        }
    }
    class ChangeNoteLength extends ChangePins {
        constructor(doc, note, truncStart, truncEnd) {
            super(doc, note);
            const continuesLastPattern = ((this._oldStart < 0 || note.continuesLastPattern) && truncStart == 0);
            truncStart -= this._oldStart;
            truncEnd -= this._oldStart;
            let setStart = false;
            let prevSize = this._oldPins[0].size;
            let prevInterval = this._oldPins[0].interval;
            let pushLastPin = true;
            let i;
            for (i = 0; i < this._oldPins.length; i++) {
                const oldPin = this._oldPins[i];
                if (oldPin.time < truncStart) {
                    prevSize = oldPin.size;
                    prevInterval = oldPin.interval;
                }
                else {
                    if (oldPin.time > truncStart && !setStart) {
                        this._newPins.push(makeNotePin(prevInterval, truncStart, prevSize));
                        setStart = true;
                    }
                    if (oldPin.time <= truncEnd) {
                        this._newPins.push(makeNotePin(oldPin.interval, oldPin.time, oldPin.size));
                        if (oldPin.time == truncEnd) {
                            pushLastPin = false;
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            if (pushLastPin)
                this._newPins.push(makeNotePin(this._oldPins[i].interval, truncEnd, this._oldPins[i].size));
            this._finishSetup(continuesLastPattern);
        }
    }
    class ChangeNoteTruncate extends ChangeSequence {
        constructor(doc, pattern, start, end, skipNote = null, force = false) {
            super();
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (note == skipNote && skipNote != null) {
                    i++;
                }
                else if (note.end <= start) {
                    i++;
                }
                else if (note.start >= end) {
                    if (!doc.song.getChannelIsMod(doc.channel)) {
                        break;
                    }
                    else {
                        i++;
                    }
                }
                else if (note.start < start && note.end > end) {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0])) {
                        const copy = note.clone();
                        this.append(new ChangeNoteLength(doc, note, note.start, start));
                        i++;
                        this.append(new ChangeNoteAdded(doc, pattern, copy, i, false));
                        this.append(new ChangeNoteLength(doc, copy, end, copy.end));
                    }
                    i++;
                }
                else if (note.start < start) {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0]))
                        this.append(new ChangeNoteLength(doc, note, note.start, start));
                    i++;
                }
                else if (note.end > end) {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0]))
                        this.append(new ChangeNoteLength(doc, note, end, note.end));
                    i++;
                }
                else {
                    if (!doc.song.getChannelIsMod(doc.channel) || force || (skipNote != null && note.pitches[0] == skipNote.pitches[0]))
                        this.append(new ChangeNoteAdded(doc, pattern, note, i, true));
                    else
                        i++;
                }
            }
        }
    }
    class ChangeSplitNotesAtSelection extends ChangeSequence {
        constructor(doc, pattern) {
            super();
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (note.start < doc.selection.patternSelectionStart && doc.selection.patternSelectionStart < note.end) {
                    const copy = note.clone();
                    this.append(new ChangeNoteLength(doc, note, note.start, doc.selection.patternSelectionStart));
                    i++;
                    this.append(new ChangeNoteAdded(doc, pattern, copy, i, false));
                    this.append(new ChangeNoteLength(doc, copy, doc.selection.patternSelectionStart, copy.end));
                }
                else if (note.start < doc.selection.patternSelectionEnd && doc.selection.patternSelectionEnd < note.end) {
                    const copy = note.clone();
                    this.append(new ChangeNoteLength(doc, note, note.start, doc.selection.patternSelectionEnd));
                    i++;
                    this.append(new ChangeNoteAdded(doc, pattern, copy, i, false));
                    this.append(new ChangeNoteLength(doc, copy, doc.selection.patternSelectionEnd, copy.end));
                    i++;
                }
                else {
                    i++;
                }
            }
        }
    }
    class ChangeTransposeNote extends UndoableChange {
        constructor(doc, channelIndex, note, upward, ignoreScale = false, octave = false) {
            super(false);
            this._doc = doc;
            this._note = note;
            this._oldPins = note.pins;
            this._newPins = [];
            this._oldPitches = note.pitches;
            this._newPitches = [];
            const isNoise = doc.song.getChannelIsNoise(channelIndex);
            if (isNoise != doc.song.getChannelIsNoise(doc.channel))
                return;
            if (doc.song.getChannelIsMod(doc.channel))
                return;
            const maxPitch = (isNoise ? Config.drumCount - 1 : Config.maxPitch);
            for (let i = 0; i < this._oldPitches.length; i++) {
                let pitch = this._oldPitches[i];
                if (octave && !isNoise) {
                    if (upward) {
                        pitch = Math.min(maxPitch, pitch + 12);
                    }
                    else {
                        pitch = Math.max(0, pitch - 12);
                    }
                }
                else {
                    let scale = doc.song.scale == Config.scales.dictionary["Custom"].index ? doc.song.scaleCustom : Config.scales[doc.song.scale].flags;
                    if (upward) {
                        for (let j = pitch + 1; j <= maxPitch; j++) {
                            if (isNoise || ignoreScale || scale[j % 12]) {
                                pitch = j;
                                break;
                            }
                        }
                    }
                    else {
                        for (let j = pitch - 1; j >= 0; j--) {
                            if (isNoise || ignoreScale || scale[j % 12]) {
                                pitch = j;
                                break;
                            }
                        }
                    }
                }
                let foundMatch = false;
                for (let j = 0; j < this._newPitches.length; j++) {
                    if (this._newPitches[j] == pitch) {
                        foundMatch = true;
                        break;
                    }
                }
                if (!foundMatch)
                    this._newPitches.push(pitch);
            }
            let min = 0;
            let max = maxPitch;
            for (let i = 1; i < this._newPitches.length; i++) {
                const diff = this._newPitches[0] - this._newPitches[i];
                if (min < diff)
                    min = diff;
                if (max > diff + maxPitch)
                    max = diff + maxPitch;
            }
            for (const oldPin of this._oldPins) {
                let interval = oldPin.interval + this._oldPitches[0];
                if (interval < min)
                    interval = min;
                if (interval > max)
                    interval = max;
                if (octave && !isNoise) {
                    if (upward) {
                        interval = Math.min(max, interval + 12);
                    }
                    else {
                        interval = Math.max(min, interval - 12);
                    }
                }
                else {
                    let scale = doc.song.scale == Config.scales.dictionary["Custom"].index ? doc.song.scaleCustom : Config.scales[doc.song.scale].flags;
                    if (upward) {
                        for (let i = interval + 1; i <= max; i++) {
                            if (isNoise || ignoreScale || scale[i % 12]) {
                                interval = i;
                                break;
                            }
                        }
                    }
                    else {
                        for (let i = interval - 1; i >= min; i--) {
                            if (isNoise || ignoreScale || scale[i % 12]) {
                                interval = i;
                                break;
                            }
                        }
                    }
                }
                interval -= this._newPitches[0];
                this._newPins.push(makeNotePin(interval, oldPin.time, oldPin.size));
            }
            if (this._newPins[0].interval != 0)
                throw new Error("wrong pin start interval");
            for (let i = 1; i < this._newPins.length - 1;) {
                if (this._newPins[i - 1].interval == this._newPins[i].interval &&
                    this._newPins[i].interval == this._newPins[i + 1].interval &&
                    this._newPins[i - 1].size == this._newPins[i].size &&
                    this._newPins[i].size == this._newPins[i + 1].size) {
                    this._newPins.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._note.pins = this._newPins;
            this._note.pitches = this._newPitches;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pins = this._oldPins;
            this._note.pitches = this._oldPitches;
            this._doc.notifier.changed();
        }
    }
    class ChangeTranspose extends ChangeSequence {
        constructor(doc, channelIndex, pattern, upward, ignoreScale = false, octave = false) {
            super();
            if (doc.selection.patternSelectionActive) {
                this.append(new ChangeSplitNotesAtSelection(doc, pattern));
            }
            for (const note of pattern.notes) {
                if (doc.selection.patternSelectionActive && (note.end <= doc.selection.patternSelectionStart || note.start >= doc.selection.patternSelectionEnd)) {
                    continue;
                }
                this.append(new ChangeTransposeNote(doc, channelIndex, note, upward, ignoreScale, octave));
            }
        }
    }
    class ChangeTrackSelection extends Change {
        constructor(doc, newX0, newX1, newY0, newY1) {
            super();
            doc.selection.boxSelectionX0 = newX0;
            doc.selection.boxSelectionX1 = newX1;
            doc.selection.boxSelectionY0 = newY0;
            doc.selection.boxSelectionY1 = newY1;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangePatternSelection extends UndoableChange {
        constructor(doc, newStart, newEnd) {
            super(false);
            this._doc = doc;
            this._oldStart = doc.selection.patternSelectionStart;
            this._oldEnd = doc.selection.patternSelectionEnd;
            this._oldActive = doc.selection.patternSelectionActive;
            this._newStart = newStart;
            this._newEnd = newEnd;
            this._newActive = newStart < newEnd;
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._doc.selection.patternSelectionStart = this._newStart;
            this._doc.selection.patternSelectionEnd = this._newEnd;
            this._doc.selection.patternSelectionActive = this._newActive;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._doc.selection.patternSelectionStart = this._oldStart;
            this._doc.selection.patternSelectionEnd = this._oldEnd;
            this._doc.selection.patternSelectionActive = this._oldActive;
            this._doc.notifier.changed();
        }
    }
    class ChangeDragSelectedNotes extends ChangeSequence {
        constructor(doc, channelIndex, pattern, parts, transpose) {
            super();
            if (parts == 0 && transpose == 0)
                return;
            if (doc.selection.patternSelectionActive) {
                this.append(new ChangeSplitNotesAtSelection(doc, pattern));
            }
            const oldStart = doc.selection.patternSelectionStart;
            const oldEnd = doc.selection.patternSelectionEnd;
            const newStart = Math.max(0, Math.min(doc.song.beatsPerBar * Config.partsPerBeat, oldStart + parts));
            const newEnd = Math.max(0, Math.min(doc.song.beatsPerBar * Config.partsPerBeat, oldEnd + parts));
            if (newStart == newEnd) {
                this.append(new ChangeNoteTruncate(doc, pattern, oldStart, oldEnd, null, true));
            }
            else if (parts < 0) {
                this.append(new ChangeNoteTruncate(doc, pattern, newStart, Math.min(oldStart, newEnd), null, true));
            }
            else {
                this.append(new ChangeNoteTruncate(doc, pattern, Math.max(oldEnd, newStart), newEnd, null, true));
            }
            this.append(new ChangePatternSelection(doc, newStart, newEnd));
            const draggedNotes = [];
            let noteInsertionIndex = 0;
            let i = 0;
            while (i < pattern.notes.length) {
                const note = pattern.notes[i];
                if (note.end <= oldStart || note.start >= oldEnd) {
                    i++;
                    if (note.end <= newStart)
                        noteInsertionIndex = i;
                }
                else {
                    draggedNotes.push(note.clone());
                    this.append(new ChangeNoteAdded(doc, pattern, note, i, true));
                }
            }
            for (const note of draggedNotes) {
                note.start += parts;
                note.end += parts;
                if (note.end <= newStart)
                    continue;
                if (note.start >= newEnd)
                    continue;
                this.append(new ChangeNoteAdded(doc, pattern, note, noteInsertionIndex++, false));
                this.append(new ChangeNoteLength(doc, note, Math.max(note.start, newStart), Math.min(newEnd, note.end)));
                for (let i = 0; i < Math.abs(transpose); i++) {
                    this.append(new ChangeTransposeNote(doc, channelIndex, note, transpose > 0, doc.prefs.notesOutsideScale));
                }
            }
        }
    }
    class ChangeHoldingModRecording extends Change {
        constructor(doc, storedChange, storedValues, slider) {
            super();
            this.storedChange = storedChange;
            this.storedValues = storedValues;
            this.storedSlider = slider;
            this._didSomething();
        }
    }
    class ChangeDuplicateSelectedReusedPatterns extends ChangeGroup {
        constructor(doc, barStart, barWidth, channelStart, channelHeight, replaceUnused) {
            super();
            for (let channelIndex = channelStart; channelIndex < channelStart + channelHeight; channelIndex++) {
                const reusablePatterns = {};
                for (let bar = barStart; bar < barStart + barWidth; bar++) {
                    const currentPatternIndex = doc.song.channels[channelIndex].bars[bar];
                    if (currentPatternIndex == 0)
                        continue;
                    if (reusablePatterns[String(currentPatternIndex)] == undefined) {
                        let isUsedElsewhere = false;
                        for (let bar2 = 0; bar2 < doc.song.barCount; bar2++) {
                            if (bar2 < barStart || bar2 >= barStart + barWidth) {
                                if (doc.song.channels[channelIndex].bars[bar2] == currentPatternIndex) {
                                    isUsedElsewhere = true;
                                    break;
                                }
                            }
                        }
                        if (isUsedElsewhere) {
                            const copiedPattern = doc.song.getPattern(channelIndex, bar);
                            this.append(new ChangePatternNumbers(doc, 0, bar, channelIndex, 1, 1));
                            this.append(new ChangeEnsurePatternExists(doc, channelIndex, bar));
                            const newPattern = doc.song.getPattern(channelIndex, bar);
                            if (newPattern == null)
                                throw new Error();
                            this.append(new ChangePaste(doc, newPattern, copiedPattern.notes, 0, Config.partsPerBeat * doc.song.beatsPerBar, Config.partsPerBeat * doc.song.beatsPerBar));
                            newPattern.instruments.length = 0;
                            newPattern.instruments.push(...copiedPattern.instruments);
                            reusablePatterns[String(currentPatternIndex)] = doc.song.channels[channelIndex].bars[bar];
                        }
                        else {
                            reusablePatterns[String(currentPatternIndex)] = currentPatternIndex;
                        }
                    }
                    this.append(new ChangePatternNumbers(doc, reusablePatterns[String(currentPatternIndex)], bar, channelIndex, 1, 1));
                }
            }
        }
    }
    class ChangePatternScale extends Change {
        constructor(doc, pattern, scaleMap) {
            super();
            if (doc.selection.patternSelectionActive) {
                new ChangeSplitNotesAtSelection(doc, pattern);
            }
            const maxPitch = Config.maxPitch;
            for (const note of pattern.notes) {
                if (doc.selection.patternSelectionActive && (note.end <= doc.selection.patternSelectionStart || note.start >= doc.selection.patternSelectionEnd)) {
                    continue;
                }
                const newPitches = [];
                const newPins = [];
                for (let i = 0; i < note.pitches.length; i++) {
                    const pitch = note.pitches[i];
                    const transformedPitch = scaleMap[pitch % 12] + (pitch - (pitch % 12));
                    if (newPitches.indexOf(transformedPitch) == -1) {
                        newPitches.push(transformedPitch);
                    }
                }
                let min = 0;
                let max = maxPitch;
                for (let i = 1; i < newPitches.length; i++) {
                    const diff = newPitches[0] - newPitches[i];
                    if (min < diff)
                        min = diff;
                    if (max > diff + maxPitch)
                        max = diff + maxPitch;
                }
                for (const oldPin of note.pins) {
                    let interval = oldPin.interval + note.pitches[0];
                    if (interval < min)
                        interval = min;
                    if (interval > max)
                        interval = max;
                    const transformedInterval = scaleMap[interval % 12] + (interval - (interval % 12));
                    newPins.push(makeNotePin(transformedInterval - newPitches[0], oldPin.time, oldPin.size));
                }
                if (newPins[0].interval != 0)
                    throw new Error("wrong pin start interval");
                for (let i = 1; i < newPins.length - 1;) {
                    if (newPins[i - 1].interval == newPins[i].interval &&
                        newPins[i].interval == newPins[i + 1].interval &&
                        newPins[i - 1].size == newPins[i].size &&
                        newPins[i].size == newPins[i + 1].size) {
                        newPins.splice(i, 1);
                    }
                    else {
                        i++;
                    }
                }
                note.pitches = newPitches;
                note.pins = newPins;
            }
            this._didSomething();
            doc.notifier.changed();
        }
    }
    class ChangeVolume extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].volume = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSongTitle extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            if (newValue.length > 30) {
                newValue = newValue.substring(0, 30);
            }
            doc.song.title = newValue;
            document.title = newValue + " - " + EditorConfig.versionDisplayName;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeChannelName extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            if (newValue.length > 15) {
                newValue = newValue.substring(0, 15);
            }
            doc.song.channels[doc.muteEditorChannel].name = newValue;
            doc.recalcChannelNames = true;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangePan extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].pan = newValue;
            doc.synth.unsetMod(Config.modulators.dictionary["pan"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    
class ChangeShift extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].pitchShift = newValue;
		doc.synth.unsetMod(Config.modulators.dictionary["pan"].index, doc.channel, doc.getCurrentInstrument());
		doc.notifier.changed();
		if (oldValue != newValue)
			this._didSomething();
	}
}
class ChangeOctaveShf extends Change {
	constructor(doc, oldValue, newValue) {
		super();
		doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].octaveShift = newValue;
		doc.synth.unsetMod(Config.modulators.dictionary["pan"].index, doc.channel, doc.getCurrentInstrument());
		doc.notifier.changed();
		if (oldValue != newValue)
			this._didSomething();
	}
}
    
    class ChangePanDelay extends Change {
        constructor(doc, oldValue, newValue) {
            super();
            doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()].panDelay = newValue;
            doc.notifier.changed();
            if (oldValue != newValue)
                this._didSomething();
        }
    }
    class ChangeSizeBend extends UndoableChange {
        constructor(doc, note, bendPart, bendSize, bendInterval, uniformSize) {
            super(false);
            this._doc = doc;
            this._note = note;
            this._oldPins = note.pins;
            this._newPins = [];
            let inserted = false;
            for (const pin of note.pins) {
                if (pin.time < bendPart) {
                    if (uniformSize) {
                        this._newPins.push(makeNotePin(pin.interval, pin.time, bendSize));
                    }
                    else {
                        this._newPins.push(pin);
                    }
                }
                else if (pin.time == bendPart) {
                    this._newPins.push(makeNotePin(bendInterval, bendPart, bendSize));
                    inserted = true;
                }
                else {
                    if (!uniformSize && !inserted) {
                        this._newPins.push(makeNotePin(bendInterval, bendPart, bendSize));
                        inserted = true;
                    }
                    if (uniformSize) {
                        this._newPins.push(makeNotePin(pin.interval, pin.time, bendSize));
                    }
                    else {
                        this._newPins.push(pin);
                    }
                }
            }
            removeRedundantPins(this._newPins);
            this._doForwards();
            this._didSomething();
        }
        _doForwards() {
            this._note.pins = this._newPins;
            this._doc.notifier.changed();
        }
        _doBackwards() {
            this._note.pins = this._oldPins;
            this._doc.notifier.changed();
        }
    }
class ChangeChipWave extends Change {
 constructor(doc, newValue) {
  super();
  const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
  if (instrument.chipWave != newValue) {
   instrument.chipWave = newValue;
   instrument.wave = Config.chipWaves[newValue]?.name ?? "unknown";
   instrument.chipwaveselected = instrument.chipWave
   instrument.preset = instrument.type;
   instrument.wavenotfound = null;
   doc.notifier.changed();
   if (!editor._instrumentName.value || editor._instrumentName.value.trim() === "") {
    const select = editor._chipWaveSelect;
    const selectedIndex = select.selectedIndex;
    const selectedOption = select.options[selectedIndex];
    
    if (selectedOption) {
     const selectedLabel = selectedOption.text;
     editor._instrumentName.value = selectedLabel;
     editor.doc.song.channels[editor.doc.channel].name = selectedLabel;
    }
   }
   this._didSomething();
  }
 }
}
    class ChangeChipWaveUseAdvancedLoopControls extends Change {
     constructor(doc, newValue) {
      super();
      const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
      if (instrument.isUsingAdvancedLoopControls != newValue) {
       instrument.isUsingAdvancedLoopControls = newValue;
       instrument.chipWaveLoopStart = 0;
       instrument.chipWaveLoopEnd = Config.chipWaves[instrument.chipWave].samples.length - 1;
       instrument.chipWaveLoopMode = 0;
       instrument.chipWavePlayBackwards = false;
       instrument.chipWaveStartOffset = 0;
       instrument.preset = instrument.type;
       doc.notifier.changed();
       this._didSomething();
      }
     }
    }
    class ChangeChipWaveLoopMode extends Change {
     constructor(doc, newValue) {
      super();
      const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
      if (instrument.chipWaveLoopMode != newValue) {
       instrument.isUsingAdvancedLoopControls = true;
       instrument.chipWaveLoopMode = newValue;
       instrument.preset = instrument.type;
       doc.notifier.changed();
       this._didSomething();
      }
     }
    }
    class ChangeChipWaveLoopStart extends Change {
     constructor(doc, newValue) {
      super();
      const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
      if (instrument.chipWaveLoopStart != newValue) {
       instrument.isUsingAdvancedLoopControls = true;
       instrument.chipWaveLoopStart = newValue;
       instrument.preset = instrument.type;
       doc.notifier.changed();
       this._didSomething();
      }
     }
    }
    class ChangeChipWaveLoopEnd extends Change {
     constructor(doc, newValue) {
      super();
      const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
      if (instrument.chipWaveLoopEnd != newValue) {
       instrument.isUsingAdvancedLoopControls = true;
       instrument.chipWaveLoopEnd = newValue;
       instrument.chipWaveLoopStart = Math.max(0, Math.min(newValue - 1, instrument.chipWaveLoopStart));
       instrument.preset = instrument.type;
       doc.notifier.changed();
       this._didSomething();
      }
     }
    }
    class ChangeChipWaveStartOffset extends Change {
     constructor(doc, newValue) {
      super();
      const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
      if (instrument.chipWaveStartOffset != newValue) {
       instrument.isUsingAdvancedLoopControls = true;
       instrument.chipWaveStartOffset = newValue;
       instrument.preset = instrument.type;
       doc.notifier.changed();
       this._didSomething();
      }
     }
    }
    class ChangeChipWavePlayBackwards extends Change {
     constructor(doc, newValue) {
      super();
      const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
      if (instrument.chipWavePlayBackwards != newValue) {
       instrument.isUsingAdvancedLoopControls = true;
       instrument.chipWavePlayBackwards = newValue;
       instrument.preset = instrument.type;
       doc.notifier.changed();
       this._didSomething();
      }
     }
    }
    class ChangeNoiseWave extends Change {
        constructor(doc, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            if (instrument.chipNoise != newValue) {
                instrument.chipNoise = newValue;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeAddEnvelope extends Change {
        constructor(doc) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.addEnvelope(0, 0, 0, true, 0, instrument.isNoiseInstrument ? Config.drumCount : Config.maxPitch, false, 1, 0);
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeRemoveEnvelope extends Change {
        constructor(doc, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.envelopeCount--;
            for (let i = index; i < instrument.envelopeCount; i++) {
                instrument.envelopes[i].target = instrument.envelopes[i + 1].target;
                instrument.envelopes[i].index = instrument.envelopes[i + 1].index;
                instrument.envelopes[i].envelope = instrument.envelopes[i + 1].envelope;
                instrument.envelopes[i].pitchEnvelopeStart = instrument.envelopes[i + 1].pitchEnvelopeStart;
                instrument.envelopes[i].pitchEnvelopeEnd = instrument.envelopes[i + 1].pitchEnvelopeEnd;
                instrument.envelopes[i].inverse = instrument.envelopes[i + 1].inverse;
                instrument.envelopes[i].perEnvelopeSpeed = instrument.envelopes[i + 1].perEnvelopeSpeed;
                instrument.envelopes[i].perEnvelopeLowerBound = instrument.envelopes[i + 1].perEnvelopeLowerBound;
                instrument.envelopes[i].perEnvelopeUpperBound = instrument.envelopes[i + 1].perEnvelopeUpperBound;
                instrument.envelopes[i].steps = instrument.envelopes[i + 1].steps;
                instrument.envelopes[i].seed = instrument.envelopes[i + 1].seed;
                instrument.envelopes[i].waveform = instrument.envelopes[i + 1].waveform;
                instrument.envelopes[i].discrete = instrument.envelopes[i + 1].discrete;
            }
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeSetEnvelopeTarget extends Change {
        constructor(doc, envelopeIndex, target, targetIndex) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldTarget = instrument.envelopes[envelopeIndex].target;
            const oldIndex = instrument.envelopes[envelopeIndex].index;
            if (oldTarget != target || oldIndex != targetIndex) {
                instrument.envelopes[envelopeIndex].target = target;
                instrument.envelopes[envelopeIndex].index = targetIndex;
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeSetEnvelopeType extends Change {
        constructor(doc, envelopeIndex, newValue) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.envelopes[envelopeIndex].envelope;
            if (oldValue != newValue) {
                instrument.envelopes[envelopeIndex].envelope = newValue;
                instrument.preset = instrument.type;
                if (oldValue == Config.newEnvelopes.dictionary["none"].index) {
                    instrument.envelopes[envelopeIndex].perEnvelopeSpeed = Config.newEnvelopes[newValue].speed;
                }
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEnvelopePitchStart extends Change {
        constructor(doc, startNote, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldStartNote = instrument.envelopes[index].pitchEnvelopeStart;
            instrument.envelopes[index].pitchEnvelopeStart = startNote;
            if (oldStartNote != startNote) {
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEnvelopePitchEnd extends Change {
        constructor(doc, endNote, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldEndNote = instrument.envelopes[index].pitchEnvelopeEnd;
            instrument.envelopes[index].pitchEnvelopeEnd = endNote;
            if (oldEndNote != endNote) {
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeEnvelopeInverse extends Change {
        constructor(doc, value, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.envelopes[index].inverse;
            instrument.envelopes[index].inverse = value;
            if (oldValue != value) {
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeDiscreteEnvelope extends Change {
        constructor(doc, newValue, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldValue = instrument.envelopes[index].discrete;
            doc.notifier.changed();
            if (oldValue != newValue) {
                instrument.envelopes[index].discrete = newValue;
                instrument.preset = instrument.type;
                this._didSomething();
            }
        }
    }
    class ChangePerEnvelopeSpeed extends IndexableChange {
        constructor(doc, oldSpeed, speed, index) {
            super(index, doc);
            this._instrument.envelopes[index].perEnvelopeSpeed = speed;
            doc.synth.unsetMod(Config.modulators.dictionary["individual envelope speed"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldSpeed != speed)
                this._didSomething();
        }
    }
    class ChangeEnvelopeLowerBound extends IndexableChange {
        constructor(doc, oldBound, bound, index) {
            super(index, doc);
            bound = bound > Config.perEnvelopeBoundMax ? Config.perEnvelopeBoundMax : bound < Config.perEnvelopeBoundMin ? Config.perEnvelopeBoundMin : Math.round(bound * 10) != bound * 10 ? Config.perEnvelopeBoundMin : bound;
            this._instrument.envelopes[index].perEnvelopeLowerBound = bound;
            doc.synth.unsetMod(Config.modulators.dictionary["individual envelope lower bound"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldBound != bound)
                this._didSomething();
        }
    }
    class ChangeEnvelopeUpperBound extends IndexableChange {
        constructor(doc, oldBound, bound, index) {
            super(index, doc);
            bound = bound > Config.perEnvelopeBoundMax ? Config.perEnvelopeBoundMax : bound < Config.perEnvelopeBoundMin ? Config.perEnvelopeBoundMin : Math.round(bound * 10) != bound * 10 ? Config.perEnvelopeBoundMin : bound;
            this._instrument.envelopes[index].perEnvelopeUpperBound = bound;
            doc.synth.unsetMod(Config.modulators.dictionary["individual envelope upper bound"].index, doc.channel, doc.getCurrentInstrument());
            doc.notifier.changed();
            if (oldBound != bound)
                this._didSomething();
        }
    }
    class ChangeRandomEnvelopeSteps extends Change {
        constructor(doc, steps, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldSteps = instrument.envelopes[index].steps;
            steps = steps > Config.randomEnvelopeStepsMax ? Config.randomEnvelopeStepsMax : steps < 1 ? 2 : Math.floor(steps);
            instrument.envelopes[index].steps = steps;
            if (oldSteps != steps) {
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class ChangeRandomEnvelopeSeed extends Change {
        constructor(doc, seed, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldSeed = instrument.envelopes[index].seed;
            seed = seed > Config.randomEnvelopeSeedMax ? Config.randomEnvelopeSeedMax : seed < 1 ? 2 : Math.floor(seed);
            instrument.envelopes[index].seed = seed;
            if (oldSeed != seed) {
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }
    class PasteEnvelope extends Change {
        constructor(doc, envelope, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            instrument.envelopes[index].fromJsonObject(envelope, "slarmoosbox");
            instrument.preset = instrument.type;
            doc.notifier.changed();
            this._didSomething();
        }
    }
    class ChangeSetEnvelopeWaveform extends Change {
        constructor(doc, waveform, index) {
            super();
            const instrument = doc.song.channels[doc.channel].instruments[doc.getCurrentInstrument()];
            const oldWaveform = instrument.envelopes[index].waveform;
            waveform = parseInt(waveform + "");
            instrument.envelopes[index].waveform = waveform;
            if (oldWaveform != waveform) {
                instrument.preset = instrument.type;
                doc.notifier.changed();
                this._didSomething();
            }
        }
    }

    class Piano {
        forceRender() {
            this._renderedScale = -1;
            this._documentChanged();
        }
        static getBassCutoffPitch(doc) {
            const octaveOffset = doc.getBaseVisibleOctave(doc.channel);
            return octaveOffset * Config.pitchesPerOctave + Math.floor(doc.getVisiblePitchCount() / (Config.pitchesPerOctave * 2)) * Config.pitchesPerOctave;
        }
        constructor(_doc) {
            this._doc = _doc;
            this._pianoContainer = HTML.div({ style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;" });
            this._drumContainer = HTML.div({ style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;" });
            this._modContainer = HTML.div({ style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;" });
            this._preview = HTML.div({ style: `width: 100%; height: 40px; border: 2px solid ${ColorConfig.primaryText}; position: absolute; box-sizing: border-box; pointer-events: none;` });
            this.container = HTML.div({ style: "width: 32px; height: 100%; overflow: hidden; position: relative; flex-shrink: 0; touch-action: none;" }, this._pianoContainer, this._drumContainer, this._modContainer, this._preview);
            this._editorHeight = 481;
            this._pianoKeys = [];
            this._pianoLabels = [];
            this._modFirstLabels = [];
            this._modSecondLabels = [];
            this._modCountLabels = [];
            this._modCountRects = [];
            this._mouseY = 0;
            this._mouseDown = false;
            this._mouseOver = false;
            this._playedPitch = -1;
            this._renderedScale = -1;
            this._renderedDrums = false;
            this._renderedMod = false;
            this._renderedKey = -1;
            this._renderedPitchCount = -1;
            this._renderedLiveInputPitches = [];
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._updatePreview();
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
                this._updatePreview();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._doc.synth.maintainLiveInput();
                this._mouseDown = true;
                const boundingRect = this.container.getBoundingClientRect();
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._updateCursorPitch();
                this._playLiveInput();
                this._updatePreview();
            };
            this._whenMouseMoved = (event) => {
                if (this._mouseDown || this._mouseOver)
                    this._doc.synth.maintainLiveInput();
                const boundingRect = this.container.getBoundingClientRect();
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._updateCursorPitch();
                if (this._mouseDown)
                    this._playLiveInput();
                this._updatePreview();
            };
            this._whenMouseReleased = (event) => {
                if (this._mouseDown)
                    this._releaseLiveInput();
                this._mouseDown = false;
                this._updatePreview();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._doc.synth.maintainLiveInput();
                this._mouseDown = true;
                const boundingRect = this.container.getBoundingClientRect();
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._updateCursorPitch();
                this._playLiveInput();
            };
            this._whenTouchMoved = (event) => {
                event.preventDefault();
                this._doc.synth.maintainLiveInput();
                const boundingRect = this.container.getBoundingClientRect();
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._updateCursorPitch();
                if (this._mouseDown)
                    this._playLiveInput();
            };
            this._whenTouchReleased = (event) => {
                event.preventDefault();
                this._mouseDown = false;
                this._releaseLiveInput();
            };
            this._onAnimationFrame = () => {
                window.requestAnimationFrame(this._onAnimationFrame);
                let liveInputChanged = false;
                let liveInputPitchCount = !this._doc.performance.pitchesAreTemporary() ? this._doc.synth.liveInputPitches.length : 0;
                liveInputPitchCount += !this._doc.performance.bassPitchesAreTemporary() ? this._doc.synth.liveBassInputPitches.length : 0;
                if (this._renderedLiveInputPitches.length != liveInputPitchCount) {
                    liveInputChanged = true;
                }
                for (let i = 0; i < this._doc.synth.liveInputPitches.length; i++) {
                    if (this._renderedLiveInputPitches[i] != this._doc.synth.liveInputPitches[i]) {
                        this._renderedLiveInputPitches[i] = this._doc.synth.liveInputPitches[i];
                        liveInputChanged = true;
                    }
                }
                for (let i = this._doc.synth.liveInputPitches.length; i < liveInputPitchCount; i++) {
                    if (this._renderedLiveInputPitches[i] != this._doc.synth.liveBassInputPitches[i - this._doc.synth.liveInputPitches.length]) {
                        this._renderedLiveInputPitches[i] = this._doc.synth.liveBassInputPitches[i - this._doc.synth.liveInputPitches.length];
                        liveInputChanged = true;
                    }
                }
                this._renderedLiveInputPitches.length = liveInputPitchCount;
                if (liveInputChanged) {
                    this._updatePreview();
                }
            };
            this._documentChanged = () => {
                const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
                const isMod = this._doc.song.getChannelIsMod(this._doc.channel);
                this._pitchCount = isMod ? Config.modCount : (isDrum ? Config.drumCount : this._doc.getVisiblePitchCount());
                this._pitchHeight = this._editorHeight / this._pitchCount;
                this._updateCursorPitch();
                if (this._mouseDown)
                    this._playLiveInput();
                if (!this._doc.prefs.showLetters)
                    return;
                if ((this._renderedScale == this._doc.song.scale && this._doc.song.scale != Config.scales.dictionary["Custom"].index) && this._renderedKey == this._doc.song.key && this._renderedDrums == isDrum && this._renderedMod == isMod && this._renderedPitchCount == this._pitchCount)
                    return;
                this._renderedScale = this._doc.song.scale;
                this._renderedKey = this._doc.song.key;
                this._renderedDrums = isDrum;
                this._renderedMod = isMod;
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                this._pianoContainer.style.display = (isDrum || isMod) ? "none" : "flex";
                this._drumContainer.style.display = isDrum ? "flex" : "none";
                this._modContainer.style.display = isMod ? "flex" : "none";
                if (!isDrum && !isMod) {
                    if (this._renderedPitchCount != this._pitchCount) {
                        this._pianoContainer.innerHTML = "";
                        for (let i = 0; i < this._pitchCount; i++) {
                            const pianoLabel = HTML.div({ class: "piano-label", style: "font-weight: bold; -webkit-text-stroke-width: 0; font-size: 11px; font-family: sans-serif; position: absolute; padding-left: 15px; white-space: nowrap;" });
                            const pianoKey = HTML.div({ class: "piano-button", style: "background: gray;" }, pianoLabel);
                            this._pianoContainer.appendChild(pianoKey)
                            this._pianoLabels[i] = pianoLabel;
                            this._pianoKeys[i] = pianoKey;
                        }
                        this._pianoLabels.length = this._pitchCount;
                        this._pianoKeys.length = this._pitchCount;
                        this._renderedPitchCount = this._pitchCount;
                    }
                    for (let j = 0; j < this._pitchCount; j++) {
                        const pitchNameIndex = (j + Config.keys[this._doc.song.key].basePitch) % Config.pitchesPerOctave;
                        const isWhiteKey = Config.keys[pitchNameIndex].isWhiteKey;
                        this._pianoKeys[j].style.background = isWhiteKey ? ColorConfig.whitePianoKey : ColorConfig.blackPianoKey;
                        let scale = this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
                        if (!scale[j % Config.pitchesPerOctave]) {
                            this._pianoKeys[j].classList.add("disabled");
                            this._pianoLabels[j].style.display = "none";
                        }
                        else {
                            this._pianoKeys[j].classList.remove("disabled");
                            this._pianoKeys[j].classList.remove("blackkey");
                            if (!Config.keys[pitchNameIndex].isWhiteKey) {
                            	this._pianoKeys[j].classList.add("blackkey");
                            }
                            this._pianoLabels[j].style.display = "";
                            const label = this._pianoLabels[j];
                            if ((j % 12) == 0) {
                                label.style.transform = "translate(-5px, 0px)";
                            }
                            else {
                                label.style.transform = "translate(0px, 0px)";
                            }
                            label.style.color = Config.keys[pitchNameIndex].isWhiteKey ? ColorConfig.whitePianoKeyText : ColorConfig.blackPianoKeyText;
                            label.textContent = Piano.getPitchName(pitchNameIndex, j, this._doc.getBaseVisibleOctave(this._doc.channel) + this._doc.song.octave);
                            this._pianoKeys[j].classList.add("PianoKey-"+pitchNameIndex);
                            this._pianoKeys[j].classList.add("PianoOctave-"+this._doc.getBaseVisibleOctave(this._doc.channel));
                        }
                    }
                }
                else if (isMod) {
                    let firstRow = "";
                    let secondRow = "";
                    let useFirstColor = ColorConfig.modLabelPrimaryText;
                    let useSecondColor = ColorConfig.modLabelSecondaryText;
                    for (let j = 0; j < Config.modCount; j++) {
                        let usingSecondRow = true;
                        let usingMod = true;
                        let instrumentVal = instrument.modInstruments[Config.modCount - j - 1] + 1;
                        let channelVal = instrument.modChannels[Config.modCount - j - 1] + 1;
                        let modulator = instrument.modulators[Config.modCount - j - 1];
                        let status = 1 + +(channelVal - 1 >= this._doc.song.pitchChannelCount);
                        if (instrument.modChannels[Config.modCount - j - 1] == -2)
                            status = 0;
                        else if (instrument.modChannels[Config.modCount - j - 1] == -1)
                            status = 3;
                        let instrumentsLength = this._doc.song.channels[Math.max(0, channelVal - 1)].instruments.length;
                        switch (status) {
                            case 0:
                                firstRow = "Mod";
                                usingSecondRow = false;
                                useSecondColor = ColorConfig.modLabelSecondaryText;
                                usingMod = false;
                                break;
                            case 1:
                                if (this._doc.song.channels[channelVal - 1].name == "") {
                                    if (instrumentsLength > 1) {
                                        if (channelVal >= 10 || instrumentVal >= 10) {
                                            firstRow = "P" + channelVal;
                                            if (instrumentVal - 1 == instrumentsLength) {
                                                firstRow += " All";
                                            }
                                            else if (instrumentVal - 1 > instrumentsLength) {
                                                firstRow += " Act";
                                            }
                                            else {
                                                firstRow += " I" + instrumentVal;
                                            }
                                        }
                                        else {
                                            firstRow = "Pitch" + channelVal;
                                            if (instrumentVal - 1 == instrumentsLength) {
                                                firstRow += " All";
                                            }
                                            else if (instrumentVal - 1 > instrumentsLength) {
                                                firstRow += " Act";
                                            }
                                            else {
                                                firstRow += " Ins" + instrumentVal;
                                            }
                                        }
                                    }
                                    else {
                                        firstRow = "Pitch " + channelVal;
                                    }
                                }
                                else {
                                    let insText;
                                    if (instrumentVal - 1 == instrumentsLength) {
                                        insText = " All";
                                    }
                                    else if (instrumentVal - 1 > instrumentsLength) {
                                        insText = " Act";
                                    }
                                    else {
                                        insText = " I" + instrumentVal;
                                    }
                                    if (instrumentsLength > 1) {
                                        firstRow = "P" + channelVal + " " + this._doc.song.channels[channelVal - 1].name + insText;
                                    }
                                    else {
                                        firstRow = "P" + channelVal + " " + this._doc.song.channels[channelVal - 1].name;
                                    }
                                }
                                break;
                            case 2:
                                const absoluteChannelVal = instrument.modChannels[Config.modCount - j - 1];
                                const relativeChannelVal = absoluteChannelVal - this._doc.song.pitchChannelCount;
                                if (this._doc.song.channels[absoluteChannelVal].name == "") {
                                    if (instrumentsLength > 1) {
                                        if ((relativeChannelVal + 1) >= 10 || instrumentVal >= 10) {
                                            firstRow = "N" + (relativeChannelVal + 1);
                                            if (instrumentVal - 1 == instrumentsLength) {
                                                firstRow += " All";
                                            }
                                            else if (instrumentVal - 1 > instrumentsLength) {
                                                firstRow += " Act";
                                            }
                                            else {
                                                firstRow += " I" + instrumentVal;
                                            }
                                        }
                                        else {
                                            firstRow = "Noise" + (relativeChannelVal + 1);
                                            if (instrumentVal - 1 == instrumentsLength) {
                                                firstRow += " All";
                                            }
                                            else if (instrumentVal - 1 > instrumentsLength) {
                                                firstRow += " Act";
                                            }
                                            else {
                                                firstRow += " Ins" + instrumentVal;
                                            }
                                        }
                                    }
                                    else {
                                        firstRow = "Noise " + (relativeChannelVal + 1);
                                    }
                                }
                                else {
                                    if (instrumentsLength > 1) {
                                        let insText;
                                        if (instrumentVal - 1 == instrumentsLength) {
                                            insText = " All";
                                        }
                                        else if (instrumentVal - 1 > instrumentsLength) {
                                            insText = " Act";
                                        }
                                        else {
                                            insText = " I" + instrumentVal;
                                        }
                                        firstRow = "N" + (relativeChannelVal + 1) + " " + this._doc.song.channels[absoluteChannelVal].name + insText;
                                    }
                                    else {
                                        firstRow = "N" + (relativeChannelVal + 1) + " " + this._doc.song.channels[absoluteChannelVal].name;
                                    }
                                }
                                break;
                            case 3:
                                firstRow = "Song";
                                break;
                        }
                        if (usingSecondRow) {
                            secondRow = Config.modulators[modulator].pianoName;
                            if (modulator == Config.modulators.dictionary["none"].index) {
                                useSecondColor = ColorConfig.modLabelSecondaryText;
                                usingMod = false;
                            }
                            else if (modulator == Config.modulators.dictionary["eq filter"].index || modulator == Config.modulators.dictionary["note filter"].index || modulator == Config.modulators.dictionary["song eq"].index) {
                                var text = " Morph";
                                var filterVal = instrument.modFilterTypes[Config.modCount - j - 1];
                                if (filterVal > 0 && (filterVal % 2)) {
                                    text = " Dot" + Math.ceil(filterVal / 2) + "X";
                                }
                                else if (filterVal > 0) {
                                    text = " Dot" + Math.ceil(filterVal / 2) + "Y";
                                }
                                secondRow += text;
                            }
                        }
                        const firstLabel = this._modFirstLabels[j];
                        const secondLabel = this._modSecondLabels[j];
                        const modCountLabel = this._modCountLabels[j];
                        const modCountRect = this._modCountRects[j];
                        firstLabel.style.fill = useFirstColor;
                        firstLabel.textContent = firstRow;
                        secondLabel.style.fill = useSecondColor;
                        secondLabel.textContent = usingSecondRow ? secondRow : "Not set";
                        modCountLabel.textContent = "" + (Config.modCount - j);
                        modCountRect.style.fill = usingMod ? ColorConfig.indicatorPrimary : ColorConfig.modLabelSecondaryText;
                        if (this._doc.song.channels[Math.max(0, instrument.modChannels[Config.modCount - j - 1])].name != "") {
                            let scaleFactor = "1";
                            let height = firstLabel.parentElement.parentElement.getBoundingClientRect().height;
                            let length = firstLabel.getComputedTextLength();
                            let squeeze = 0;
                            if (length > height - 8) {
                                scaleFactor = "0.65";
                                squeeze = 2;
                            }
                            else if (length > height - 24) {
                                scaleFactor = "0.8";
                                squeeze = 1;
                            }
                            firstLabel.style.transform = "rotate(-90deg) translate(" + (-20 - squeeze - Math.round(Math.max(0, (height - 80) / 2))) + "px, 39px) scale(" + scaleFactor + ", 1)";
                            while (scaleFactor == "0.65" && firstLabel.getComputedTextLength() > height + 8) {
                                var offset = 4 + (instrumentVal >= 10 ? 1 : 0);
                                firstLabel.textContent = firstLabel.textContent.substr(0, firstLabel.textContent.length - offset) + firstLabel.textContent.substr(firstLabel.textContent.length - offset + 1);
                            }
                        }
                        else {
                            let height = firstLabel.parentElement.parentElement.getBoundingClientRect().height;
                            firstLabel.style.transform = "rotate(-90deg) translate(" + (-20 - Math.round(Math.max(0, (height - 80) / 2))) + "px, 39px) scale(1, 1)";
                        }
                    }
                }
                this._updatePreview();
            };
            for (let i = 0; i < Config.drumCount; i++) {
                const scale = (1.0 - (i / Config.drumCount) * 0.35) * 100;
                this._drumContainer.appendChild(HTML.div({ class: "drum-button", style: `background-size: ${scale}% ${scale}%;` }));
            }
            for (let i = 0; i < Config.modCount; i++) {
                const firstRowText = SVG.text({ class: "modulator-label", "text-anchor": "left", fill: ColorConfig.modLabelPrimaryText, style: "font-weight: bold; align-self: flex-start; transform-origin: center; transform: rotate(-90deg) translate(-19px, 39px); font-size: 11px; font-family: sans-serif;" });
                const secondRowText = SVG.text({ class: "modulator-label", "text-anchor": "left", fill: ColorConfig.modLabelPrimaryText, style: "font-weight: bold; align-self: flex-end; transform-origin: center; transform: rotate(-90deg) translate(-26px, 42px); font-size: 11px; font-family: sans-serif;" });
                const countText = SVG.text({ class: "modulator-inverse-label", fill: ColorConfig.modLabelPrimary, style: "font-weight: bold; align-self: flex-start; transform-origin: center; transform: rotate(-90deg) translate(4px, 13px); font-size: 11px; font-family: sans-serif;" });
                const countRect = SVG.rect({ width: "12px", height: "9px", fill: ColorConfig.indicatorPrimary, style: "pointer-events: none; transform: translate(4px, 4px);" });
                const firstRowSVG = SVG.svg({ viewBox: "0 0 16 66", width: "16px", style: "pointer-events: none; flex-grow: 1;" }, [
                    firstRowText,
                ]);
                const countSVG = SVG.svg({ viewBox: "0 0 16 14", width: "16px", style: "pointer-events: none;" }, [
                    countRect,
                    countText,
                ]);
                const secondRowSVG = SVG.svg({ viewBox: "0 0 16 80", width: "16px", style: "pointer-events: none;" }, [
                    secondRowText,
                ]);
                const flexRow1 = HTML.div({ style: "display: flex; flex-direction: column; justify-content: space-between; pointer-events: none;" }, [
                    countSVG,
                    firstRowSVG,
                ]);
                const flexRow2 = HTML.div({ style: "display: flex; flex-direction: column-reverse; justify-content: space-between; pointer-events: none;" }, [
                    secondRowSVG,
                ]);
                const flexContainer = HTML.div({ style: "display: flex; flex-direction: row; justify-content: space-between; padding: 0px; width: 32px; height: 100%; overflow: hidden; pointer-events: none;" }, [
                    flexRow1,
                    flexRow2,
                ]);
                const modKey = HTML.div({ class: "modulator-button", style: "background: " + ColorConfig.modLabelPrimary + ";" }, flexContainer);
                this._modContainer.appendChild(modKey);
                this._modFirstLabels.push(firstRowText);
                this._modSecondLabels.push(secondRowText);
                this._modCountLabels.push(countText);
                this._modCountRects.push(countRect);
            }
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenMouseReleased);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenTouchReleased);
            this.container.addEventListener("touchcancel", this._whenTouchReleased);
            this._doc.notifier.watch(this._documentChanged);
            this._documentChanged();
            window.requestAnimationFrame(this._onAnimationFrame);
        }
        _updateCursorPitch() {
            const scale = this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
            const mousePitch = Math.max(0, Math.min(this._pitchCount - 1, this._pitchCount - (this._mouseY / this._pitchHeight)));
            if (scale[Math.floor(mousePitch) % Config.pitchesPerOctave] || this._doc.song.getChannelIsNoise(this._doc.channel)) {
                this._cursorPitch = Math.floor(mousePitch);
            }
            else {
                let topPitch = Math.floor(mousePitch) + 1;
                let bottomPitch = Math.floor(mousePitch) - 1;
                while (!scale[topPitch % Config.pitchesPerOctave]) {
                    topPitch++;
                }
                while (!scale[(bottomPitch) % Config.pitchesPerOctave]) {
                    bottomPitch--;
                }
                let topRange = topPitch;
                let bottomRange = bottomPitch + 1;
                if (topPitch % Config.pitchesPerOctave == 0 || topPitch % Config.pitchesPerOctave == 7) {
                    topRange -= 0.5;
                }
                if (bottomPitch % Config.pitchesPerOctave == 0 || bottomPitch % Config.pitchesPerOctave == 7) {
                    bottomRange += 0.5;
                }
                this._cursorPitch = mousePitch - bottomRange > topRange - mousePitch ? topPitch : bottomPitch;
            }
        }
        _playLiveInput() {
            const octaveOffset = this._doc.getBaseVisibleOctave(this._doc.channel) * Config.pitchesPerOctave;
            const currentPitch = this._cursorPitch + octaveOffset;
            if (this._playedPitch == currentPitch)
                return;
            this._doc.performance.removePerformedPitch(this._playedPitch);
            this._playedPitch = currentPitch;
            this._doc.performance.addPerformedPitch(currentPitch);
        }
        _releaseLiveInput() {
            this._doc.performance.removePerformedPitch(this._playedPitch);
            this._playedPitch = -1;
        }
        _updatePreview() {
            this._preview.style.visibility = (!this._mouseOver || this._mouseDown) ? "hidden" : "visible";
            if (this._mouseOver && !this._mouseDown) {
                const boundingRect = this.container.getBoundingClientRect();
                const pitchHeight = this._pitchHeight / (this._editorHeight / (boundingRect.bottom - boundingRect.top));
                this._preview.style.left = "0px";
                this._preview.style.top = pitchHeight * (this._pitchCount - this._cursorPitch - 1) + "px";
                this._preview.style.height = pitchHeight + "px";
            }
            const octaveOffset = this._doc.getBaseVisibleOctave(this._doc.channel) * Config.pitchesPerOctave;
            const container = this._doc.song.getChannelIsNoise(this._doc.channel) ? this._drumContainer : this._pianoContainer;
            const children = container.children;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (this._renderedLiveInputPitches.indexOf(i + octaveOffset) == -1) {
                    child.classList.remove("pressed");
                }
                else {
                    child.classList.add("pressed");
                }
            }
        }
        static getPitchName(pitchNameIndex, scaleIndex, baseVisibleOctave) {
            let text;
            if (Config.keys[pitchNameIndex].isWhiteKey) {
                text = Config.keys[pitchNameIndex].name;
            }
            else {
                const shiftDir = Config.blackKeyNameParents[scaleIndex % Config.pitchesPerOctave];
                text = Config.keys[(pitchNameIndex + Config.pitchesPerOctave + shiftDir) % Config.pitchesPerOctave].name;
                if (shiftDir == 1) {
                    text += "";
                }
                else if (shiftDir == -1) {
                    text += "";
                }
            }
            if (scaleIndex % 12 == 0) {
                text += Math.floor(scaleIndex / 12) + baseVisibleOctave;
            }
            return text;
        }
    }

    class SongPerformance {
        constructor(_doc) {
            this._doc = _doc;
            this._channelIsDrum = false;
            this._channelOctave = -1;
            this._songKey = -1;
            this._pitchesAreTemporary = false;
            this._bassPitchesAreTemporary = false;
            this._recentlyAddedPitches = [];
            this._recentlyAddedBassPitches = [];
            this._songLengthWhenRecordingStarted = -1;
            this._playheadPart = -1;
            this._bassPlayheadPart = -1;
            this._playheadPattern = null;
            this._bassPlayheadPattern = null;
            this._pitchesChanged = false;
            this._bassPitchesChanged = false;
            this._lastNote = null;
            this._lastBassNote = null;
            this._recordingChange = null;
this.isRecordingWhistle = this._doc.synth.isRecordingWhistle ;
this.currNote = "";
this._onAnimationFrame = () => {
	this.isRecordingWhistle = this._doc.synth.isRecordingWhistle ;
	window.requestAnimationFrame(this._onAnimationFrame);
	if (this._doc.synth.recording && !this.isRecordingWhistle) {
		let dirty = this._updateRecordedNotes(); 
		dirty = this._updateRecordedBassNotes() ? true : dirty;
		if (dirty) this._doc.notifier.notifyWatchers();
	}
};

            this._documentChanged = () => {
                const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
                const octave = this._doc.song.channels[this._doc.channel].octave;
                if (this._doc.synth.liveInputChannel != this._doc.channel || this._doc.synth.liveBassInputChannel != this._getBassOffsetChannel() || this._channelIsDrum != isDrum || this._channelOctave != octave || this._songKey != this._doc.song.key) {
                    this._doc.synth.liveInputChannel = this._doc.channel;
                    this._doc.synth.liveBassInputChannel = this._getBassOffsetChannel();
                    this._channelIsDrum = isDrum;
                    this._channelOctave = octave;
                    this._songKey = this._doc.song.key;
                    this.clearAllPitches();
                    this.clearAllBassPitches();
                }
                this._doc.synth.liveInputInstruments = this._doc.recentPatternInstruments[this._doc.channel];
                this._doc.synth.liveBassInputInstruments = this._doc.recentPatternInstruments[this._doc.synth.liveBassInputChannel];
            };
            this._doc.notifier.watch(this._documentChanged);
            this._documentChanged();
            window.requestAnimationFrame(this._onAnimationFrame);
        }
        play() {
            this._doc.synth.play();
            this._doc.synth.enableMetronome = false;
            this._doc.synth.countInMetronome = false;
            this._doc.synth.maintainLiveInput(); 
        }
        togglePerformedPitch(pitch) {
    if (pitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
        if (this._doc.synth.liveInputPitches.includes(pitch)) {
            this.removePerformedPitch(pitch);
            if (this._doc.synth.liveInputPitches.length === 0) this._pitchesAreTemporary = false;
        } else {
            this.addPerformedPitch(pitch);
        }
    } else {
        if (this._doc.synth.liveBassInputPitches.includes(pitch)) {
            this.removePerformedPitch(pitch);
            if (this._doc.synth.liveBassInputPitches.length === 0) this._bassPitchesAreTemporary = false;
        } else {
            this.addPerformedPitch(pitch);
        }
    }
}

        pause() {
            this.clearAllPitches();
            this.clearAllBassPitches();
            if (this._recordingChange != null) {
                if (this._doc.song.barCount > this._songLengthWhenRecordingStarted && !this._lastBarHasPatterns()) {
                    new ChangeDeleteBars(this._doc, this._doc.song.barCount - 1, 1);
                    new ChangeChannelBar(this._doc, this._doc.channel, this._doc.song.barCount - 1);
                }
                if (!this._recordingChange.isNoop()) {
                    this._doc.record(this._recordingChange);
                    this._recordingChange = null;
                }
                this._lastNote = null;
            }
            this._doc.synth.pause();
            this._doc.synth.resetEffects();
            this._doc.synth.enableMetronome = false;
            this._doc.synth.countInMetronome = false;
            if (this._doc.prefs.autoFollow) {
                this._doc.synth.goToBar(this._doc.bar);
            }
            this._doc.synth.snapToBar();
        } 
        
noteToMidi(note) {
	const notes = { C: 0, 'C#': 1, D: 2, 'D#': 3, E: 4, F: 5, 'F#': 6, G: 7, 'G#': 8, A: 9, 'A#': 10, B: 11 };
	const regex = /^([A-G]#?)(\d)$/;
	const match = note.match(regex);
	if (!match) return 60;
	const [, n, octave] = match;
	return notes[n] + ((parseInt(octave) + 1) * 12) - 12;
}
updatePerformedNote(note) {
	if (!note) {
		if (this._lastWhistlePitch !== null) {
			this.clearAllPitches();
			this._lastWhistlePitch = null;
			this._lastWhistlePitch = null;
		}
		return;
	}
	const midiPitch = this.noteToMidi(note);
	if (this._lastWhistlePitch !== midiPitch) {
		this.setTemporaryPitches([midiPitch], Number.MAX_SAFE_INTEGER);
		this._lastWhistlePitch = midiPitch;
	}
}
        
        record() {
            this._doc.synth.snapToBar();
            const playheadBar = Math.floor(this._doc.synth.playhead);
            if (playheadBar != this._doc.bar) {
                new ChangeChannelBar(this._doc, this._doc.channel, playheadBar);
            }
            if (this._pitchesAreTemporary) {
                this.clearAllPitches();
                this._pitchesAreTemporary = false;
            }
            if (this._bassPitchesAreTemporary) {
                this.clearAllBassPitches();
                this._bassPitchesAreTemporary = false;
            }
            this._doc.synth.enableMetronome = this._doc.prefs.metronomeWhileRecording;
            this._doc.synth.countInMetronome = this._doc.prefs.metronomeCountIn;
            this._doc.synth.startRecording();
            this._doc.synth.maintainLiveInput();
            this._songLengthWhenRecordingStarted = this._doc.song.barCount;
            this._playheadPart = this._getCurrentPlayheadPart();
            this._bassPlayheadPart = this._getCurrentPlayheadPart();
            this._playheadPattern = null;
            this._bassPlayheadPattern = null;
            this._pitchesChanged = false;
            this._bassPitchesChanged = false;
            this._lastNote = null;
            this._lastBassNote = null;
            this._recentlyAddedPitches.length = 0;
            this._recentlyAddedBassPitches.length = 0;
            this._recordingChange = new ChangeGroup();
            this._doc.setProspectiveChange(this._recordingChange);
        }
        abortRecording() {
            this._recordingChange = null;
            this.pause();
        }
        pitchesAreTemporary() {
            return this._pitchesAreTemporary;
        }
        bassPitchesAreTemporary() {
            return this._bassPitchesAreTemporary;
        }
        _getBassOffsetChannel() {
            if (this._doc.channel >= this._doc.song.pitchChannelCount)
                return this._doc.channel;
            return Math.max(0, Math.min(this._doc.song.pitchChannelCount - 1, this._doc.channel + this._doc.prefs.bassOffset));
        }
        _getMinDivision() {
            if (this._doc.prefs.snapRecordedNotesToRhythm) {
                return Config.partsPerBeat / Config.rhythms[this._doc.song.rhythm].stepsPerBeat;
            }
            else {
                return 1;
            }
        }
        _getCurrentPlayheadPart() {
            const currentPart = this._doc.synth.playhead * this._doc.song.beatsPerBar * Config.partsPerBeat;
            if (this._doc.prefs.snapRecordedNotesToRhythm) {
                const minDivision = this._getMinDivision();
                return Math.round(currentPart / minDivision) * minDivision;
            }
            return Math.round(currentPart);
        }
        _lastBarHasPatterns() {
            for (let channelIndex = 0; channelIndex < this._doc.song.getChannelCount(); channelIndex++) {
                if (this._doc.song.channels[channelIndex].bars[this._doc.song.barCount - 1] != 0)
                    return true;
            }
            return false;
        }
        _updateRecordedNotes() { 
            if (this._recordingChange == null)
                return false;
            if (!this._doc.lastChangeWas(this._recordingChange)) {
                this.abortRecording();
                return false;
            }
            if (this._doc.synth.countInMetronome) {
                this._recentlyAddedPitches.length = 0;
                this._pitchesChanged = false;
                return false;
            }
            const partsPerBar = this._doc.song.beatsPerBar * Config.partsPerBeat;
            const oldPart = this._playheadPart % partsPerBar;
            const oldBar = Math.floor(this._playheadPart / partsPerBar);
            const oldPlayheadPart = this._playheadPart;
            this._playheadPart = this._getCurrentPlayheadPart();
            const newPart = this._playheadPart % partsPerBar;
            const newBar = Math.floor(this._playheadPart / partsPerBar);
            if (oldPart == newPart && oldBar == newBar)
                return false;
            if (this._playheadPart < oldPlayheadPart) {
                this._lastNote = null;
                this._playheadPattern = null;
                return false;
            }
            let dirty = false;
            for (let bar = oldBar; bar <= newBar; bar++) {
                if (bar != oldBar) {
                    this._playheadPattern = null;
                }
                const startPart = (bar == oldBar) ? oldPart : 0;
                const endPart = (bar == newBar) ? newPart : partsPerBar;
                if (startPart == endPart)
                    break;
                if (this._lastNote != null && !this._pitchesChanged && startPart > 0 && this._doc.synth.liveInputPitches.length > 0) {
                    this._recordingChange.append(new ChangePinTime(this._doc, this._lastNote, 1, endPart, this._lastNote.continuesLastPattern));
                    this._doc.currentPatternIsDirty = true;
                }
                else {
                    if (this._lastNote != null) {
                        this._lastNote = null;
                    }
                    let noteStartPart = startPart;
                    let noteEndPart = endPart;
                    while (noteStartPart < endPart) {
                        let addedAlreadyReleasedPitch = false;
                        if (this._recentlyAddedPitches.length > 0 || this._doc.synth.liveInputPitches.length > 0) {
                            if (this._playheadPattern == null) {
                                this._doc.selection.erasePatternInBar(this._recordingChange, this._doc.synth.liveInputChannel, bar);
                                this._recordingChange.append(new ChangeEnsurePatternExists(this._doc, this._doc.synth.liveInputChannel, bar));
                                this._playheadPattern = this._doc.song.getPattern(this._doc.synth.liveInputChannel, bar);
                            }
                            if (this._playheadPattern == null)
                                throw new Error();
                            this._lastNote = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, this._doc.song.getChannelIsNoise(this._doc.synth.liveInputChannel));
                            this._lastNote.continuesLastPattern = (noteStartPart == 0 && !this._pitchesChanged);
                            this._lastNote.pitches.length = 0;
                            while (this._recentlyAddedPitches.length > 0) {
                                if (this._lastNote.pitches.length >= Config.maxChordSize)
                                    break;
                                const recentPitch = this._recentlyAddedPitches.shift();
                                if (this._doc.synth.liveInputPitches.indexOf(recentPitch) == -1) {
                                    this._lastNote.pitches.push(recentPitch);
                                    addedAlreadyReleasedPitch = true;
                                }
                            }
                            for (let i = 0; i < this._doc.synth.liveInputPitches.length; i++) {
                                if (this._lastNote.pitches.length >= Config.maxChordSize)
                                    break;
                                this._lastNote.pitches.push(this._doc.synth.liveInputPitches[i]);
                            }
                            this._recordingChange.append(new ChangeNoteAdded(this._doc, this._playheadPattern, this._lastNote, this._playheadPattern.notes.length));
                            if (addedAlreadyReleasedPitch) {
                                noteEndPart = noteStartPart + this._getMinDivision();
                                new ChangeNoteLength(this._doc, this._lastNote, this._lastNote.start, noteEndPart);
                                this._lastNote = null;
                            }
                            dirty = true;
                        }
                        this._pitchesChanged = addedAlreadyReleasedPitch;
                        noteStartPart = noteEndPart;
                        noteEndPart = endPart;
                    }
                }
                if (bar == this._doc.song.barCount - 1) {
                    if (this._lastBarHasPatterns()) {
                        new ChangeInsertBars(this._doc, this._doc.song.barCount, 1);
                        this._doc.bar--;
                        dirty = true;
                    }
                }
            }
            return dirty;
        }
        _updateRecordedBassNotes() {
            if (this._recordingChange == null)
                return false;
            if (!this._doc.lastChangeWas(this._recordingChange)) {
                this.abortRecording();
                return false;
            }
            if (this._doc.synth.countInMetronome) {
                this._recentlyAddedBassPitches.length = 0;
                this._bassPitchesChanged = false;
                return false;
            }
            const partsPerBar = this._doc.song.beatsPerBar * Config.partsPerBeat;
            const oldPart = this._bassPlayheadPart % partsPerBar;
            const oldBar = Math.floor(this._bassPlayheadPart / partsPerBar);
            const oldPlayheadPart = this._bassPlayheadPart;
            this._bassPlayheadPart = this._getCurrentPlayheadPart();
            const newPart = this._bassPlayheadPart % partsPerBar;
            const newBar = Math.floor(this._bassPlayheadPart / partsPerBar);
            if (oldPart == newPart && oldBar == newBar)
                return false;
            if (this._bassPlayheadPart < oldPlayheadPart) {
                this._lastBassNote = null;
                this._bassPlayheadPattern = null;
                return false;
            }
            let dirty = false;
            for (let bar = oldBar; bar <= newBar; bar++) {
                if (bar != oldBar) {
                    this._bassPlayheadPattern = null;
                }
                const startPart = (bar == oldBar) ? oldPart : 0;
                const endPart = (bar == newBar) ? newPart : partsPerBar;
                if (startPart == endPart)
                    break;
                if (this._lastBassNote != null && !this._bassPitchesChanged && startPart > 0 && this._doc.synth.liveBassInputPitches.length > 0) {
                    this._recordingChange.append(new ChangePinTime(this._doc, this._lastBassNote, 1, endPart, this._lastBassNote.continuesLastPattern));
                    this._doc.currentPatternIsDirty = true;
                }
                else {
                    if (this._lastBassNote != null) {
                        this._lastBassNote = null;
                    }
                    let noteStartPart = startPart;
                    let noteEndPart = endPart;
                    while (noteStartPart < endPart) {
                        let addedAlreadyReleasedPitch = false;
                        if (this._recentlyAddedBassPitches.length > 0 || this._doc.synth.liveBassInputPitches.length > 0) {
                            if (this._bassPlayheadPattern == null) {
                                this._doc.selection.erasePatternInBar(this._recordingChange, this._doc.synth.liveBassInputChannel, bar);
                                this._recordingChange.append(new ChangeEnsurePatternExists(this._doc, this._doc.synth.liveBassInputChannel, bar));
                                this._bassPlayheadPattern = this._doc.song.getPattern(this._doc.synth.liveBassInputChannel, bar);
                            }
                            if (this._bassPlayheadPattern == null)
                                throw new Error();
                            this._lastBassNote = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, this._doc.song.getChannelIsNoise(this._doc.synth.liveBassInputChannel));
                            this._lastBassNote.continuesLastPattern = (noteStartPart == 0 && !this._bassPitchesChanged);
                            this._lastBassNote.pitches.length = 0;
                            while (this._recentlyAddedBassPitches.length > 0) {
                                if (this._lastBassNote.pitches.length >= Config.maxChordSize)
                                    break;
                                const recentPitch = this._recentlyAddedBassPitches.shift();
                                if (this._doc.synth.liveBassInputPitches.indexOf(recentPitch) == -1) {
                                    this._lastBassNote.pitches.push(recentPitch);
                                    addedAlreadyReleasedPitch = true;
                                }
                            }
                            for (let i = 0; i < this._doc.synth.liveBassInputPitches.length; i++) {
                                if (this._lastBassNote.pitches.length >= Config.maxChordSize)
                                    break;
                                this._lastBassNote.pitches.push(this._doc.synth.liveBassInputPitches[i]);
                            }
                            this._recordingChange.append(new ChangeNoteAdded(this._doc, this._bassPlayheadPattern, this._lastBassNote, this._bassPlayheadPattern.notes.length));
                            if (addedAlreadyReleasedPitch) {
                                noteEndPart = noteStartPart + this._getMinDivision();
                                new ChangeNoteLength(this._doc, this._lastBassNote, this._lastBassNote.start, noteEndPart);
                                this._lastBassNote = null;
                            }
                            dirty = true;
                        }
                        this._bassPitchesChanged = addedAlreadyReleasedPitch;
                        noteStartPart = noteEndPart;
                        noteEndPart = endPart;
                    }
                }
                if (bar == this._doc.song.barCount - 1) {
                    if (this._lastBarHasPatterns()) {
                        new ChangeInsertBars(this._doc, this._doc.song.barCount, 1);
                        this._doc.bar--;
                        dirty = true;
                    }
                }
            }
            return dirty;
        }
        setTemporaryPitches(pitches, duration) {
            this._updateRecordedNotes();
            for (let i = 0; i < pitches.length; i++) {
                this._doc.synth.liveInputPitches[i] = pitches[i];
            }
            this._doc.synth.liveInputPitches.length = Math.min(pitches.length, Config.maxChordSize);
            this._doc.synth.liveInputDuration = duration;
            this._doc.synth.liveInputStarted = true;
            this._pitchesAreTemporary = true;
            this._pitchesChanged = true;
        }
        setTemporaryBassPitches(pitches, duration) {
            this._updateRecordedBassNotes();
            for (let i = 0; i < pitches.length; i++) {
                this._doc.synth.liveBassInputPitches[i] = pitches[i];
            }
            this._doc.synth.liveBassInputPitches.length = Math.min(pitches.length, Config.maxChordSize);
            this._doc.synth.liveBassInputDuration = duration;
            this._doc.synth.liveBassInputStarted = true;
            this._bassPitchesAreTemporary = true;
            this._bassPitchesChanged = true;
        }
addPerformedNote(note) {
	if (!note) return;
	
	const midiPitch = this.noteToMidi(note);
	this._doc.synth.maintainLiveInput();
	if (midiPitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
		this._updateRecordedNotes();
		if (this._pitchesAreTemporary) {
			this.clearAllPitches();
			this._lastWhistlePitch = null;
			this._pitchesAreTemporary = false;
		}
		if (this._doc.synth.liveInputPitches.indexOf(midiPitch) === -1) {
			this._doc.synth.liveInputPitches.push(midiPitch);
		}
		this._doc.synth.liveInputDuration = Number.MAX_SAFE_INTEGER;
		this._doc.synth.liveInputStarted = true;
		this._pitchesAreTemporary = true;
		this._pitchesChanged = true;
		if (this._recordingChange != null) {
			const recentIndex = this._recentlyAddedPitches.indexOf(midiPitch);
			if (recentIndex !== -1) this._recentlyAddedPitches.splice(recentIndex, 1);
			this._recentlyAddedPitches.push(midiPitch);
			while (this._recentlyAddedPitches.length > Config.maxChordSize * 4) this._recentlyAddedPitches.shift();
		}
	} else {
		this._updateRecordedBassNotes();
		if (this._bassPitchesAreTemporary) {
			this.clearAllBassPitches();
			this._bassPitchesAreTemporary = false;
		}
		if (this._doc.synth.liveBassInputPitches.indexOf(midiPitch) === -1) {
			this._doc.synth.liveBassInputPitches.push(midiPitch);
		}
		this._doc.synth.liveBassInputDuration = Number.MAX_SAFE_INTEGER;
		this._doc.synth.liveBassInputStarted = true;
		this._bassPitchesAreTemporary = true;
		this._bassPitchesChanged = true;
		if (this._recordingChange != null) {
			const recentIndex = this._recentlyAddedBassPitches.indexOf(midiPitch);
			if (recentIndex !== -1) this._recentlyAddedBassPitches.splice(recentIndex, 1);
			this._recentlyAddedBassPitches.push(midiPitch);
			while (this._recentlyAddedBassPitches.length > Config.maxChordSize * 4) this._recentlyAddedBassPitches.shift();
		}
	}
}
        addPerformedPitch(pitch) {
        	if (this.isRecordingWhistle) return;
            this._doc.synth.maintainLiveInput();
            if (pitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
                this._updateRecordedNotes();
                if (this._pitchesAreTemporary) {
                    this.clearAllPitches();
                    this._pitchesAreTemporary = false;
                }
                if (this._doc.prefs.ignorePerformedNotesNotInScale && !Config.scales[this._doc.song.scale].flags[pitch % Config.pitchesPerOctave]) {
                    return;
                }
                if (this._doc.synth.liveInputPitches.indexOf(pitch) == -1) {
                    this._doc.synth.liveInputPitches.push(pitch);
                    this._pitchesChanged = true;
                    while (this._doc.synth.liveInputPitches.length > Config.maxChordSize) {
                        this._doc.synth.liveInputPitches.shift();
                    }
                    this._doc.synth.liveInputDuration = Number.MAX_SAFE_INTEGER;
                    if (this._recordingChange != null) {
                        const recentIndex = this._recentlyAddedPitches.indexOf(pitch);
                        if (recentIndex != -1) {
                            this._recentlyAddedPitches.splice(recentIndex, 1);
                        }
                        this._recentlyAddedPitches.push(pitch);
                        while (this._recentlyAddedPitches.length > Config.maxChordSize * 4) {
                            this._recentlyAddedPitches.shift();
                        }
                    }
                }
            }
            else {
                this._updateRecordedBassNotes();
                if (this._bassPitchesAreTemporary) {
                    this.clearAllBassPitches();
                    this._bassPitchesAreTemporary = false;
                }
                if (this._doc.prefs.ignorePerformedNotesNotInScale && !Config.scales[this._doc.song.scale].flags[pitch % Config.pitchesPerOctave]) {
                    return;
                }
                if (this._doc.synth.liveBassInputPitches.indexOf(pitch) == -1) {
                    this._doc.synth.liveBassInputPitches.push(pitch);
                    this._bassPitchesChanged = true;
                    while (this._doc.synth.liveBassInputPitches.length > Config.maxChordSize) {
                        this._doc.synth.liveBassInputPitches.shift();
                    }
                    this._doc.synth.liveBassInputDuration = Number.MAX_SAFE_INTEGER;
                    if (this._recordingChange != null) {
                        const recentIndex = this._recentlyAddedPitches.indexOf(pitch);
                        if (recentIndex != -1) {
                            this._recentlyAddedBassPitches.splice(recentIndex, 1);
                        }
                        this._recentlyAddedBassPitches.push(pitch);
                        while (this._recentlyAddedBassPitches.length > Config.maxChordSize * 4) {
                            this._recentlyAddedBassPitches.shift();
                        }
                    }
                }
            }
        }
        removePerformedPitch(pitch) {
            if (pitch > Piano.getBassCutoffPitch(this._doc) || this._getBassOffsetChannel() == this._doc.channel) {
                this._updateRecordedNotes();
                for (let i = 0; i < this._doc.synth.liveInputPitches.length; i++) {
                    if (this._doc.synth.liveInputPitches[i] == pitch) {
                        this._doc.synth.liveInputPitches.splice(i, 1);
                        this._pitchesChanged = true;
                        i--;
                    }
                }
            }
            else {
                this._updateRecordedBassNotes();
                for (let i = 0; i < this._doc.synth.liveBassInputPitches.length; i++) {
                    if (this._doc.synth.liveBassInputPitches[i] == pitch) {
                        this._doc.synth.liveBassInputPitches.splice(i, 1);
                        this._bassPitchesChanged = true;
                        i--;
                    }
                }
            }
        }
        clearAllPitches() {
            this._updateRecordedNotes();
            this._doc.synth.liveInputPitches.length = 0;
            this._pitchesChanged = true;
        }
        clearAllBassPitches() {
            this._updateRecordedBassNotes();
            this._doc.synth.liveBassInputPitches.length = 0;
            this._bassPitchesChanged = true;
        }
    }

    class Selection {
        constructor(_doc) { 
            this._doc = _doc;
            this.micStream = null
            this.audioctx24 = new(window.AudioContext || window.webkitAudioContext)()
            this.boxSelectionX0 = 0;
            this.boxSelectionY0 = 0;
            this.boxSelectionX1 = 0;
            this.boxSelectionY1 = 0;
            this.digits = "";
            this.instrumentDigits = "";
            this.patternSelectionStart = 0;
            this.patternSelectionEnd = 0;
            this.patternSelectionActive = false;
            this._changeTranspose = null;
            this._changeTrack = null;
            this._changeInstrument = null;
            this._changeReorder = null;
        }
        toJSON() {
            return {
                "x0": this.boxSelectionX0,
                "x1": this.boxSelectionX1,
                "y0": this.boxSelectionY0,
                "y1": this.boxSelectionY1,
                "start": this.patternSelectionStart,
                "end": this.patternSelectionEnd,
            };
        }
        fromJSON(json) {
            if (json == null)
                return;
            this.boxSelectionX0 = +json["x0"];
            this.boxSelectionX1 = +json["x1"];
            this.boxSelectionY0 = +json["y0"];
            this.boxSelectionY1 = +json["y1"];
            this.patternSelectionStart = +json["start"];
            this.patternSelectionEnd = +json["end"];
            this.digits = "";
            this.instrumentDigits = "";
            this.patternSelectionActive = this.patternSelectionStart < this.patternSelectionEnd;
        }
        selectionUpdated() {
            this._doc.notifier.changed();
            this.digits = "";
            this.instrumentDigits = "";
        }
        get boxSelectionBar() {
            return Math.min(this.boxSelectionX0, this.boxSelectionX1);
        }
        get boxSelectionChannel() {
            return Math.min(this.boxSelectionY0, this.boxSelectionY1);
        }
        get boxSelectionWidth() {
            return Math.abs(this.boxSelectionX0 - this.boxSelectionX1) + 1;
        }
        get boxSelectionHeight() {
            return Math.abs(this.boxSelectionY0 - this.boxSelectionY1) + 1;
        }
        get boxSelectionActive() {
            return this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1;
        }
        scrollToSelectedPattern() {
            this._doc.barScrollPos = Math.min(this._doc.bar, Math.max(this._doc.bar - (this._doc.trackVisibleBars - 1), this._doc.barScrollPos));
            this._doc.channelScrollPos = Math.min(this._doc.channel, Math.max(this._doc.channel - (this._doc.trackVisibleChannels - 1), this._doc.channelScrollPos));
        }
        scrollToEndOfSelection() {
            this._doc.barScrollPos = Math.min(this.boxSelectionX1, Math.max(this.boxSelectionX1 - (this._doc.trackVisibleBars - 1), this._doc.barScrollPos));
            this._doc.channelScrollPos = Math.min(this.boxSelectionY1, Math.max(this.boxSelectionY1 - (this._doc.trackVisibleChannels - 1), this._doc.channelScrollPos));
        }
        setChannelBar(channelIndex, bar) {
            if (channelIndex == this._doc.channel && bar == this._doc.bar)
                return;
            const canReplaceLastChange = this._doc.lastChangeWas(this._changeTrack);
            this._changeTrack = new ChangeGroup();
            this._changeTrack.append(new ChangeChannelBar(this._doc, channelIndex, bar));
            const pattern = this._doc.getCurrentPattern(0);
            if (pattern != null) {
                if (pattern.instruments.indexOf(this._doc.viewedInstrument[this._doc.channel]) < 0) {
                    this._doc.viewedInstrument[this._doc.channel] = pattern.instruments[0];
                }
            }
            if (!this._doc.hasRedoHistory()) {
                this._doc.record(this._changeTrack, canReplaceLastChange);
            }
            this.selectionUpdated();
        }
        setPattern(pattern) {
        	
            this._doc.record(new ChangePatternNumbers(this._doc, pattern, this.boxSelectionBar, this.boxSelectionChannel, this.boxSelectionWidth, this.boxSelectionHeight));
        }
        nextDigit(digit, forInstrument, forRhythms) {
            if (forRhythms) {
                if (digit == "3") {
                    this._doc.record(new ChangeRhythm(this._doc, 0));
                }
                else if (digit == "4") {
                    this._doc.record(new ChangeRhythm(this._doc, 1));
                }
                else if (digit == "6") {
                    this._doc.record(new ChangeRhythm(this._doc, 2));
                }
                else if (digit == "8") {
                    this._doc.record(new ChangeRhythm(this._doc, 3));
                }
                else if (digit == "0" || digit == "1") {
                    this._doc.record(new ChangeRhythm(this._doc, 4));
                }
            }
            else if (forInstrument) {
                if (digit == "0")
                    digit = "10";
                this.instrumentDigits += digit;
                var parsed = parseInt(this.instrumentDigits);
                if (parsed != 0 && parsed <= this._doc.song.channels[this._doc.channel].instruments.length) {
                    this.selectInstrument(parsed - 1);
                    return;
                }
                this.instrumentDigits = digit;
                parsed = parseInt(this.instrumentDigits);
                if (parsed != 0 && parsed <= this._doc.song.channels[this._doc.channel].instruments.length) {
                    this.selectInstrument(parsed - 1);
                    return;
                }
                this.instrumentDigits = "";
            }
            else {
                this.digits += digit;
                let parsed = parseInt(this.digits);
                if (parsed <= this._doc.song.patternsPerChannel) {
                    this.setPattern(parsed);
                    return;
                }
                this.digits = digit;
                parsed = parseInt(this.digits);
                if (parsed <= this._doc.song.patternsPerChannel) {
                    this.setPattern(parsed);
                    return;
                }
                this.digits = "";
            }
        }
        setModChannel(mod, index) {
            this._doc.record(new ChangeModChannel(this._doc, mod, index));
        }
        setModInstrument(mod, instrument) {
            this._doc.record(new ChangeModInstrument(this._doc, mod, instrument));
        }
        setModSetting(mod, text) {
            this._doc.record(new ChangeModSetting(this._doc, mod, text));
        }
        setModFilter(mod, type) {
            this._doc.record(new ChangeModFilter(this._doc, mod, type));
        }
        setModEnvelope(mod, type) {
            this._doc.record(new ChangeModEnvelope(this._doc, mod, type));
        }
        insertBars() {
            this._doc.record(new ChangeInsertBars(this._doc, this.boxSelectionBar + this.boxSelectionWidth, this.boxSelectionWidth));
            const width = this.boxSelectionWidth;
            this.boxSelectionX0 += width;
            this.boxSelectionX1 += width;
        }
        insertChannel() {
            const group = new ChangeGroup();
            const insertIndex = this.boxSelectionChannel + this.boxSelectionHeight;
            const isNoise = this._doc.song.getChannelIsNoise(insertIndex - 1);
            const isMod = this._doc.song.getChannelIsMod(insertIndex - 1);
            group.append(new ChangeAddChannel(this._doc, insertIndex, isNoise, isMod));
            if (!group.isNoop()) {
                this.boxSelectionY0 = this.boxSelectionY1 = insertIndex;
                group.append(new ChangeChannelBar(this._doc, insertIndex, this._doc.bar));
                this._doc.record(group);
            }
        }
        deleteBars() {
            const group = new ChangeGroup();
            if (this._doc.selection.patternSelectionActive) {
                if (this.boxSelectionActive) {
                    group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, false));
                }
                for (const channelIndex of this._eachSelectedChannel()) {
                    for (const pattern of this._eachSelectedPattern(channelIndex)) {
                        group.append(new ChangeNoteTruncate(this._doc, pattern, this._doc.selection.patternSelectionStart, this._doc.selection.patternSelectionEnd));
                    }
                }
                group.append(new ChangePatternSelection(this._doc, 0, 0));
            }
            else {
                group.append(new ChangeDeleteBars(this._doc, this.boxSelectionBar, this.boxSelectionWidth));
                const width = this.boxSelectionWidth;
                this.boxSelectionX0 = Math.max(0, this.boxSelectionX0 - width);
                this.boxSelectionX1 = Math.max(0, this.boxSelectionX1 - width);
            }
            this._doc.record(group);
        }
        deleteChannel() {
            this._doc.record(new ChangeRemoveChannel(this._doc, this.boxSelectionChannel, this.boxSelectionChannel + this.boxSelectionHeight - 1));
            this.boxSelectionY0 = this.boxSelectionY1 = this._doc.channel;
            ColorConfig.resetColors();
        }
        *_eachSelectedChannel() {
            for (let channelIndex = this.boxSelectionChannel; channelIndex < this.boxSelectionChannel + this.boxSelectionHeight; channelIndex++) {
                yield channelIndex;
            }
        }
        *_eachSelectedBar() {
            for (let bar = this.boxSelectionBar; bar < this.boxSelectionBar + this.boxSelectionWidth; bar++) {
                yield bar;
            }
        }
        *_eachSelectedPattern(channelIndex) {
            const handledPatterns = {};
            for (const bar of this._eachSelectedBar()) {
                const currentPatternIndex = this._doc.song.channels[channelIndex].bars[bar];
                if (currentPatternIndex == 0)
                    continue;
                if (handledPatterns[String(currentPatternIndex)])
                    continue;
                handledPatterns[String(currentPatternIndex)] = true;
                const pattern = this._doc.song.getPattern(channelIndex, bar);
                if (pattern == null)
                    throw new Error();
                yield pattern;
            }
        }
        _parseCopiedInstrumentArray(patternCopy, channelIndex) {
            const instruments = Array.from(patternCopy["instruments"]).map(i => i >>> 0);
            discardInvalidPatternInstruments(instruments, this._doc.song, channelIndex);
            return instruments;
        }
        _patternIndexIsUnused(channelIndex, patternIndex) {
            for (let i = 0; i < this._doc.song.barCount; i++) {
                if (this._doc.song.channels[channelIndex].bars[i] == patternIndex) {
                    return false;
                }
            }
            return true;
        }
        copy() {
            const channels = [];
            for (const channelIndex of this._eachSelectedChannel()) {
                const patterns = {};
                const bars = [];
                for (const bar of this._eachSelectedBar()) {
                    const patternNumber = this._doc.song.channels[channelIndex].bars[bar];
                    bars.push(patternNumber);
                    if (patterns[String(patternNumber)] == undefined) {
                        const pattern = this._doc.song.getPattern(channelIndex, bar);
                        let instruments = this._doc.recentPatternInstruments[channelIndex];
                        let notes = [];
                        if (pattern != null) {
                            instruments = pattern.instruments.concat();
                            if (this.patternSelectionActive) {
                                for (const note of pattern.cloneNotes()) {
                                    if (note.end <= this.patternSelectionStart)
                                        continue;
                                    if (note.start >= this.patternSelectionEnd)
                                        continue;
                                    note.start -= this.patternSelectionStart;
                                    note.end -= this.patternSelectionStart;
                                    if (note.start < 0 || note.end > this.patternSelectionEnd - this.patternSelectionStart) {
                                        new ChangeNoteLength(null, note, Math.max(note.start, 0), Math.min(this.patternSelectionEnd - this.patternSelectionStart, note.end));
                                    }
                                    notes.push(note);
                                }
                            }
                            else {
                                notes = pattern.notes;
                            }
                        }
                        patterns[String(patternNumber)] = { "instruments": instruments, "notes": notes };
                    }
                }
                const channelCopy = {
                    "isNoise": this._doc.song.getChannelIsNoise(channelIndex),
                    "isMod": this._doc.song.getChannelIsMod(channelIndex),
                    "patterns": patterns,
                    "bars": bars,
                };
                channels.push(channelCopy);
            }
            const selectionCopy = {
                "partDuration": this.patternSelectionActive ? this.patternSelectionEnd - this.patternSelectionStart : this._doc.song.beatsPerBar * Config.partsPerBeat,
                "channels": channels,
            };
            window.localStorage.setItem("selectionCopy", JSON.stringify(selectionCopy));
            new ChangePatternSelection(this._doc, 0, 0);
        }
        _remapToNoisePitches(oldPitches) {
            let newPitches = oldPitches.slice();
            newPitches.sort(function (a, b) { return a - b; });
            let lowestPitch = newPitches[0] % Config.drumCount;
            const numberOfPitches = newPitches.length;
            let highestPitch = lowestPitch + (numberOfPitches - 1);
            while (highestPitch >= Config.drumCount) {
                lowestPitch--;
                highestPitch--;
            }
            for (let notePitchIndex = 0; notePitchIndex < newPitches.length; notePitchIndex++) {
                newPitches[notePitchIndex] = notePitchIndex + lowestPitch;
            }
            return newPitches;
        }
        _convertCopiedPitchNotesToNoiseNotes(oldNotes) {
            let newNotes = [];
            for (let noteIndex = 0; noteIndex < oldNotes.length; noteIndex++) {
                const oldNote = oldNotes[noteIndex];
                const newNotePitches = this._remapToNoisePitches(oldNote["pitches"].slice());
                const oldNotePins = oldNote.pins;
                let newNotePins = [];
                for (let notePinIndex = 0; notePinIndex < oldNotePins.length; notePinIndex++) {
                    const oldPin = oldNotePins[notePinIndex];
                    newNotePins.push({
                        interval: oldPin.interval,
                        time: oldPin.time,
                        size: oldPin.size,
                    });
                }
                const newNoteStart = oldNote["start"];
                const newNoteEnd = oldNote["end"];
                const newNoteContinuesLastPattern = oldNote["continuesLastPattern"];
                const newNote = new Note(0, newNoteStart, newNoteEnd, 0, false);
                newNote.pitches = newNotePitches;
                newNote.pins = newNotePins;
                newNote.continuesLastPattern = newNoteContinuesLastPattern;
                newNotes.push(newNote);
            }
            return newNotes;
        }
        cutNotes() {
            const group = new ChangeGroup();
            const channelIndex = this.boxSelectionChannel;
            const barIndex = this.boxSelectionBar;
            const cutHeight = this.boxSelectionHeight;
            const cutWidth = this.boxSelectionWidth;
            this.copy();
            for (let channel = channelIndex; channel < channelIndex + cutHeight; channel++) {
                for (let bar = barIndex; bar < barIndex + cutWidth; bar++) {
                    const patternNumber = this._doc.song.channels[channel].bars[bar];
                    if (patternNumber != 0) {
                        const pattern = this._doc.song.channels[channel].patterns[patternNumber - 1];
                        group.append(new ChangeNoteTruncate(this._doc, pattern, 0, Config.partsPerBeat * this._doc.song.beatsPerBar));
                    }
                }
            }
            this._doc.record(group);
        }
        pasteNotes() {
            const selectionCopy = JSON.parse(String(window.localStorage.getItem("selectionCopy")));
            if (selectionCopy == null)
                return;
            const channelCopies = selectionCopy["channels"] || [];
            const copiedPartDuration = selectionCopy["partDuration"] >>> 0;
            const group = new ChangeGroup();
            const fillSelection = (this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1);
            const pasteHeight = fillSelection ? this.boxSelectionHeight : Math.min(channelCopies.length, this._doc.song.getChannelCount() - this.boxSelectionChannel);
            for (let pasteChannel = 0; pasteChannel < pasteHeight; pasteChannel++) {
                const channelCopy = channelCopies[pasteChannel % channelCopies.length];
                const channelIndex = this.boxSelectionChannel + pasteChannel;
                const channelIsNoise = this._doc.song.getChannelIsNoise(channelIndex);
                const isNoise = !!channelCopy["isNoise"];
                const isMod = !!channelCopy["isMod"];
                const isPitch = !isNoise && !isMod;
                const patternCopies = channelCopy["patterns"] || {};
                const copiedBars = channelCopy["bars"] || [];
                if (copiedBars.length == 0)
                    continue;
                if (isNoise && this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                if (isMod != this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                const pasteWidth = fillSelection ? this.boxSelectionWidth : Math.min(copiedBars.length, this._doc.song.barCount - this.boxSelectionBar);
                if (!fillSelection && copiedBars.length == 1 && channelCopies.length == 1) {
                    const copiedPatternIndex = copiedBars[0] >>> 0;
                    const bar = this.boxSelectionBar;
                    const currentPatternIndex = this._doc.song.channels[channelIndex].bars[bar];
                    if (copiedPatternIndex == 0 && currentPatternIndex == 0)
                        continue;
                    const patternCopy = patternCopies[String(copiedPatternIndex)];
                    const instrumentsCopy = this._parseCopiedInstrumentArray(patternCopy, channelIndex);
                    let pastedNotes = patternCopy["notes"];
                    if (isPitch && channelIsNoise) {
                        pastedNotes = this._convertCopiedPitchNotesToNoiseNotes(pastedNotes);
                    }
                    if (currentPatternIndex == 0) {
                        const existingPattern = this._doc.song.channels[channelIndex].patterns[copiedPatternIndex - 1];
                        if (existingPattern != undefined &&
                            !this.patternSelectionActive &&
                            ((comparePatternNotes(pastedNotes, existingPattern.notes) && patternsContainSameInstruments(instrumentsCopy, existingPattern.instruments)) ||
                                this._patternIndexIsUnused(channelIndex, copiedPatternIndex))) {
                            group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                        }
                        else {
                            group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                        }
                    }
                    const pattern = this._doc.song.getPattern(channelIndex, bar);
                    if (pattern == null)
                        throw new Error();
                    group.append(new ChangePaste(this._doc, pattern, pastedNotes, this.patternSelectionActive ? this.patternSelectionStart : 0, this.patternSelectionActive ? this.patternSelectionEnd : Config.partsPerBeat * this._doc.song.beatsPerBar, copiedPartDuration));
                    if (currentPatternIndex == 0 || patternCopy.notes.length == 0 || channelIndex >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        this.selectInstrument(instrumentsCopy[0]);
                        group.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instrumentsCopy, pattern));
                    }
                }
                else if (this.patternSelectionActive) {
                    const reusablePatterns = {};
                    const usedPatterns = {};
                    group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, pasteWidth, this.boxSelectionChannel, pasteHeight, false));
                    for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                        const bar = this.boxSelectionBar + pasteBar;
                        const copiedPatternIndex = copiedBars[pasteBar % copiedBars.length] >>> 0;
                        const currentPatternIndex = this._doc.song.channels[channelIndex].bars[bar];
                        const reusedIndex = [copiedPatternIndex, currentPatternIndex].join(",");
                        if (copiedPatternIndex == 0 && currentPatternIndex == 0)
                            continue;
                        if (reusablePatterns[reusedIndex] != undefined) {
                            group.append(new ChangePatternNumbers(this._doc, reusablePatterns[reusedIndex], bar, channelIndex, 1, 1));
                            continue;
                        }
                        if (currentPatternIndex == 0) {
                            group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                            const patternCopy = patternCopies[String(copiedPatternIndex)];
                            const instrumentsCopy = this._parseCopiedInstrumentArray(patternCopy, channelIndex);
                            const pattern = this._doc.song.getPattern(channelIndex, bar);
                            group.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instrumentsCopy, pattern));
                        }
                        else {
                            const pattern = this._doc.song.getPattern(channelIndex, bar);
                            if (pattern == null)
                                throw new Error();
                            if (!usedPatterns[String(currentPatternIndex)]) {
                                usedPatterns[String(currentPatternIndex)] = true;
                            }
                            else {
                                group.append(new ChangePatternNumbers(this._doc, 0, bar, channelIndex, 1, 1));
                                group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                                const newPattern = this._doc.song.getPattern(channelIndex, bar);
                                if (newPattern == null)
                                    throw new Error();
                                for (const note of pattern.cloneNotes()) {
                                    if (isPitch && channelIsNoise) {
                                        note.pitches = this._remapToNoisePitches(note.pitches);
                                    }
                                    group.append(new ChangeNoteAdded(this._doc, newPattern, note, newPattern.notes.length, false));
                                }
                            }
                        }
                        const pattern = this._doc.song.getPattern(channelIndex, bar);
                        if (pattern == null)
                            throw new Error();
                        if (copiedPatternIndex == 0) {
                            group.append(new ChangeNoteTruncate(this._doc, pattern, this.patternSelectionStart, this.patternSelectionEnd));
                        }
                        else {
                            const patternCopy = patternCopies[String(copiedPatternIndex)];
                            let pastedNotes = patternCopy["notes"];
                            if (isPitch && channelIsNoise) {
                                pastedNotes = this._convertCopiedPitchNotesToNoiseNotes(pastedNotes);
                            }
                            group.append(new ChangePaste(this._doc, pattern, pastedNotes, this.patternSelectionStart, this.patternSelectionEnd, copiedPartDuration));
                        }
                        reusablePatterns[reusedIndex] = this._doc.song.channels[channelIndex].bars[bar];
                    }
                }
                else {
                    for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                        this.erasePatternInBar(group, channelIndex, this.boxSelectionBar + pasteBar);
                    }
                    const reusablePatterns = {};
                    for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                        const bar = this.boxSelectionBar + pasteBar;
                        const copiedPatternIndex = copiedBars[pasteBar % copiedBars.length] >>> 0;
                        const reusedIndex = String(copiedPatternIndex);
                        if (copiedPatternIndex == 0)
                            continue;
                        if (reusablePatterns[reusedIndex] != undefined) {
                            group.append(new ChangePatternNumbers(this._doc, reusablePatterns[reusedIndex], bar, channelIndex, 1, 1));
                            continue;
                        }
                        const patternCopy = patternCopies[String(copiedPatternIndex)];
                        const instrumentsCopy = this._parseCopiedInstrumentArray(patternCopy, channelIndex);
                        const existingPattern = this._doc.song.channels[channelIndex].patterns[copiedPatternIndex - 1];
                        let pastedNotes = patternCopy["notes"];
                        if (isPitch && channelIsNoise) {
                            pastedNotes = this._convertCopiedPitchNotesToNoiseNotes(pastedNotes);
                        }
                        if (existingPattern != undefined &&
                            copiedPartDuration == Config.partsPerBeat * this._doc.song.beatsPerBar &&
                            comparePatternNotes(pastedNotes, existingPattern.notes) &&
                            patternsContainSameInstruments(instrumentsCopy, existingPattern.instruments)) {
                            group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                        }
                        else {
                            if (existingPattern != undefined && this._patternIndexIsUnused(channelIndex, copiedPatternIndex)) {
                                group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                            }
                            else {
                                group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                            }
                            const pattern = this._doc.song.getPattern(channelIndex, bar);
                            if (pattern == null)
                                throw new Error();
                            group.append(new ChangePaste(this._doc, pattern, pastedNotes, this.patternSelectionActive ? this.patternSelectionStart : 0, this.patternSelectionActive ? this.patternSelectionEnd : Config.partsPerBeat * this._doc.song.beatsPerBar, copiedPartDuration));
                            group.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instrumentsCopy, pattern));
                        }
                        reusablePatterns[reusedIndex] = this._doc.song.channels[channelIndex].bars[bar];
                    }
                }
            }
            this._doc.record(group);
        }
        erasePatternInBar(group, channelIndex, bar) {
            const removedPattern = this._doc.song.channels[channelIndex].bars[bar];
            if (removedPattern != 0) {
                group.append(new ChangePatternNumbers(this._doc, 0, bar, channelIndex, 1, 1));
                if (this._patternIndexIsUnused(channelIndex, removedPattern)) {
                    this._doc.song.channels[channelIndex].patterns[removedPattern - 1].notes.length = 0;
                }
            }
        }
        pasteNumbers() {
            const selectionCopy = JSON.parse(String(window.localStorage.getItem("selectionCopy")));
            if (selectionCopy == null)
                return;
            const channelCopies = selectionCopy["channels"] || [];
            const group = new ChangeGroup();
            const fillSelection = this.boxSelectionActive;
            const pasteHeight = fillSelection ? this.boxSelectionHeight : Math.min(channelCopies.length, this._doc.song.getChannelCount() - this.boxSelectionChannel);
            for (let pasteChannel = 0; pasteChannel < pasteHeight; pasteChannel++) {
                const channelCopy = channelCopies[pasteChannel % channelCopies.length];
                const channelIndex = this.boxSelectionChannel + pasteChannel;
                const copiedBars = channelCopy["bars"] || [];
                if (copiedBars.length == 0)
                    continue;
                const pasteWidth = fillSelection ? this.boxSelectionWidth : Math.min(copiedBars.length, this._doc.song.barCount - this.boxSelectionBar);
                for (let pasteBar = 0; pasteBar < pasteWidth; pasteBar++) {
                    const copiedPatternIndex = copiedBars[pasteBar % copiedBars.length] >>> 0;
                    const bar = this.boxSelectionBar + pasteBar;
                    if (copiedPatternIndex > this._doc.song.patternsPerChannel) {
                        group.append(new ChangePatternsPerChannel(this._doc, copiedPatternIndex));
                    }
                    group.append(new ChangePatternNumbers(this._doc, copiedPatternIndex, bar, channelIndex, 1, 1));
                }
            }
            this._doc.record(group);
        }
        selectAll() {
            new ChangePatternSelection(this._doc, 0, 0);
            if (this.boxSelectionBar == 0 &&
                this.boxSelectionChannel == 0 &&
                this.boxSelectionWidth == this._doc.song.barCount &&
                this.boxSelectionHeight == this._doc.song.getChannelCount()) {
                this.setTrackSelection(this._doc.bar, this._doc.bar, this._doc.channel, this._doc.channel);
            }
            else {
                this.setTrackSelection(0, this._doc.song.barCount - 1, 0, this._doc.song.getChannelCount() - 1);
            }
            this.selectionUpdated();
        }
        
        

whistleRecord() {
	let _1doc= this._doc
 let oo = new WhistleRecordContainer(document.body, _1doc);

  
 oo.show();
 oo.ondone = (params) => {
_1doc.synth.STABLE_N      = params.STABLE_N;
_1doc.synth.SILENCE_N     = params.SILENCE_N;
_1doc.synth.MIN_NOTE_MS   = params.MIN_NOTE_MS;
_1doc.synth.CHANGE_HOLD_MS= params.CHANGE_HOLD_MS;
_1doc.synth.SHIFT= params.Shift;
_1doc.synth.TOLERANCE= params.TOLERANCE;
_1doc.synth.NOTE_HOLD_EXTRA= params.NOTE_HOLD_EXTRA;
_1doc.synth.Db   = params.DB;
if (_1doc.synth.playing) {
 _1doc.performance.pause();
 _1doc.synth.isRecordingWhistle = false
 _1doc.performance.record();
_1doc.synth.isRecordingWhistle = true
}
else {
 _1doc.performance.record();
 _1doc.synth.isRecordingWhistle = true
}

 
let analyser, mediaSource, isRecording3 = false, startTs = 0
let playing = false, playingSources2 = [], timeouts = []
let currentNote = null, currentStart = 0
let stableBuf = [], silenceStreak = 0
let pendingNote = null, pendingSince = 0
var STABLE_N = _1doc.synth.STABLE_N, SILENCE_N = _1doc.synth.SILENCE_N  , MIN_NOTE_MS = _1doc.synth.MIN_NOTE_MS , CHANGE_HOLD_MS = _1doc.synth.CHANGE_HOLD_MS, DB = _1doc.synth.Db, Shift = _1doc.synth.SHIFT, TOLERANCE= _1doc.synth.TOLERANCE, NOTE_HOLD_EXTRA= _1doc.synth.NOTE_HOLD_EXTRA;
let frameDuration = 1000 / 60;
let currNote={text:""}
let semitoneShift = params.Shift || -12
const baseFrequencies2 = {
  'c': 261.63, 'c#': 277.18, 'd': 293.66, 'd#': 311.13, 'e': 329.63,
  'f': 349.23, 'f#': 369.99, 'g': 392, 'g#': 415.3, 'a': 440,
  'a#': 466.16, 'h': 493.88
}
const order = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','h']
const octaves = [1,2,3,4,5,6,7]
const bank = buildNoteBank()
let sensitivityDb = DB||70;
function steps(value, step) {
  return ((value % step) + step) % step
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max)
}
function buildNoteBank() {
  const rows = []
  for (const o of octaves) {
    for (const n of order) {
      const f = baseFrequencies2[n] * Math.pow(2, o - 4)
      rows.push({ name: n, oct: o, f })
    }
  }
  rows.sort((a, b) => a.f - b.f)
  for (let i = 0; i < rows.length; i++) {
    const prev = rows[i - 1]?.f || rows[i].f / Math.pow(2, 1 / 12)
    const next = rows[i + 1]?.f || rows[i].f * Math.pow(2, 1 / 12)
    rows[i].lo = (prev + rows[i].f) / 2
    rows[i].hi = (rows[i].f + next) / 2
  }
  return rows
}
function quantize(freq) {
  for (const r of bank) {
    const tolerance = r.f * TOLERANCE|| 0.008; 
    if (freq >= r.lo + tolerance && freq < r.hi - tolerance) return r
  }
  return null
}
  

const self = this; 
async function initMic() {
    try {
        self.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        self.mediaSource = self.audioctx24.createMediaStreamSource(self.micStream);
        self.analyser = self.audioctx24.createAnalyser();
        self.analyser.fftSize = 1024;
        self.mediaSource.connect(self.analyser);
        console.log("Mic connected");
    } catch (e) {
        console.error(e);
        showToast("Microphone Access Error")
    }
}



function detectPitch() {
  const N = self.analyser.fftSize
  const buf = new Float32Array(N)
  self.analyser.getFloatTimeDomainData(buf)
  let rms = 0
  for (let i = 0; i < N; i++) rms += buf[i] * buf[i]
  rms = Math.sqrt(rms / N)
  let db = 20 * Math.log10(rms + 1e-12)
  db = Math.max(0, Math.min(100, db + 100))
  if (db < sensitivityDb) return { freq: null, clarity: 0, db }

  let minLag = Math.floor(self.audioctx24.sampleRate / 2000)
  let maxLag = Math.floor(self.audioctx24.sampleRate / 150)
  let bestLag = -1, bestCorr = 0
  let sumSq = 0
  for (let i = 0; i < N; i++) sumSq += buf[i] * buf[i]
  for (let lag = minLag; lag <= maxLag; lag++) {
    let corr = 0, energy = 0
    for (let i = 0; i < N - lag; i++) {
      corr += buf[i] * buf[i + lag]
      energy += buf[i + lag] * buf[i + lag]
    }
    const norm = corr / Math.sqrt(sumSq * energy || 1)
    if (norm > bestCorr) { bestCorr = norm; bestLag = lag }
  }
  if (bestLag < 0 || bestCorr < 0.6) return { freq: null, clarity: bestCorr, db }

  const c1 = xcorrAt(buf, bestLag - 1), c2 = xcorrAt(buf, bestLag), c3 = xcorrAt(buf, bestLag + 1)
  const shift = (c3 - c1) / (2 * (2 * c2 - c1 - c3) || 1)
  const refinedLag = bestLag + shift
  const freq = self.audioctx24.sampleRate / refinedLag
  return { freq, clarity: bestCorr, db }
}

function xcorrAt(buf, lag) {
  let N = buf.length, c = 0, ss1 = 0, ss2 = 0
  for (let i = 0; i < N - lag; i++) {
    c += buf[i] * buf[i + lag]
    ss1 += buf[i] * buf[i]
    ss2 += buf[i + lag] * buf[i + lag]
  }
  return c / Math.sqrt(ss1 * ss2 || 1)
}
function getNote(noteObj) {
  if (!noteObj) return;
  if (noteObj.dur < MIN_NOTE_MS) return;

  const shiftedF = noteObj.f * Math.pow(2, semitoneShift / 12);
  const label = quantize(shiftedF);

  if (label) {
    return {
      text: label.name + label.oct,
      freq: noteObj.f / Math.pow(2, semitoneShift / 12),
      dur: noteObj.dur  
    };
  }
}
const _doc = _1doc;

let lastDrawnNote = null
let repeatCount = 0;
let heldNote = null;

function loop() {
    if (!isRecording3) return;

    let currnote2 = currNote ? currNote.text : "";
    _doc.performance.currNote = currnote2.charAt(0).toUpperCase() + currnote2.slice(1).toLowerCase();
if (_doc.performance.isRecordingWhistle) {
	let dirty = _doc.performance._updateRecordedNotes();
	_doc.performance.updatePerformedNote(_doc.performance.currNote);
	dirty = true;
	if (dirty) _doc.performance._doc.notifier.notifyWatchers();
}
		 
		
    const { freq, db } = detectPitch();
    let q = null;
    if (freq && db >= sensitivityDb) {
        const shiftedFreq = freq * Math.pow(2, semitoneShift / 12);
        q = quantize(shiftedFreq);
    }

    if (q) {
        stableBuf.push(q);
        if (stableBuf.length > STABLE_N) stableBuf.shift();
        const same = stableBuf.every(x => x && x.name === stableBuf[0].name && x.oct === stableBuf[0].oct);

        if (!currentNote && same) {
            currentNote = { name: q.name, oct: q.oct, f: q.f, start: performance.now() };
            silenceStreak = 0;
            pendingNote = null;
        } else if (currentNote && (currentNote.name !== q.name || currentNote.oct !== q.oct) && same) {
            if (!pendingNote) {
                pendingNote = { name: q.name, oct: q.oct, f: q.f, start: performance.now() };
                pendingSince = performance.now();
            } else if (performance.now() - pendingSince > CHANGE_HOLD_MS) {
                currNote = { ...getNote(currentNote) };
                heldNote = { ...currNote, holdUntil: performance.now() + NOTE_HOLD_EXTRA };
                currentNote = pendingNote;
                pendingNote = null;
            }
        } else {
            pendingNote = null;
            silenceStreak = 0;
        }
    } else {
        stableBuf = [];
        pendingNote = null;
        silenceStreak++;
        if (currentNote && silenceStreak >= SILENCE_N) {
    const now = performance.now();
    const duration = now - currentNote.start;
    const noteObj = getNote({ ...currentNote, dur: duration });
    if (noteObj) {
        noteObj.dur = Math.max(duration, NOTE_HOLD_EXTRA);
        currNote = noteObj;
        heldNote = { ...noteObj, holdUntil: now + NOTE_HOLD_EXTRA };
    }
    currentNote = null;
}
}

    if (heldNote && performance.now() < heldNote.holdUntil) {
        currNote = heldNote;
    } else if (heldNote && performance.now() >= heldNote.holdUntil) {
        heldNote = null;
        currNote = { text: "" };
    }

    lastDrawnNote = currNote ? currNote.text : "";

    if (_doc.synth.isRecordingWhistle) setTimeout(loop, frameDuration);
}


let loopRunning = false; 
(async () => {
  await self.audioctx24.resume()
  await initMic()
  isRecording3 = true
  currentNote = null
  startTs = performance.now()
  stableBuf = []
  silenceStreak = 0
  pendingNote = null
  if (!loopRunning) {
 	loopRunning = true
 	loop()
}
})();
function hasOverlap(existingNotes, startTick, endTick) {
  			return existingNotes.some(note => {
  				const nStart = note.points[0].tick;
  				const nEnd = note.points[1].tick;
  				return (startTick < nEnd && endTick > nStart);
});
}
let maxEndTick = 0;
  	function freqToPitchIndex(freq) {
  		const midi = 69 + 12 * Math.log2(freq / 440);
  		const pitch = Math.round(midi - 12);
  		if (pitch < 0 || pitch > 95*2) return null;
  		return pitch;
}

}
}
        
        
        
        selectChannel() {
            new ChangePatternSelection(this._doc, 0, 0);
            if (this.boxSelectionBar == 0 && this.boxSelectionWidth == this._doc.song.barCount) {
                this.setTrackSelection(this._doc.bar, this._doc.bar, this.boxSelectionY0, this.boxSelectionY1);
            }
            else {
                this.setTrackSelection(0, this._doc.song.barCount - 1, this.boxSelectionY0, this.boxSelectionY1);
            }
            this.selectionUpdated();
        }
        duplicatePatterns(replaceUnused) {
            this._doc.record(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, replaceUnused));
        }
        muteChannels(allChannels) {
            if (allChannels) {
                let anyMuted = false;
                for (let channelIndex = 0; channelIndex < this._doc.song.channels.length; channelIndex++) {
                    if (this._doc.song.channels[channelIndex].muted) {
                        anyMuted = true;
                        break;
                    }
                }
                for (let channelIndex = 0; channelIndex < this._doc.song.channels.length; channelIndex++) {
                    this._doc.song.channels[channelIndex].muted = !anyMuted;
                }
            }
            else {
                let anyUnmuted = false;
                for (const channelIndex of this._eachSelectedChannel()) {
                    if (!this._doc.song.channels[channelIndex].muted) {
                        anyUnmuted = true;
                        break;
                    }
                }
                for (const channelIndex of this._eachSelectedChannel()) {
                    this._doc.song.channels[channelIndex].muted = anyUnmuted;
                }
            }
            this._doc.notifier.changed();
        }
        soloChannels(invert) {
            let alreadySoloed = true;
            if (this.boxSelectionChannel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                const currentChannel = this._doc.song.channels[this.boxSelectionChannel];
                const bar = currentChannel.bars[this._doc.bar] - 1;
                const modInstrument = (bar >= 0) ? currentChannel.instruments[currentChannel.patterns[bar].instruments[0]] : currentChannel.instruments[this._doc.viewedInstrument[this.boxSelectionChannel]];
                const soloPattern = [];
                let matchesSoloPattern = !invert;
                for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                    soloPattern[channelIndex] = false;
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        if (modInstrument.modChannels[mod] == channelIndex) {
                            soloPattern[channelIndex] = true;
                        }
                    }
                }
                for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                    if (this._doc.song.channels[channelIndex].muted == soloPattern[channelIndex]) {
                        matchesSoloPattern = invert;
                        break;
                    }
                }
                for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                    if (matchesSoloPattern) {
                        this._doc.song.channels[channelIndex].muted = false;
                    }
                    else {
                        this._doc.song.channels[channelIndex].muted = !soloPattern[channelIndex];
                    }
                }
            }
            else {
                for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                    const shouldBeMuted = (channelIndex < this.boxSelectionChannel || channelIndex >= this.boxSelectionChannel + this.boxSelectionHeight) ? !invert : invert;
                    if (this._doc.song.channels[channelIndex].muted != shouldBeMuted) {
                        alreadySoloed = false;
                        break;
                    }
                }
                if (alreadySoloed) {
                    for (let channelIndex = 0; channelIndex < this._doc.song.channels.length; channelIndex++) {
                        this._doc.song.channels[channelIndex].muted = false;
                    }
                }
                else {
                    for (let channelIndex = 0; channelIndex < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex++) {
                        this._doc.song.channels[channelIndex].muted = (channelIndex < this.boxSelectionChannel || channelIndex >= this.boxSelectionChannel + this.boxSelectionHeight) ? !invert : invert;
                    }
                }
            }
            this._doc.notifier.changed();
        }
        forceRhythm() {
            const group = new ChangeGroup();
            if (this.boxSelectionActive) {
                group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, false));
            }
            for (const channelIndex of this._eachSelectedChannel()) {
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    group.append(new ChangePatternRhythm(this._doc, pattern));
                }
            }
            this._doc.record(group);
        }
        forceScale() {
            const group = new ChangeGroup();
            if (this.boxSelectionActive) {
                group.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, false));
            }
            const scaleFlags = [true, false, false, false, false, false, false, false, false, false, false, false];
            for (const channelIndex of this._eachSelectedChannel()) {
                if (this._doc.song.getChannelIsNoise(channelIndex) || this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    unionOfUsedNotes(pattern, scaleFlags);
                }
            }
            const scaleMap = generateScaleMap(scaleFlags, this._doc.song.scale, this._doc.song.scaleCustom);
            for (const channelIndex of this._eachSelectedChannel()) {
                if (this._doc.song.getChannelIsNoise(channelIndex) || this._doc.song.getChannelIsMod(channelIndex))
                    continue;
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    group.append(new ChangePatternScale(this._doc, pattern, scaleMap));
                }
            }
            this._doc.record(group);
        }
        setTrackSelection(newX0, newX1, newY0, newY1) {
            const canReplaceLastChange = true;
            this._changeTrack = new ChangeGroup();
            this._changeTrack.append(new ChangeTrackSelection(this._doc, newX0, newX1, newY0, newY1));
            this._doc.record(this._changeTrack, canReplaceLastChange);
        }
        transpose(upward, octave) {
            const canReplaceLastChange = this._doc.lastChangeWas(this._changeTranspose);
            this._changeTranspose = new ChangeGroup();
            if (this.boxSelectionActive) {
                this._changeTranspose.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, false));
            }
            for (const channelIndex of this._eachSelectedChannel()) {
                if (channelIndex >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                    continue;
                for (const pattern of this._eachSelectedPattern(channelIndex)) {
                    this._changeTranspose.append(new ChangeTranspose(this._doc, channelIndex, pattern, upward, this._doc.prefs.notesOutsideScale, octave));
                }
            }
            this._doc.record(this._changeTranspose, canReplaceLastChange);
        }
        swapChannels(offset) {
            const possibleSectionBoundaries = [
                this._doc.song.pitchChannelCount,
                this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount,
                this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount + this._doc.song.modChannelCount,
                this._doc.song.getChannelCount(),
            ];
            let channelSectionMin = 0;
            let channelSectionMax = 0;
            for (const nextBoundary of possibleSectionBoundaries) {
                if ((this.boxSelectionChannel < nextBoundary && offset < 0) || (this.boxSelectionChannel + this.boxSelectionHeight <= nextBoundary)) {
                    channelSectionMax = nextBoundary - 1;
                    break;
                }
                channelSectionMin = nextBoundary;
            }
            const newSelectionMin = Math.max(this.boxSelectionChannel, channelSectionMin);
            const newSelectionMax = Math.min(this.boxSelectionChannel + this.boxSelectionHeight - 1, channelSectionMax);
            offset = Math.max(offset, channelSectionMin - newSelectionMin);
            offset = Math.min(offset, channelSectionMax - newSelectionMax);
            if (offset != 0) {
                const canReplaceLastChange = this._doc.lastChangeWas(this._changeReorder);
                this._changeReorder = new ChangeGroup();
                this.boxSelectionY0 = newSelectionMin + offset;
                this.boxSelectionY1 = newSelectionMax + offset;
                this._changeReorder.append(new ChangeChannelOrder(this._doc, newSelectionMin, newSelectionMax, offset));
                this._changeReorder.append(new ChangeChannelBar(this._doc, Math.max(this.boxSelectionY0, Math.min(this.boxSelectionY1, this._doc.channel + offset)), this._doc.bar));
                this.selectionUpdated();
                this._doc.record(this._changeReorder, canReplaceLastChange);
            }
        }
        selectInstrument(instrument) {
            if (this._doc.viewedInstrument[this._doc.channel] == instrument) {
                if (this._doc.song.layeredInstruments && this._doc.song.patternInstruments && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                    const canReplaceLastChange = this._doc.lastChangeWas(this._changeInstrument);
                    this._changeInstrument = new ChangeGroup();
                    const instruments = this._doc.recentPatternInstruments[this._doc.channel];
                    this._doc.notifier.changed();
                    if (instruments.indexOf(instrument) == -1) {
                        instruments.push(instrument);
                        const maxLayers = this._doc.song.getMaxInstrumentsPerPattern(this._doc.channel);
                        if (instruments.length > maxLayers) {
                            instruments.splice(0, instruments.length - maxLayers);
                        }
                    }
                    else {
                        instruments.splice(instruments.indexOf(instrument), 1);
                        if (instruments.length == 0)
                            instruments[0] = 0;
                    }
                    if (this.boxSelectionActive) {
                        this._changeInstrument.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, false));
                    }
                    for (const channelIndex of this._eachSelectedChannel()) {
                        for (const pattern of this._eachSelectedPattern(channelIndex)) {
                            this._changeInstrument.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instruments, pattern));
                        }
                    }
                    if (!this._changeInstrument.isNoop())
                        this._doc.record(this._changeInstrument, canReplaceLastChange);
                }
            }
            else {
                const canReplaceLastChange = this._doc.lastChangeWas(this._changeInstrument);
                this._changeInstrument = new ChangeGroup();
                this._changeInstrument.append(new ChangeViewInstrument(this._doc, instrument));
                if (!(this._doc.song.layeredInstruments && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) && this._doc.song.patternInstruments) {
                    if (this.boxSelectionActive) {
                        this._changeInstrument.append(new ChangeDuplicateSelectedReusedPatterns(this._doc, this.boxSelectionBar, this.boxSelectionWidth, this.boxSelectionChannel, this.boxSelectionHeight, false));
                    }
                    const instruments = [instrument];
                    for (const channelIndex of this._eachSelectedChannel()) {
                        for (const pattern of this._eachSelectedPattern(channelIndex)) {
                            this._changeInstrument.append(new ChangeSetPatternInstruments(this._doc, channelIndex, instruments, pattern));
                        }
                    }
                    this._doc.record(this._changeInstrument, canReplaceLastChange);
                }
                else if (!this._doc.hasRedoHistory()) {
                    this._doc.record(this._changeInstrument, canReplaceLastChange);
                }
            }
        }
        resetBoxSelection() {
            this.boxSelectionX0 = this.boxSelectionX1 = this._doc.bar;
            this.boxSelectionY0 = this.boxSelectionY1 = this._doc.channel;
        }
    }
function rebuiltKeyboard(){ 
	if (typeof editor === "undefined" || !editor) return;
	if (!editor.doc || !editor.doc.prefs) return;
	const pianoStyleId = "dynamic-piano-styles";
let pianoStyleElement = document.getElementById(pianoStyleId);
if (editor.doc.prefs.pianoKeyboard == true) {
	if (!pianoStyleElement) {
		pianoStyleElement = document.createElement("style");
		pianoStyleElement.id = pianoStyleId;
		pianoStyleElement.textContent = `
            .beepboxEditor .piano-button.blackkey + .piano-button:not(.blackkey) {
                border:0px solid white; outline:none; transform: scale(100%,250%) translateY(15%) !important;  
            }
            .beepboxEditor .piano-button.blackkey {
                margin-left:20% !important;
                position:relative !important; z-index:2;
                box-shadow: 0px 5px 15px -2px rgba(44, 44, 49, 1);
            }
            .beepboxEditor .piano-button::before {
                display:none !important;
                border:2px solid #3d3c3a;
            }
            .beepboxEditor .piano-button.blackkey .piano-label {
                padding-left:25% !important;
            }
            .beepboxEditor .piano-button.blackkey + .piano-button:not(.blackkey) .piano-label {
                transform:scale(100%,40%) translateY(-4px) !important;
            }
            .beepboxEditor .piano-button.blackkey::before {
                display: none;
                border: 1px solid #3d3c3a !important;
                background-clip:none !important;
            }
        `;
const labels = document.querySelectorAll('.piano-label');
labels.forEach(label => {
	let keysinparallel=['c','c','d','d','e','f','f','g','g','a','a','h']
	 
let lab = ((label.textContent).toLowerCase())[1] ? (((label.textContent).toLowerCase())[0] + ((label.textContent).toLowerCase())[1] ): ((label.textContent).toLowerCase())[0];
	if (lab.includes(keysinparallel[editor.doc.song.key]) ) {
		label.style.opacity = "1";
	} else {
		label.style.opacity = "0";
	}
});
		document.head.appendChild(pianoStyleElement);
	}
} else {
	if (pianoStyleElement) {
		pianoStyleElement.remove();
	}
	const labels = document.querySelectorAll('.piano-label');
labels.forEach(label => {
		label.style.opacity = "1";
});
}
}
    class Preferences {
        constructor() {
            this.showFifth = true;
            this.volume = 75;
            this.visibleOctaves = Preferences.defaultVisibleOctaves;
            this.reload();
        }
        reload() {
            this.autoPlay = window.localStorage.getItem("autoPlay") == "true";
            this.autoFollow = window.localStorage.getItem("autoFollow") != "false";
            this.enableNotePreview = window.localStorage.getItem("enableNotePreview") != "false";
            this.showFifth = window.localStorage.getItem("showFifth") != "false";
            this.notesOutsideScale = window.localStorage.getItem("notesOutsideScale") == "true";
            this.showLetters = window.localStorage.getItem("showLetters") != "false";
            this.showChannels = window.localStorage.getItem("showChannels") != "false";
            this.showScrollBar = window.localStorage.getItem("showScrollBar") != "false";
            
            this.useCustomSelectPrompt = window.localStorage.getItem("useCustomSelectPrompt") == "true";
            
            this.differentMod = window.localStorage.getItem("differentMod") != "false";
            this.newloopeditor = window.localStorage.getItem("newloopeditor") == "true";
            this.increaseAllPins = window.localStorage.getItem("increaseAllPins") == "true";

            this.oldButtonSheme = window.localStorage.getItem("oldButtonSheme") == "true";
            this.whistleRecord = window.localStorage.getItem("whistleRecord") != "false"; 
            
            
            this.alwaysFineNoteVol = window.localStorage.getItem("alwaysFineNoteVol") == "true";
            this.displayVolumeBar = window.localStorage.getItem("displayVolumeBar") != "false";
            this.instrumentCopyPaste = window.localStorage.getItem("instrumentCopyPaste") != "false";
            this.instrumentImportExport = window.localStorage.getItem("instrumentImportExport") == "true";
            this.instrumentButtonsAtTop = window.localStorage.getItem("instrumentButtonsAtTop") == "true";
            this.enableChannelMuting = window.localStorage.getItem("enableChannelMuting") != "false";
            this.displayBrowserUrl = window.localStorage.getItem("displayBrowserUrl") != "false";
            this.pressControlForShortcuts = window.localStorage.getItem("pressControlForShortcuts") == "true";
            this.enableMidi = window.localStorage.getItem("enableMidi") != "false";
            this.showRecordButton = window.localStorage.getItem("showRecordButton") == "true";
            this.snapRecordedNotesToRhythm = window.localStorage.getItem("snapRecordedNotesToRhythm") == "true";
            this.ignorePerformedNotesNotInScale = window.localStorage.getItem("ignorePerformedNotesNotInScale") == "true";
            this.metronomeCountIn = window.localStorage.getItem("metronomeCountIn") != "false";
            this.metronomeWhileRecording = window.localStorage.getItem("metronomeWhileRecording") != "false";
            this.notesFlashWhenPlayed = window.localStorage.getItem("notesFlashWhenPlayed") == "true";
            this.showOscilloscope = window.localStorage.getItem("showOscilloscope") != "false";
            this.showSampleLoadingStatus = window.localStorage.getItem("showSampleLoadingStatus") != "false";
            this.showDescription = window.localStorage.getItem("showDescription") != "false";
            this.showPlugins = window.localStorage.getItem("showPlugins") == "true";
 
            this.showInstrumentScrollbars = window.localStorage.getItem("showInstrumentScrollbars") == "true";
            this.closePromptByClickoff = window.localStorage.getItem("closePromptByClickoff") == "true";
            this.frostedGlassBackground = window.localStorage.getItem("frostedGlassBackground") == "true";
            this.pianoKeyboard = window.localStorage.getItem("pianoKeyboard") != "false";
            setTimeout(function (){rebuiltKeyboard()},100)
            this.keyboardLayout = window.localStorage.getItem("keyboardLayout") || "pianoTransposingC";
            this.bassOffset = (+window.localStorage.getItem("bassOffset")) || 0;
            this.layout = window.localStorage.getItem("layout") || "large";
            this.colorTheme = window.localStorage.getItem("colorTheme") || ColorConfig.defaultTheme;
            this.language = window.localStorage.getItem("language") || "en";
            this.customTheme = window.localStorage.getItem("customTheme");
            this.customTheme2 = window.localStorage.getItem("customTheme2");
            this.visibleOctaves = (window.localStorage.getItem("visibleOctaves") >>> 0) || Preferences.defaultVisibleOctaves;
            const defaultScale = Config.scales.dictionary[window.localStorage.getItem("defaultScale")];
            this.defaultScale = (defaultScale != undefined) ? defaultScale.index : 0;
            if (window.localStorage.getItem("volume") != null) {
                this.volume = Math.min(window.localStorage.getItem("volume") >>> 0, 75);
            }
            if (window.localStorage.getItem("fullScreen") != null) {
                if (window.localStorage.getItem("fullScreen") == "true")
                    this.layout = "long";
                window.localStorage.removeItem("fullScreen");
            }
        }
        save() {
        	 
        	window.localStorage.setItem("differentMod", this.differentMod ? "true" : "false"); 
        	window.localStorage.setItem("newloopeditor", this.newloopeditor ? "true" : "false"); 
        	window.localStorage.setItem("increaseAllPins", this.increaseAllPins ? "true" : "false"); 
        	window.localStorage.setItem("oldButtonSheme", this.oldButtonSheme ? "true" : "false"); 
        	window.localStorage.setItem("whistleRecord", this.whistleRecord ? "true" : "false"); 
        	
            window.localStorage.setItem("autoPlay", this.autoPlay ? "true" : "false");
            window.localStorage.setItem("autoFollow", this.autoFollow ? "true" : "false");
            window.localStorage.setItem("enableNotePreview", this.enableNotePreview ? "true" : "false");
            window.localStorage.setItem("showFifth", this.showFifth ? "true" : "false");
            window.localStorage.setItem("notesOutsideScale", this.notesOutsideScale ? "true" : "false");
            window.localStorage.setItem("defaultScale", Config.scales[this.defaultScale].name);
            window.localStorage.setItem("showLetters", this.showLetters ? "true" : "false");
            window.localStorage.setItem("showChannels", this.showChannels ? "true" : "false");
            window.localStorage.setItem("showScrollBar", this.showScrollBar ? "true" : "false");
            window.localStorage.setItem("useCustomSelectPrompt", this.useCustomSelectPrompt ? "true" : "false");
            window.localStorage.setItem("alwaysFineNoteVol", this.alwaysFineNoteVol ? "true" : "false");
            window.localStorage.setItem("displayVolumeBar", this.displayVolumeBar ? "true" : "false");
            window.localStorage.setItem("enableChannelMuting", this.enableChannelMuting ? "true" : "false");
            window.localStorage.setItem("instrumentCopyPaste", this.instrumentCopyPaste ? "true" : "false");
            window.localStorage.setItem("instrumentImportExport", this.instrumentImportExport ? "true" : "false");
            window.localStorage.setItem("instrumentButtonsAtTop", this.instrumentButtonsAtTop ? "true" : "false");
            window.localStorage.setItem("displayBrowserUrl", this.displayBrowserUrl ? "true" : "false");
            window.localStorage.setItem("pressControlForShortcuts", this.pressControlForShortcuts ? "true" : "false");
            window.localStorage.setItem("enableMidi", this.enableMidi ? "true" : "false");
            window.localStorage.setItem("showRecordButton", this.showRecordButton ? "true" : "false");
            window.localStorage.setItem("snapRecordedNotesToRhythm", this.snapRecordedNotesToRhythm ? "true" : "false");
            window.localStorage.setItem("ignorePerformedNotesNotInScale", this.ignorePerformedNotesNotInScale ? "true" : "false");
            window.localStorage.setItem("metronomeCountIn", this.metronomeCountIn ? "true" : "false");
            window.localStorage.setItem("metronomeWhileRecording", this.metronomeWhileRecording ? "true" : "false");
            window.localStorage.setItem("notesFlashWhenPlayed", this.notesFlashWhenPlayed ? "true" : "false");
            window.localStorage.setItem("showOscilloscope", this.showOscilloscope ? "true" : "false");
            window.localStorage.setItem("showSampleLoadingStatus", this.showSampleLoadingStatus ? "true" : "false");
            window.localStorage.setItem("showDescription", this.showDescription ? "true" : "false");
            window.localStorage.setItem("showPlugins", this.showPlugins ? "true" : "false");
            window.localStorage.setItem("showInstrumentScrollbars", this.showInstrumentScrollbars ? "true" : "false");
            window.localStorage.setItem("closePromptByClickoff", this.closePromptByClickoff ? "true" : "false");
            window.localStorage.setItem("frostedGlassBackground", this.frostedGlassBackground ? "true" : "false");
            window.localStorage.setItem("pianoKeyboard", this.pianoKeyboard ? "true" : "false");

            window.localStorage.setItem("keyboardLayout", this.keyboardLayout);
            window.localStorage.setItem("bassOffset", String(this.bassOffset));
            window.localStorage.setItem("layout", this.layout);
            window.localStorage.setItem("colorTheme", this.colorTheme);
            window.localStorage.setItem("language", this.language);
            window.localStorage.setItem("customTheme", this.customTheme);
            window.localStorage.setItem("customTheme2", this.customTheme2);
            window.localStorage.setItem("volume", String(this.volume));
            window.localStorage.setItem("visibleOctaves", String(this.visibleOctaves));
        }
    }
    Preferences.defaultVisibleOctaves = 3;

    class ChangeNotifier {
        constructor() {
            this._watchers = [];
            this._dirty = false;
        }
        watch(watcher) {
            if (this._watchers.indexOf(watcher) == -1) {
                this._watchers.push(watcher);
            }
        }
        unwatch(watcher) {
            const index = this._watchers.indexOf(watcher);
            if (index != -1) {
                this._watchers.splice(index, 1);
            }
        }
        changed() {
            this._dirty = true;
        }
        notifyWatchers() {
            if (!this._dirty)
                return;
            this._dirty = false;
            for (const watcher of this._watchers.concat()) {
                watcher();
            }
        }
    }

    class SongDocument { 
        constructor() {
            this.notifier = new ChangeNotifier();
            this.selection = new Selection(this);
            this.prefs = new Preferences();
            this.channel = 0;
            this._pendingPlugin=""
            this.muteEditorChannel = 0;
            this.bar = 0;
            this.recentPatternInstruments = [];
            this.viewedInstrument = [];
            this.recordingModulators = false;
            this.continuingModRecordingChange = null;
            this.trackVisibleBars = 16;
            this.trackVisibleChannels = 4;
            this.barScrollPos = 0;
            this.channelScrollPos = 0;
            this.prompt = null;
            this.addedEffect = false;
            this.addedEnvelope = false;
            this.currentPatternIsDirty = false;
            this._recovery = new SongRecovery();
            this._recentChange = null;
            this._sequenceNumber = 0;
            this._lastSequenceNumber = 0;
            this._stateShouldBePushed = false;
            this._recordedNewSong = false;
            this._waitingToUpdateState = false;
             this._whenHistoryStateChanged = () => {
    	if (this.synth.recording) {
    		this.performance.abortRecording();
    	}
    	if (window.history.state == null && window.location.hash != "") {
    		this._sequenceNumber++;
    		this._resetSongRecoveryUid();
    		const state = { canUndo: true, sequenceNumber: this._sequenceNumber, bar: this.bar, channel: this.channel, instrument: this.viewedInstrument[this.channel], recoveryUid: this._recoveryUid, prompt: null, selection: this.selection.toJSON() };
    		try {
    			new ChangeSong(this, this._getHash());
    		}
    		catch (error) {
    			errorAlert(error);
    		}
    		this.prompt = state.prompt;
    		if (this.prefs.displayBrowserUrl) {
    			this._replaceState(state, this.song.toBase64String());
    		}
    		else {
    			this._pushState(state, this.song.toBase64String());
    		}
    		this.forgetLastChange();
    		this.notifier.notifyWatchers();
    		this.synth.pause();
    		this.synth.goToBar(0);
    		return;
    	}
    	const state = this._getHistoryState();
    	if (state == null)
    		throw new Error("History state is null.");
    	if (state.sequenceNumber == this._sequenceNumber)
    		return;
    	this.bar = state.bar;
    	this.channel = state.channel;
    	this.viewedInstrument[this.channel] = state.instrument;
    	this._sequenceNumber = state.sequenceNumber;
    	this.prompt = state.prompt;
    	try {
    		new ChangeSong(this, this._getHash());
    	}
    	catch (error) {
    		errorAlert(error);
    	}
    	this._recoveryUid = state.recoveryUid;
    	this.selection.fromJSON(state.selection);
    	this.forgetLastChange();
    	this.notifier.notifyWatchers();
    };
            this._cleanDocument = () => {
                this.notifier.notifyWatchers();
            };
            this._cleanDocumentIfNotRecordingMods = () => {
                if (!this.recordingModulators)
                    this.notifier.notifyWatchers();
                else {
                    this.modRecordingHandler();
                }
            };
            this._validateDocState = () => {
                const channelCount = this.song.getChannelCount();
                for (let i = this.recentPatternInstruments.length; i < channelCount; i++) {
                    this.recentPatternInstruments[i] = [0];
                }
                this.recentPatternInstruments.length = channelCount;
                for (let i = 0; i < channelCount; i++) {
                    if (i == this.channel) {
                        if (this.song.patternInstruments) {
                            const pattern = this.song.getPattern(this.channel, this.bar);
                            if (pattern != null) {
                                this.recentPatternInstruments[i] = pattern.instruments.concat();
                            }
                        }
                        else {
                            const channel = this.song.channels[this.channel];
                            for (let j = 0; j < channel.instruments.length; j++) {
                                this.recentPatternInstruments[i][j] = j;
                            }
                            this.recentPatternInstruments[i].length = channel.instruments.length;
                        }
                    }
                    discardInvalidPatternInstruments(this.recentPatternInstruments[i], this.song, i);
                }
                for (let i = this.viewedInstrument.length; i < channelCount; i++) {
                    this.viewedInstrument[i] = 0;
                }
                this.viewedInstrument.length = channelCount;
                for (let i = 0; i < channelCount; i++) {
                    if (this.song.patternInstruments && !this.song.layeredInstruments && i == this.channel) {
                        const pattern = this.song.getPattern(this.channel, this.bar);
                        if (pattern != null) {
                            this.viewedInstrument[i] = pattern.instruments[0];
                        }
                    }
                    this.viewedInstrument[i] = Math.min(this.viewedInstrument[i] | 0, this.song.channels[i].instruments.length - 1);
                }
                const highlightedPattern = this.getCurrentPattern();
                if (highlightedPattern != null && this.song.patternInstruments) {
                    this.recentPatternInstruments[this.channel] = highlightedPattern.instruments.concat();
                }
                if ((!this.synth.playing && (this.bar < this.selection.boxSelectionBar || this.selection.boxSelectionBar + this.selection.boxSelectionWidth <= this.bar)) ||
                    this.channel < this.selection.boxSelectionChannel ||
                    this.selection.boxSelectionChannel + this.selection.boxSelectionHeight <= this.channel ||
                    this.song.barCount < this.selection.boxSelectionBar + this.selection.boxSelectionWidth ||
                    channelCount < this.selection.boxSelectionChannel + this.selection.boxSelectionHeight ||
                    (this.selection.boxSelectionWidth == 1 && this.selection.boxSelectionHeight == 1)) {
                    this.selection.resetBoxSelection();
                }
                this.barScrollPos = Math.max(0, Math.min(this.song.barCount - this.trackVisibleBars, this.barScrollPos));
                this.channelScrollPos = Math.max(0, Math.min(this.song.getChannelCount() - this.trackVisibleChannels, this.channelScrollPos));
            };
            this._updateHistoryState = () => {
                this._waitingToUpdateState = false;
                let hash;
                try {
                    hash = this.song.toBase64String();
                }
                catch (error) {
                    errorAlert(error);
                    return;
                }
                if (this._stateShouldBePushed)
                    this._sequenceNumber++;
                if (this._recordedNewSong) {
                    this._resetSongRecoveryUid();
                }
                else {
                    this._recovery.saveVersion(this._recoveryUid, this.song.title, hash);
                }
                let state = { canUndo: true, sequenceNumber: this._sequenceNumber, bar: this.bar, channel: this.channel, instrument: this.viewedInstrument[this.channel], recoveryUid: this._recoveryUid, prompt: this.prompt, selection: this.selection.toJSON() };
                if (this._stateShouldBePushed) {
                    this._pushState(state, hash);
                }
                else {
                    this._replaceState(state, hash);
                }
                this._stateShouldBePushed = false;
                this._recordedNewSong = false;
            };
            this.notifier.watch(this._validateDocState);
            ColorConfig.setTheme(this.prefs.colorTheme);
            Layout.setLayout(this.prefs.layout);
            if (window.sessionStorage.getItem("currentUndoIndex") == null) {
                window.sessionStorage.setItem("currentUndoIndex", "0");
                window.sessionStorage.setItem("oldestUndoIndex", "0");
                window.sessionStorage.setItem("newestUndoIndex", "0");
            }
            let songString = window.location.hash;
            if (songString == "") {
                songString = this._getHash();
            }
            try {
                this.song = new Song(songString);
                if (songString == "" || songString == undefined) {
                    setDefaultInstruments(this.song);
                    this.song.scale = this.prefs.defaultScale;
                }
            }
            catch (error) {
                errorAlert(error);
            }
            songString = this.song.toBase64String();
            this.synth = new Synth(this.song);
            this.synth.volume = this._calcVolume();
            this.synth.anticipatePoorPerformance = isMobile;
            let state = this._getHistoryState();
            if (state == null) {
                state = { canUndo: false, sequenceNumber: 0, bar: 0, channel: 0, instrument: 0, recoveryUid: generateUid(), prompt: null, selection: this.selection.toJSON() };
            }
            if (state.recoveryUid == undefined)
                state.recoveryUid = generateUid();
            this._replaceState(state, songString);
            window.addEventListener("hashchange", this._whenHistoryStateChanged);
            window.addEventListener("popstate", this._whenHistoryStateChanged);
            this.bar = state.bar | 0;
            this.channel = state.channel | 0;
            for (let i = 0; i <= this.channel; i++)
                this.viewedInstrument[i] = 0;
            this.viewedInstrument[this.channel] = state.instrument | 0;
            this._recoveryUid = state.recoveryUid;
            this.prompt = state.prompt;
            this.selection.fromJSON(state.selection);
            this.selection.scrollToSelectedPattern();
            for (const eventName of ["change", "click", "keyup", "mousedown", "mouseup", "touchstart", "touchmove", "touchend", "touchcancel"]) {
                window.addEventListener(eventName, this._cleanDocument);
            }
            for (const eventName of ["keydown", "input", "mousemove"]) {
                window.addEventListener(eventName, this._cleanDocumentIfNotRecordingMods);
            }
            this._validateDocState();
            this.performance = new SongPerformance(this);
        }
        toggleDisplayBrowserUrl() {
            const state = this._getHistoryState();
            if (state == null)
                throw new Error("History state is null.");
            this.prefs.displayBrowserUrl = !this.prefs.displayBrowserUrl;
            this._replaceState(state, this.song.toBase64String());
        }
        _getHistoryState() {
            if (this.prefs.displayBrowserUrl) {
                return window.history.state;
            }
            else {
                const json = JSON.parse(window.sessionStorage.getItem(window.sessionStorage.getItem("currentUndoIndex")));
                return json == null ? null : json.state;
            }
        }
        _getHash() {
            if (this.prefs.displayBrowserUrl) {
                return window.location.hash;
            }
            else {
                const json = JSON.parse(window.sessionStorage.getItem(window.sessionStorage.getItem("currentUndoIndex")));
                return json == null ? "" : json.hash;
            }
        }
        _replaceState(state, hash) {
            if (this.prefs.displayBrowserUrl) {
                window.history.replaceState(state, "", "#" + hash);
            }
            else {
                window.sessionStorage.setItem(window.sessionStorage.getItem("currentUndoIndex") || "0", JSON.stringify({ state, hash }));
                window.history.replaceState(null, "", location.pathname);
            }
        }
        _pushState(state, hash) {
            if (this.prefs.displayBrowserUrl) {
                window.history.pushState(state, "", "#" + hash);
            }
            else {
                let currentIndex = Number(window.sessionStorage.getItem("currentUndoIndex"));
                let oldestIndex = Number(window.sessionStorage.getItem("oldestUndoIndex"));
                currentIndex = (currentIndex + 1) % SongDocument._maximumUndoHistory;
                window.sessionStorage.setItem("currentUndoIndex", String(currentIndex));
                window.sessionStorage.setItem("newestUndoIndex", String(currentIndex));
                if (currentIndex == oldestIndex) {
                    oldestIndex = (oldestIndex + 1) % SongDocument._maximumUndoHistory;
                    window.sessionStorage.setItem("oldestUndoIndex", String(oldestIndex));
                }
                window.sessionStorage.setItem(String(currentIndex), JSON.stringify({ state, hash }));
                window.history.replaceState(null, "", location.pathname);
            }
            this._lastSequenceNumber = state.sequenceNumber;
        }
        hasRedoHistory() {
            return this._lastSequenceNumber > this._sequenceNumber;
        }
        _forward() {
            if (this.prefs.displayBrowserUrl) {
                window.history.forward();
            }
            else {
                let currentIndex = Number(window.sessionStorage.getItem("currentUndoIndex"));
                let newestIndex = Number(window.sessionStorage.getItem("newestUndoIndex"));
                if (currentIndex != newestIndex) {
                    currentIndex = (currentIndex + 1) % SongDocument._maximumUndoHistory;
                    window.sessionStorage.setItem("currentUndoIndex", String(currentIndex));
                    setTimeout(this._whenHistoryStateChanged);
                }
            }
        }
        _back() {
            if (this.prefs.displayBrowserUrl) {
                window.history.back();
            }
            else {
                let currentIndex = Number(window.sessionStorage.getItem("currentUndoIndex"));
                let oldestIndex = Number(window.sessionStorage.getItem("oldestUndoIndex"));
                if (currentIndex != oldestIndex) {
                    currentIndex = (currentIndex + SongDocument._maximumUndoHistory - 1) % SongDocument._maximumUndoHistory;
                    window.sessionStorage.setItem("currentUndoIndex", String(currentIndex));
                    setTimeout(this._whenHistoryStateChanged);
                }
            }
        }
        record(change, replace = false, newSong = false) {
            if (change.isNoop()) {
                this._recentChange = null;
                if (replace)
                    this._back();
            }
            else {
                change.commit();
                this._recentChange = change;
                this._stateShouldBePushed = this._stateShouldBePushed || !replace;
                this._recordedNewSong = this._recordedNewSong || newSong;
                if (!this._waitingToUpdateState) {
                    window.requestAnimationFrame(this._updateHistoryState);
                    this._waitingToUpdateState = true;
                }
            }
        }
        _resetSongRecoveryUid() {
            this._recoveryUid = generateUid();
        }
        openPrompt(prompt) {
            this.prompt = prompt;
            const hash = this.song.toBase64String();
            this._sequenceNumber++;
            const state = { canUndo: true, sequenceNumber: this._sequenceNumber, bar: this.bar, channel: this.channel, instrument: this.viewedInstrument[this.channel], recoveryUid: this._recoveryUid, prompt: this.prompt, selection: this.selection.toJSON() };
            this._pushState(state, hash);
        }
        undo() {
            const state = this._getHistoryState();
            if (state == null || state.canUndo)
                this._back();
        }
        redo() {
            this._forward();
        }
        setProspectiveChange(change) {
            this._recentChange = change;
        }
        forgetLastChange() {
            this._recentChange = null;
        }
        checkLastChange() {
            return this._recentChange;
        }
        lastChangeWas(change) {
            return change != null && change == this._recentChange;
        }
        goBackToStart() {
            this.bar = 0;
            this.channel = 0;
            this.barScrollPos = 0;
            this.channelScrollPos = 0;
            this.synth.snapToStart();
            this.notifier.changed();
        }
        setVolume(val) {
            this.prefs.volume = val;
            this.prefs.save();
            this.synth.volume = this._calcVolume();
          //  alert(this.synth.volume)
        }
        _calcVolume() {
            return Math.min(1.0, Math.pow(this.prefs.volume / 50.0, 0.5)) * Math.pow(2.0, (this.prefs.volume - 75.0) / 25.0);
        }
        getCurrentPattern(barOffset = 0) {
            return this.song.getPattern(this.channel, this.bar + barOffset);
        }
        getCurrentInstrument(barOffset = 0) {
            if (barOffset == 0) {
                return this.viewedInstrument[this.channel];
            }
            else {
                const pattern = this.getCurrentPattern(barOffset);
                return pattern == null ? 0 : pattern.instruments[0];
            }
        }
        getMobileLayout() {
            return (this.prefs.layout == "wide") ? window.innerWidth <= 1000 : window.innerWidth <= 71;
        }
        getBarWidth() {
            return (!this.getMobileLayout() && this.prefs.enableChannelMuting && (!this.getFullScreen() || this.prefs.layout == "wide")) ? 30 : 32;
        }
        getChannelHeight() {
            const squashed = this.getMobileLayout() || this.song.getChannelCount() > 4 || (this.song.barCount > this.trackVisibleBars && this.song.getChannelCount() > 3);
            const megaSquashed = !this.getMobileLayout() && (((this.prefs.layout != "wide") && this.song.getChannelCount() > 11) || this.song.getChannelCount() > 22);
            return megaSquashed ? 23 : (squashed ? 27 : 32);
        }
        getFullScreen() {
            return !this.getMobileLayout() && (this.prefs.layout != "small");
        }
        getVisibleOctaveCount() {
            return this.getFullScreen() ? this.prefs.visibleOctaves : Preferences.defaultVisibleOctaves;
        }
        getVisiblePitchCount() {
            return this.getVisibleOctaveCount() * Config.pitchesPerOctave + 1;
        }
        getBaseVisibleOctave(channel) {
            const visibleOctaveCount = this.getVisibleOctaveCount();
            return Math.max(0, Math.min(Config.pitchOctaves - visibleOctaveCount, Math.ceil(this.song.channels[channel].octave - visibleOctaveCount * 0.5)));
        }
    }
    SongDocument._maximumUndoHistory = 300;

    function transfer(source, length) {
        const dest = new ArrayBuffer(length);
        let nextOffset = 0;
        let leftBytes = Math.min(source.byteLength, dest.byteLength);
        const wordSizes = [8, 4, 2, 1];
        for (const wordSize of wordSizes) {
            if (leftBytes >= wordSize) {
                const done = transferWith(wordSize, source, dest, nextOffset, leftBytes);
                nextOffset = done.nextOffset;
                leftBytes = done.leftBytes;
            }
        }
        return dest;
        function transferWith(wordSize, source, dest, nextOffset, leftBytes) {
            let ViewClass = Uint8Array;
            switch (wordSize) {
                case 8:
                    ViewClass = Float64Array;
                    break;
                case 4:
                    ViewClass = Float32Array;
                    break;
                case 2:
                    ViewClass = Uint16Array;
                    break;
                case 1:
                    ViewClass = Uint8Array;
                    break;
                default:
                    ViewClass = Uint8Array;
                    break;
            }
            const view_source = new ViewClass(source, nextOffset, (leftBytes / wordSize) | 0);
            const view_dest = new ViewClass(dest, nextOffset, (leftBytes / wordSize) | 0);
            for (let i = 0; i < view_dest.length; i++) {
                view_dest[i] = view_source[i];
            }
            return {
                nextOffset: view_source.byteOffset + view_source.byteLength,
                leftBytes: leftBytes - view_dest.length * wordSize,
            };
        }
    }
    class ArrayBufferWriter {
        constructor(initialCapacity) {
            this._writeIndex = 0;
            this._fileSize = 0;
            this._arrayBuffer = new ArrayBuffer(initialCapacity);
            this._data = new DataView(this._arrayBuffer);
        }
        _addBytes(numBytes) {
            this._fileSize += numBytes;
            if (this._fileSize > this._arrayBuffer.byteLength) {
                this._arrayBuffer = transfer(this._arrayBuffer, Math.max(this._arrayBuffer.byteLength * 2, this._fileSize));
                this._data = new DataView(this._arrayBuffer);
            }
        }
        getWriteIndex() {
            return this._writeIndex;
        }
        rewriteUint32(index, value) {
            this._data.setUint32(index, value >>> 0, false);
        }
        writeUint32(value) {
            value = value >>> 0;
            this._addBytes(4);
            this._data.setUint32(this._writeIndex, value, false);
            this._writeIndex = this._fileSize;
        }
        writeUint24(value) {
            value = value >>> 0;
            this._addBytes(3);
            this._data.setUint8(this._writeIndex, (value >> 16) & 0xff);
            this._data.setUint8(this._writeIndex + 1, (value >> 8) & 0xff);
            this._data.setUint8(this._writeIndex + 2, (value) & 0xff);
            this._writeIndex = this._fileSize;
        }
        writeUint16(value) {
            value = value >>> 0;
            this._addBytes(2);
            this._data.setUint16(this._writeIndex, value, false);
            this._writeIndex = this._fileSize;
        }
        writeUint8(value) {
            value = value >>> 0;
            this._addBytes(1);
            this._data.setUint8(this._writeIndex, value);
            this._writeIndex = this._fileSize;
        }
        writeInt8(value) {
            value = value | 0;
            this._addBytes(1);
            this._data.setInt8(this._writeIndex, value);
            this._writeIndex = this._fileSize;
        }
        writeMidi7Bits(value) {
            value = value >>> 0;
            if (value >= 0x80)
                throw new Error("7 bit value contained 8th bit!");
            this._addBytes(1);
            this._data.setUint8(this._writeIndex, value);
            this._writeIndex = this._fileSize;
        }
        writeMidiVariableLength(value) {
            value = value >>> 0;
            if (value > 0x0fffffff)
                throw new Error("writeVariableLength value too big.");
            let startWriting = false;
            for (let i = 0; i < 4; i++) {
                const shift = 21 - i * 7;
                const bits = (value >>> shift) & 0x7f;
                if (bits != 0 || i == 3)
                    startWriting = true;
                if (startWriting)
                    this.writeUint8((i == 3 ? 0x00 : 0x80) | bits);
            }
        }
        writeMidiAscii(string) {
            this.writeMidiVariableLength(string.length);
            for (let i = 0; i < string.length; i++) {
                const charCode = string.charCodeAt(i);
                if (charCode > 0x7f)
                    throw new Error("Trying to write unicode character as ascii.");
                this.writeUint8(charCode);
            }
        }
        toCompactArrayBuffer() {
            return transfer(this._arrayBuffer, this._fileSize);
        }
    }

    const defaultMidiExpression = 0x7F;
    const defaultMidiPitchBend = 0x2000;
    const analogousDrumMap = {
        35: { frequency: 0, duration: 2, volume: 3 },
        36: { frequency: 0, duration: 2, volume: 3 },
        37: { frequency: 5, duration: 1, volume: 3 },
        38: { frequency: 4, duration: 2, volume: 3 },
        39: { frequency: 5, duration: 2, volume: 3 },
        40: { frequency: 4, duration: 2, volume: 3 },
        41: { frequency: 1, duration: 2, volume: 3 },
        42: { frequency: 8, duration: 1, volume: 3 },
        43: { frequency: 1, duration: 2, volume: 3 },
        44: { frequency: 8, duration: 1, volume: 2 },
        45: { frequency: 2, duration: 2, volume: 3 },
        46: { frequency: 8, duration: 4, volume: 3 },
        47: { frequency: 2, duration: 2, volume: 3 },
        48: { frequency: 3, duration: 2, volume: 3 },
        49: { frequency: 7, duration: 4, volume: 3 },
        50: { frequency: 3, duration: 2, volume: 3 },
        51: { frequency: 6, duration: 4, volume: 2 },
        52: { frequency: 7, duration: 4, volume: 3 },
        53: { frequency: 6, duration: 2, volume: 3 },
        54: { frequency: 11, duration: 2, volume: 3 },
        55: { frequency: 9, duration: 4, volume: 3 },
        56: { frequency: 7, duration: 1, volume: 2 },
        57: { frequency: 7, duration: 4, volume: 3 },
        58: { frequency: 10, duration: 2, volume: 2 },
        59: { frequency: 6, duration: 4, volume: 3 },
        69: { frequency: 10, duration: 2, volume: 3 },
        70: { frequency: 10, duration: 2, volume: 3 },
        73: { frequency: 10, duration: 1, volume: 2 },
        74: { frequency: 10, duration: 2, volume: 2 },
    };
    function midiVolumeToVolumeMult(volume) {
        return Math.pow(volume / 127, 4.0) / 0.3844015376046128;
    }
    function volumeMultToMidiVolume(volumeMult) {
        return Math.pow(volumeMult * 0.3844015376046128, 0.25) * 127;
    }
    function midiExpressionToVolumeMult(expression) {
        return Math.pow(expression / 127, 4.0);
    }
    function volumeMultToMidiExpression(volumeMult) {
        return Math.pow(volumeMult, 0.25) * 127;
    }

    const { button: button$o, div: div$o, h2: h2$n, input: input$h, select: select$d, option: option$d } = HTML;
    function lerp(low, high, t) {
        return low + t * (high - low);
    }
    
    function blobToBase64(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => {
			const base64data = reader.result.split(',')[1];
			resolve(base64data);
		};
		reader.onerror = reject;
		reader.readAsDataURL(blob);
	});
}
 function save(blob, name, text, jsontype) {
     if (location.href.startsWith("file:///")) {
 if (jsontype) {
  NativeJava.DownloadText((text), name);
 } else {
  try {
   blobToBase64(blob).then(base64data => { 
    NativeJava.DownloadFile(base64data, name);
   });
  } catch (e) {
   alert(e)
  }
 }
} else {
        if (navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, name);
            return;
        }
        const anchor = document.createElement("a");
        if (anchor.download != undefined) {
            const url = URL.createObjectURL(blob);
            setTimeout(function () { URL.revokeObjectURL(url); }, 60000);
            anchor.href = url;
            anchor.download = name;
            setTimeout(function () { anchor.dispatchEvent(new MouseEvent("click")); }, 0);
        }
        else {
            const url = URL.createObjectURL(blob);
            setTimeout(function () { URL.revokeObjectURL(url); }, 60000);
            if (!window.open(url, "_blank"))
                window.location.href = url;
        }
    }
}
    class ExportPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this.outputStarted = false;
            this._fileName = input$h({ type: "text", style: "width: 10em;", value: Config.jsonFormat + "-Song", maxlength: 250, "autofocus": "autofocus" });
            this._computedSamplesLabel = div$o({ style: "width: 10em;" }, new Text("0:00"));
            this._enableIntro = input$h({ type: "checkbox" });
            this._loopDropDown = input$h({ style: "width: 2em;", type: "number", min: "1", max: "4", step: "1" });
            this._enableOutro = input$h({ type: "checkbox" });
            this._formatSelect = select$d({ style: "width: 100%;" }, option$d({ value: "wav" }, "Export to .wav file."), option$d({ value: "mp3" }, "Export to .mp3 file."), option$d({ value: "midi" }, "Export to .mid file."), option$d({ value: "json" }, "Export to .json file."), option$d({ value: "html" }, "Export to .html file."));
            this._removeWhitespace = input$h({ type: "checkbox" });
            this._removeWhitespaceDiv = div$o({ style: "vertical-align: middle; align-items: center; justify-content: space-between; margin-bottom: 14px;" }, "Remove Whitespace: ", this._removeWhitespace);
            this._cancelButton = button$o({ class: "cancelButton" });
            this._exportButton = button$o({ class: "exportButton", style: "width:45%;" }, "Export");
            this._outputProgressBar = div$o({ style: `width: 0%; background: ${ColorConfig.loopAccent}; height: 100%; position: absolute; z-index: 2;` });
            this._outputProgressLabel = div$o({ style: `position: relative; top: -1px; z-index: 3;` }, "0%");
            this._outputProgressContainer = div$o({ style: `height: 12px; background: ${ColorConfig.uiWidgetBackground}; display: block; position: relative; z-index: 1;` }, this._outputProgressBar, this._outputProgressLabel);
            this.container = div$o({ class: "prompt noSelection", style: "width: 200px;" }, h2$n("Export Options"), div$o({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "File name:", this._fileName), div$o({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "Length:", this._computedSamplesLabel), div$o({ style: "display: table; width: 100%;" }, div$o({ style: "display: table-row;" }, div$o({ style: "display: table-cell;" }, "Intro:"), div$o({ style: "display: table-cell;" }, "Loop Count:"), div$o({ style: "display: table-cell;" }, "Outro:")), div$o({ style: "display: table-row;" }, div$o({ style: "display: table-cell; vertical-align: middle;" }, this._enableIntro), div$o({ style: "display: table-cell; vertical-align: middle;" }, this._loopDropDown), div$o({ style: "display: table-cell; vertical-align: middle;" }, this._enableOutro))), div$o({ class: "selectContainer", style: "width: 100%;" }, this._formatSelect), this._removeWhitespaceDiv, div$o({ style: "text-align: left;" }, "Exporting can be slow. Reloading the page or clicking the X will cancel it. Please be patient."), this._outputProgressContainer, div$o({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._exportButton), this._cancelButton);
            this._close = () => {
                if (this.synth != null)
                    this.synth.renderingSong = false;
                this.outputStarted = false;
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._fileName.removeEventListener("input", ExportPrompt._validateFileName);
                this._loopDropDown.removeEventListener("blur", ExportPrompt._validateNumber);
                this._exportButton.removeEventListener("click", this._export);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._export();
                }
            };
            this._export = () => {
                if (this.outputStarted == true)
                    return;
                window.localStorage.setItem("exportFormat", this._formatSelect.value);
                window.localStorage.setItem("exportWhitespace", this._removeWhitespace.value);
                switch (this._formatSelect.value) {
                    case "wav":
                        this.outputStarted = true;
                        this._exportTo("wav");
                        break;
                    case "mp3":
                        this.outputStarted = true;
                        this._exportTo("mp3");
                        break;
                    case "midi":
                        this.outputStarted = true;
                        this._exportToMidi();
                        break;
                    case "json":
                        this.outputStarted = true;
                        this._exportToJson();
                        break;
                    case "html":
                        this._exportToHtml();
                        break;
                    default:
                        throw new Error("Unhandled file export type.");
                }
            };
            this._loopDropDown.value = "1";
            if (this._doc.song.loopStart == 0) {
                this._enableIntro.checked = false;
                this._enableIntro.disabled = true;
            }
            else {
                this._enableIntro.checked = true;
                this._enableIntro.disabled = false;
            }
            if (this._doc.song.loopStart + this._doc.song.loopLength == this._doc.song.barCount) {
                this._enableOutro.checked = false;
                this._enableOutro.disabled = true;
            }
            else {
                this._enableOutro.checked = true;
                this._enableOutro.disabled = false;
            }
            const lastExportFormat = window.localStorage.getItem("exportFormat");
            if (lastExportFormat != null) {
                this._formatSelect.value = lastExportFormat;
            }
            const lastExportWhitespace = window.localStorage.getItem("exportWhitespace") != "false";
            if (lastExportWhitespace != null) {
                this._removeWhitespace.checked = lastExportWhitespace;
            }
            if (this._formatSelect.value == "json") {
                this._removeWhitespaceDiv.style.display = "block";
            }
            else {
                this._removeWhitespaceDiv.style.display = "none";
            }
            this._fileName.select();
            setTimeout(() => this._fileName.focus());
            this._fileName.addEventListener("input", ExportPrompt._validateFileName);
            this._loopDropDown.addEventListener("blur", ExportPrompt._validateNumber);
            this._exportButton.addEventListener("click", this._export);
            this._cancelButton.addEventListener("click", this._close);
            this._enableOutro.addEventListener("click", () => { this._computedSamplesLabel.firstChild.textContent = ExportPrompt.samplesToTime(this._doc, this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1)); });
            this._enableIntro.addEventListener("click", () => { this._computedSamplesLabel.firstChild.textContent = ExportPrompt.samplesToTime(this._doc, this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1)); });
            this._loopDropDown.addEventListener("change", () => { this._computedSamplesLabel.firstChild.textContent = ExportPrompt.samplesToTime(this._doc, this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1)); });
            this._formatSelect.addEventListener("change", () => { if (this._formatSelect.value == "json") {
                this._removeWhitespaceDiv.style.display = "block";
            }
            else {
                this._removeWhitespaceDiv.style.display = "none";
            } });
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._fileName.value = _doc.song.title;
            ExportPrompt._validateFileName(null, this._fileName);
            this._computedSamplesLabel.firstChild.textContent = ExportPrompt.samplesToTime(this._doc, this._doc.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, +this._loopDropDown.value - 1));
        }
        static samplesToTime(_doc, samples) {
            const rawSeconds = Math.round(samples / _doc.synth.samplesPerSecond);
            const seconds = rawSeconds % 60;
            const minutes = Math.floor(rawSeconds / 60);
            return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
        }
        changeFileName(newValue) {
            this._fileName.value = newValue;
        }
        static _validateFileName(event, use) {
            let input;
            if (event != null) {
                input = event.target;
            }
            else if (use != undefined) {
                input = use;
            }
            else {
                return;
            }
            const deleteChars = /[\+\*\$\?\|\{\}\\\/<>#%!`&'"=:@]/gi;
            if (deleteChars.test(input.value)) {
                let cursorPos = input.selectionStart;
                input.value = input.value.replace(deleteChars, "");
                cursorPos--;
                input.setSelectionRange(cursorPos, cursorPos);
            }
        }
        static _validateNumber(event) {
            const input = event.target;
            input.value = Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value)))) + "";
        }
        _synthesize() {
            if (this.outputStarted == false) {
                return;
            }
            const samplesPerChunk = this.synth.samplesPerSecond * 5;
            const currentFrame = this.currentChunk * samplesPerChunk;
            const samplesInChunk = Math.min(samplesPerChunk, this.sampleFrames - currentFrame);
            const tempSamplesL = new Float32Array(samplesInChunk);
            const tempSamplesR = new Float32Array(samplesInChunk);
            this.synth.renderingSong = true;
            this.synth.synthesize(tempSamplesL, tempSamplesR, samplesInChunk);
            this.recordedSamplesL.set(tempSamplesL, currentFrame);
            this.recordedSamplesR.set(tempSamplesR, currentFrame);
            this._outputProgressBar.style.setProperty("width", Math.round((this.currentChunk + 1) / this.totalChunks * 100.0) + "%");
            this._outputProgressLabel.innerText = Math.round((this.currentChunk + 1) / this.totalChunks * 100.0) + "%";
            this.currentChunk++;
            if (this.currentChunk >= this.totalChunks) {
                this.synth.renderingSong = false;
                this._outputProgressLabel.innerText = "Encoding...";
                if (this.thenExportTo == "wav") {
                    this._exportToWavFinish();
                }
                else if (this.thenExportTo == "mp3") {
                    this._exportToMp3Finish();
                }
                else {
                    throw new Error("Unrecognized file export type chosen!");
                }
            }
            else {
                setTimeout(() => { this._synthesize(); });
            }
        }
        _exportTo(type) {
            this.thenExportTo = type;
            this.currentChunk = 0;
            this.synth = new Synth(this._doc.song);
            if (type == "wav") {
                this.synth.samplesPerSecond = 48000;
            }
            else if (type == "mp3") {
                this.synth.samplesPerSecond = 44100;
            }
            else {
                throw new Error("Unrecognized file export type chosen!");
            }
            this._outputProgressBar.style.setProperty("width", "0%");
            this._outputProgressLabel.innerText = "0%";
            this.synth.loopRepeatCount = Number(this._loopDropDown.value) - 1;
            if (!this._enableIntro.checked) {
                for (let introIter = 0; introIter < this._doc.song.loopStart; introIter++) {
                    this.synth.goToNextBar();
                }
            }
            this.synth.initModFilters(this._doc.song);
            this.synth.computeLatestModValues();
            this.synth.warmUpSynthesizer(this._doc.song);
            this.sampleFrames = this.synth.getTotalSamples(this._enableIntro.checked, this._enableOutro.checked, this.synth.loopRepeatCount);
            this.totalChunks = Math.ceil(this.sampleFrames / (this.synth.samplesPerSecond * 5));
            this.recordedSamplesL = new Float32Array(this.sampleFrames);
            this.recordedSamplesR = new Float32Array(this.sampleFrames);
            setTimeout(() => { this._synthesize(); });
        }
        _exportToWavFinish() {
            const sampleFrames = this.recordedSamplesL.length;
            const sampleRate = this.synth.samplesPerSecond;
            const wavChannelCount = 2;
            const bytesPerSample = 2;
            const bitsPerSample = 8 * bytesPerSample;
            const sampleCount = wavChannelCount * sampleFrames;
            const totalFileSize = 44 + sampleCount * bytesPerSample;
            let index = 0;
            const arrayBuffer = new ArrayBuffer(totalFileSize);
            const data = new DataView(arrayBuffer);
            data.setUint32(index, 0x52494646, false);
            index += 4;
            data.setUint32(index, 36 + sampleCount * bytesPerSample, true);
            index += 4;
            data.setUint32(index, 0x57415645, false);
            index += 4;
            data.setUint32(index, 0x666D7420, false);
            index += 4;
            data.setUint32(index, 0x00000010, true);
            index += 4;
            data.setUint16(index, 0x0001, true);
            index += 2;
            data.setUint16(index, wavChannelCount, true);
            index += 2;
            data.setUint32(index, sampleRate, true);
            index += 4;
            data.setUint32(index, sampleRate * bytesPerSample * wavChannelCount, true);
            index += 4;
            data.setUint16(index, bytesPerSample * wavChannelCount, true);
            index += 2;
            data.setUint16(index, bitsPerSample, true);
            index += 2;
            data.setUint32(index, 0x64617461, false);
            index += 4;
            data.setUint32(index, sampleCount * bytesPerSample, true);
            index += 4;
            {
                const range = (1 << (bitsPerSample - 1)) - 1;
                for (let i = 0; i < sampleFrames; i++) {
                    let valL = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesL[i])) * range);
                    let valR = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesR[i])) * range);
                    {
                        data.setInt16(index, valL, true);
                        index += 2;
                        data.setInt16(index, valR, true);
                        index += 2;
                    }
                }
            }
            const blob = new Blob([arrayBuffer], { type: "audio/wav" });
            save(blob, this._fileName.value.trim() + ".wav",[arrayBuffer] );
            this._close();
        }
        _exportToMp3Finish() {
            const whenEncoderIsAvailable = () => {
                const lamejs = window["lamejs"];
                const channelCount = 2;
                const kbps = 192;
                const sampleBlockSize = 1152;
                const mp3encoder = new lamejs.Mp3Encoder(channelCount, this.synth.samplesPerSecond, kbps);
                const mp3Data = [];
                const left = new Int16Array(this.recordedSamplesL.length);
                const right = new Int16Array(this.recordedSamplesR.length);
                const range = (1 << 15) - 1;
                for (let i = 0; i < this.recordedSamplesL.length; i++) {
                    left[i] = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesL[i])) * range);
                    right[i] = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesR[i])) * range);
                }
                for (let i = 0; i < left.length; i += sampleBlockSize) {
                    const leftChunk = left.subarray(i, i + sampleBlockSize);
                    const rightChunk = right.subarray(i, i + sampleBlockSize);
                    const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                    if (mp3buf.length > 0)
                        mp3Data.push(mp3buf);
                }
                const mp3buf = mp3encoder.flush();
                if (mp3buf.length > 0)
                    mp3Data.push(mp3buf);
                const blob = new Blob(mp3Data, { type: "audio/mp3" });
                save(blob, this._fileName.value.trim() + ".mp3",[mp3Data]);
                this._close();
            };
            if ("lamejs" in window) {
                whenEncoderIsAvailable();
            }
            else {
                var script = document.createElement("script");
                script.src = "https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js";
                script.onload = whenEncoderIsAvailable;
                document.head.appendChild(script);
            }
        }
        _exportToMidi() {
            const song = this._doc.song;
            const midiTicksPerBeepBoxTick = 2;
            const midiTicksPerBeat = midiTicksPerBeepBoxTick * Config.ticksPerPart * Config.partsPerBeat;
            const midiTicksPerPart = midiTicksPerBeepBoxTick * Config.ticksPerPart;
            const secondsPerMinute = 60;
            const microsecondsPerMinute = secondsPerMinute * 1000000;
            const beatsPerMinute = song.getBeatsPerMinute();
            const microsecondsPerBeat = Math.round(microsecondsPerMinute / beatsPerMinute);
            const midiTicksPerBar = midiTicksPerBeat * song.beatsPerBar;
            const pitchBendRange = 24;
            const defaultNoteVelocity = 90;
            const unrolledBars = [];
            if (this._enableIntro.checked) {
                for (let bar = 0; bar < song.loopStart; bar++) {
                    unrolledBars.push(bar);
                }
            }
            for (let loopIndex = 0; loopIndex < Number(this._loopDropDown.value); loopIndex++) {
                for (let bar = song.loopStart; bar < song.loopStart + song.loopLength; bar++) {
                    unrolledBars.push(bar);
                }
            }
            if (this._enableOutro.checked) {
                for (let bar = song.loopStart + song.loopLength; bar < song.barCount; bar++) {
                    unrolledBars.push(bar);
                }
            }
            const tracks = [{ isMeta: true, channel: -1, midiChannel: -1, isNoise: false, isDrumset: false }];
            let midiChannelCounter = 0;
            let foundADrumset = false;
            for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                if (!foundADrumset && this._doc.song.channels[channel].instruments[0].type == 4) {
                    tracks.push({ isMeta: false, channel: channel, midiChannel: 9, isNoise: true, isDrumset: true });
                    foundADrumset = true;
                }
                else {
                    if (midiChannelCounter >= 16)
                        continue;
                    tracks.push({ isMeta: false, channel: channel, midiChannel: midiChannelCounter++, isNoise: this._doc.song.getChannelIsNoise(channel), isDrumset: false });
                    if (midiChannelCounter == 9)
                        midiChannelCounter++;
                }
            }
            const writer = new ArrayBufferWriter(1024);
            writer.writeUint32(1297377380);
            writer.writeUint32(6);
            writer.writeUint16(1);
            writer.writeUint16(tracks.length);
            writer.writeUint16(midiTicksPerBeat);
            for (const track of tracks) {
                writer.writeUint32(1297379947);
                const { isMeta, channel, midiChannel, isNoise, isDrumset } = track;
                const trackStartIndex = writer.getWriteIndex();
                writer.writeUint32(0);
                let prevTime = 0;
                let barStartTime = 0;
                const writeEventTime = function (time) {
                    if (time < prevTime)
                        throw new Error("Midi event time cannot go backwards.");
                    writer.writeMidiVariableLength(time - prevTime);
                    prevTime = time;
                };
                const writeControlEvent = function (message, value) {
                    if (!(value >= 0 && value <= 0x7F))
                        throw new Error("Midi control event value out of range: " + value);
                    writer.writeUint8(176 | midiChannel);
                    writer.writeMidi7Bits(message);
                    writer.writeMidi7Bits(value | 0);
                };
                if (isMeta) {
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(1);
                    writer.writeMidiAscii("Composed with jummbus.bitbucket.io");
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(81);
                    writer.writeMidiVariableLength(3);
                    writer.writeUint24(microsecondsPerBeat);
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(88);
                    writer.writeMidiVariableLength(4);
                    writer.writeUint8(song.beatsPerBar);
                    writer.writeUint8(2);
                    writer.writeUint8(24);
                    writer.writeUint8(8);
                    let tempScale = song.scale == Config.scales.dictionary["Custom"].index ? song.scaleCustom : Config.scales[song.scale].flags;
                    const isMinor = tempScale[3] && !tempScale[4];
                    const key = song.key;
                    let numSharps = key;
                    if ((key & 1) == 1)
                        numSharps += 6;
                    if (isMinor)
                        numSharps += 9;
                    while (numSharps > 6)
                        numSharps -= 12;
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(89);
                    writer.writeMidiVariableLength(2);
                    writer.writeInt8(numSharps);
                    writer.writeUint8(isMinor ? 1 : 0);
                    if (this._enableIntro.checked)
                        barStartTime += midiTicksPerBar * song.loopStart;
                    writeEventTime(barStartTime);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(6);
                    writer.writeMidiAscii("Loop Start");
                    for (let loopIndex = 0; loopIndex < parseInt(this._loopDropDown.value); loopIndex++) {
                        barStartTime += midiTicksPerBar * song.loopLength;
                        writeEventTime(barStartTime);
                        writer.writeUint8(255);
                        writer.writeMidi7Bits(6);
                        writer.writeMidiAscii(loopIndex < Number(this._loopDropDown.value) - 1 ? "Loop Repeat" : "Loop End");
                    }
                    if (this._enableOutro.checked)
                        barStartTime += midiTicksPerBar * (song.barCount - song.loopStart - song.loopLength);
                    if (barStartTime != midiTicksPerBar * unrolledBars.length)
                        throw new Error("Miscalculated number of bars.");
                }
                else {
                    let channelName = isNoise
                        ? "noise channel " + channel
                        : "pitch channel " + channel;
                    writeEventTime(0);
                    writer.writeUint8(255);
                    writer.writeMidi7Bits(3);
                    writer.writeMidiAscii(channelName);
                    writeEventTime(0);
                    writeControlEvent(101, 0);
                    writeEventTime(0);
                    writeControlEvent(100, 0);
                    writeEventTime(0);
                    writeControlEvent(6, pitchBendRange);
                    writeEventTime(0);
                    writeControlEvent(38, 0);
                    writeEventTime(0);
                    writeControlEvent(101, 127);
                    writeEventTime(0);
                    writeControlEvent(100, 127);
                    let prevInstrumentIndex = -1;
                    function writeInstrumentSettings(instrumentIndex) {
                        const instrument = song.channels[channel].instruments[instrumentIndex];
                        const preset = EditorConfig.valueToPreset(instrument.preset);
                        if (prevInstrumentIndex != instrumentIndex) {
                            prevInstrumentIndex = instrumentIndex;
                            writeEventTime(barStartTime);
                            writer.writeUint8(255);
                            writer.writeMidi7Bits(4);
                            writer.writeMidiAscii("Instrument " + (instrumentIndex + 1));
                            if (!isDrumset) {
                                let instrumentProgram = 81;
                                if (preset != null && preset.midiProgram != undefined) {
                                    instrumentProgram = preset.midiProgram;
                                }
                                else if (instrument.type == 4) {
                                    instrumentProgram = 116;
                                }
                                else {
                                    if (instrument.type == 2 || instrument.type == 3) {
                                        if (isNoise) {
                                            instrumentProgram = 116;
                                        }
                                        else {
                                            instrumentProgram = 75;
                                        }
                                    }
                                    else if (instrument.type == 0) {
                                        if (ExportPrompt.midiChipInstruments.length > instrument.chipWave) {
                                            instrumentProgram = ExportPrompt.midiChipInstruments[instrument.chipWave];
                                        }
                                    }
                                    else if (instrument.type == 6 || instrument.type == 1 || instrument.type == 11 || instrument.type == 5 || instrument.type == 8) {
                                        instrumentProgram = 81;
                                    }
                                    else if ( instrument.type == 12) {
                                        instrumentProgram = 81;
                                    }
                                    else if (instrument.type == 7) {
                                        instrumentProgram = 0x19;
                                    }
                                    else if (instrument.type == 9) {
                                        instrumentProgram = 81;
                                    }
                                    else {
                                        throw new Error("Unrecognized instrument type.");
                                    }
                                }
                                writeEventTime(barStartTime);
                                writer.writeUint8(192 | midiChannel);
                                writer.writeMidi7Bits(instrumentProgram);
                            }
                            writeEventTime(barStartTime);
                            let instrumentVolume = volumeMultToMidiVolume(Synth.instrumentVolumeToVolumeMult(instrument.volume));
                            writeControlEvent(7, Math.min(0x7f, Math.round(instrumentVolume)));
                            writeEventTime(barStartTime);
                            let instrumentPan = (instrument.pan / Config.panCenter - 1) * 0x3f + 0x40;
                            writeControlEvent(10, Math.min(0x7f, Math.round(instrumentPan)));
                        }
                    }
                    if (song.getPattern(channel, 0) == null) {
                        writeInstrumentSettings(0);
                    }
                    let prevPitchBend = defaultMidiPitchBend;
                    let prevExpression = defaultMidiExpression;
                    let shouldResetExpressionAndPitchBend = false;
                    const channelRoot = isNoise ? Config.spectrumBasePitch : Config.keys[song.key].basePitch;
                    const intervalScale = isNoise ? Config.noiseInterval : 1;
                    for (const bar of unrolledBars) {
                        const pattern = song.getPattern(channel, bar);
                        if (pattern != null) {
                            const instrumentIndex = pattern.instruments[0];
                            const instrument = song.channels[channel].instruments[instrumentIndex];
                            const preset = EditorConfig.valueToPreset(instrument.preset);
                            writeInstrumentSettings(instrumentIndex);
                            let usesArpeggio = instrument.getChord().arpeggiates;
                            let polyphony = usesArpeggio ? 1 : Config.maxChordSize;
                            if (instrument.getChord().customInterval) {
                                if (instrument.type == 0 || instrument.type == 5) {
                                    polyphony = 2;
                                    usesArpeggio = true;
                                }
                                else if (instrument.type == 1) {
                                    polyphony = Config.operatorCount;
                                }
                                else {
                                    console.error("Unrecognized instrument type for harmonizing arpeggio: " + instrument.type);
                                }
                            }
                            for (let noteIndex = 0; noteIndex < pattern.notes.length; noteIndex++) {
                                const note = pattern.notes[noteIndex];
                                const noteStartTime = barStartTime + note.start * midiTicksPerPart;
                                let pinTime = noteStartTime;
                                let pinSize = note.pins[0].size;
                                let pinInterval = note.pins[0].interval;
                                const prevPitches = [-1, -1, -1, -1];
                                const nextPitches = [-1, -1, -1, -1];
                                const toneCount = Math.min(polyphony, note.pitches.length);
                                const velocity = isDrumset ? Math.max(1, Math.round(defaultNoteVelocity * note.pins[0].size / Config.noteSizeMax)) : defaultNoteVelocity;
                                let mainInterval = note.pickMainInterval();
                                let pitchOffset = mainInterval * intervalScale;
                                if (!isDrumset) {
                                    let maxPitchOffset = pitchBendRange;
                                    let minPitchOffset = -pitchBendRange;
                                    for (let pinIndex = 1; pinIndex < note.pins.length; pinIndex++) {
                                        const interval = note.pins[pinIndex].interval * intervalScale;
                                        maxPitchOffset = Math.min(maxPitchOffset, interval + pitchBendRange);
                                        minPitchOffset = Math.max(minPitchOffset, interval - pitchBendRange);
                                    }
                                    pitchOffset = Math.min(maxPitchOffset, Math.max(minPitchOffset, pitchOffset));
                                }
                                for (let pinIndex = 1; pinIndex < note.pins.length; pinIndex++) {
                                    const nextPinTime = noteStartTime + note.pins[pinIndex].time * midiTicksPerPart;
                                    const nextPinSize = note.pins[pinIndex].size;
                                    const nextPinInterval = note.pins[pinIndex].interval;
                                    const length = nextPinTime - pinTime;
                                    for (let midiTick = 0; midiTick < length; midiTick++) {
                                        const midiTickTime = pinTime + midiTick;
                                        const linearSize = lerp(pinSize, nextPinSize, midiTick / length);
                                        const linearInterval = lerp(pinInterval, nextPinInterval, midiTick / length);
                                        const interval = linearInterval * intervalScale - pitchOffset;
                                        const pitchBend = Math.max(0, Math.min(0x3fff, Math.round(0x2000 * (1.0 + interval / pitchBendRange))));
                                        const expression = Math.min(0x7f, Math.round(volumeMultToMidiExpression(Synth.noteSizeToVolumeMult(linearSize))));
                                        if (pitchBend != prevPitchBend) {
                                            writeEventTime(midiTickTime);
                                            writer.writeUint8(224 | midiChannel);
                                            writer.writeMidi7Bits(pitchBend & 0x7f);
                                            writer.writeMidi7Bits((pitchBend >> 7) & 0x7f);
                                            prevPitchBend = pitchBend;
                                        }
                                        if (expression != prevExpression && !isDrumset) {
                                            writeEventTime(midiTickTime);
                                            writeControlEvent(11, expression);
                                            prevExpression = expression;
                                        }
                                        const noteStarting = midiTickTime == noteStartTime;
                                        for (let toneIndex = 0; toneIndex < toneCount; toneIndex++) {
                                            let nextPitch = note.pitches[toneIndex];
                                            if (isDrumset) {
                                                nextPitch += mainInterval;
                                                const drumsetMap = [
                                                    36,
                                                    41,
                                                    45,
                                                    48,
                                                    40,
                                                    39,
                                                    59,
                                                    49,
                                                    46,
                                                    55,
                                                    69,
                                                    54,
                                                ];
                                                if (nextPitch < 0 || nextPitch >= drumsetMap.length)
                                                    throw new Error("Could not find corresponding drumset pitch. " + nextPitch);
                                                nextPitch = drumsetMap[nextPitch];
                                            }
                                            else {
                                                if (usesArpeggio && note.pitches.length > toneIndex + 1 && toneIndex == toneCount - 1) {
                                                    const midiTicksSinceBeat = (midiTickTime - barStartTime) % midiTicksPerBeat;
                                                    const midiTicksPerArpeggio = Config.ticksPerArpeggio * midiTicksPerPart / Config.ticksPerPart;
                                                    const arpeggio = Math.floor(midiTicksSinceBeat / midiTicksPerArpeggio);
                                                    nextPitch = note.pitches[toneIndex + getArpeggioPitchIndex(note.pitches.length - toneIndex, instrument.fastTwoNoteArp, arpeggio)];
                                                }
                                                nextPitch = channelRoot + nextPitch * intervalScale + pitchOffset;
                                                if (preset != null && preset.midiSubharmonicOctaves != undefined) {
                                                    nextPitch += 12 * preset.midiSubharmonicOctaves;
                                                }
                                                else if (isNoise) {
                                                    nextPitch += 12 * (+EditorConfig.presetCategories.dictionary["Drum Presets"].presets.dictionary["taiko drum"].midiSubharmonicOctaves);
                                                }
                                                if (isNoise)
                                                    nextPitch *= 2;
                                            }
                                            nextPitch = Math.max(0, Math.min(127, nextPitch));
                                            nextPitches[toneIndex] = nextPitch;
                                            if (!noteStarting && prevPitches[toneIndex] != nextPitches[toneIndex]) {
                                                writeEventTime(midiTickTime);
                                                writer.writeUint8(128 | midiChannel);
                                                writer.writeMidi7Bits(prevPitches[toneIndex]);
                                                writer.writeMidi7Bits(velocity);
                                            }
                                        }
                                        for (let toneIndex = 0; toneIndex < toneCount; toneIndex++) {
                                            if (noteStarting || prevPitches[toneIndex] != nextPitches[toneIndex]) {
                                                writeEventTime(midiTickTime);
                                                writer.writeUint8(144 | midiChannel);
                                                writer.writeMidi7Bits(nextPitches[toneIndex]);
                                                writer.writeMidi7Bits(velocity);
                                                prevPitches[toneIndex] = nextPitches[toneIndex];
                                            }
                                        }
                                    }
                                    pinTime = nextPinTime;
                                    pinSize = nextPinSize;
                                    pinInterval = nextPinInterval;
                                }
                                const noteEndTime = barStartTime + note.end * midiTicksPerPart;
                                for (let toneIndex = 0; toneIndex < toneCount; toneIndex++) {
                                    writeEventTime(noteEndTime);
                                    writer.writeUint8(128 | midiChannel);
                                    writer.writeMidi7Bits(prevPitches[toneIndex]);
                                    writer.writeMidi7Bits(velocity);
                                }
                                shouldResetExpressionAndPitchBend = true;
                            }
                        }
                        else {
                            if (shouldResetExpressionAndPitchBend) {
                                shouldResetExpressionAndPitchBend = false;
                                if (prevExpression != defaultMidiExpression) {
                                    prevExpression = defaultMidiExpression;
                                    writeEventTime(barStartTime);
                                    writeControlEvent(11, prevExpression);
                                }
                                if (prevPitchBend != defaultMidiPitchBend) {
                                    prevPitchBend = defaultMidiPitchBend;
                                    writeEventTime(barStartTime);
                                    writer.writeUint8(224 | midiChannel);
                                    writer.writeMidi7Bits(prevPitchBend & 0x7f);
                                    writer.writeMidi7Bits((prevPitchBend >> 7) & 0x7f);
                                }
                            }
                        }
                        barStartTime += midiTicksPerBar;
                    }
                }
                writeEventTime(barStartTime);
                writer.writeUint8(255);
                writer.writeMidi7Bits(47);
                writer.writeMidiVariableLength(0x00);
                writer.rewriteUint32(trackStartIndex, writer.getWriteIndex() - trackStartIndex - 4);
            }
            const blob = new Blob([writer.toCompactArrayBuffer()], { type: "audio/midi" });
            save(blob, this._fileName.value.trim() + ".mid", [writer.toCompactArrayBuffer()] );
            this._close();
        }
        _exportToJson() {
            const jsonObject = this._doc.song.toJsonObject(this._enableIntro.checked, Number(this._loopDropDown.value), this._enableOutro.checked);
            let whiteSpaceParam = this._removeWhitespace.checked ? undefined : '\t';
            const jsonString = JSON.stringify(jsonObject, null, whiteSpaceParam);
            const blob = new Blob([jsonString], { type: "application/json" });
            save(blob, this._fileName.value.trim() + ".json",jsonString,true);
            this._close();
        }
        _exportToHtml() {
            const fileContents = `\
<!DOCTYPE html><meta charset="utf-8">

You should be redirected to the song at:<br /><br />

<a id="destination" href="${new URL("#" + this._doc.song.toBase64String(), location.href).href}"></a>

<style>
	:root {
		color: white;
		background: black;
		font-family:
		sans-serif;
	}
	a {
		color: #98f;
	}
	a[href]::before {
		content: attr(href);
	}
</style>

<script>
	location.assign(document.querySelector("a#destination").href);
</script>
`;
            const blob = new Blob([fileContents], { type: "text/html" });
            save(blob, this._fileName.value.trim() + ".html",[fileContents]);
            this._close();
        }
    }
    ExportPrompt.midiChipInstruments = [
        0x4A,
        0x47,
        0x50,
        0x46,
        0x44,
        0x51,
        0x51,
        0x51,
        0x51,
    ];

    const { button: button$n, div: div$n, span: span$6, h2: h2$m, input: input$g, br: br$4, select: select$c, option: option$c } = HTML;
    class BeatsPerBarPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._computedSamplesLabel = div$n({ style: "width: 10em;" }, new Text("0:00"));
            this._beatsStepper = input$g({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._conversionStrategySelect = select$c({ style: "width: 100%;" }, option$c({ value: "splice" }, "Splice beats at end of bars."), option$c({ value: "stretch" }, "Stretch notes to fit in bars."), option$c({ value: "overflow" }, "Overflow notes across bars."));
            this._cancelButton = button$n({ class: "cancelButton" });
            this._okayButton = button$n({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$n({ class: "prompt noSelection", style: "width: 250px;" }, h2$m("Beats Per Bar"), div$n({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "Length:", this._computedSamplesLabel), div$n({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$n({ style: "text-align: right;" }, "Beats per bar:", br$4(), span$6({ style: "font-size: smaller; color: ${ColorConfig.secondaryText};" }, "(Multiples of 3 or 4 are recommended)")), this._beatsStepper), div$n({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$n({ class: "selectContainer", style: "width: 100%;" }, this._conversionStrategySelect)), div$n({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._beatsStepper.removeEventListener("keypress", BeatsPerBarPrompt._validateKey);
                this._beatsStepper.removeEventListener("blur", BeatsPerBarPrompt._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("beatCountStrategy", this._conversionStrategySelect.value);
                this._doc.prompt = null;
                this._doc.record(new ChangeBeatsPerBar(this._doc, BeatsPerBarPrompt._validate(this._beatsStepper), this._conversionStrategySelect.value), true);
            };
            this._beatsStepper.value = this._doc.song.beatsPerBar + "";
            this._beatsStepper.min = Config.beatsPerBarMin + "";
            this._beatsStepper.max = Config.beatsPerBarMax + "";
            const lastStrategy = window.localStorage.getItem("beatCountStrategy");
            if (lastStrategy != null) {
                this._conversionStrategySelect.value = lastStrategy;
            }
            this._beatsStepper.select();
            setTimeout(() => this._beatsStepper.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._beatsStepper.addEventListener("keypress", BeatsPerBarPrompt._validateKey);
            this._beatsStepper.addEventListener("blur", BeatsPerBarPrompt._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._beatsStepper.addEventListener("input", () => { this._computedSamplesLabel.firstChild.textContent = this._predictFutureLength(); });
            this._conversionStrategySelect.addEventListener("change", () => { this._computedSamplesLabel.firstChild.textContent = this._predictFutureLength(); });
            this._computedSamplesLabel.firstChild.textContent = ExportPrompt.samplesToTime(this._doc, this._doc.synth.getTotalSamples(true, true, 0));
        }
        static _validateKey(event) {
            const charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 46 && charCode > 31 && (charCode < 48 || charCode > 57)) {
                event.preventDefault();
                return true;
            }
            return false;
        }
        static _validateNumber(event) {
            const input = event.target;
            input.value = String(BeatsPerBarPrompt._validate(input));
        }
        static _validate(input) {
            return Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value))));
        }
        _predictFutureLength() {
            var _a, _b, _c;
            const futureDoc = new SongDocument();
            (_a = futureDoc.synth.song) === null || _a === void 0 ? void 0 : _a.fromBase64String(((_b = this._doc.synth.song) === null || _b === void 0 ? void 0 : _b.toBase64String()) ? (_c = this._doc.synth.song) === null || _c === void 0 ? void 0 : _c.toBase64String() : "");
            new ChangeBeatsPerBar(futureDoc, BeatsPerBarPrompt._validate(this._beatsStepper), this._conversionStrategySelect.value);
            return ExportPrompt.samplesToTime(futureDoc, futureDoc.synth.getTotalSamples(true, true, 0));
        }
    }

    const { button: button$m, div: div$m, label: label$3, br: br$3, h2: h2$l, input: input$f } = HTML;
    class ChannelSettingsPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._patternsStepper = input$f({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._pitchChannelStepper = input$f({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._drumChannelStepper = input$f({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._modChannelStepper = input$f({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._layeredInstrumentsBox = input$f({ style: "width: 3em; margin-left: 1em;", type: "checkbox" });
            this._patternInstrumentsBox = input$f({ style: "width: 3em; margin-left: 1em;", type: "checkbox" });
            this._octaveStepper = input$f({ style: "width: 3em; margin-left: 1em; ", type: "number", step: "1" });
            this._cancelButton = button$m({ class: "cancelButton" });
            this._okayButton = button$m({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$m({ class: "prompt noSelection", style: "width: 250px; text-align: right;" }, h2$l("Channel Settings"), label$3({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Pitch channels:", this._pitchChannelStepper), label$3({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Drum channels:", this._drumChannelStepper), div$m({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Mod channels:", this._modChannelStepper), label$3({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Available patterns per channel:", this._patternsStepper), label$3({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Simultaneous instruments", br$3(), "per channel:", this._layeredInstrumentsBox), label$3({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Different instruments", br$3(), "per pattern:", this._patternInstrumentsBox),label$3({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end; display:none;" }, "Max octaves", br$3(), this._octaveStepper), div$m({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._patternsStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._pitchChannelStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._drumChannelStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._modChannelStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._octaveStepper.removeEventListener("keypress", ChannelSettingsPrompt._validateKey);
                this._patternsStepper.removeEventListener("blur", this._validateNumber);
                this._pitchChannelStepper.removeEventListener("blur", this._validateNumber);
                this._drumChannelStepper.removeEventListener("blur", this._validateNumber);
                this._modChannelStepper.removeEventListener("blur", this._validateNumber);
                this._octaveStepper.removeEventListener("blur", this._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._validateNumber = (event) => {
                const input = event.target;
                input.value = String(ChannelSettingsPrompt._validate(input));
            };
            this._saveChanges = () => {
                const group = new ChangeGroup();
                group.append(new ChangeInstrumentsFlags(this._doc, this._layeredInstrumentsBox.checked, this._patternInstrumentsBox.checked));
                group.append(new ChangePatternsPerChannel(this._doc, ChannelSettingsPrompt._validate(this._patternsStepper)));
                //group.append(new ChangeMaxOctaves(this._doc, ChannelSettingsPrompt._validate(this._octaveStepper)));
                group.append(new ChangeChannelCount(this._doc, ChannelSettingsPrompt._validate(this._pitchChannelStepper), ChannelSettingsPrompt._validate(this._drumChannelStepper), ChannelSettingsPrompt._validate(this._modChannelStepper) ));
                this._doc.prompt = null;
                this._doc.record(group, true);
            };
            this._patternsStepper.value = this._doc.song.patternsPerChannel + "";
            this._patternsStepper.min = "1";
            this._patternsStepper.max = Config.barCountMax + "";
            this._pitchChannelStepper.value = this._doc.song.pitchChannelCount + "";
            this._pitchChannelStepper.min = Config.pitchChannelCountMin + "";
            this._pitchChannelStepper.max = Config.pitchChannelCountMax + "";
            this._drumChannelStepper.value = this._doc.song.noiseChannelCount + "";
            this._drumChannelStepper.min = Config.noiseChannelCountMin + "";
            this._drumChannelStepper.max = Config.noiseChannelCountMax + "";
            this._modChannelStepper.value = this._doc.song.modChannelCount + "";
            this._octaveStepper.value = Config.pitchOctaves + "";
            this._modChannelStepper.min = Config.modChannelCountMin + "";
            this._modChannelStepper.max = Config.modChannelCountMax + "";
            this._layeredInstrumentsBox.checked = this._doc.song.layeredInstruments;
            this._patternInstrumentsBox.checked = this._doc.song.patternInstruments;
            this._pitchChannelStepper.select();
            setTimeout(() => this._pitchChannelStepper.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._patternsStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._pitchChannelStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._drumChannelStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._modChannelStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._octaveStepper.addEventListener("keypress", ChannelSettingsPrompt._validateKey);
            this._patternsStepper.addEventListener("blur", this._validateNumber);
            this._pitchChannelStepper.addEventListener("blur", this._validateNumber);
            this._drumChannelStepper.addEventListener("blur", this._validateNumber);
            this._modChannelStepper.addEventListener("blur", this._validateNumber);
            this._octaveStepper.addEventListener("blur", this._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        static _validateKey(event) {
            const charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 46 && charCode > 31 && (charCode < 48 || charCode > 57)) {
                event.preventDefault();
                return true;
            }
            return false;
        }
        static _validate(input) {
            return Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value))));
        }
    }

    const { button: button$l, div: div$l, h2: h2$k } = HTML;
    class CustomChipPromptCanvas {
        constructor(doc) {
            this._mouseX = 0;
            this._mouseY = 0;
            this._lastIndex = 0;
            this._lastAmp = 0;
            this._mouseDown = false;
            this.chipData = new Float32Array(64);
            this.startingChipData = new Float32Array(64);
            this._undoHistoryState = 0;
            this._changeQueue = [];
            this._editorWidth = 768;
            this._editorHeight = 294;
            this._fill = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._ticks = SVG.svg({ "pointer-events": "none" });
            this._subticks = SVG.svg({ "pointer-events": "none" });
            this._blocks = SVG.svg({ "pointer-events": "none" });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; overflow: visible;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._fill, this._ticks, this._subticks, this._blocks);
            this.container = HTML.div({ class: "", style: "height: 294px; width: 768px; padding-bottom: 1.5em;" }, this._svg);
            this._storeChange = () => {
                var sameCheck = true;
                if (this._changeQueue.length > 0) {
                    for (var i = 0; i < 64; i++) {
                        if (this._changeQueue[this._undoHistoryState][i] != this.chipData[i]) {
                            sameCheck = false;
                            i = 64;
                        }
                    }
                }
                if (sameCheck == false || this._changeQueue.length == 0) {
                    this._changeQueue.splice(0, this._undoHistoryState);
                    this._undoHistoryState = 0;
                    this._changeQueue.unshift(this.chipData.slice());
                    if (this._changeQueue.length > 32) {
                        this._changeQueue.pop();
                    }
                }
            };
            this.undo = () => {
                if (this._undoHistoryState < this._changeQueue.length - 1) {
                    this._undoHistoryState++;
                    this.chipData = this._changeQueue[this._undoHistoryState].slice();
                    new ChangeCustomWave(this._doc, this.chipData);
                    this.render();
                }
            };
            this.redo = () => {
                if (this._undoHistoryState > 0) {
                    this._undoHistoryState--;
                    this.chipData = this._changeQueue[this._undoHistoryState].slice();
                    new ChangeCustomWave(this._doc, this.chipData);
                    this.render();
                }
            };
            this._whenKeyPressed = (event) => {
                if (event.keyCode == 90) {
                    this.undo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 89) {
                    this.redo();
                    event.stopPropagation();
                }
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._lastIndex = -1;
                this._whenCursorMoved();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._lastIndex = -1;
                this._whenCursorMoved();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                this._storeChange();
                this._mouseDown = false;
            };
            this._doc = doc;
            for (let i = 0; i <= 4; i += 2) {
                this._ticks.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i * this._editorWidth / 4) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 1; i <= 8; i++) {
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i * this._editorWidth / 8) - 1, y: 0, width: 1, height: this._editorHeight }));
            }
            this._ticks.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: 0, y: (this._editorHeight / 2) - 1, width: this._editorWidth, height: 2 }));
            for (let i = 0; i < 3; i++) {
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: 0, y: i * 8 * (this._editorHeight / 49), width: this._editorWidth, height: 1 }));
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: 0, y: this._editorHeight - 1 - i * 8 * (this._editorHeight / 49), width: this._editorWidth, height: 1 }));
            }
            let col = ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote;
            for (let i = 0; i <= 64; i++) {
                let val = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].customChipWave[i];
                this.chipData[i] = val;
                this.startingChipData[i] = val;
                this._blocks.appendChild(SVG.rect({ fill: col, x: (i * this._editorWidth / 64), y: (val + 24) * (this._editorHeight / 49), width: this._editorWidth / 64, height: this._editorHeight / 49 }));
            }
            this._storeChange();
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
            this._svg.addEventListener("keydown", this._whenKeyPressed);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        _whenCursorMoved() { 
            if (this._mouseDown) {
                const index = Math.min(63, Math.max(0, Math.floor(this._mouseX * 64 / this._editorWidth)));
                const amp = Math.min(48, Math.max(0, Math.floor(this._mouseY * 49 / this._editorHeight)));
                if (this._lastIndex != -1 && this._lastIndex != index) {
                    var lowest = index;
                    var highest = this._lastIndex;
                    var startingAmp = amp;
                    var endingAmp = this._lastAmp;
                    if (this._lastIndex < index) {
                        lowest = this._lastIndex;
                        highest = index;
                        startingAmp = this._lastAmp;
                        endingAmp = amp;
                    }
                    for (var i = lowest; i <= highest; i++) {
                        const medAmp = Math.round(startingAmp + (endingAmp - startingAmp) * ((i - lowest) / (highest - lowest)));
                        this.chipData[i] = medAmp - 24;
                        this._blocks.children[i].setAttribute("y", "" + (medAmp * (this._editorHeight / 49)));
                    }
                }
                else {
                    this.chipData[index] = amp - 24;
                    this._blocks.children[index].setAttribute("y", "" + (amp * (this._editorHeight / 49)));
                }
                new ChangeCustomWave(this._doc, this.chipData);
                this._lastIndex = index;
                this._lastAmp = amp;
            }
        }
        render() {
            for (var i = 0; i < 64; i++) {
                this._blocks.children[i].setAttribute("y", "" + ((this.chipData[i] + 24) * (this._editorHeight / 49)));
            }
        }
    }
    class CustomChipPrompt {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this.customChipCanvas = new CustomChipPromptCanvas(this._doc);
            this._playButton = button$l({ style: "width: 55%;", type: "button" });
            this._cancelButton = button$l({ class: "cancelButton" });
            this._okayButton = button$l({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.copyButton = button$l({ style: "width:86px; margin-right: 5px;", class: "copyButton" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this.pasteButton = button$l({ style: "width:86px;", class: "pasteButton" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this.copyPasteContainer = div$l({ style: "width: 185px;" }, this.copyButton, this.pasteButton);
            this.container = div$l({ class: "prompt noSelection", style: "width: 600px;" }, h2$k("Edit Custom Chip Instrument"), div$l({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), div$l({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center;" }, this.customChipCanvas.container), div$l({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this.copyPasteContainer), this._cancelButton);
            this._togglePlay = () => {
                this._songEditor.togglePlay();
                this.updatePlayButton();
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this._copySettings = () => {
                const chipCopy = this.customChipCanvas.chipData;
                window.localStorage.setItem("chipCopy", JSON.stringify(Array.from(chipCopy)));
            };
            this._pasteSettings = () => {
                const storedChipWave = JSON.parse(String(window.localStorage.getItem("chipCopy")));
                for (let i = 0; i < 64; i++) {
                    this.customChipCanvas.chipData[i] = storedChipWave[i];
                }
                this.customChipCanvas._storeChange();
                new ChangeCustomWave(this._doc, this.customChipCanvas.chipData);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                else if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
                else if (event.keyCode == 90) {
                    this.customChipCanvas.undo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 89) {
                    this.customChipCanvas.redo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 219) {
                    this._doc.synth.goToPrevBar();
                }
                else if (event.keyCode == 221) {
                    this._doc.synth.goToNextBar();
                }
            };
            this._saveChanges = () => {
                this._doc.prompt = null;
                new ChangeCustomWave(this._doc, this.customChipCanvas.startingChipData);
                this._doc.record(new ChangeCustomWave(this._doc, this.customChipCanvas.chipData), true);
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this.whenKeyPressed);
            this.copyButton.addEventListener("click", this._copySettings);
            this.pasteButton.addEventListener("click", this._pasteSettings);
            this._playButton.addEventListener("click", this._togglePlay);
            this.updatePlayButton();
            setTimeout(() => this._playButton.focus());
            this.customChipCanvas.render();
        }
        updatePlayButton() {
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            } 
        }
    }

    class FilterEditor {
        constructor(_doc, useNoteFilter = false, larger = false, forSong = false) {
            this._doc = _doc;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._responsePath = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._indicators = [];
            this._subFilters = [];
            this._writingMods = false;
            this._controlPointPath = SVG.path({ fill: "currentColor", "pointer-events": "none" });
            this._dottedLinePath = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 1, "stroke-dasharray": "3, 2", "pointer-events": "none" });
            this._highlight = SVG.circle({ fill: "white", stroke: "none", "pointer-events": "none", r: 4 });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._responsePath, this._dottedLinePath, this._highlight, this._controlPointPath);
            this.selfUndoSettings = [];
            this.selfUndoHistoryPos = 0;
            this._label = HTML.div({ style: "position: absolute; bottom: 0; left: 2px; font-size: 8px; line-height: 1; pointer-events: none;" });
            this.coordText = null;
            this.container = HTML.div({ class: "filterEditor", style: "height: 100%; position: relative;" }, this._svg, this._label);
            this._pointRadius = 2;
            this._useNoteFilter = false;
            this._larger = false;
            this._touchMode = false;
            this._mouseX = 0;
            this._mouseY = 0;
            this._mouseOver = false;
            this._mouseDown = false;
            this._mouseDragging = false;
            this._addingPoint = false;
            this._deletingPoint = false;
            this._addedType = 2;
            this._selectedIndex = 0;
            this._freqStart = 0;
            this._gainStart = 0;
            this._dragChange = null;
            this._subfilterIndex = 0;
            this._renderedSelectedIndex = -1;
            this._renderedPointCount = -1;
            this._renderedPointTypes = -1;
            this._renderedPointFreqs = -1;
            this._renderedPointGains = -1;
            this._forSong = false;
            this._whenKeyPressed = (event) => {
                if (event.keyCode == 90) {
                    this.undo();
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    this.redo();
                    event.stopPropagation();
                }
            };
            this._whenMouseOver = (event) => {
                this._mouseOver = true;
                if (!this._larger)
                    this._controlPointPath.style.setProperty("fill", "currentColor");
            };
            this._whenMouseOut = (event) => {
                this._mouseOver = false;
                this._updatePath();
                if (this.coordText != null) {
                    this.coordText.innerText = "";
                }
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._touchMode = false;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorPressed();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._touchMode = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorPressed();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (!this._mouseDown)
                    this._updateCursor();
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (this._mouseDown)
                    event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (!this._mouseDown)
                    this._updateCursor();
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (this._writingMods) {
                    if (this._forSong) {
                        this._useFilterSettings = this._getTargetFilterSettingsForSong(this._doc.song);
                    }
                    else {
                        const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                        this._useFilterSettings = this._getTargetFilterSettings(instrument);
                    }
                }
                if (this.container.offsetParent == null)
                    return;
                if (this._mouseDown && (this._doc.lastChangeWas(this._dragChange) || this._writingMods) && this._dragChange != null) {
                    if (!this._addingPoint && !this._mouseDragging && !this._touchMode) {
                        if (this._selectedIndex < this._useFilterSettings.controlPointCount && this._selectedIndex != -1) {
                            const point = this._useFilterSettings.controlPoints[this._selectedIndex];
                            if (this._forSong) {
                                let change = new ChangeSongFilterAddPoint(this._doc, this._useFilterSettings, point, this._selectedIndex, true);
                                if (!this._larger) {
                                    this._doc.record(change);
                                }
                            }
                            else {
                                let change = new ChangeFilterAddPoint(this._doc, this._useFilterSettings, point, this._selectedIndex, this._useNoteFilter, true);
                                if (!this._larger) {
                                    this._doc.record(change);
                                }
                            }
                        }
                    }
                    else if (!this._larger) {
                        this._doc.record(this._dragChange);
                    }
                    this._updatePath();
                    if (this._larger) {
                        this.selfUndoSettings.length = this.selfUndoHistoryPos + 1;
                        this.selfUndoSettings.push(JSON.stringify(this._filterSettings.toJsonObject()));
                        this.selfUndoHistoryPos++;
                    }
                }
                this._dragChange = null;
                this._mouseDragging = false;
                this._deletingPoint = false;
                this._mouseDown = false;
                this._writingMods = false;
                this._updateCursor();
            };
            this._useNoteFilter = useNoteFilter;
            this._larger = larger;
            this._forSong = forSong;
            if (this._larger) {
                this.container.addEventListener("keydown", this._whenKeyPressed);
                this._editorWidth = 1200;
                this._editorHeight = 260;
                this._pointRadius = 14;
                this._svg.setAttribute("viewBox", "0 -20 " + this._editorWidth + " " + (this._editorHeight + 30));
                this._label.style.setProperty("font-size", "16px");
                this._label.style.setProperty("position", "");
                this._label.style.setProperty("bottom", "-16px");
                this._label.style.setProperty("min-height", "1em");
                this._dottedLinePath.style.setProperty("stroke-width", "3");
                this._dottedLinePath.style.setProperty("stroke-dasharray", "6, 4");
                this._dottedLinePath.setAttribute("color", ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
                this.container.style.setProperty("width", "85%");
                this._highlight.setAttribute("r", "20");
                this._controlPointPath.setAttribute("fill", ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
                for (let i = 0; i < Config.filterMaxPoints; i++) {
                    this._indicators[i] = SVG.text();
                    this._indicators[i].setAttribute("fill", ColorConfig.invertedText);
                    this._indicators[i].setAttribute("text-anchor", "middle");
                    this._indicators[i].setAttribute("dominant-baseline", "central");
                    this._indicators[i].setAttribute("pointer-events", "none");
                    this._indicators[i].setAttribute("font-weight", "bolder");
                    this._indicators[i].textContent = "" + (i + 1);
                    this._indicators[i].style.setProperty("display", "none");
                    if (i > 8) {
                        this._indicators[i].style.setProperty("font-size", "19px");
                    }
                    else {
                        this._indicators[i].style.setProperty("font-size", "24px");
                    }
                    this._svg.appendChild(this._indicators[i]);
                }
                let filterSettings;
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                if (this._forSong) {
                    filterSettings = this._doc.song.eqFilter;
                }
                else {
                    filterSettings = this._useNoteFilter ? instrument.noteFilter : instrument.eqFilter;
                }
                this.selfUndoSettings.push(JSON.stringify(filterSettings.toJsonObject()));
                this._subFilters[0] = filterSettings;
                for (let i = 1; i < Config.filterMorphCount; i++) {
                    if (this._forSong) {
                        const subFilter = this._doc.song.eqSubFilters[i];
                        if (subFilter != null) {
                            let parsedFilter = new FilterSettings();
                            parsedFilter.fromJsonObject(subFilter.toJsonObject());
                            this._subFilters[i] = parsedFilter;
                        }
                    }
                    else {
                        const subFilter = this._useNoteFilter ? instrument.noteSubFilters[i] : instrument.eqSubFilters[i];
                        if (subFilter != null) {
                            let parsedFilter = new FilterSettings();
                            parsedFilter.fromJsonObject(subFilter.toJsonObject());
                            this._subFilters[i] = parsedFilter;
                        }
                    }
                }
            }
            this.container.addEventListener("mousedown", this._whenMousePressed);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _xToFreq(x) {
            return Config.filterFreqRange * x / this._editorWidth - 0.5;
        }
        _freqToX(freq) {
            return this._editorWidth * (freq + 0.5) / Config.filterFreqRange;
        }
        _yToGain(y) {
            return (Config.filterGainRange - 1) * (1 - (y - .5) / (this._editorHeight - 1));
        }
        _gainToY(gain) {
            return (this._editorHeight - 1) * (1 - gain / (Config.filterGainRange - 1)) + .5;
        }
        _whenCursorPressed() {
            this._mouseDown = true;
            const sequence = new ChangeSequence();
            this._dragChange = sequence;
            this._doc.setProspectiveChange(this._dragChange);
            this._updateCursor();
            this._whenCursorMoved();
        }
        _updateCursor() {
            this._freqStart = this._xToFreq(this._mouseX);
            this._gainStart = this._yToGain(this._mouseY);
            this._addingPoint = true;
            this._selectedIndex = -1;
            let nearestDistance = Number.POSITIVE_INFINITY;
            for (let i = 0; i < this._useFilterSettings.controlPointCount; i++) {
                const point = this._useFilterSettings.controlPoints[i];
                const distance = Math.sqrt(Math.pow(this._freqToX(point.freq) - this._mouseX, 2) + Math.pow(this._gainToY(point.gain) - this._mouseY, 2));
                if ((distance <= 13 * (1 + +this._larger) || this._useFilterSettings.controlPointCount >= Config.filterMaxPoints) && distance < nearestDistance) {
                    nearestDistance = distance;
                    this._selectedIndex = i;
                    this._addingPoint = false;
                }
            }
            if (this._addingPoint) {
                const ratio = this._mouseX / this._editorWidth;
                if (ratio < 0.2) {
                    this._addedType = 1;
                }
                else if (ratio < 0.8) {
                    this._addedType = 2;
                }
                else {
                    this._addedType = 0;
                }
            }
        }
        _whenCursorMoved() {
            if (this._writingMods) {
                if (this._forSong) {
                    this._useFilterSettings = this._getTargetFilterSettingsForSong(this._doc.song);
                }
                else {
                    const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                    this._useFilterSettings = this._getTargetFilterSettings(instrument);
                }
                if (this._dragChange != null) {
                    if (this._dragChange instanceof ChangeSequence && this._dragChange.checkFirst() instanceof ChangeFilterMovePoint) {
                        const data = this._dragChange.checkFirst().getMoveData(true);
                        const newPoint = this._useFilterSettings.controlPoints[this._selectedIndex];
                        if (newPoint == null || newPoint.type != data.point.type) {
                            this._dragChange = null;
                            this._writingMods = false;
                            this._mouseDown = false;
                        }
                        else {
                            newPoint.freq = data.freq;
                            newPoint.gain = data.gain;
                        }
                    }
                    else if (this._forSong && this._dragChange instanceof ChangeSequence && this._dragChange.checkFirst() instanceof ChangeSongFilterMovePoint) {
                        const data = this._dragChange.checkFirst().getMoveData(true);
                        const newPoint = this._useFilterSettings.controlPoints[this._selectedIndex];
                        if (newPoint == null || newPoint.type != data.point.type) {
                            this._dragChange = null;
                            this._writingMods = false;
                            this._mouseDown = false;
                        }
                        else {
                            newPoint.freq = data.freq;
                            newPoint.gain = data.gain;
                        }
                    }
                    else {
                        this._dragChange = null;
                        this._writingMods = false;
                        this._mouseDown = false;
                    }
                }
            }
            if (this._dragChange != null && (this._doc.lastChangeWas(this._dragChange) || this._writingMods)) {
                this._dragChange.undo();
            }
            else {
                this._mouseDown = false;
            }
            this._dragChange = null;
            this._deletingPoint = false;
            if (this.coordText != null && !this._mouseDown) {
                let gain = Math.round(this._yToGain(this._mouseY));
                let freq = Math.round(this._xToFreq(this._mouseX));
                if (freq >= 0 && freq < Config.filterFreqRange && gain >= 0 && gain < Config.filterGainRange)
                    this.coordText.innerText = "(" + freq + ", " + gain + ")";
                else
                    this.coordText.innerText = "";
            }
            if (this._mouseDown) {
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._doc.setProspectiveChange(this._dragChange);
                if (this._addingPoint) {
                    const gain = Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(this._yToGain(this._mouseY))));
                    const freq = this._findNearestFreqSlot(this._useFilterSettings, this._xToFreq(this._mouseX), -1);
                    if (freq >= 0 && freq < Config.filterFreqRange) {
                        const point = new FilterControlPoint();
                        point.type = this._addedType;
                        point.freq = freq;
                        point.gain = gain;
                        if (this._forSong) {
                            sequence.append(new ChangeSongFilterAddPoint(this._doc, this._useFilterSettings, point, this._useFilterSettings.controlPointCount));
                        }
                        else {
                            sequence.append(new ChangeFilterAddPoint(this._doc, this._useFilterSettings, point, this._useFilterSettings.controlPointCount, this._useNoteFilter));
                        }
                        if (this.coordText != null) {
                            this.coordText.innerText = "(" + freq + ", " + gain + ")";
                        }
                    }
                    else {
                        this._deletingPoint = true;
                    }
                }
                else if (this._selectedIndex >= this._useFilterSettings.controlPointCount || this._selectedIndex == -1) {
                    this._dragChange = null;
                    this._mouseDown = false;
                }
                else {
                    const freqDelta = this._xToFreq(this._mouseX) - this._freqStart;
                    const gainDelta = this._yToGain(this._mouseY) - this._gainStart;
                    let point = this._useFilterSettings.controlPoints[this._selectedIndex];
                    const gain = Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(point.gain + gainDelta)));
                    const freq = this._findNearestFreqSlot(this._useFilterSettings, point.freq + freqDelta, this._selectedIndex);
                    if (Math.round(freqDelta) != 0.0 || Math.round(gainDelta) != 0.0 || freq != point.freq || gain != point.gain) {
                        this._mouseDragging = true;
                    }
                    if (freq >= 0 && freq < Config.filterFreqRange) {
                        if (this._forSong) {
                            sequence.append(new ChangeSongFilterMovePoint(this._doc, point, point.freq, freq, point.gain, gain, this._selectedIndex));
                        }
                        else {
                            sequence.append(new ChangeFilterMovePoint(this._doc, point, point.freq, freq, point.gain, gain, this._useNoteFilter, this._selectedIndex));
                        }
                        if (this.coordText != null) {
                            this.coordText.innerText = "(" + freq + ", " + gain + ")";
                            if (!this._writingMods) {
                                if (this._forSong) {
                                    this._doc.song.tmpEqFilterStart = this._doc.song.eqFilter;
                                    this._doc.song.tmpEqFilterEnd = null;
                                }
                                else {
                                    const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                                    instrument.tmpEqFilterStart = instrument.eqFilter;
                                    instrument.tmpEqFilterEnd = null;
                                    instrument.tmpNoteFilterStart = instrument.noteFilter;
                                    instrument.tmpNoteFilterEnd = null;
                                }
                            }
                        }
                    }
                    else {
                        if (this._forSong) {
                            sequence.append(new ChangeSongFilterAddPoint(this._doc, this._useFilterSettings, point, this._selectedIndex, true));
                        }
                        else {
                            sequence.append(new ChangeFilterAddPoint(this._doc, this._useFilterSettings, point, this._selectedIndex, this._useNoteFilter, true));
                        }
                        this._deletingPoint = true;
                    }
                }
            }
            if (this._mouseDown || this._mouseOver) {
                this._updatePath();
            }
        }
        _findNearestFreqSlot(filterSettings, targetFreq, ignoreIndex) {
            const roundedFreq = Math.round(targetFreq);
            let lowerFreq = roundedFreq;
            let upperFreq = roundedFreq;
            let tryingLower = (roundedFreq <= targetFreq);
            while (true) {
                let foundConflict = false;
                const currentFreq = tryingLower ? lowerFreq : upperFreq;
                for (let i = 0; i < filterSettings.controlPointCount; i++) {
                    if (i == ignoreIndex)
                        continue;
                    if (filterSettings.controlPoints[i].freq == currentFreq) {
                        foundConflict = true;
                        break;
                    }
                }
                if (!foundConflict)
                    return currentFreq;
                tryingLower = !tryingLower;
                if (tryingLower)
                    lowerFreq--;
                if (!tryingLower)
                    upperFreq++;
            }
        }
        static _circlePath(cx, cy, radius, reverse = false) {
            return `M ${cx - radius} ${cy} ` +
                `a ${radius} ${radius} 0 1 ${reverse ? 1 : 0} ${radius * 2} 0 ` +
                `a ${radius} ${radius} 0 1 ${reverse ? 1 : 0} ${-radius * 2} 0 `;
        }
        _updatePath() {
            this._highlight.style.display = "none";
            this._label.textContent = "";
            let controlPointPath = "";
            let dottedLinePath = "";
            for (let i = 0; i < this._useFilterSettings.controlPointCount; i++) {
                const point = this._useFilterSettings.controlPoints[i];
                const pointX = this._freqToX(point.freq);
                const pointY = this._gainToY(point.gain);
                controlPointPath += FilterEditor._circlePath(pointX, pointY, this._pointRadius);
                if (point.type == 1) {
                    dottedLinePath += "M " + 0 + " " + pointY + " L " + pointX + " " + pointY + " ";
                }
                else if (point.type == 0) {
                    dottedLinePath += "M " + this._editorWidth + " " + pointY + " L " + pointX + " " + pointY + " ";
                }
                if (this._selectedIndex == i && this._mouseOver && !this._mouseDown) {
                    this._highlight.setAttribute("cx", String(pointX));
                    this._highlight.setAttribute("cy", String(pointY));
                    this._highlight.style.display = "";
                    if (this.coordText != null) {
                        this.coordText.innerText = "(" + point.freq + ", " + point.gain + ")";
                    }
                }
                if ((this._selectedIndex == i || (this._addingPoint && this._mouseDown && i == this._useFilterSettings.controlPointCount - 1)) && (this._mouseOver || this._mouseDown) && !this._deletingPoint) {
                    this._label.textContent = (i + 1) + ": " + Config.filterTypeNames[point.type] + (this._larger ? " @" + prettyNumber(point.getHz()) + "Hz" : "");
                }
                if (this._larger) {
                    this._indicators[i].style.setProperty("display", "");
                    this._indicators[i].setAttribute("x", "" + (pointX));
                    this._indicators[i].setAttribute("y", "" + (pointY + 2));
                }
            }
            this._controlPointPath.setAttribute("d", controlPointPath);
            this._dottedLinePath.setAttribute("d", dottedLinePath);
            if (this._addingPoint && !this._mouseDown && this._mouseOver) {
                this._label.textContent = "+ " + Config.filterTypeNames[this._addedType];
            }
            if (this._larger) {
                for (let i = this._useFilterSettings.controlPointCount; i < Config.filterMaxPoints; i++) {
                    this._indicators[i].style.setProperty("display", "none");
                }
            }
            const standardSampleRate = 44800;
            const filters = [];
            for (let i = 0; i < this._useFilterSettings.controlPointCount; i++) {
                const point = this._useFilterSettings.controlPoints[i];
                const filter = new FilterCoefficients();
                point.toCoefficients(filter, standardSampleRate);
                filters.push(filter);
            }
            const response = new FrequencyResponse();
            let responsePath = "M 0 " + this._editorHeight + " ";
            for (let i = -1; i <= Config.filterFreqRange; i++) {
                const hz = FilterControlPoint.getHzFromSettingValue(i);
                const cornerRadiansPerSample = 2.0 * Math.PI * hz / standardSampleRate;
                const real = Math.cos(cornerRadiansPerSample);
                const imag = Math.sin(cornerRadiansPerSample);
                let linearGain = 1.0;
                for (const filter of filters) {
                    response.analyzeComplex(filter, real, imag);
                    linearGain *= response.magnitude();
                }
                const gainSetting = Math.log2(linearGain) / Config.filterGainStep + Config.filterGainCenter;
                const y = this._gainToY(gainSetting);
                const x = this._freqToX(i);
                responsePath += "L " + prettyNumber(x) + " " + prettyNumber(y) + " ";
            }
            responsePath += "L " + this._editorWidth + " " + this._editorHeight + " L 0 " + this._editorHeight + " z ";
            this._responsePath.setAttribute("d", responsePath);
        }
        swapToSettings(settings, useHistory = false) {
            if (this._forSong) {
                new ChangeSongFilterSettings(this._doc, settings, this._filterSettings, this._subFilters, this._doc.song.eqSubFilters);
            }
            else {
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                new ChangeFilterSettings(this._doc, settings, this._filterSettings, this._useNoteFilter, this._subFilters, this._useNoteFilter ? instrument.noteSubFilters : instrument.eqSubFilters);
            }
            this._filterSettings = settings;
            this._subFilters[this._subfilterIndex] = settings;
            if (useHistory && this._larger) {
                this.selfUndoSettings.length = this.selfUndoHistoryPos + 1;
                this.selfUndoSettings.push(JSON.stringify((this._filterSettings.toJsonObject())));
                this.selfUndoHistoryPos++;
            }
            this._useFilterSettings = this._filterSettings;
            this._updatePath();
        }
        saveSettings() {
            let firstFilter = new FilterSettings;
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            firstFilter.fromJsonObject(JSON.parse(String(this.selfUndoSettings[0])));
            if (this._forSong) {
                this._doc.record(new ChangeSongFilterSettings(this._doc, this._subFilters[0], firstFilter, this._subFilters, this._doc.song.eqSubFilters), true);
            }
            else {
                this._doc.record(new ChangeFilterSettings(this._doc, this._subFilters[0], firstFilter, this._useNoteFilter, this._subFilters, this._useNoteFilter ? instrument.noteSubFilters : instrument.eqSubFilters), true);
            }
        }
        undo() {
            if (this.selfUndoHistoryPos > 0) {
                this.selfUndoHistoryPos--;
                if (this.selfUndoSettings[this.selfUndoHistoryPos + 1] != null && this.selfUndoSettings[this.selfUndoHistoryPos + 1].startsWith("jmp")) {
                    let str = this.selfUndoSettings[this.selfUndoHistoryPos + 1];
                    let jumpIndex = +str.substring(3, str.indexOf("|"));
                    this.swapToSubfilter(this._subfilterIndex, jumpIndex);
                    return jumpIndex;
                }
                else if (this.selfUndoSettings[this.selfUndoHistoryPos].startsWith("jmp")) {
                    let savedFilter = new FilterSettings();
                    let str = this.selfUndoSettings[this.selfUndoHistoryPos];
                    savedFilter.fromJsonObject(JSON.parse(str.substring(str.indexOf(":") + 1)));
                    this.swapToSettings(savedFilter, false);
                }
                else {
                    let savedFilter = new FilterSettings();
                    savedFilter.fromJsonObject(JSON.parse(String(this.selfUndoSettings[this.selfUndoHistoryPos])));
                    this.swapToSettings(savedFilter, false);
                }
            }
            return -1;
        }
        redo() {
            if (this.selfUndoHistoryPos < this.selfUndoSettings.length - 1) {
                this.selfUndoHistoryPos++;
                if (this.selfUndoSettings[this.selfUndoHistoryPos].startsWith("jmp")) {
                    let str = this.selfUndoSettings[this.selfUndoHistoryPos];
                    let jumpIndex = +str.substring(str.indexOf("|") + 1, str.indexOf(":"));
                    this.swapToSubfilter(this._subfilterIndex, jumpIndex, false);
                    return jumpIndex;
                }
                else {
                    let savedFilter = new FilterSettings();
                    savedFilter.fromJsonObject(JSON.parse(String(this.selfUndoSettings[this.selfUndoHistoryPos])));
                    this.swapToSettings(savedFilter, false);
                }
            }
            return -1;
        }
        resetToInitial() {
            this.selfUndoHistoryPos = 1;
            this.undo();
        }
        swapSubfilterIndices(newIndex) {
            if (this._selectedIndex == -1)
                return;
            if (newIndex >= this._useFilterSettings.controlPointCount)
                return;
            let tmp = this._useFilterSettings.controlPoints[this._selectedIndex];
            this._useFilterSettings.controlPoints[this._selectedIndex] = this._useFilterSettings.controlPoints[newIndex];
            this._useFilterSettings.controlPoints[newIndex] = tmp;
            this.render();
        }
        swapToSubfilter(oldIndex, newIndex, useHistory = false) {
            if (oldIndex != newIndex) {
                let currFilter = new FilterSettings();
                currFilter.fromJsonObject(this._filterSettings.toJsonObject());
                this._subFilters[oldIndex] = currFilter;
                if (this._subFilters[newIndex] == undefined) {
                    let parsedFilter = new FilterSettings();
                    parsedFilter.fromJsonObject(this._subFilters[0].toJsonObject());
                    this._subFilters[newIndex] = parsedFilter;
                }
                if (useHistory) {
                    this.selfUndoSettings.length = this.selfUndoHistoryPos + 1;
                    this.selfUndoSettings.push("jmp" + oldIndex + "|" + newIndex + ":" + JSON.stringify(this._subFilters[newIndex].toJsonObject()));
                    this.selfUndoHistoryPos++;
                }
                this._subfilterIndex = newIndex;
                this.swapToSettings(this._subFilters[newIndex], false);
            }
        }
        _getTargetFilterSettingsForSong(song) {
            let targetSettings = song.tmpEqFilterStart;
            if (targetSettings == null)
                targetSettings = song.eqFilter;
            return targetSettings;
        }
        _getTargetFilterSettings(instrument) {
            let targetSettings = (this._useNoteFilter) ? instrument.tmpNoteFilterStart : instrument.tmpEqFilterStart;
            if (targetSettings == null)
                targetSettings = (this._useNoteFilter) ? instrument.noteFilter : instrument.eqFilter;
            return targetSettings;
        }
        render(activeMods = false, forceModRender = false) {
            this._writingMods = forceModRender && this._mouseDown;
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const filterSettings = this._forSong ? this._doc.song.eqFilter : (this._useNoteFilter ? instrument.noteFilter : instrument.eqFilter);
            let displayMods = (activeMods && !this._larger && (forceModRender || (!this._mouseOver && !this._mouseDragging && !this._mouseDown)) && this._doc.synth.playing);
            if (displayMods)
                this._controlPointPath.style.setProperty("fill", `${ColorConfig.overwritingModSlider}`);
            else if (!this._larger)
                this._controlPointPath.style.setProperty("fill", "currentColor");
            if (this._useFilterSettings != filterSettings && !this._writingMods) {
                this._dragChange = null;
                this._mouseDown = false;
            }
            this._filterSettings = filterSettings;
            if (displayMods) {
                this._useFilterSettings = this._forSong ? this._getTargetFilterSettingsForSong(this._doc.song) : this._getTargetFilterSettings(instrument);
                if (this._writingMods)
                    this._whenCursorMoved();
            }
            else {
                this._useFilterSettings = filterSettings;
            }
            if (!this._mouseDown)
                this._updateCursor();
            let pointTypes = 0;
            let pointFreqs = 0;
            let pointGains = 0;
            for (let i = 0; i < this._useFilterSettings.controlPointCount; i++) {
                const point = this._useFilterSettings.controlPoints[i];
                pointTypes = pointTypes * 3 + point.type;
                pointFreqs = pointFreqs * Config.filterFreqRange + point.freq;
                pointGains = pointGains * Config.filterGainRange + point.gain;
            }
            if (this._renderedSelectedIndex != this._selectedIndex ||
                this._renderedPointCount != this._useFilterSettings.controlPointCount ||
                this._renderedPointTypes != pointTypes ||
                this._renderedPointFreqs != pointFreqs ||
                this._renderedPointGains != pointGains) {
                this._renderedSelectedIndex = this._selectedIndex;
                this._renderedPointCount = this._useFilterSettings.controlPointCount;
                this._renderedPointTypes = pointTypes;
                this._renderedPointFreqs = pointFreqs;
                this._renderedPointGains = pointGains;
                this._updatePath();
            }
        }
    }

    const { button: button$k, div: div$k, h2: h2$j, p: p$7 } = HTML;
    class CustomFilterPrompt {
        constructor(_doc, _songEditor, _useNoteFilter, forSong = false) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._useNoteFilter = _useNoteFilter;
            this.forSong = forSong;
            this.filterData = new FilterSettings;
            this.startingFilterData = new FilterSettings;
            this._subfilterIndex = 0;
            this._playButton = button$k({ style: "width: 55%;", type: "button" });
            this._filterButtons = [];
            this._filterButtonContainer = div$k({ class: "instrument-bar", style: "justify-content: center;" });
            this._cancelButton = button$k({ class: "cancelButton" });
            this._okayButton = button$k({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._filterContainer = div$k({ style: "width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: center;" });
            this._editorTitle = div$k({}, h2$j("Edit Filter"));
            this._filterCopyButton = button$k({ style: "width:86px; margin-right: 5px;", class: "copyButton" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this._filterPasteButton = button$k({ style: "width:86px;", class: "pasteButton" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this._filterCopyPasteContainer = div$k({ style: "width: 185px;" }, this._filterCopyButton, this._filterPasteButton);
            this._filterCoordinateText = div$k({ style: "text-align: left; margin-bottom: 0px; font-size: x-small; height: 1.3em; color: " + ColorConfig.secondaryText + ";" }, p$7(""));
            this.container = div$k({ class: "prompt noSelection", style: "width: 600px;" }, this._editorTitle, div$k({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), this._filterButtonContainer, this._filterContainer, div$k({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this._filterCopyPasteContainer), this._cancelButton);
            this._setSubfilter = (index, useHistory = true, doSwap = true) => {
                this._filterButtons[this._subfilterIndex].classList.remove("selected-instrument");
                if (doSwap)
                    this.filterEditor.swapToSubfilter(this._subfilterIndex, index, useHistory);
                this._subfilterIndex = index;
                this._filterButtons[index].classList.add("selected-instrument");
            };
            this._copyFilterSettings = () => {
                const filterCopy = this.forSong
                    ? this._doc.song.eqFilter.toJsonObject()
                    : this._useNoteFilter
                        ? this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].noteFilter.toJsonObject()
                        : this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].eqFilter.toJsonObject();
                window.localStorage.setItem("filterCopy", JSON.stringify(filterCopy));
            };
            this._pasteFilterSettings = () => {
                let filterCopy = new FilterSettings();
                filterCopy.fromJsonObject(JSON.parse(String(window.localStorage.getItem("filterCopy"))));
                if (filterCopy != null) {
                    this.filterEditor.swapToSettings(filterCopy, true);
                }
            };
            this._whenKeyPressed = (event) => {
                if (event.keyCode == 90) {
                    let newIdx = this.filterEditor.undo();
                    if (newIdx >= 0) {
                        this._setSubfilter(newIdx, false, false);
                    }
                    event.stopPropagation();
                }
                if (event.keyCode == 89) {
                    let newIdx = this.filterEditor.redo();
                    if (newIdx >= 0) {
                        this._setSubfilter(newIdx, false, false);
                    }
                    event.stopPropagation();
                }
                if (event.keyCode >= 49 && event.keyCode <= 57) {
                    if (!event.shiftKey) {
                        this.filterEditor.swapSubfilterIndices(event.keyCode - 49);
                        event.stopPropagation();
                    }
                }
            };
            this._togglePlay = () => {
                this._songEditor.togglePlay();
                this.updatePlayButton();
            };
            this._close = () => {
                this._doc.prompt = null;
                this.filterEditor.resetToInitial();
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                else if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
                else if (event.keyCode == 90) {
                    this.filterEditor.undo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 89) {
                    this.filterEditor.redo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 219) {
                    this._doc.synth.goToPrevBar();
                }
                else if (event.keyCode == 221) {
                    this._doc.synth.goToNextBar();
                }
                else if (event.keyCode >= 48 && event.keyCode <= 57) {
                    if (event.shiftKey) {
                        this._setSubfilter(event.keyCode - 48);
                    }
                }
            };
            this._saveChanges = () => {
                this._doc.prompt = null;
                this.filterEditor.saveSettings();
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._playButton.addEventListener("click", this._togglePlay);
            this._filterCopyButton.addEventListener("click", this._copyFilterSettings);
            this._filterPasteButton.addEventListener("click", this._pasteFilterSettings);
            this.updatePlayButton();
            let colors = ColorConfig.getChannelColor(this._doc.song, this._doc.channel);
            this.filterEditor = new FilterEditor(_doc, _useNoteFilter, true, this.forSong);
            this._filterContainer.appendChild(this.filterEditor.container);
            this.filterEditor.container.insertBefore(this._filterCoordinateText, this.filterEditor.container.firstChild);
            this.filterEditor.coordText = this._filterCoordinateText;
            this._editorTitle.children[0].innerHTML = forSong ? "Edit Song EQ Filter" : (_useNoteFilter) ? "Edit Note Filter" : "Edit EQ Filter";
            let newButton = button$k({ class: "no-underline", style: "max-width: 5em;" }, "Main");
            this._filterButtonContainer.appendChild(newButton);
            this._filterButtons.push(newButton);
            newButton.addEventListener("click", () => { this._setSubfilter(0); });
            for (let i = 1; i < Config.filterMorphCount; i++) {
                let newSubButton = button$k({ class: "no-underline", style: "max-width: 2em;" }, "" + i);
                this._filterButtons.push(newSubButton);
                this._filterButtonContainer.appendChild(newSubButton);
                newSubButton.addEventListener("click", () => { this._setSubfilter(i); });
            }
            this._filterButtons[Config.filterMorphCount - 1].classList.add("last-button");
            this._filterButtons[0].classList.add("selected-instrument");
            this._filterButtonContainer.style.setProperty("--text-color-lit", colors.primaryNote);
            this._filterButtonContainer.style.setProperty("--text-color-dim", colors.secondaryNote);
            this._filterButtonContainer.style.setProperty("--background-color-lit", colors.primaryChannel);
            this._filterButtonContainer.style.setProperty("--background-color-dim", colors.secondaryChannel);
            this._filterContainer.addEventListener("keydown", this._whenKeyPressed);
            this.filterEditor.container.addEventListener("keydown", this._whenKeyPressed);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            setTimeout(() => this._playButton.focus());
            this.filterEditor.render();
        }
        updatePlayButton() {
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            }
        }
    }

    const { button: button$j, div: div$j, h2: h2$i, input: input$e, label: label$2, br: br$2 } = HTML;
    class InstrumentExportPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._cancelButton = button$j({ class: "cancelButton" });
            this._exportButton = button$j({ class: "exportButton", style: "width:45%;" }, "Export");
            this._exportMultipleBox = input$e({ style: "width: 3em; margin-left: 1em;", type: "checkbox" });
            this._channelName = this._doc.song.channels[this._doc.channel].name == "" ? Config.jsonFormat + "-Instrument" : this._doc.song.channels[this._doc.channel].name;
            this._fileName = input$e({ type: "text", style: "width: 10em;", value: this._channelName, maxlength: 250, "autofocus": "autofocus" });
            this.container = div$j({ class: "prompt noSelection", style: "width: 200px;" }, h2$i("Export Instruments Options"), div$j({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "File name:", this._fileName), label$2({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, "Export all instruments", br$2(), "in channel:", this._exportMultipleBox), div$j({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._exportButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._cancelButton.removeEventListener("click", this._close);
                this._exportButton.removeEventListener("click", this._decide_export);
                this._fileName.removeEventListener("input", InstrumentExportPrompt._validateFileName);
            };
            this._decide_export = () => {
                this._exportMultipleBox.checked ? this._export_multiple() : this._export_single();
            };
            this._export_multiple = () => {
                const channel = this._doc.song.channels[this._doc.channel];
                const instruments = channel.instruments.map((instrument) => {
                    const instrumentCopy = instrument.toJsonObject();
                    instrumentCopy["isDrum"] = this._doc.song.getChannelIsNoise(this._doc.channel);
                    return instrumentCopy;
                });
                const jsonBlob = new Blob([JSON.stringify(instruments)], { type: 'application/json' });
                if (location.href.startsWith("file:///")) {
                 	NativeJava.DownloadText(jsonBlob , this._fileName.value + '.json') 
                }
                const downloadLink = document.createElement('a');
                downloadLink.href = URL.createObjectURL(jsonBlob);
                downloadLink.download = this._fileName.value + '.json';
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                this._close();
            };
            this._export_single = () => {
                const channel = this._doc.song.channels[this._doc.channel];
                const instrument = channel.instruments[this._doc.getCurrentInstrument()];
                const instrumentCopy = instrument.toJsonObject();
                instrumentCopy["isDrum"] = this._doc.song.getChannelIsNoise(this._doc.channel);
                const jsonBlob = new Blob([JSON.stringify(instrumentCopy)], { type: 'application/json' });
                if (location.href.startsWith("file:///")) {
                 	NativeJava.DownloadText(jsonBlob, this._fileName.value + '.json');
                }
                const downloadLink = document.createElement('a');
                downloadLink.href = URL.createObjectURL(jsonBlob);
                downloadLink.download = this._fileName.value + '.json';
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                this._close();
            };
            this._cancelButton.addEventListener("click", this._close);
            this._exportButton.addEventListener("click", this._decide_export);
            this._fileName.addEventListener("input", InstrumentExportPrompt._validateFileName);
        }
        static _validateFileName(event, use) {
            let input;
            if (event != null) {
                input = event.target;
            }
            else if (use != undefined) {
                input = use;
            }
            else {
                return;
            }
            const deleteChars = /[\+\*\$\?\|\{\}\\\/<>#%!`&'"=:@]/gi;
            if (deleteChars.test(input.value)) {
                let cursorPos = input.selectionStart;
                input.value = input.value.replace(deleteChars, "");
                cursorPos--;
                input.setSelectionRange(cursorPos, cursorPos);
            }
        }
    }

    const { button: button$i, div: div$i, h2: h2$h, input: input$d, select: select$b, option: option$b, code: code$1 } = HTML;
    class InstrumentImportPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._cancelButton = button$i({ class: "cancelButton" });
            this._importStrategySelect = select$b({ style: "width: 100%;" }, option$b({ value: "append" }, "Append instruments to the end of the list."), option$b({ value: "replace" }, "Replace only the selected instrument."), option$b({ value: "all" }, "Replace all instruments in the channel."));
            this._fileInput = input$d({ type: "file", accept: ".json,application/json" });
            this._strategyInfoText = div$i({ style: "text-align: left;" }, "You must enable either ", code$1("Simultaneous instruments per channel"), " or ", code$1("Different instruments per pattern"), " to change the import strategy.");
            this.container = div$i({ class: "prompt noSelection", style: "width: 300px;" }, h2$h("Import Instrument(s)"), this._strategyInfoText, div$i({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$i({ class: "selectContainer", style: "width: 100%;" }, this._importStrategySelect)), this._fileInput, this._cancelButton);
            this._whenFileSelected = () => {
                const file = this._fileInput.files[0];
                if (!file)
                    return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    var _a;
                    try {
                        const fileParsed = JSON.parse(String((_a = e.target) === null || _a === void 0 ? void 0 : _a.result));
                        console.log("Processing file:", fileParsed);
                        if (fileParsed.constructor.name == "Array") {
                            if ((this._doc.song.patternInstruments || this._doc.song.layeredInstruments) == false) {
                                alert("Instrument file contains multiple instruments! Please turn on either Simultaneous instruments per channel or Different instruments per pattern!");
                                return;
                            }
                            this._import_multiple(fileParsed);
                            return;
                        }
                        else {
                            this._import_single(fileParsed);
                        }
                    }
                    catch (error) {
                        console.error('Error reading file:', error);
                    }
                };
                reader.readAsText(file);
            };
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._fileInput.removeEventListener("change", this._whenFileSelected);
                this._cancelButton.removeEventListener("click", this._close);
            };
            this._import_multiple = (file) => {
                const channel = this._doc.song.channels[this._doc.channel];
                const currentInstrum = channel.instruments[this._doc.getCurrentInstrument()];
                switch (this._importStrategySelect.value) {
                    case "replace":
                        window.localStorage.setItem("instrumentImportStrategy", this._importStrategySelect.value);
                        const firstInstrum = file[0];
                        this._doc.record(new ChangePasteInstrument(this._doc, currentInstrum, firstInstrum));
                        for (let i = 1; i < file.length; i++) {
                            const insturm = file[i];
                            if (!this._validate_instrument_limit(channel)) {
                                alert("Max instruments reached! Some instruments were not imported.");
                                break;
                            }
                            this._doc.record(new ChangeAppendInstrument(this._doc, channel, insturm));
                        }
                        this._doc.record(new ChangeViewInstrument(this._doc, this._doc.getCurrentInstrument()));
                        this._doc.prompt = null;
                        this._doc.notifier.changed();
                        return;
                    case "all":
                        window.localStorage.setItem("instrumentImportStrategy", this._importStrategySelect.value);
                        channel.instruments.length = 0;
                        for (let insturm of file) {
                            if (!this._validate_instrument_limit(channel)) {
                                alert("Max instruments reached! Some instruments were not imported.");
                                break;
                            }
                            this._doc.record(new ChangeAppendInstrument(this._doc, channel, insturm));
                        }
                        this._doc.record(new ChangeViewInstrument(this._doc, channel.instruments.length - 1));
                        this._doc.prompt = null;
                        this._doc.notifier.changed();
                        return;
                    default:
                        window.localStorage.setItem("instrumentImportStrategy", this._importStrategySelect.value);
                        for (let insturm of file) {
                            if (!this._validate_instrument_limit(channel)) {
                                alert("Max instruments reached! Some instruments were not imported.");
                                break;
                            }
                            this._doc.record(new ChangeAppendInstrument(this._doc, channel, insturm));
                        }
                        this._doc.record(new ChangeViewInstrument(this._doc, channel.instruments.length - 1));
                        this._doc.prompt = null;
                        this._doc.notifier.changed();
                        return;
                }
            };
            this._validate_instrument_limit = (channel) => {
                if (this._doc.song.getMaxInstrumentsPerChannel() <= channel.instruments.length) {
                    return false;
                }
                return true;
            };
            this._import_single = (file) => {
                const channel = this._doc.song.channels[this._doc.channel];
                const currentInstrum = channel.instruments[this._doc.getCurrentInstrument()];
                switch (this._importStrategySelect.value) {
                    case "replace":
                        window.localStorage.setItem("instrumentImportStrategy", this._importStrategySelect.value);
                        this._doc.record(new ChangePasteInstrument(this._doc, currentInstrum, file));
                        this._doc.record(new ChangeViewInstrument(this._doc, this._doc.getCurrentInstrument()));
                        this._doc.prompt = null;
                        this._doc.notifier.changed();
                        return;
                    case "all":
                        window.localStorage.setItem("instrumentImportStrategy", this._importStrategySelect.value);
                        channel.instruments.length = 1;
                        const firstInstrum = channel.instruments[0];
                        this._doc.record(new ChangePasteInstrument(this._doc, firstInstrum, file));
                        this._doc.record(new ChangeViewInstrument(this._doc, 0));
                        this._doc.prompt = null;
                        this._doc.notifier.changed();
                        return;
                    default:
                        if (!this._validate_instrument_limit(channel)) {
                            alert("Max instruments reached! The instrument was not imported.");
                            this._doc.prompt = null;
                            return;
                        }
                        window.localStorage.setItem("instrumentImportStrategy", this._importStrategySelect.value);
                        this._doc.record(new ChangeAppendInstrument(this._doc, channel, file));
                        this._doc.record(new ChangeViewInstrument(this._doc, channel.instruments.length - 1));
                        this._doc.prompt = null;
                        this._doc.notifier.changed();
                        return;
                }
            };
            if ((_doc.song.patternInstruments || _doc.song.layeredInstruments) == false) {
                this._importStrategySelect.disabled = true;
                this._importStrategySelect.value = "replace";
                this._strategyInfoText.hidden = false;
            }
            else {
                const lastStrategy = window.localStorage.getItem("instrumentImportStrategy");
                if (lastStrategy != null)
                    this._importStrategySelect.value = lastStrategy;
                this._strategyInfoText.hidden = true;
            }
            this._fileInput.addEventListener("change", this._whenFileSelected);
            this._cancelButton.addEventListener("click", this._close);
        }
    }

    const { button: button$h, div: div$h, h2: h2$g, input: input$c } = HTML;
    function gcd(x, y) {
        while (y !== 0) {
            const z = x % y;
            x = y;
            y = z;
        }
        return x;
    }
    function lcm(a, b) {
        return Math.floor(Math.abs(a * b) / gcd(a, b));
    }
    function fraction(a, b) {
        let n = a;
        let d = b;
        const g = gcd(n, d);
        if (g > 1) {
            n = Math.floor(n / g);
            d = Math.floor(d / g);
        }
        return [n, d];
    }
    function fractionMul(a, b) {
        const an = a[0];
        const ad = a[1];
        const bn = b[0];
        const bd = b[1];
        return fraction(an * bn, ad * bd);
    }
    function fractionDiv(a, b) {
        const an = a[0];
        const ad = a[1];
        const bn = b[0];
        const bd = b[1];
        return fraction(an * bd, ad * bn);
    }
    function fractionLCM(a, b) {
        const an = a[0];
        const ad = a[1];
        const bn = b[0];
        const bd = b[1];
        return fraction(lcm(an, bn), gcd(ad, bd));
    }
    function generateEuclideanRhythm(steps, pulses, offset) {
        steps = Math.max(0, steps);
        pulses = Math.max(0, Math.min(steps, pulses));
        let columns = [];
        for (let step = 0; step < steps; step++)
            columns.push([step >= pulses ? 0 : 1]);
        let a = steps;
        let b = steps - pulses;
        if (a > 0 && b > 0) {
            while (a !== b) {
                if (a > b) {
                    a = a - b;
                }
                else {
                    b = b - a;
                }
                const amountToMove = Math.min(a, b);
                if (amountToMove <= 1)
                    continue;
                for (let i = 0; i < amountToMove; i++) {
                    const moved = columns.pop();
                    if (moved != null)
                        for (const v of moved)
                            columns[i].push(v);
                }
            }
        }
        let pattern = [];
        for (const c of columns)
            for (const v of c)
                pattern.push(v);
        if (offset !== 0) {
            offset = (offset % pattern.length + pattern.length) % pattern.length;
            offset = pattern.length - offset;
            pattern = pattern.slice(offset).concat(pattern.slice(0, offset));
        }
        return pattern;
    }
    class EuclideanRhythmPrompt {
        constructor(_doc) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            this._doc = _doc;
            this._minSteps = 2;
            this._maxSteps = 64;
            this._maxSequences = 14;
            this._maxChannel = Config.pitchChannelCountMax + Config.noiseChannelCountMax - 1;
            this._localStorageKey = "euclidGenMemory";
            this._sequenceIndex = 0;
            this._renderedSequenceCount = 0;
            this._highlightedSequenceIndex = -1;
            this._startBar = 0;
            this._barAmount = 1;
            this._barsAvailable = Config.barCountMax;
            this._barPreviewBarIndex = 0;
            this._barPreviewWidth = 400;
            this._barPreviewHeight = 10;
            this._clockWidth = 100;
            this._clockHeight = 100;
            this._clockPointMinRadius = this._clockWidth / this._maxSteps;
            this._clockPointMaxRadius = this._clockWidth / 16;
            this._clockPadding = this._clockWidth / this._maxSteps;
            this._clockRadius = this._clockWidth / 2 - this._clockPointMaxRadius - this._clockPadding;
            this._sequenceButtons = [];
            this._sequenceRemoveButton = button$h({ class: "no-underline", style: "flex-grow: 0; flex-basis: 30px;" }, SVG.svg({ width: "26", height: "26", viewBox: "-13 -13 26 26", "pointer-events": "none" }, SVG.path({ d: "M -7.07 -5.66 L -5.66 -7.07 L 0 -1.4 L 5.66 -7.07 L 7.07 -5.66 L 1.4 0 L 7.07 5.66 L 5.66 7.07 L 0 1.4 L -5.66 7.07 L -7.07 5.66 L -1.4 0 z", fill: ColorConfig.primaryText })));
            this._sequenceAddButton = button$h({ class: "no-underline last-button", style: "flex-grow: 0; flex-basis: 30px;" }, SVG.svg({ width: "26", height: "26", viewBox: "-13 -13 26 26", "pointer-events": "none" }, SVG.path({ d: "M -8 -1 L -1 -1 L -1 -8 L 1 -8 L 1 -1 L 8 -1 L 8 1 L 1 1 L 1 8 L -1 8 L -1 1 L -8 1 z", fill: ColorConfig.primaryText })));
            this._sequenceButtonContainer = div$h({ class: "instrument-bar", style: "justify-content: center; width: 100%;" }, this._sequenceRemoveButton, this._sequenceAddButton);
            this._barPreviewBackground = SVG.svg({ "pointer-events": "none" });
            this._barPreviewSteps = SVG.svg({ "pointer-events": "none" });
            this._barPreviewLabel = div$h({ style: `flex-grow: 1; color: ${ColorConfig.secondaryText}` });
            this._barPreviewGoToFirstButton = button$h({ style: "height: auto; min-height: var(--button-size);" }, SVG.svg({ width: "26", height: "26", viewBox: "-13 -14 26 26", "pointer-events": "none" }, SVG.rect({ x: "-6", y: "-6", width: "2", height: "12", fill: ColorConfig.primaryText }), SVG.path({ d: "M 6 -6 L 6 6 L -3 0 z", fill: ColorConfig.primaryText })));
            this._barPreviewGoBackButton = button$h({ style: "height: auto; min-height: var(--button-size); margin-left: 1em;" }, SVG.svg({ width: "24", height: "26", viewBox: "-10 -14 24 26", "pointer-events": "none" }, SVG.path({ d: "M 6 -6 L 6 6 L -3 0 z", fill: ColorConfig.primaryText })));
            this._barPreviewGoForwardButton = button$h({ style: "height: auto; min-height: var(--button-size);" }, SVG.svg({ width: "24", height: "26", viewBox: "-14 -14 24 26", "pointer-events": "none" }, SVG.path({ d: "M -6 -6 L -6 6 L 3 0 z", fill: ColorConfig.primaryText })));
            this._barPreviewGoToLastButton = button$h({ style: "height: auto; min-height: var(--button-size); margin-left: 1em;" }, SVG.svg({ width: "26", height: "26", viewBox: "-13 -14 26 26", "pointer-events": "none" }, SVG.rect({ x: "4", y: "-6", width: "2", height: "12", fill: ColorConfig.primaryText }), SVG.path({ d: "M -6 -6 L -6 6 L 3 0 z", fill: ColorConfig.primaryText })));
            this._clockWire = SVG.circle({ cx: this._clockWidth / 2, cy: this._clockHeight / 2, r: this._clockRadius, stroke: ColorConfig.primaryText, "stroke-width": "0.5", fill: "none" });
            this._clockPoints = SVG.svg({ "pointer-events": "none" });
            this._stepsStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: this._minSteps, max: this._maxSteps, value: "8", step: "1" });
            this._pulsesStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "0", max: "8", value: "5", step: "1" });
            this._rotationStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "0", max: this._maxSteps, value: "0", step: "1" });
            this._stepSizeNumeratorStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "1", max: Config.partsPerBeat, value: "1", step: "1" });
            this._stepSizeDenominatorStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "1", max: Config.partsPerBeat, value: "4", step: "1" });
            this._channelStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "1", max: this._maxChannel + 1, value: "1", step: "1" });
            this._pitchStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "0", max: Config.maxPitch, value: "0", step: "1" });
            this._barAmountStepper = input$c({ style: "width: 3em; margin-left: 1em;", type: "number", min: "1", max: Config.barCountMax, value: "1", step: "1" });
            this._extendUntilLoopButton = button$h({ style: "height: auto; min-height: var(--button-size); margin-left: 1em;" }, "Extend until loop");
            this._generateFadingNotesBox = input$c({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: 1em;" });
            this._invertBox = input$c({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: 1em;" });
            this._okayButton = button$h({ class: "okayButton", style: "width: 45%;" }, "Okay");
            this._cancelButton = button$h({ class: "cancelButton" });
            this.container = div$h({ class: "prompt noSelection", style: "width: 600px;" }, h2$g("Generate Euclidean Rhythm"), div$h({ style: "display: flex; flex-direction: row; align-items: center;" }, this._sequenceButtonContainer), div$h({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, div$h({ style: "flex-grow: 0; flex-shrink: 0;" }, this._barPreviewGoToFirstButton, this._barPreviewGoBackButton), this._barPreviewLabel, div$h({ style: "flex-grow: 0; flex-shrink: 0;" }, this._barPreviewGoForwardButton, this._barPreviewGoToLastButton)), div$h({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center;" }, SVG.svg({ "pointer-events": "none", style: "touch-action: none; overflow: hidden;", width: "100%", height: "20px", viewBox: `0 0 ${this._barPreviewWidth} ${this._barPreviewHeight}`, preserveAspectRatio: "none" }, this._barPreviewBackground, this._barPreviewSteps)), div$h({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-evenly;" }, div$h({ style: "max-width: 150px; height: 100%;" }, SVG.svg({ "pointer-events": "none", width: "100%", height: "100%", style: "touch-action: none; overflow: hidden; margin-right: 1.5em; max-width: 150px; height: 100%;", viewBox: `0 0 ${this._clockWidth} ${this._clockHeight}`, preserveAspectRatio: "none" }, this._clockWire, this._clockPoints)), div$h({ style: "display: flex; height: 100%;" }, div$h({ style: "flex-grow: 1; " }, div$h({ style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end;" }, div$h({ style: `text-align: right; flex-grow: 1; color: ${ColorConfig.primaryText};` }, "Steps"), this._stepsStepper), div$h({ style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;" }, div$h({ style: `text-align: right; flex-grow: 1; color: ${ColorConfig.primaryText};` }, "Pulses"), this._pulsesStepper), div$h({ style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;" }, div$h({ style: `text-align: right; flex-grow: 1; color: ${ColorConfig.primaryText};` }, "Rotation"), this._rotationStepper)), div$h({ style: "flex-grow: 1; margin-left: 1em;" }, div$h({ style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-bottom: 1em;" }, div$h({ style: `text-align: right; flex-grow: 1; color: ${ColorConfig.primaryText};` }, "Size"), div$h({ style: "display: flex; flex-direction: column;" }, this._stepSizeNumeratorStepper, this._stepSizeDenominatorStepper)), div$h({ style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;" }, div$h({ style: `text-align: right; flex-grow: 1; color: ${ColorConfig.primaryText};` }, "Channel"), this._channelStepper), div$h({ style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;" }, div$h({ style: `text-align: right; flex-grow: 1; color: ${ColorConfig.primaryText};` }, "Pitch"), this._pitchStepper)))), div$h({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;" }, div$h({ style: `text-align: right; color: ${ColorConfig.primaryText};` }, "Generate fading notes"), this._generateFadingNotesBox, div$h({ style: `text-align: right; color: ${ColorConfig.primaryText}; margin-left: 1em;` }, "Invert"), this._invertBox), div$h({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;" }, div$h({ style: `text-align: right; color: ${ColorConfig.primaryText};` }, "Length (in bars)"), this._barAmountStepper, this._extendUntilLoopButton), div$h({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
                this._sequenceButtonContainer.removeEventListener("click", this._whenSelectSequence);
                this._barPreviewGoToFirstButton.removeEventListener("click", this._whenBarPreviewGoToFirstClicked);
                this._barPreviewGoBackButton.removeEventListener("click", this._whenBarPreviewGoBackClicked);
                this._barPreviewGoForwardButton.removeEventListener("click", this._whenBarPreviewGoForwardClicked);
                this._barPreviewGoToLastButton.removeEventListener("click", this._whenBarPreviewGoToLastClicked);
                this._stepsStepper.removeEventListener("change", this._whenStepsChanges);
                this._pulsesStepper.removeEventListener("change", this._whenPulsesChanges);
                this._rotationStepper.removeEventListener("change", this._whenRotationChanges);
                this._stepSizeNumeratorStepper.removeEventListener("change", this._whenStepSizeChanges);
                this._stepSizeDenominatorStepper.removeEventListener("change", this._whenStepSizeChanges);
                this._channelStepper.removeEventListener("change", this._whenChannelChanges);
                this._pitchStepper.removeEventListener("change", this._whenPitchChanges);
                this._barAmountStepper.removeEventListener("change", this._whenBarAmountChanges);
                this._invertBox.removeEventListener("change", this._whenInvertChanges);
                this._generateFadingNotesBox.removeEventListener("change", this._whenGenerateFadingNotesChanges);
                this._extendUntilLoopButton.removeEventListener("click", this._whenExtendUntilLoopClicked);
            };
            this._close = () => {
                this._doc.undo();
            };
            this._saveChanges = () => {
                this._doc.prompt = null;
                const group = new ChangeGroup();
                const beatsPerBar = this._doc.song.beatsPerBar;
                const partsPerBeat = Config.partsPerBeat;
                const partsPerBar = partsPerBeat * beatsPerBar;
                const firstBar = this._startBar;
                const lastBar = firstBar + this._barAmount;
                if (lastBar > this._doc.song.barCount) {
                    const existing = this._doc.song.barCount - firstBar;
                    const remaining = this._barAmount - existing;
                    group.append(new ChangeInsertBars(this._doc, this._doc.song.barCount, remaining));
                }
                let allNewNotesByChannel = new Map();
                let pitchesToBeGenerated = new Map();
                for (let bar = firstBar; bar < lastBar; bar++) {
                    const relativeBar = bar - firstBar;
                    const partOffset = relativeBar * partsPerBar;
                    for (let sequenceIndex = 0; sequenceIndex < this._sequences.length; sequenceIndex++) {
                        const sequence = this._sequences[sequenceIndex];
                        const generatedSequence = this._generatedSequences[sequenceIndex];
                        const hasGeneratedSequence = generatedSequence.length > 0;
                        if (!hasGeneratedSequence) {
                            continue;
                        }
                        const steps = sequence.steps;
                        if (generatedSequence.length !== steps) {
                            console.error("The size of the generated sequence and the specified number of steps it should take have diverged: generated", generatedSequence.length, "steps but expected", steps);
                            continue;
                        }
                        const stepSize = sequence.stepSizeNumerator / sequence.stepSizeDenominator;
                        const pitch = sequence.pitch;
                        const channelIndex = sequence.channel;
                        const invert = sequence.invert;
                        const on = invert ? 0 : 1;
                        const generateFadingNotes = sequence.generateFadingNotes;
                        pitchesToBeGenerated.set(pitch, true);
                        let resultingChannel = allNewNotesByChannel.get(channelIndex);
                        if (resultingChannel == undefined) {
                            resultingChannel = [];
                            for (let i = 0; i < this._barAmount; i++) {
                                const newResultingBar = [];
                                for (let j = 0; j < this._sequences.length; j++) {
                                    const newResultingSequence = [];
                                    newResultingBar.push(newResultingSequence);
                                }
                                resultingChannel.push(newResultingBar);
                            }
                            allNewNotesByChannel.set(channelIndex, resultingChannel);
                        }
                        const resultingBar = resultingChannel[relativeBar];
                        let resultingSequence = resultingBar[sequenceIndex];
                        const firstStep = Math.floor((beatsPerBar * relativeBar) / stepSize);
                        const lastStep = Math.ceil((beatsPerBar * (relativeBar + 1)) / stepSize);
                        for (let step = firstStep; step < lastStep; step++) {
                            let continuesLastPattern = false;
                            let needToAdjustPins = false;
                            const rawStepPartStart = (Math.floor(step * partsPerBeat * stepSize) - partOffset);
                            const rawStepPartEnd = (Math.floor((step + 1) * partsPerBeat * stepSize) - partOffset);
                            if (rawStepPartStart < 0) {
                                continuesLastPattern = true;
                            }
                            if (continuesLastPattern || rawStepPartEnd > partsPerBar) {
                                needToAdjustPins = true;
                            }
                            const stepPartStart = Math.max(0, Math.min(partsPerBar, rawStepPartStart));
                            const stepPartEnd = Math.max(0, Math.min(partsPerBar, rawStepPartEnd));
                            if (generatedSequence[step % steps] === on) {
                                const note = new Note(pitch, stepPartStart, stepPartEnd, Config.noteSizeMax, generateFadingNotes);
                                if (continuesLastPattern) {
                                    note.continuesLastPattern = true;
                                }
                                if (needToAdjustPins && generateFadingNotes) {
                                    const startRatio = (stepPartStart - rawStepPartStart) / (rawStepPartEnd - rawStepPartStart);
                                    const startPinSize = Math.round(Config.noteSizeMax + (0 - Config.noteSizeMax) * startRatio);
                                    note.pins[0].size = startPinSize;
                                    const endRatio = (stepPartEnd - rawStepPartStart) / (rawStepPartEnd - rawStepPartStart);
                                    const endPinSize = Math.round(Config.noteSizeMax + (0 - Config.noteSizeMax) * endRatio);
                                    note.pins[1].size = endPinSize;
                                }
                                resultingSequence.push(note);
                            }
                        }
                    }
                }
                for (const [channelIndex, resultingChannel] of allNewNotesByChannel.entries()) {
                    for (let resultingBarIndex = 0; resultingBarIndex < resultingChannel.length; resultingBarIndex++) {
                        const resultingBar = resultingChannel[resultingBarIndex];
                        const bar = resultingBarIndex + firstBar;
                        let oldNotes = [];
                        const oldPattern = this._doc.song.getPattern(channelIndex, bar);
                        if (oldPattern != null) {
                            oldNotes = oldPattern.cloneNotes();
                        }
                        group.append(new ChangePatternNumbers(this._doc, 0, bar, channelIndex, 1, 1));
                        group.append(new ChangeEnsurePatternExists(this._doc, channelIndex, bar));
                        const pattern = this._doc.song.getPattern(channelIndex, bar);
                        if (pattern == null) {
                            throw new Error("Couldn't create new pattern");
                        }
                        let merged = [];
                        for (let oldNoteIndex = oldNotes.length - 1; oldNoteIndex >= 0; oldNoteIndex--) {
                            const oldNote = oldNotes[oldNoteIndex];
                            let newPitches = [];
                            for (const oldPitch of oldNote.pitches) {
                                if (!pitchesToBeGenerated.has(oldPitch)) {
                                    newPitches.push(oldPitch);
                                }
                            }
                            oldNote.pitches = newPitches;
                            if (oldNote.pitches.length < 1) {
                                oldNotes.splice(oldNoteIndex, 1);
                            }
                        }
                        let timeline = [];
                        for (const note of oldNotes) {
                            timeline.push({ noteType: "old", eventType: "start", part: note.start, note: note });
                            timeline.push({ noteType: "old", eventType: "end", part: note.end, note: note });
                        }
                        for (const resultingSequence of resultingBar) {
                            for (const note of resultingSequence) {
                                timeline.push({ noteType: "new", eventType: "start", part: note.start, note: note });
                                timeline.push({ noteType: "new", eventType: "end", part: note.end, note: note });
                            }
                        }
                        timeline.sort((a, b) => { return a.part - b.part; });
                        let eventGroups = [];
                        let currentEventGroup = null;
                        for (let event of timeline) {
                            if (currentEventGroup == null) {
                                currentEventGroup = { part: event.part, events: [event] };
                            }
                            else {
                                if (event.part !== currentEventGroup.part) {
                                    eventGroups.push(currentEventGroup);
                                    currentEventGroup = { part: event.part, events: [event] };
                                }
                                else {
                                    currentEventGroup.events.push(event);
                                }
                            }
                        }
                        if (currentEventGroup != null)
                            eventGroups.push(currentEventGroup);
                        let heldNotes = [];
                        let mergedStartPart = 0;
                        let mergedEndPart = 0;
                        let notesToDrop = new Set();
                        let notesToAdd = [];
                        let setOfPitchesToCommit = new Set();
                        for (const eventGroup of eventGroups) {
                            if (heldNotes.length === 0) {
                                for (const event of eventGroup.events) {
                                    if (event.eventType === "end") {
                                        throw new Error("Got note end earlier than expected");
                                    }
                                    else if (event.eventType === "start") {
                                        heldNotes.push({ noteType: event.noteType, note: event.note });
                                    }
                                    else {
                                        throw new Error("Unknown mergeable event type");
                                    }
                                }
                                mergedStartPart = eventGroup.part;
                            }
                            else {
                                for (const event of eventGroup.events) {
                                    if (event.eventType === "end") {
                                        notesToDrop.add(event.note);
                                    }
                                    else if (event.eventType === "start") {
                                        notesToAdd.push({ noteType: event.noteType, note: event.note });
                                    }
                                    else {
                                        throw new Error("Unknown mergeable event type");
                                    }
                                }
                                mergedEndPart = eventGroup.part;
                                const mergedNote = new Note(0, mergedStartPart, mergedEndPart, Config.noteSizeMax, false);
                                let continuesLastPattern = false;
                                let theNewNote = null;
                                let theOldNote = null;
                                for (const mergeableNote of heldNotes) {
                                    const note = mergeableNote.note;
                                    for (const candidatePitch of note.pitches) {
                                        setOfPitchesToCommit.add(candidatePitch);
                                    }
                                    if (note.continuesLastPattern)
                                        continuesLastPattern = true;
                                    if (mergeableNote.noteType === "new") {
                                        if (theNewNote == null
                                            || mergeableNote.note.start > theNewNote.start
                                            || mergeableNote.note.end < theNewNote.end) {
                                            theNewNote = mergeableNote.note;
                                        }
                                    }
                                    else if (mergeableNote.noteType === "old") {
                                        if (theOldNote != null)
                                            throw new Error("Somehow got more than one old note");
                                        theOldNote = mergeableNote.note;
                                    }
                                }
                                const pitchesToCommit = Array.from(setOfPitchesToCommit).sort((a, b) => a - b);
                                mergedNote.pitches = pitchesToCommit;
                                mergedNote.continuesLastPattern = continuesLastPattern;
                                if (theNewNote != null) {
                                    const theNewNoteStartPart = theNewNote.start;
                                    const theNewNoteEndPart = theNewNote.end;
                                    const startSize = theNewNote.pins[0].size;
                                    const endSize = theNewNote.pins[1].size;
                                    const startRatio = (mergedStartPart - theNewNoteStartPart) / (theNewNoteEndPart - theNewNoteStartPart);
                                    const startPinSize = Math.round(startSize + (endSize - startSize) * startRatio);
                                    mergedNote.pins[0].size = startPinSize;
                                    const endRatio = (mergedEndPart - theNewNoteStartPart) / (theNewNoteEndPart - theNewNoteStartPart);
                                    const endPinSize = Math.round(startSize + (endSize - startSize) * endRatio);
                                    mergedNote.pins[1].size = endPinSize;
                                }
                                else if (theOldNote != null) {
                                    const mergedNoteLength = mergedEndPart - mergedStartPart;
                                    const mergedStartRelativeToOldStart = mergedStartPart - theOldNote.start;
                                    const mergedEndRelativeToOldStart = mergedEndPart - theOldNote.start;
                                    let newPins = [];
                                    let firstVisibleOldPinIndex = -1;
                                    let lastVisibleOldPinIndex = -1;
                                    let leftAdjacentOldPinIndex = 0;
                                    let rightAdjacentOldPinIndex = theOldNote.pins.length - 1;
                                    for (let oldPinIndex = 0; oldPinIndex < theOldNote.pins.length; oldPinIndex++) {
                                        const oldPin = theOldNote.pins[oldPinIndex];
                                        if (oldPin.time < mergedStartRelativeToOldStart) {
                                            leftAdjacentOldPinIndex = oldPinIndex;
                                        }
                                        else if (oldPin.time >= mergedStartRelativeToOldStart && oldPin.time <= mergedEndRelativeToOldStart) {
                                            if (firstVisibleOldPinIndex === -1) {
                                                firstVisibleOldPinIndex = oldPinIndex;
                                            }
                                            lastVisibleOldPinIndex = oldPinIndex;
                                        }
                                        else if (oldPin.time > mergedEndRelativeToOldStart) {
                                            rightAdjacentOldPinIndex = oldPinIndex;
                                            break;
                                        }
                                    }
                                    if (firstVisibleOldPinIndex !== -1) {
                                        for (let visibleOldPinIndex = firstVisibleOldPinIndex; visibleOldPinIndex <= lastVisibleOldPinIndex; visibleOldPinIndex++) {
                                            const visibleOldPin = theOldNote.pins[visibleOldPinIndex];
                                            const correctedTime = visibleOldPin.time - mergedStartRelativeToOldStart;
                                            newPins.push(makeNotePin(0, correctedTime, visibleOldPin.size));
                                        }
                                        const firstNewPin = newPins[0];
                                        const lastNewPin = newPins[newPins.length - 1];
                                        if (firstNewPin.time !== 0) {
                                            const leftAdjacentOldPin = theOldNote.pins[leftAdjacentOldPinIndex];
                                            const lineMiddleTime = mergedStartRelativeToOldStart - leftAdjacentOldPin.time;
                                            const lineEndTime = lineMiddleTime + firstNewPin.time;
                                            const ratio = lineMiddleTime / lineEndTime;
                                            const newSize = Math.round(leftAdjacentOldPin.size + (firstNewPin.size - leftAdjacentOldPin.size) * ratio);
                                            newPins.unshift(makeNotePin(0, 0, newSize));
                                        }
                                        if (lastNewPin.time !== mergedNoteLength) {
                                            const rightAdjacentOldPin = theOldNote.pins[rightAdjacentOldPinIndex];
                                            const lineMiddleTime = mergedEndRelativeToOldStart - (lastNewPin.time + mergedStartRelativeToOldStart);
                                            const lineEndTime = lineMiddleTime + (rightAdjacentOldPin.time - mergedEndRelativeToOldStart);
                                            const ratio = lineMiddleTime / lineEndTime;
                                            const newSize = Math.round(lastNewPin.size + (rightAdjacentOldPin.size - lastNewPin.size) * ratio);
                                            newPins.push(makeNotePin(0, mergedNoteLength, newSize));
                                        }
                                    }
                                    else {
                                        const leftAdjacentOldPin = theOldNote.pins[leftAdjacentOldPinIndex];
                                        const rightAdjacentOldPin = theOldNote.pins[rightAdjacentOldPinIndex];
                                        const lineFirstIntersectionTime = mergedStartRelativeToOldStart - leftAdjacentOldPin.time;
                                        const lineLastIntersectionTime = mergedEndRelativeToOldStart - leftAdjacentOldPin.time;
                                        const lineLength = rightAdjacentOldPin.time - leftAdjacentOldPin.time;
                                        const firstRatio = lineFirstIntersectionTime / lineLength;
                                        const lastRatio = lineLastIntersectionTime / lineLength;
                                        const firstNewSize = Math.round(leftAdjacentOldPin.size + (rightAdjacentOldPin.size - leftAdjacentOldPin.size) * firstRatio);
                                        const lastNewSize = Math.round(leftAdjacentOldPin.size + (rightAdjacentOldPin.size - leftAdjacentOldPin.size) * lastRatio);
                                        newPins.push(makeNotePin(0, 0, firstNewSize));
                                        newPins.push(makeNotePin(0, mergedNoteLength, lastNewSize));
                                    }
                                    mergedNote.pins = newPins;
                                }
                                if (mergedNote.pins.length < 2) {
                                    throw new Error("Ended up generating note with less than two pins");
                                }
                                if (mergedNote.pitches.length < 1) {
                                    throw new Error("Ended up generating note with no pitches");
                                }
                                merged.push(mergedNote);
                                for (let note of notesToDrop) {
                                    for (let heldNoteIndex = heldNotes.length - 1; heldNoteIndex >= 0; heldNoteIndex--) {
                                        let heldNote = heldNotes[heldNoteIndex].note;
                                        if (note === heldNote) {
                                            heldNotes.splice(heldNoteIndex, 1);
                                        }
                                    }
                                }
                                for (let note of notesToAdd)
                                    heldNotes.push(note);
                                setOfPitchesToCommit.clear();
                                notesToDrop.clear();
                                while (notesToAdd.length > 0)
                                    notesToAdd.pop();
                                mergedStartPart = mergedEndPart;
                            }
                        }
                        pattern.notes = [];
                        for (let noteIndex = 0; noteIndex < merged.length; noteIndex++) {
                            const note = merged[noteIndex];
                            group.append(new ChangeNoteAdded(this._doc, pattern, note, noteIndex));
                        }
                    }
                }
                this._doc.record(group, true);
                window.localStorage.setItem(this._localStorageKey, JSON.stringify({
                    "sequences": this._sequences,
                    "barAmount": this._barAmount,
                }));
            };
            this._generateAllSequences = () => {
                this._generatedSequences = [];
                for (let i = 0; i < this._sequences.length; i++) {
                    this._generatedSequences.push([]);
                    this._generateSequence(i);
                }
            };
            this._generateSequence = (index) => {
                const sequence = this._sequences[index];
                this._generatedSequences[index] = generateEuclideanRhythm(sequence.steps, sequence.pulses, sequence.rotation);
            };
            this._generateCurrentSequence = () => {
                this._generateSequence(this._sequenceIndex);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._whenSelectSequence = (event) => {
                if (event.target == this._sequenceAddButton) {
                    const currentSequence = this._sequences[this._sequenceIndex];
                    this._sequences.push({
                        steps: currentSequence.steps,
                        pulses: currentSequence.pulses,
                        rotation: currentSequence.rotation,
                        stepSizeNumerator: currentSequence.stepSizeNumerator,
                        stepSizeDenominator: currentSequence.stepSizeDenominator,
                        channel: currentSequence.channel,
                        pitch: currentSequence.pitch,
                        invert: currentSequence.invert,
                        generateFadingNotes: currentSequence.generateFadingNotes,
                    });
                    this._sequenceIndex = this._sequences.length - 1;
                    this._generateCurrentSequence();
                    this._refreshSequenceWidgets();
                    this._reconfigurePulsesStepper();
                    this._reconfigurePitchStepper();
                    this._render();
                }
                else if (event.target == this._sequenceRemoveButton) {
                    this._sequences.splice(this._sequenceIndex, 1);
                    this._generatedSequences.splice(this._sequenceIndex, 1);
                    this._sequenceIndex = Math.max(0, Math.min(this._sequences.length - 1, this._sequenceIndex));
                    this._refreshSequenceWidgets();
                    this._reconfigurePulsesStepper();
                    this._reconfigurePitchStepper();
                    this._render();
                }
                else {
                    const index = this._sequenceButtons.indexOf(event.target);
                    if (index != -1) {
                        this._sequenceIndex = index;
                        this._refreshSequenceWidgets();
                        this._reconfigurePulsesStepper();
                        this._reconfigurePitchStepper();
                        this._render();
                    }
                }
            };
            this._whenBarPreviewGoToFirstClicked = (event) => {
                this._barPreviewBarIndex = this._startBar;
                this._renderBarPreview();
                this._renderLabel();
            };
            this._whenBarPreviewGoBackClicked = (event) => {
                this._barPreviewBarIndex = this._barPreviewBarIndex - 1;
                if (this._barPreviewBarIndex < this._startBar) {
                    this._barPreviewBarIndex += this._barAmount;
                }
                this._renderBarPreview();
                this._renderLabel();
            };
            this._whenBarPreviewGoForwardClicked = (event) => {
                this._barPreviewBarIndex = this._barPreviewBarIndex + 1;
                const lastBar = this._startBar + this._barAmount;
                if (this._barPreviewBarIndex >= lastBar) {
                    this._barPreviewBarIndex -= this._barAmount;
                }
                this._renderBarPreview();
                this._renderLabel();
            };
            this._whenBarPreviewGoToLastClicked = (event) => {
                const firstBar = this._startBar;
                const lastBar = firstBar + this._barAmount;
                this._barPreviewBarIndex = lastBar - 1;
                this._renderBarPreview();
                this._renderLabel();
            };
            this._whenInvertChanges = (event) => {
                const sequence = this._sequences[this._sequenceIndex];
                const invert = this._invertBox.checked;
                sequence.invert = invert;
                this._renderClock();
                this._renderBarPreview();
            };
            this._whenGenerateFadingNotesChanges = (event) => {
                const sequence = this._sequences[this._sequenceIndex];
                const generateFadingNotes = this._generateFadingNotesBox.checked;
                sequence.generateFadingNotes = generateFadingNotes;
                this._renderBarPreview();
            };
            this._whenExtendUntilLoopClicked = (event) => {
                const beatsPerBar = this._doc.song.beatsPerBar;
                const beatsPerBarFraction = [beatsPerBar, 1];
                const barAmountFraction = fractionDiv(this._sequences.reduce((acc, seq) => {
                    const steps = [seq.steps, 1];
                    const stepSize = fraction(seq.stepSizeNumerator, seq.stepSizeDenominator);
                    const total = fractionMul(steps, stepSize);
                    return fractionLCM(acc, fractionLCM(total, beatsPerBarFraction));
                }, [1, 1]), beatsPerBarFraction);
                const barAmount = barAmountFraction[0];
                this._barAmount = Math.max(1, Math.min(this._barsAvailable, barAmount));
                const firstBar = this._startBar;
                const lastBar = this._startBar + this._barAmount;
                this._barPreviewBarIndex = Math.max(firstBar, Math.min(lastBar - 1, this._barPreviewBarIndex));
                this._barAmountStepper.value = this._barAmount + "";
                this._renderBarPreview();
                this._renderLabel();
            };
            this._whenStepsChanges = (event) => {
                const steps = Math.max(this._minSteps, Math.min(this._maxSteps, +this._stepsStepper.value));
                const sequence = this._sequences[this._sequenceIndex];
                sequence.steps = steps;
                this._stepsStepper.value = steps + "";
                this._reconfigurePulsesStepper();
                this._generateCurrentSequence();
                this._render();
            };
            this._whenPulsesChanges = (event) => {
                const sequence = this._sequences[this._sequenceIndex];
                const pulses = Math.max(0, Math.min(sequence.steps, +this._pulsesStepper.value));
                sequence.pulses = pulses;
                this._pulsesStepper.value = pulses + "";
                this._generateCurrentSequence();
                this._render();
            };
            this._whenRotationChanges = (event) => {
                const rotation = Math.max(0, Math.min(this._maxSteps, +this._rotationStepper.value));
                const sequence = this._sequences[this._sequenceIndex];
                sequence.rotation = rotation;
                this._rotationStepper.value = rotation + "";
                this._generateCurrentSequence();
                this._render();
            };
            this._whenStepSizeChanges = (event) => {
                const numerator = Math.max(1, Math.min(Config.partsPerBeat, +this._stepSizeNumeratorStepper.value));
                const denominator = Math.max(1, Math.min(Config.partsPerBeat, +this._stepSizeDenominatorStepper.value));
                const sequence = this._sequences[this._sequenceIndex];
                sequence.stepSizeNumerator = numerator;
                sequence.stepSizeDenominator = denominator;
                this._stepSizeNumeratorStepper.value = numerator + "";
                this._stepSizeDenominatorStepper.value = denominator + "";
                this._renderBarPreview();
            };
            this._whenPitchChanges = (event) => {
                const sequence = this._sequences[this._sequenceIndex];
                const maxPitch = this._doc.song.getChannelIsNoise(sequence.channel) ? (Config.drumCount - 1) : Config.maxPitch;
                const pitch = Math.max(0, Math.min(maxPitch, +this._pitchStepper.value));
                sequence.pitch = pitch;
                this._pitchStepper.value = pitch + "";
                this._renderLabel();
            };
            this._whenChannelChanges = (event) => {
                const channel = Math.max(0, Math.min(this._maxChannel, (+this._channelStepper.value) - 1));
                const sequence = this._sequences[this._sequenceIndex];
                sequence.channel = channel;
                this._channelStepper.value = (channel + 1) + "";
                this._reconfigurePitchStepper();
                this._render();
            };
            this._whenBarAmountChanges = (event) => {
                const barAmount = Math.max(1, Math.min(this._barsAvailable, +this._barAmountStepper.value));
                this._barAmount = barAmount;
                const firstBar = this._startBar;
                const lastBar = this._startBar + this._barAmount;
                this._barPreviewBarIndex = Math.max(firstBar, Math.min(lastBar - 1, this._barPreviewBarIndex));
                this._barAmountStepper.value = barAmount + "";
                this._renderBarPreview();
                this._renderLabel();
            };
            this._initialRender = () => {
                const beatsPerBar = this._doc.song.beatsPerBar;
                const color = ColorConfig.pitchBackground;
                const container = this._barPreviewBackground;
                const padding = 1;
                const beatWidth = this._barPreviewWidth / beatsPerBar;
                const beatHeight = this._barPreviewHeight;
                for (let beat = 0; beat < beatsPerBar; beat++) {
                    const x = beat * beatWidth + padding;
                    const y = padding;
                    const w = beatWidth - padding * 2;
                    const h = beatHeight - padding * 2;
                    const beatElement = SVG.rect({
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        style: `fill: ${color};`,
                    });
                    container.appendChild(beatElement);
                }
                this._refreshSequenceWidgets();
                this._reconfigurePitchStepper();
                this._reconfigurePulsesStepper();
            };
            this._refreshSequenceWidgets = () => {
                const sequence = this._sequences[this._sequenceIndex];
                this._stepsStepper.value = sequence.steps + "";
                this._pulsesStepper.value = sequence.pulses + "";
                this._rotationStepper.value = sequence.rotation + "";
                this._stepSizeNumeratorStepper.value = sequence.stepSizeNumerator + "";
                this._stepSizeDenominatorStepper.value = sequence.stepSizeDenominator + "";
                this._channelStepper.value = (sequence.channel + 1) + "";
                this._pitchStepper.value = sequence.pitch + "";
                this._invertBox.checked = sequence.invert;
                this._generateFadingNotesBox.checked = sequence.generateFadingNotes;
                this._barAmountStepper.value = this._barAmount + "";
            };
            this._reconfigurePitchStepper = () => {
                const sequence = this._sequences[this._sequenceIndex];
                const channel = sequence.channel;
                const maxPitch = this._doc.song.getChannelIsNoise(channel) ? (Config.drumCount - 1) : Config.maxPitch;
                this._pitchStepper.value = Math.max(0, Math.min(maxPitch, +this._pitchStepper.value)) + "";
                this._pitchStepper.max = maxPitch + "";
                sequence.pitch = +this._pitchStepper.value;
            };
            this._reconfigurePulsesStepper = () => {
                const sequence = this._sequences[this._sequenceIndex];
                const steps = sequence.steps;
                this._pulsesStepper.value = Math.max(0, Math.min(steps, +this._pulsesStepper.value)) + "";
                this._pulsesStepper.max = steps + "";
                sequence.pulses = +this._pulsesStepper.value;
            };
            this._render = () => {
                this._renderClock();
                this._renderBarPreview();
                this._renderLabel();
                this._renderSequenceButtons();
            };
            this._renderSequenceButtons = () => {
                const container = this._sequenceButtonContainer;
                while (this._sequenceButtons.length < this._sequences.length) {
                    const sequenceButton = button$h({ class: "no-underline" }, (this._sequenceButtons.length + 1) + "");
                    this._sequenceButtons.push(sequenceButton);
                    container.insertBefore(sequenceButton, this._sequenceRemoveButton);
                }
                for (let i = this._renderedSequenceCount; i < this._sequences.length; i++) {
                    const sequenceButton = this._sequenceButtons[i];
                    sequenceButton.style.display = "";
                }
                for (let i = this._sequences.length; i < this._renderedSequenceCount; i++) {
                    this._sequenceButtons[i].style.display = "none";
                }
                this._renderedSequenceCount = this._sequences.length;
                while (this._sequenceButtons.length > this._maxSequences) {
                    container.removeChild(this._sequenceButtons.pop());
                }
                this._sequenceRemoveButton.style.display = (this._sequences.length > 1) ? "" : "none";
                this._sequenceAddButton.style.display = (this._sequences.length < this._maxSequences) ? "" : "none";
                if (this._sequences.length < this._maxSequences) {
                    this._sequenceRemoveButton.classList.remove("last-button");
                }
                else {
                    this._sequenceRemoveButton.classList.add("last-button");
                }
                if (this._highlightedSequenceIndex != this._sequenceIndex) {
                    const oldButton = this._sequenceButtons[this._highlightedSequenceIndex];
                    if (oldButton != null)
                        oldButton.classList.remove("selected-instrument");
                    const newButton = this._sequenceButtons[this._sequenceIndex];
                    newButton.classList.add("selected-instrument");
                    this._highlightedSequenceIndex = this._sequenceIndex;
                }
                for (let sequence = 0; sequence < this._sequences.length; sequence++) {
                    const sequenceButton = this._sequenceButtons[sequence];
                    if (sequence === this._highlightedSequenceIndex) {
                        sequenceButton.style.color = "";
                    }
                    else {
                        sequenceButton.style.color = ColorConfig.primaryText;
                    }
                }
                const colors = ColorConfig.getChannelColor(this._doc.song, this._sequences[this._sequenceIndex].channel);
                this._sequenceButtonContainer.style.setProperty("--text-color-lit", colors.primaryNote);
                this._sequenceButtonContainer.style.setProperty("--text-color-dim", colors.secondaryNote);
                this._sequenceButtonContainer.style.setProperty("--background-color-lit", colors.primaryChannel);
                this._sequenceButtonContainer.style.setProperty("--background-color-dim", colors.secondaryChannel);
            };
            this._renderLabel = () => {
                const sequence = this._sequences[this._sequenceIndex];
                const sequencePitch = sequence.pitch;
                const pitchNameIndex = (sequencePitch + Config.keys[this._doc.song.key].basePitch) % Config.pitchesPerOctave;
                let pitch = "";
                if (Config.keys[pitchNameIndex].isWhiteKey) {
                    pitch = Config.keys[pitchNameIndex].name;
                }
                else {
                    const shiftDir = Config.blackKeyNameParents[sequencePitch % Config.pitchesPerOctave];
                    pitch = Config.keys[(pitchNameIndex + Config.pitchesPerOctave + shiftDir) % Config.pitchesPerOctave].name;
                    if (shiftDir == 1) {
                        pitch += "";
                    }
                    else if (shiftDir == -1) {
                        pitch += "";
                    }
                }
                pitch += Math.floor(sequencePitch / Config.pitchesPerOctave);
                this._barPreviewLabel.innerText = `Bar ${this._barPreviewBarIndex + 1}, ${pitch}`;
            };
            this._renderClock = () => {
                const sequence = this._sequences[this._sequenceIndex];
                const steps = sequence.steps;
                const channelIndex = sequence.channel;
                const generatedSequence = this._generatedSequences[this._sequenceIndex];
                const hasGeneratedSequence = generatedSequence.length > 0;
                const invert = sequence.invert;
                const on = invert ? 0 : 1;
                const color = ColorConfig.getChannelColor(this._doc.song, channelIndex).primaryNote;
                const backgroundColor = ColorConfig.editorBackground;
                this._clockWire.setAttribute("stroke", color);
                const container = this._clockPoints;
                while (container.firstChild !== null) {
                    container.removeChild(container.firstChild);
                }
                const centerX = this._clockWidth / 2;
                const centerY = this._clockHeight / 2;
                const clockRadius = this._clockRadius;
                const clockPointRadius = Math.max(this._clockPointMinRadius, Math.min(this._clockPointMaxRadius, this._clockWidth / steps));
                for (let step = 0; step < steps; step++) {
                    const angle = (step / steps) * Math.PI * 2 - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * clockRadius;
                    const y = centerY + Math.sin(angle) * clockRadius;
                    const clockPoint = SVG.circle({
                        cx: x,
                        cy: y,
                        r: clockPointRadius,
                        style: `stroke: ${color}; stroke-width: 0.5; fill: ${backgroundColor}`,
                    });
                    if (hasGeneratedSequence && generatedSequence[step % steps] === on) {
                        clockPoint.setAttribute("style", `fill: ${color};`);
                    }
                    container.appendChild(clockPoint);
                }
            };
            this._renderBarPreview = () => {
                const beatsPerBar = this._doc.song.beatsPerBar;
                const partsPerBeat = Config.partsPerBeat;
                const partsPerBar = partsPerBeat * beatsPerBar;
                const sequence = this._sequences[this._sequenceIndex];
                const steps = sequence.steps;
                const channelIndex = sequence.channel;
                const stepSize = sequence.stepSizeNumerator / sequence.stepSizeDenominator;
                const generatedSequence = this._generatedSequences[this._sequenceIndex];
                const hasGeneratedSequence = generatedSequence.length > 0;
                const invert = sequence.invert;
                const on = invert ? 0 : 1;
                const generateFadingNotes = sequence.generateFadingNotes;
                const channelColors = ColorConfig.getChannelColor(this._doc.song, channelIndex);
                const color = channelColors.primaryNote;
                const secondaryColor = channelColors.secondaryNote;
                const bar = this._barPreviewBarIndex - this._startBar;
                const partOffset = bar * partsPerBar;
                const container = this._barPreviewSteps;
                while (container.firstChild !== null) {
                    container.removeChild(container.firstChild);
                }
                let toPushAtTheEnd = [];
                const beatWidth = this._barPreviewWidth / beatsPerBar;
                const partWidth = beatWidth / partsPerBeat;
                const beatHeight = this._barPreviewHeight;
                const padding = 0.2;
                const firstStep = Math.floor((beatsPerBar * bar) / stepSize);
                const lastStep = Math.ceil((beatsPerBar * (bar + 1)) / stepSize);
                const y = padding;
                const h = beatHeight - padding * 2;
                for (let step = firstStep; step < lastStep; step++) {
                    let continuesLastPattern = false;
                    let needToAdjustPins = false;
                    const rawStepPartStart = (Math.floor(step * partsPerBeat * stepSize) - partOffset);
                    const rawStepPartEnd = (Math.floor((step + 1) * partsPerBeat * stepSize) - partOffset);
                    if (rawStepPartStart < 0) {
                        continuesLastPattern = true;
                    }
                    if (continuesLastPattern || rawStepPartEnd > partsPerBar) {
                        needToAdjustPins = true;
                    }
                    const stepPartStart = Math.max(0, Math.min(partsPerBar, rawStepPartStart));
                    const stepPartEnd = Math.max(0, Math.min(partsPerBar, rawStepPartEnd));
                    const partAmount = stepPartEnd - stepPartStart;
                    const x = padding + stepPartStart * partWidth;
                    const w = partAmount * partWidth - padding * 2;
                    if (hasGeneratedSequence && generatedSequence[step % steps] === on) {
                        if (generateFadingNotes) {
                            const stepBackgroundElement = SVG.rect({
                                x: x,
                                y: y,
                                width: w,
                                height: h,
                                style: `fill: ${secondaryColor};`,
                            });
                            container.appendChild(stepBackgroundElement);
                            let startSize = Config.noteSizeMax;
                            let endSize = 0;
                            if (needToAdjustPins) {
                                const startRatio = (stepPartStart - rawStepPartStart) / (rawStepPartEnd - rawStepPartStart);
                                const startPinSize = Math.round(Config.noteSizeMax + (0 - Config.noteSizeMax) * startRatio);
                                startSize = startPinSize;
                                const endRatio = (stepPartEnd - rawStepPartStart) / (rawStepPartEnd - rawStepPartStart);
                                const endPinSize = Math.round(Config.noteSizeMax + (0 - Config.noteSizeMax) * endRatio);
                                endSize = endPinSize;
                            }
                            startSize /= Config.noteSizeMax;
                            endSize /= Config.noteSizeMax;
                            const x0 = x;
                            const y0 = y + (h / 2) * (1 - startSize);
                            const x1 = x + w;
                            const y1 = y + (h / 2) * (1 - endSize);
                            const x2 = x + w;
                            const y2 = y + h - (h / 2) * (1 - endSize);
                            const x3 = x;
                            const y3 = y + h - (h / 2) * (1 - startSize);
                            const stepElement = SVG.path({
                                d: `M ${x0} ${y0} L ${x1} ${y1} L ${x2} ${y2} L ${x3} ${y3} z`,
                                style: `fill: ${color};`,
                            });
                            container.appendChild(stepElement);
                        }
                        else {
                            const stepElement = SVG.rect({
                                x: x,
                                y: y,
                                width: w,
                                height: h,
                                style: `fill: ${color};`,
                            });
                            container.appendChild(stepElement);
                        }
                        if (continuesLastPattern) {
                            let indicatorOffset = 2 + padding;
                            const arrowHeight = Math.min(h, 20);
                            const arrowY = y + h / 2;
                            let arrowPath;
                            arrowPath = "M " + prettyNumber(partWidth * stepPartStart + indicatorOffset) + " " + prettyNumber(arrowY - 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(partWidth * stepPartStart + indicatorOffset) + " " + prettyNumber(arrowY + 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(partWidth * stepPartStart + indicatorOffset + 4) + " " + prettyNumber(arrowY + 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(partWidth * stepPartStart + indicatorOffset + 4) + " " + prettyNumber(arrowY + 0.3 * arrowHeight);
                            arrowPath += "L " + prettyNumber(partWidth * stepPartStart + indicatorOffset + 12) + " " + prettyNumber(arrowY);
                            arrowPath += "L " + prettyNumber(partWidth * stepPartStart + indicatorOffset + 4) + " " + prettyNumber(arrowY - 0.3 * arrowHeight);
                            arrowPath += "L " + prettyNumber(partWidth * stepPartStart + indicatorOffset + 4) + " " + prettyNumber(arrowY - 0.1 * arrowHeight);
                            const arrow = SVG.path();
                            arrow.setAttribute("d", arrowPath);
                            arrow.setAttribute("fill", ColorConfig.invertedText);
                            toPushAtTheEnd.push(arrow);
                        }
                    }
                }
                for (let element of toPushAtTheEnd) {
                    container.appendChild(element);
                }
            };
            this._startBar = this._doc.bar;
            this._barPreviewBarIndex = this._startBar;
            this._barsAvailable = Config.barCountMax - this._startBar;
            this._barAmountStepper.max = this._barsAvailable + "";
            this._maxChannel = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount - 1;
            this._channelStepper.max = (this._maxChannel + 1) + "";
            const defaultSteps = Math.max(this._minSteps, Math.min(this._maxSteps, this._doc.song.beatsPerBar));
            const defaultPulses = Math.max(0, Math.min(defaultSteps, 5));
            this._sequences = [{
                    steps: defaultSteps,
                    pulses: defaultPulses,
                    rotation: 0,
                    stepSizeNumerator: 1,
                    stepSizeDenominator: 4,
                    channel: Math.max(0, Math.min(this._maxChannel, this._doc.channel)),
                    pitch: 0,
                    invert: false,
                    generateFadingNotes: false,
                }];
            if (this._doc.selection.boxSelectionActive) {
                this._startBar = this._doc.selection.boxSelectionBar;
                this._barPreviewBarIndex = this._startBar;
                this._barAmount = Math.max(1, Math.min(this._barsAvailable, this._doc.selection.boxSelectionWidth));
                this._sequences[0].channel = Math.max(0, Math.min(this._maxChannel, this._doc.selection.boxSelectionChannel));
                for (let i = 1; i < this._doc.selection.boxSelectionHeight; i++) {
                    this._sequences.push({
                        steps: defaultSteps,
                        pulses: defaultPulses,
                        rotation: 0,
                        stepSizeNumerator: 1,
                        stepSizeDenominator: 4,
                        channel: Math.max(0, Math.min(this._maxChannel, this._doc.selection.boxSelectionChannel + i)),
                        pitch: 0,
                        invert: false,
                        generateFadingNotes: false,
                    });
                }
            }
            else {
                const savedData = JSON.parse(String(window.localStorage.getItem(this._localStorageKey)));
                if (savedData != null) {
                    const rawSequences = savedData["sequences"];
                    if (rawSequences != null && Array.isArray(rawSequences)) {
                        let parsedSequences = [];
                        for (let rawSequence of rawSequences) {
                            parsedSequences.push({
                                steps: Math.max(this._minSteps, Math.min(this._maxSteps, (_a = rawSequence["steps"]) !== null && _a !== void 0 ? _a : this._doc.song.beatsPerBar)),
                                pulses: Math.max(0, Math.min(this._maxSteps, (_b = rawSequence["pulses"]) !== null && _b !== void 0 ? _b : 5)),
                                rotation: Math.max(0, Math.min(this._maxSteps, (_c = rawSequence["rotation"]) !== null && _c !== void 0 ? _c : 0)),
                                stepSizeNumerator: Math.max(1, Math.min(Config.partsPerBeat, (_d = rawSequence["stepSizeNumerator"]) !== null && _d !== void 0 ? _d : 1)),
                                stepSizeDenominator: Math.max(1, Math.min(Config.partsPerBeat, (_e = rawSequence["stepSizeDenominator"]) !== null && _e !== void 0 ? _e : 4)),
                                channel: Math.max(0, Math.min(this._maxChannel, rawSequence["channel"])),
                                pitch: (_f = rawSequence["pitch"]) !== null && _f !== void 0 ? _f : 0,
                                invert: (_g = rawSequence["invert"]) !== null && _g !== void 0 ? _g : false,
                                generateFadingNotes: (_h = rawSequence["generateFadingNotes"]) !== null && _h !== void 0 ? _h : false,
                            });
                        }
                        this._sequences = parsedSequences;
                        if (this._sequences.length === 1) {
                            const sequence = this._sequences[this._sequenceIndex];
                            const channel = Math.max(0, Math.min(this._maxChannel, this._doc.channel));
                            sequence.channel = channel;
                            const maxPitch = this._doc.song.getChannelIsNoise(channel) ? (Config.drumCount - 1) : Config.maxPitch;
                            sequence.pitch = Math.max(0, Math.min(maxPitch, sequence.pitch));
                        }
                    }
                    this._barAmount = Math.max(1, Math.min(this._barsAvailable, (_j = savedData["barAmount"]) !== null && _j !== void 0 ? _j : this._barAmount));
                }
            }
            this._generateAllSequences();
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._sequenceButtonContainer.addEventListener("click", this._whenSelectSequence);
            this._barPreviewGoToFirstButton.addEventListener("click", this._whenBarPreviewGoToFirstClicked);
            this._barPreviewGoBackButton.addEventListener("click", this._whenBarPreviewGoBackClicked);
            this._barPreviewGoForwardButton.addEventListener("click", this._whenBarPreviewGoForwardClicked);
            this._barPreviewGoToLastButton.addEventListener("click", this._whenBarPreviewGoToLastClicked);
            this._stepsStepper.addEventListener("change", this._whenStepsChanges);
            this._pulsesStepper.addEventListener("change", this._whenPulsesChanges);
            this._rotationStepper.addEventListener("change", this._whenRotationChanges);
            this._stepSizeNumeratorStepper.addEventListener("change", this._whenStepSizeChanges);
            this._stepSizeDenominatorStepper.addEventListener("change", this._whenStepSizeChanges);
            this._channelStepper.addEventListener("change", this._whenChannelChanges);
            this._pitchStepper.addEventListener("change", this._whenPitchChanges);
            this._barAmountStepper.addEventListener("change", this._whenBarAmountChanges);
            this._invertBox.addEventListener("change", this._whenInvertChanges);
            this._generateFadingNotesBox.addEventListener("change", this._whenGenerateFadingNotesChanges);
            this._extendUntilLoopButton.addEventListener("click", this._whenExtendUntilLoopClicked);
            this._initialRender();
            this._render();
        }
    }

    class HarmonicsEditor {
        constructor(_doc, _isPrompt = false) {
            this._doc = _doc;
            this._isPrompt = _isPrompt;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._octaves = SVG.svg({ "pointer-events": "none" });
            this._fifths = SVG.svg({ "pointer-events": "none" });
            this._curve = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 2, "pointer-events": "none" });
            this._lastControlPoints = [];
            this._lastControlPointContainer = SVG.svg({ "pointer-events": "none" });
            this._svg = SVG.svg({ style: "background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;", width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._octaves, this._fifths, this._curve, this._lastControlPointContainer);
            this.container = HTML.div({ class: "harmonics", style: "height: 100%;" }, this._svg);
            this._mouseX = 0;
            this._mouseY = 0;
            this._freqPrev = 0;
            this._ampPrev = 0;
            this._mouseDown = false;
            this._change = null;
            this._renderedPath = "";
            this._renderedFifths = true;
            this._undoHistoryState = 0;
            this._changeQueue = [];
            this.storeChange = () => {
                var sameCheck = true;
                if (this._changeQueue.length > 0) {
                    for (var i = 0; i < Config.harmonicsControlPoints; i++) {
                        if (this._changeQueue[this._undoHistoryState][i] != this.instrument.harmonicsWave.harmonics[i]) {
                            sameCheck = false;
                            i = Config.harmonicsControlPoints;
                        }
                    }
                }
                if (sameCheck == false || this._changeQueue.length == 0) {
                    this._changeQueue.splice(0, this._undoHistoryState);
                    this._undoHistoryState = 0;
                    this._changeQueue.unshift(this.instrument.harmonicsWave.harmonics.slice());
                    if (this._changeQueue.length > 32) {
                        this._changeQueue.pop();
                    }
                }
            };
            this.undo = () => {
                if (this._undoHistoryState < this._changeQueue.length - 1) {
                    this._undoHistoryState++;
                    const harmonics = this._changeQueue[this._undoHistoryState].slice();
                    this.setHarmonicsWave(harmonics);
                }
            };
            this.redo = () => {
                if (this._undoHistoryState > 0) {
                    this._undoHistoryState--;
                    const harmonics = this._changeQueue[this._undoHistoryState].slice();
                    this.setHarmonicsWave(harmonics);
                }
            };
            this._whenMousePressed = (event) => { 
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
                this.render();
            };
            this._whenCursorReleased = (event) => {
                if (this._mouseDown) {
                    if (!this._isPrompt) {
                        this._doc.record(this._change);
                    }
                    this.storeChange();
                    this._change = null;
                }
                this._mouseDown = false;
            };
            this.instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            for (let i = 1; i <= Config.harmonicsControlPoints; i = i * 2) {
                this._octaves.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i - 0.5) * (this._editorWidth - 8) / (Config.harmonicsControlPoints - 1) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 3; i <= Config.harmonicsControlPoints; i = i * 2) {
                this._fifths.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i - 0.5) * (this._editorWidth - 8) / (Config.harmonicsControlPoints - 1) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 0; i < 4; i++) {
                const rect = SVG.rect({ fill: "currentColor", x: (this._editorWidth - i * 2 - 1), y: 0, width: 1, height: this._editorHeight });
                this._lastControlPoints.push(rect);
                this._lastControlPointContainer.appendChild(rect);
            }
            this.storeChange();
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _xToFreq(x) {
            return (Config.harmonicsControlPoints - 1) * x / (this._editorWidth - 8) - 0.5;
        }
        _yToAmp(y) {
            return Config.harmonicsMax * (1 - y / this._editorHeight);
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                const freq = this._xToFreq(this._mouseX);
                const amp = this._yToAmp(this._mouseY);
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                const harmonicsWave = instrument.harmonicsWave;
                if (freq != this._freqPrev) {
                    const slope = (amp - this._ampPrev) / (freq - this._freqPrev);
                    const offset = this._ampPrev - this._freqPrev * slope;
                    const lowerFreq = Math.ceil(Math.min(this._freqPrev, freq));
                    const upperFreq = Math.floor(Math.max(this._freqPrev, freq));
                    for (let i = lowerFreq; i <= upperFreq; i++) {
                        if (i < 0 || i >= Config.harmonicsControlPoints)
                            continue;
                        harmonicsWave.harmonics[i] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(i * slope + offset)));
                    }
                }
                harmonicsWave.harmonics[Math.max(0, Math.min(Config.harmonicsControlPoints - 1, Math.round(freq)))] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(amp)));
                this._freqPrev = freq;
                this._ampPrev = amp;
                this._change = new ChangeHarmonics(this._doc, instrument, harmonicsWave);
                this._doc.setProspectiveChange(this._change);
            }
        }
        getHarmonicsWave() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            return instrument.harmonicsWave;
        }
        setHarmonicsWave(harmonics, saveHistory = false) {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            for (let i = 0; i < Config.harmonicsControlPoints; i++) {
                instrument.harmonicsWave.harmonics[i] = harmonics[i];
            }
            const harmonicsChange = new ChangeHarmonics(this._doc, instrument, instrument.harmonicsWave);
            if (saveHistory || !this._isPrompt) {
                this._doc.record(harmonicsChange);
            }
            this.render();
        }
        saveSettings() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            return new ChangeHarmonics(this._doc, instrument, instrument.harmonicsWave);
        }
        resetToInitial() {
            this._changeQueue = [];
            this._undoHistoryState = 0;
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const harmonicsWave = instrument.harmonicsWave;
            const controlPointToHeight = (point) => {
                return (1 - (point / Config.harmonicsMax)) * this._editorHeight;
            };
            let bottom = prettyNumber(this._editorHeight);
            let path = "";
            for (let i = 0; i < Config.harmonicsControlPoints - 1; i++) {
                if (harmonicsWave.harmonics[i] == 0)
                    continue;
                let xPos = prettyNumber((i + 0.5) * (this._editorWidth - 8) / (Config.harmonicsControlPoints - 1));
                path += "M " + xPos + " " + bottom + " ";
                path += "L " + xPos + " " + prettyNumber(controlPointToHeight(harmonicsWave.harmonics[i])) + " ";
            }
            const lastHeight = controlPointToHeight(harmonicsWave.harmonics[Config.harmonicsControlPoints - 1]);
            for (let i = 0; i < 4; i++) {
                const rect = this._lastControlPoints[i];
                rect.setAttribute("y", prettyNumber(lastHeight));
                rect.setAttribute("height", prettyNumber(this._editorHeight - lastHeight));
            }
            if (this._renderedPath != path) {
                this._renderedPath = path;
                this._curve.setAttribute("d", path);
            }
            if (this._renderedFifths != this._doc.prefs.showFifth) {
                this._renderedFifths = this._doc.prefs.showFifth;
                this._fifths.style.display = this._doc.prefs.showFifth ? "" : "none";
            }
        }
    }
    class HarmonicsEditorPrompt {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this.harmonicsEditor = new HarmonicsEditor(this._doc, true);
            this._playButton = HTML.button({ style: "width: 55%;", type: "button" });
            this._cancelButton = HTML.button({ class: "cancelButton" });
            this._okayButton = HTML.button({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.copyButton = HTML.button({ style: "width:86px; margin-right: 5px;", class: "copyButton" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this.pasteButton = HTML.button({ style: "width:86px;", class: "pasteButton" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this.copyPasteContainer = HTML.div({ style: "width: 185px;" }, this.copyButton, this.pasteButton);
            this.container = HTML.div({ class: "prompt noSelection", style: "width: 500px;" }, HTML.h2("Edit Harmonics Instrument"), HTML.div({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), HTML.div({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center;" }, this.harmonicsEditor.container), HTML.div({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this.copyPasteContainer), this._cancelButton);
            this._togglePlay = () => {
                this._songEditor.togglePlay();
                this.updatePlayButton();
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this.harmonicsEditor.container.removeEventListener("mousemove", () => this.harmonicsEditor.render());
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this._copySettings = () => {
                const harmonicsCopy = this.harmonicsEditor.getHarmonicsWave();
                window.localStorage.setItem("harmonicsCopy", JSON.stringify(harmonicsCopy.harmonics));
            };
            this._pasteSettings = () => {
                const storedHarmonicsWave = JSON.parse(String(window.localStorage.getItem("harmonicsCopy")));
                this.harmonicsEditor.setHarmonicsWave(storedHarmonicsWave);
                this.harmonicsEditor.storeChange();
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                else if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
                else if (event.keyCode == 90) {
                    this.harmonicsEditor.undo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 89) {
                    this.harmonicsEditor.redo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 219) {
                    this._doc.synth.goToPrevBar();
                }
                else if (event.keyCode == 221) {
                    this._doc.synth.goToNextBar();
                }
            };
            this._saveChanges = () => {
                this._doc.prompt = null;
                this._doc.record(this.harmonicsEditor.saveSettings(), true);
                this._doc.prompt = null;
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this.whenKeyPressed);
            this.copyButton.addEventListener("click", this._copySettings);
            this.pasteButton.addEventListener("click", this._pasteSettings);
            this._playButton.addEventListener("click", this._togglePlay);
            this.harmonicsEditor.container.addEventListener("mousemove", () => this.harmonicsEditor.render());
            this.harmonicsEditor.container.addEventListener("mousedown", () => this.harmonicsEditor.render());
            this.container.addEventListener("mousemove", () => this.harmonicsEditor.render());
            this.updatePlayButton();
            setTimeout(() => this._playButton.focus());
            this.harmonicsEditor.render();
        }
        updatePlayButton() {
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            }
        }
    }

    const { span: span$5 } = HTML;
    class InputBox {
        constructor(input, _doc, _getChange) {
            this.input = input;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._value = "";
            this._oldValue = "";
            this._whenInput = () => {
                const continuingProspectiveChange = this._doc.lastChangeWas(this._change);
                if (!continuingProspectiveChange)
                    this._oldValue = this._value;
                this._change = this._getChange(this._oldValue, this.input.value);
                this._doc.setProspectiveChange(this._change);
            };
            this._whenChange = () => {
                this._doc.record(this._change);
                this._change = null;
            };
            input.addEventListener("input", this._whenInput);
            input.addEventListener("change", this._whenChange);
        }
        updateValue(value) {
            this._value = value;
            this.input.value = String(value);
        }
    }
    class Slider {
        constructor(input, _doc, _getChange, midTick) {
            this.input = input;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._value = 0;
            this._oldValue = 0;
            this._whenInput = () => {
                const continuingProspectiveChange = this._doc.lastChangeWas(this._change);
                if (!continuingProspectiveChange)
                    this._oldValue = this._value;
                if (this._getChange != null) {
                    this._change = this._getChange(this._oldValue, parseFloat(this.input.value));
                    this._doc.setProspectiveChange(this._change);
                }
            };
            this._whenChange = () => {
                if (this._getChange != null) {
                    this._doc.record(this._change);
                    this._change = null;
                }
            };
            this.container = (midTick) ? span$5({ class: "midTick", style: "position: sticky; width: 61.5%;" }, input) : span$5({ style: "position: sticky;" }, input);
            input.addEventListener("input", this._whenInput);
            input.addEventListener("change", this._whenChange);
        }
        updateValue(value) {
            this._value = value;
            this.input.value = String(value);
        }
        getValueBeforeProspectiveChange() {
            return this._oldValue;
        }
    }

    class ArrayBufferReader {
        constructor(data) {
            this._readIndex = 0;
            this._data = data;
        }
        getReadIndex() {
            return this._readIndex;
        }
        readUint32() {
            if (this._readIndex + 4 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getUint32(this._readIndex, false);
            this._readIndex += 4;
            return result;
        }
        readUint24() {
            return (this.readUint8() << 16) | (this.readUint8() << 8) | (this.readUint8());
        }
        readUint16() {
            if (this._readIndex + 2 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getUint16(this._readIndex, false);
            this._readIndex += 2;
            return result;
        }
        readUint8() {
            if (this._readIndex + 1 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getUint8(this._readIndex);
            this._readIndex++;
            return result;
        }
        readInt8() {
            if (this._readIndex + 1 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = this._data.getInt8(this._readIndex);
            this._readIndex++;
            return result;
        }
        peakUint8() {
            if (this._readIndex + 1 > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            return this._data.getUint8(this._readIndex);
        }
        readMidi7Bits() {
            const result = this.readUint8();
            if (result >= 0x80)
                console.log("7 bit value contained 8th bit! value " + result + ", index " + this._readIndex);
            return result & 0x7f;
        }
        readMidiVariableLength() {
            let result = 0;
            for (let i = 0; i < 4; i++) {
                const nextByte = this.readUint8();
                result += nextByte & 0x7f;
                if (nextByte & 0x80) {
                    result = result << 7;
                }
                else {
                    break;
                }
            }
            return result;
        }
        skipBytes(length) {
            this._readIndex += length;
        }
        hasMore() {
            return this._data.byteLength > this._readIndex;
        }
        getReaderForNextBytes(length) {
            if (this._readIndex + length > this._data.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const result = new ArrayBufferReader(new DataView(this._data.buffer, this._data.byteOffset + this._readIndex, length));
            this.skipBytes(length);
            return result;
        }
    }

    const { button: button$g, p: p$6, div: div$g, h2: h2$f, input: input$b, select: select$a, option: option$a } = HTML;
    class ImportPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._fileInput = input$b({ type: "file", accept: ".json,application/json,.mid,.midi,audio/midi,audio/x-midi" });
            this._cancelButton = button$g({ class: "cancelButton" });
            this._modeImportSelect = select$a({ style: "width: 100%;" }, option$a({ value: "auto" }, "Auto-detect mode (for json)"), option$a({ value: "BeepBox" }, "BeepBox"), option$a({ value: "ModBox" }, "ModBox"), option$a({ value: "JummBox" }, "JummBox"), option$a({ value: "SynthBox" }, "SynthBox"), option$a({ value: "GoldBox" }, "GoldBox"), option$a({ value: "PaandorasBox" }, "PaandorasBox"), option$a({ value: "UltraBox" }, "UltraBox"), option$a({ value: "slarmoosbox" }, "Slarmoo's Box"));
            this.container = div$g({ class: "prompt noSelection", style: "width: 300px;" }, h2$f("Import"), p$6({ style: "text-align: left; margin: 0.5em 0;" }, "BeepBox songs can be exported and re-imported as .json files. You could also use other means to make .json files for BeepBox as long as they follow the same structure."), p$6({ style: "text-align: left; margin: 0.5em 0;" }, "BeepBox can also (crudely) import .mid files. There are many tools available for creating .mid files. Shorter and simpler songs are more likely to work well."), this._modeImportSelect, this._fileInput, this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._fileInput.removeEventListener("change", this._whenFileSelected);
                this._cancelButton.removeEventListener("click", this._close);
            };
            this._whenFileSelected = () => {
                const file = this._fileInput.files[0];
                if (!file)
                    return;
                const extension = file.name.slice((file.name.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
                if (extension == "json") { 
                    const reader = new FileReader();
                    reader.addEventListener("load", (event) => {
let waveIndex = 0;
let registerWaves = []
let OBJeR = JSON.parse(reader.result)
                        this._doc.prompt = null;
                        this._doc.goBackToStart();
                        this._doc.record(new ChangeSong(this._doc, reader.result, this._modeImportSelect.value), true, true);
 
for (let channel of this._doc.song.channels) {
 for (let instrument of channel.instruments) {
  if (registerWaves[waveIndex] !== undefined && registerWaves[waveIndex] !== -1) {
   instrument.chipwaveselected = registerWaves[waveIndex];
  } else if (instrument.chipWave !== undefined && instrument.chipWave !== null) {
   instrument.chipwaveselected = instrument.chipWave
  } else {
   instrument.chipwaveselected = 0;
  }
  waveIndex++;
 }
}
                        
                    });
                    reader.readAsText(file);
                }
                else if (extension == "midi" || extension == "mid") {
                    const reader = new FileReader();
                    reader.addEventListener("load", (event) => {
                        this._doc.prompt = null;
                        this._doc.goBackToStart();
                        this._parseMidiFile(reader.result);
                        
for (let channel of this._doc.song.channels) {
 for (let instrument of channel.instruments) {
  if (instrument.chipWave !== undefined && instrument.chipWave !== null) {
   instrument.chipwaveselected = instrument.chipWave
  } else {
   instrument.chipwaveselected = 0;
  }
 }
}
                        
                    });
                    reader.readAsArrayBuffer(file);
                }
                else {
                    console.error("Unrecognized file extension.");
                    this._close();
                }
            };
            this._fileInput.select();
            setTimeout(() => this._fileInput.focus());
            this._fileInput.addEventListener("change", this._whenFileSelected);
            this._cancelButton.addEventListener("click", this._close);
        }
        _parseMidiFile(buffer) {
            const reader = new ArrayBufferReader(new DataView(buffer));
            let headerReader = null;
            const tracks = [];
            while (reader.hasMore()) {
                const chunkType = reader.readUint32();
                const chunkLength = reader.readUint32();
                if (chunkType == 1297377380) {
                    if (headerReader == null) {
                        headerReader = reader.getReaderForNextBytes(chunkLength);
                    }
                    else {
                        console.error("This MIDI file has more than one header chunk.");
                    }
                }
                else if (chunkType == 1297379947) {
                    const trackReader = reader.getReaderForNextBytes(chunkLength);
                    if (trackReader.hasMore()) {
                        tracks.push({
                            reader: trackReader,
                            nextEventMidiTick: trackReader.readMidiVariableLength(),
                            ended: false,
                            runningStatus: -1,
                        });
                    }
                }
                else {
                    reader.skipBytes(chunkLength);
                }
            }
            if (headerReader == null) {
                console.error("No header chunk found in this MIDI file.");
                this._close();
                return;
            }
            const fileFormat = headerReader.readUint16();
            headerReader.readUint16();
            const midiTicksPerBeat = headerReader.readUint16();
            let currentIndependentTrackIndex = 0;
            const currentTrackIndices = [];
            const independentTracks = (fileFormat == 2);
            if (independentTracks) {
                currentTrackIndices.push(currentIndependentTrackIndex);
            }
            else {
                for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
                    currentTrackIndices.push(trackIndex);
                }
            }
            const channelRPNMSB = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
            const channelRPNLSB = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
            const pitchBendRangeMSB = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];
            const pitchBendRangeLSB = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            const currentInstrumentProgram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            const currentInstrumentVolumes = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100];
            const currentInstrumentPans = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];
            const noteEvents = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            const pitchBendEvents = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            const noteSizeEvents = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            let tempoChanges = [];
            let microsecondsPerBeat = 500000;
            let beatsPerBar = 8;
            let numSharps = 0;
            let isMinor = false;
            let currentMidiTick = 0;
            while (true) {
                let nextEventMidiTick = Number.MAX_VALUE;
                let anyTrackHasMore = false;
                for (const trackIndex of currentTrackIndices) {
                    const track = tracks[trackIndex];
                    while (!track.ended && track.nextEventMidiTick == currentMidiTick) {
                        const peakStatus = track.reader.peakUint8();
                        const eventStatus = (peakStatus & 0x80) ? track.reader.readUint8() : track.runningStatus;
                        const eventType = eventStatus & 0xF0;
                        const eventChannel = eventStatus & 0x0F;
                        if (eventType != 240) {
                            track.runningStatus = eventStatus;
                        }
                        let foundTrackEndEvent = false;
                        switch (eventType) {
                            case 128:
                                {
                                    const pitch = track.reader.readMidi7Bits();
                                    track.reader.readMidi7Bits();
                                    noteEvents[eventChannel].push({ midiTick: currentMidiTick, pitch: pitch, velocity: 0.0, program: -1, instrumentVolume: -1, instrumentPan: -1, on: false });
                                }
                                break;
                            case 144:
                                {
                                    const pitch = track.reader.readMidi7Bits();
                                    const velocity = track.reader.readMidi7Bits();
                                    if (velocity == 0) {
                                        noteEvents[eventChannel].push({ midiTick: currentMidiTick, pitch: pitch, velocity: 0.0, program: -1, instrumentVolume: -1, instrumentPan: -1, on: false });
                                    }
                                    else {
                                        const volume = Math.max(0, Math.min(Config.volumeRange - 1, Math.round(Synth.volumeMultToInstrumentVolume(midiVolumeToVolumeMult(currentInstrumentVolumes[eventChannel])))));
                                        const pan = Math.max(0, Math.min(Config.panMax, Math.round(((currentInstrumentPans[eventChannel] - 64) / 63 + 1) * Config.panCenter)));
                                        noteEvents[eventChannel].push({
                                            midiTick: currentMidiTick,
                                            pitch: pitch,
                                            velocity: Math.max(0.0, Math.min(1.0, (velocity + 14) / 90.0)),
                                            program: currentInstrumentProgram[eventChannel],
                                            instrumentVolume: volume,
                                            instrumentPan: pan,
                                            on: true,
                                        });
                                    }
                                }
                                break;
                            case 160:
                                {
                                    track.reader.readMidi7Bits();
                                    track.reader.readMidi7Bits();
                                }
                                break;
                            case 176:
                                {
                                    const message = track.reader.readMidi7Bits();
                                    const value = track.reader.readMidi7Bits();
                                    switch (message) {
                                        case 6:
                                            {
                                                if (channelRPNMSB[eventChannel] == 0 && channelRPNLSB[eventChannel] == 0) {
                                                    pitchBendRangeMSB[eventChannel] = value;
                                                }
                                            }
                                            break;
                                        case 7:
                                            {
                                                currentInstrumentVolumes[eventChannel] = value;
                                            }
                                            break;
                                        case 10:
                                            {
                                                currentInstrumentPans[eventChannel] = value;
                                            }
                                            break;
                                        case 11:
                                            {
                                                noteSizeEvents[eventChannel].push({ midiTick: currentMidiTick, size: Synth.volumeMultToNoteSize(midiExpressionToVolumeMult(value)) });
                                            }
                                            break;
                                        case 38:
                                            {
                                                if (channelRPNMSB[eventChannel] == 0 && channelRPNLSB[eventChannel] == 0) {
                                                    pitchBendRangeLSB[eventChannel] = value;
                                                }
                                            }
                                            break;
                                        case 100:
                                            {
                                                channelRPNLSB[eventChannel] = value;
                                            }
                                            break;
                                        case 101:
                                            {
                                                channelRPNMSB[eventChannel] = value;
                                            }
                                            break;
                                    }
                                }
                                break;
                            case 192:
                                {
                                    const program = track.reader.readMidi7Bits();
                                    currentInstrumentProgram[eventChannel] = program;
                                }
                                break;
                            case 208:
                                {
                                    track.reader.readMidi7Bits();
                                }
                                break;
                            case 224:
                                {
                                    const lsb = track.reader.readMidi7Bits();
                                    const msb = track.reader.readMidi7Bits();
                                    const pitchBend = (((msb << 7) | lsb) / 0x2000) - 1.0;
                                    const pitchBendRange = pitchBendRangeMSB[eventChannel] + pitchBendRangeLSB[eventChannel] * 0.01;
                                    const interval = pitchBend * pitchBendRange;
                                    pitchBendEvents[eventChannel].push({ midiTick: currentMidiTick, interval: interval });
                                }
                                break;
                            case 240:
                                {
                                    if (eventStatus == 255) {
                                        const message = track.reader.readMidi7Bits();
                                        const length = track.reader.readMidiVariableLength();
                                        if (message == 47) {
                                            foundTrackEndEvent = true;
                                            track.reader.skipBytes(length);
                                        }
                                        else if (message == 81) {
                                            microsecondsPerBeat = track.reader.readUint24();
                                            tempoChanges.push({
                                                midiTick: currentMidiTick,
                                                microsecondsPerBeat: microsecondsPerBeat,
                                            });
                                            track.reader.skipBytes(length - 3);
                                        }
                                        else if (message == 88) {
                                            const numerator = track.reader.readUint8();
                                            let denominatorExponent = track.reader.readUint8();
                                            track.reader.readUint8();
                                            track.reader.readUint8();
                                            track.reader.skipBytes(length - 4);
                                            beatsPerBar = numerator * 4;
                                            while ((beatsPerBar & 1) == 0 && (denominatorExponent > 0 || beatsPerBar > Config.beatsPerBarMax) && beatsPerBar >= Config.beatsPerBarMin * 2) {
                                                beatsPerBar = beatsPerBar >> 1;
                                                denominatorExponent = denominatorExponent - 1;
                                            }
                                            beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, beatsPerBar));
                                        }
                                        else if (message == 89) {
                                            numSharps = track.reader.readInt8();
                                            isMinor = track.reader.readUint8() == 1;
                                            track.reader.skipBytes(length - 2);
                                        }
                                        else {
                                            track.reader.skipBytes(length);
                                        }
                                    }
                                    else if (eventStatus == 0xF0 || eventStatus == 0xF7) {
                                        const length = track.reader.readMidiVariableLength();
                                        track.reader.skipBytes(length);
                                    }
                                    else {
                                        console.error("Unrecognized event status: " + eventStatus);
                                        this._close();
                                        return;
                                    }
                                }
                                break;
                            default: {
                                console.error("Unrecognized event type: " + eventType);
                                this._close();
                                return;
                            }
                        }
                        if (!foundTrackEndEvent && track.reader.hasMore()) {
                            track.nextEventMidiTick = currentMidiTick + track.reader.readMidiVariableLength();
                        }
                        else {
                            track.ended = true;
                            if (independentTracks) {
                                currentIndependentTrackIndex++;
                                if (currentIndependentTrackIndex < tracks.length) {
                                    currentTrackIndices[0] = currentIndependentTrackIndex;
                                    tracks[currentIndependentTrackIndex].nextEventMidiTick += currentMidiTick;
                                    nextEventMidiTick = Math.min(nextEventMidiTick, tracks[currentIndependentTrackIndex].nextEventMidiTick);
                                    anyTrackHasMore = true;
                                }
                            }
                        }
                    }
                    if (!track.ended) {
                        anyTrackHasMore = true;
                        nextEventMidiTick = Math.min(nextEventMidiTick, track.nextEventMidiTick);
                    }
                }
                if (anyTrackHasMore) {
                    currentMidiTick = nextEventMidiTick;
                }
                else {
                    break;
                }
            }
            for (const change of tempoChanges) {
                microsecondsPerBeat = change.microsecondsPerBeat;
                break;
            }
            const microsecondsPerMinute = 60 * 1000 * 1000;
            const beatsPerMinute = Math.max(Config.tempoMin, Math.min(Config.tempoMax, Math.round(microsecondsPerMinute / microsecondsPerBeat)));
            const midiTicksPerPart = midiTicksPerBeat / Config.partsPerBeat;
            const partsPerBar = Config.partsPerBeat * beatsPerBar;
            const songTotalBars = Math.ceil(currentMidiTick / midiTicksPerPart / partsPerBar);
            function quantizeMidiTickToPart(midiTick) {
                return Math.round(midiTick / midiTicksPerPart);
            }
            let key = numSharps;
            if (isMinor)
                key += 3;
            if ((key & 1) == 1)
                key += 6;
            while (key < 0)
                key += 12;
            key = key % 12;
            const pitchChannels = [];
            const noiseChannels = [];
            const modChannels = [];
            for (let midiChannel = 0; midiChannel < 16; midiChannel++) {
                if (noteEvents[midiChannel].length == 0)
                    continue;
                const channel = new Channel();
                const channelPresetValue = EditorConfig.midiProgramToPresetValue(noteEvents[midiChannel][0].program);
                const channelPreset = (channelPresetValue == null) ? null : EditorConfig.valueToPreset(channelPresetValue);
                const isDrumsetChannel = (midiChannel == 9);
                const isNoiseChannel = isDrumsetChannel || (channelPreset != null && channelPreset.isNoise == true);
                const isModChannel = (channelPreset != null && channelPreset.isMod == true);
                const channelBasePitch = isNoiseChannel ? Config.spectrumBasePitch : Config.keys[key].basePitch;
                const intervalScale = isNoiseChannel ? Config.noiseInterval : 1;
                const midiIntervalScale = isNoiseChannel ? 0.5 : 1;
                const channelMaxPitch = isNoiseChannel ? Config.drumCount - 1 : Config.maxPitch;
                if (isNoiseChannel) {
                    if (isDrumsetChannel) {
                        noiseChannels.unshift(channel);
                    }
                    else {
                        noiseChannels.push(channel);
                    }
                }
                else if (isModChannel) {
                    modChannels.push(channel);
                }
                else {
                    pitchChannels.push(channel);
                }
                let currentVelocity = 1.0;
                let currentProgram = 0;
                let currentInstrumentVolume = 0;
                let currentInstrumentPan = Config.panCenter;
                if (isDrumsetChannel) {
                    const heldPitches = [];
                    let currentBar = -1;
                    let pattern = null;
                    let prevEventPart = 0;
                    let setInstrumentVolume = false;
                    const presetValue = EditorConfig.nameToPresetValue("standard drumset");
                    const preset = EditorConfig.valueToPreset(presetValue);
                    const instrument = new Instrument(false, false);
                    instrument.fromJsonObject(preset.settings, false, false, false, false, 1);
                    instrument.preset = presetValue;
                    channel.instruments.push(instrument);
                    for (let noteEventIndex = 0; noteEventIndex <= noteEvents[midiChannel].length; noteEventIndex++) {
                        const noMoreNotes = noteEventIndex == noteEvents[midiChannel].length;
                        const noteEvent = noMoreNotes ? null : noteEvents[midiChannel][noteEventIndex];
                        const nextEventPart = noteEvent == null ? Number.MAX_SAFE_INTEGER : quantizeMidiTickToPart(noteEvent.midiTick);
                        if (heldPitches.length > 0 && nextEventPart > prevEventPart && (noteEvent == null || noteEvent.on)) {
                            const bar = Math.floor(prevEventPart / partsPerBar);
                            const barStartPart = bar * partsPerBar;
                            if (currentBar != bar || pattern == null) {
                                currentBar++;
                                while (currentBar < bar) {
                                    channel.bars[currentBar] = 0;
                                    currentBar++;
                                }
                                pattern = new Pattern();
                                channel.patterns.push(pattern);
                                channel.bars[currentBar] = channel.patterns.length;
                                pattern.instruments[0] = 0;
                                pattern.instruments.length = 1;
                            }
                            if (!setInstrumentVolume || instrument.volume > currentInstrumentVolume) {
                                instrument.volume = currentInstrumentVolume;
                                instrument.pan = currentInstrumentPan;
                                instrument.panDelay = 0;
                                setInstrumentVolume = true;
                            }
                            const drumFreqs = [];
                            let minDuration = channelMaxPitch;
                            let maxDuration = 0;
                            let noteSize = 1;
                            for (const pitch of heldPitches) {
                                const drum = analogousDrumMap[pitch];
                                if (drumFreqs.indexOf(drum.frequency) == -1) {
                                    drumFreqs.push(drum.frequency);
                                }
                                noteSize = Math.max(noteSize, Math.round(drum.volume * currentVelocity));
                                minDuration = Math.min(minDuration, drum.duration);
                                maxDuration = Math.max(maxDuration, drum.duration);
                            }
                            const duration = Math.min(maxDuration, Math.max(minDuration, 2));
                            const noteStartPart = prevEventPart - barStartPart;
                            const noteEndPart = Math.min(partsPerBar, Math.min(nextEventPart - barStartPart, noteStartPart + duration * 6));
                            const note = new Note(-1, noteStartPart, noteEndPart, noteSize, true);
                            note.pitches.length = 0;
                            for (let pitchIndex = 0; pitchIndex < Math.min(Config.maxChordSize, drumFreqs.length); pitchIndex++) {
                                const heldPitch = drumFreqs[pitchIndex + Math.max(0, drumFreqs.length - Config.maxChordSize)];
                                if (note.pitches.indexOf(heldPitch) == -1) {
                                    note.pitches.push(heldPitch);
                                }
                            }
                            pattern.notes.push(note);
                            heldPitches.length = 0;
                        }
                        if (noteEvent != null && noteEvent.on && analogousDrumMap[noteEvent.pitch] != undefined) {
                            heldPitches.push(noteEvent.pitch);
                            prevEventPart = nextEventPart;
                            currentVelocity = noteEvent.velocity;
                            currentInstrumentVolume = noteEvent.instrumentVolume;
                            currentInstrumentPan = noteEvent.instrumentPan;
                        }
                    }
                }
                else {
                    let currentMidiInterval = 0.0;
                    let currentMidiNoteSize = Config.noteSizeMax;
                    let pitchBendEventIndex = 0;
                    let noteSizeEventIndex = 0;
                    function updateCurrentMidiInterval(midiTick) {
                        while (pitchBendEventIndex < pitchBendEvents[midiChannel].length && pitchBendEvents[midiChannel][pitchBendEventIndex].midiTick <= midiTick) {
                            currentMidiInterval = pitchBendEvents[midiChannel][pitchBendEventIndex].interval;
                            pitchBendEventIndex++;
                        }
                    }
                    function updateCurrentMidiNoteSize(midiTick) {
                        while (noteSizeEventIndex < noteSizeEvents[midiChannel].length && noteSizeEvents[midiChannel][noteSizeEventIndex].midiTick <= midiTick) {
                            currentMidiNoteSize = noteSizeEvents[midiChannel][noteSizeEventIndex].size;
                            noteSizeEventIndex++;
                        }
                    }
                    const instrumentByProgram = [];
                    const heldPitches = [];
                    let currentBar = -1;
                    let pattern = null;
                    let prevEventMidiTick = 0;
                    let prevEventPart = 0;
                    let pitchSum = 0;
                    let pitchCount = 0;
                    for (let noteEvent of noteEvents[midiChannel]) {
                        const nextEventMidiTick = noteEvent.midiTick;
                        const nextEventPart = quantizeMidiTickToPart(nextEventMidiTick);
                        if (heldPitches.length > 0 && nextEventPart > prevEventPart) {
                            const startBar = Math.floor(prevEventPart / partsPerBar);
                            const endBar = Math.ceil(nextEventPart / partsPerBar);
                            let createdNote = false;
                            for (let bar = startBar; bar < endBar; bar++) {
                                const barStartPart = bar * partsPerBar;
                                const barStartMidiTick = bar * beatsPerBar * midiTicksPerBeat;
                                const barEndMidiTick = (bar + 1) * beatsPerBar * midiTicksPerBeat;
                                const noteStartPart = Math.max(0, prevEventPart - barStartPart);
                                const noteEndPart = Math.min(partsPerBar, nextEventPart - barStartPart);
                                const noteStartMidiTick = Math.max(barStartMidiTick, prevEventMidiTick);
                                const noteEndMidiTick = Math.min(barEndMidiTick, nextEventMidiTick);
                                if (noteStartPart < noteEndPart) {
                                    const presetValue = EditorConfig.midiProgramToPresetValue(currentProgram);
                                    const preset = (presetValue == null) ? null : EditorConfig.valueToPreset(presetValue);
                                    if (currentBar != bar || pattern == null) {
                                        currentBar++;
                                        while (currentBar < bar) {
                                            channel.bars[currentBar] = 0;
                                            currentBar++;
                                        }
                                        pattern = new Pattern();
                                        channel.patterns.push(pattern);
                                        channel.bars[currentBar] = channel.patterns.length;
                                        if (instrumentByProgram[currentProgram] == undefined) {
                                            const instrument = new Instrument(isNoiseChannel, isModChannel);
                                            instrumentByProgram[currentProgram] = instrument;
                                            if (presetValue != null && preset != null && (preset.isNoise == true) == isNoiseChannel) {
                                                instrument.fromJsonObject(preset.settings, isNoiseChannel, isModChannel, false, false, 1);
                                                instrument.preset = presetValue;
                                            }
                                            else {
                                                instrument.setTypeAndReset(isModChannel ? 10 : (isNoiseChannel ? 2 : 0), isNoiseChannel, isModChannel);
                                                instrument.chord = 0;
                                            }
                                            instrument.volume = currentInstrumentVolume;
                                            instrument.pan = currentInstrumentPan;
                                            instrument.panDelay = 0;
                                            channel.instruments.push(instrument);
                                        }
                                        pattern.instruments[0] = channel.instruments.indexOf(instrumentByProgram[currentProgram]);
                                        pattern.instruments.length = 1;
                                    }
                                    if (instrumentByProgram[currentProgram] != undefined) {
                                        instrumentByProgram[currentProgram].volume = Math.min(instrumentByProgram[currentProgram].volume, currentInstrumentVolume);
                                        instrumentByProgram[currentProgram].pan = Math.min(instrumentByProgram[currentProgram].pan, currentInstrumentPan);
                                    }
                                    const note = new Note(-1, noteStartPart, noteEndPart, Config.noteSizeMax, false);
                                    note.pins.length = 0;
                                    note.continuesLastPattern = (createdNote && noteStartPart == 0);
                                    createdNote = true;
                                    updateCurrentMidiInterval(noteStartMidiTick);
                                    updateCurrentMidiNoteSize(noteStartMidiTick);
                                    const shiftedHeldPitch = heldPitches[0] * midiIntervalScale - channelBasePitch;
                                    const initialBeepBoxPitch = Math.round((shiftedHeldPitch + currentMidiInterval) / intervalScale);
                                    const heldPitchOffset = Math.round(currentMidiInterval - channelBasePitch);
                                    let firstPin = makeNotePin(0, 0, Math.round(currentVelocity * currentMidiNoteSize));
                                    note.pins.push(firstPin);
                                    const potentialPins = [
                                        { part: 0, pitch: initialBeepBoxPitch, size: firstPin.size, keyPitch: false, keySize: false }
                                    ];
                                    let prevPinIndex = 0;
                                    let prevPartPitch = (shiftedHeldPitch + currentMidiInterval) / intervalScale;
                                    let prevPartSize = currentVelocity * currentMidiNoteSize;
                                    for (let part = noteStartPart + 1; part <= noteEndPart; part++) {
                                        const midiTick = Math.max(noteStartMidiTick, Math.min(noteEndMidiTick - 1, Math.round(midiTicksPerPart * (part + barStartPart))));
                                        const noteRelativePart = part - noteStartPart;
                                        const lastPart = (part == noteEndPart);
                                        updateCurrentMidiInterval(midiTick);
                                        updateCurrentMidiNoteSize(midiTick);
                                        const partPitch = (currentMidiInterval + shiftedHeldPitch) / intervalScale;
                                        const partSize = currentVelocity * currentMidiNoteSize;
                                        const nearestPitch = Math.round(partPitch);
                                        const pitchIsNearInteger = Math.abs(partPitch - nearestPitch) < 0.01;
                                        const pitchCrossedInteger = (Math.abs(prevPartPitch - Math.round(prevPartPitch)) < 0.01)
                                            ? Math.abs(partPitch - prevPartPitch) >= 1.0
                                            : Math.floor(partPitch) != Math.floor(prevPartPitch);
                                        const keyPitch = pitchIsNearInteger || pitchCrossedInteger;
                                        const nearestSize = Math.round(partSize);
                                        const sizeIsNearInteger = Math.abs(partSize - nearestSize) < 0.01;
                                        const sizeCrossedInteger = (Math.abs(prevPartSize - Math.round(prevPartSize)))
                                            ? Math.abs(partSize - prevPartSize) >= 1.0
                                            : Math.floor(partSize) != Math.floor(prevPartSize);
                                        const keySize = sizeIsNearInteger || sizeCrossedInteger;
                                        prevPartPitch = partPitch;
                                        prevPartSize = partSize;
                                        if (keyPitch || keySize || lastPart) {
                                            const currentPin = { part: noteRelativePart, pitch: nearestPitch, size: nearestSize, keyPitch: keyPitch || lastPart, keySize: keySize || lastPart };
                                            const prevPin = potentialPins[prevPinIndex];
                                            let addPin = false;
                                            let addPinAtIndex = Number.MAX_VALUE;
                                            if (currentPin.keyPitch) {
                                                const slope = (currentPin.pitch - prevPin.pitch) / (currentPin.part - prevPin.part);
                                                let furthestIntervalDistance = Math.abs(slope);
                                                let addIntervalPin = false;
                                                let addIntervalPinAtIndex = Number.MAX_VALUE;
                                                for (let potentialIndex = prevPinIndex + 1; potentialIndex < potentialPins.length; potentialIndex++) {
                                                    const potentialPin = potentialPins[potentialIndex];
                                                    if (potentialPin.keyPitch) {
                                                        const interpolatedInterval = prevPin.pitch + slope * (potentialPin.part - prevPin.part);
                                                        const distance = Math.abs(interpolatedInterval - potentialPin.pitch);
                                                        if (furthestIntervalDistance < distance) {
                                                            furthestIntervalDistance = distance;
                                                            addIntervalPin = true;
                                                            addIntervalPinAtIndex = potentialIndex;
                                                        }
                                                    }
                                                }
                                                if (addIntervalPin) {
                                                    addPin = true;
                                                    addPinAtIndex = Math.min(addPinAtIndex, addIntervalPinAtIndex);
                                                }
                                            }
                                            if (currentPin.keySize) {
                                                const slope = (currentPin.size - prevPin.size) / (currentPin.part - prevPin.part);
                                                let furthestSizeDistance = Math.abs(slope);
                                                let addSizePin = false;
                                                let addSizePinAtIndex = Number.MAX_VALUE;
                                                for (let potentialIndex = prevPinIndex + 1; potentialIndex < potentialPins.length; potentialIndex++) {
                                                    const potentialPin = potentialPins[potentialIndex];
                                                    if (potentialPin.keySize) {
                                                        const interpolatedSize = prevPin.size + slope * (potentialPin.part - prevPin.part);
                                                        const distance = Math.abs(interpolatedSize - potentialPin.size);
                                                        if (furthestSizeDistance < distance) {
                                                            furthestSizeDistance = distance;
                                                            addSizePin = true;
                                                            addSizePinAtIndex = potentialIndex;
                                                        }
                                                    }
                                                }
                                                if (addSizePin) {
                                                    addPin = true;
                                                    addPinAtIndex = Math.min(addPinAtIndex, addSizePinAtIndex);
                                                }
                                            }
                                            if (addPin) {
                                                const toBePinned = potentialPins[addPinAtIndex];
                                                note.pins.push(makeNotePin(toBePinned.pitch - initialBeepBoxPitch, toBePinned.part, toBePinned.size));
                                                prevPinIndex = addPinAtIndex;
                                            }
                                            potentialPins.push(currentPin);
                                        }
                                    }
                                    const lastToBePinned = potentialPins[potentialPins.length - 1];
                                    note.pins.push(makeNotePin(lastToBePinned.pitch - initialBeepBoxPitch, lastToBePinned.part, lastToBePinned.size));
                                    let maxPitch = channelMaxPitch;
                                    let minPitch = 0;
                                    for (const notePin of note.pins) {
                                        maxPitch = Math.min(maxPitch, channelMaxPitch - notePin.interval);
                                        minPitch = Math.min(minPitch, -notePin.interval);
                                    }
                                    note.pitches.length = 0;
                                    for (let pitchIndex = 0; pitchIndex < Math.min(Config.maxChordSize, heldPitches.length); pitchIndex++) {
                                        let heldPitch = heldPitches[pitchIndex + Math.max(0, heldPitches.length - Config.maxChordSize)] * midiIntervalScale;
                                        if (preset != null && preset.midiSubharmonicOctaves != undefined) {
                                            heldPitch -= 12 * preset.midiSubharmonicOctaves;
                                        }
                                        const shiftedPitch = Math.max(minPitch, Math.min(maxPitch, Math.round((heldPitch + heldPitchOffset) / intervalScale)));
                                        if (note.pitches.indexOf(shiftedPitch) == -1) {
                                            note.pitches.push(shiftedPitch);
                                            const weight = note.end - note.start;
                                            pitchSum += shiftedPitch * weight;
                                            pitchCount += weight;
                                        }
                                    }
                                    pattern.notes.push(note);
                                }
                            }
                        }
                        if (heldPitches.indexOf(noteEvent.pitch) != -1) {
                            heldPitches.splice(heldPitches.indexOf(noteEvent.pitch), 1);
                        }
                        if (noteEvent.on) {
                            heldPitches.push(noteEvent.pitch);
                            currentVelocity = noteEvent.velocity;
                            currentProgram = noteEvent.program;
                            currentInstrumentVolume = noteEvent.instrumentVolume;
                            currentInstrumentPan = noteEvent.instrumentPan;
                        }
                        prevEventMidiTick = nextEventMidiTick;
                        prevEventPart = nextEventPart;
                    }
                    const averagePitch = pitchSum / pitchCount;
                    channel.octave = (isNoiseChannel || isModChannel) ? 0 : Math.max(0, Math.min(Config.pitchOctaves - 1, Math.floor((averagePitch / 12))));
                }
                while (channel.bars.length < songTotalBars) {
                    channel.bars.push(0);
                }
            }
            if (tempoChanges.length > 1) {
                let tempoModChannel = new Channel();
                modChannels.push(tempoModChannel);
                let tempoModInstrument = new Instrument(false, true);
                tempoModInstrument.setTypeAndReset(9, false, true);
                tempoModInstrument.modulators[0] = Config.modulators.dictionary["tempo"].index;
                tempoModInstrument.modChannels[0] = -1;
                tempoModChannel.instruments.push(tempoModInstrument);
                const tempoModPitch = Config.modCount - 1;
                let currentBar = -1;
                let pattern = null;
                let prevChangeEndPart = 0;
                for (let changeIndex = 0; changeIndex < tempoChanges.length; changeIndex++) {
                    const change = tempoChanges[changeIndex];
                    const changeStartMidiTick = change.midiTick;
                    const changeStartPart = quantizeMidiTickToPart(changeStartMidiTick);
                    let changeEndMidiTick = -1;
                    let changeEndPart = -1;
                    if (changeIndex === tempoChanges.length - 1) {
                        changeEndMidiTick = changeStartMidiTick + 1;
                        changeEndPart = changeStartPart + 1;
                    }
                    else {
                        const nextChange = tempoChanges[changeIndex + 1];
                        changeEndMidiTick = nextChange.midiTick;
                        changeEndPart = quantizeMidiTickToPart(changeEndMidiTick);
                    }
                    let startBar = Math.floor(changeStartPart / partsPerBar);
                    let endBar = Math.ceil(changeEndPart / partsPerBar);
                    for (let bar = startBar; bar < endBar; bar++) {
                        const barStartPart = bar * partsPerBar;
                        const noteStartPart = Math.max(0, prevChangeEndPart - barStartPart);
                        let noteEndPart = Math.min(partsPerBar, changeEndPart - barStartPart);
                        if (noteStartPart < noteEndPart) {
                            if (currentBar != bar || pattern == null) {
                                currentBar++;
                                while (currentBar < bar) {
                                    tempoModChannel.bars[currentBar] = 0;
                                    currentBar++;
                                }
                                pattern = new Pattern();
                                tempoModChannel.patterns.push(pattern);
                                tempoModChannel.bars[currentBar] = tempoModChannel.patterns.length;
                                pattern.instruments[0] = 0;
                                pattern.instruments.length = 1;
                            }
                            const newBPM = Math.max(Config.tempoMin, Math.min(Config.tempoMax, Math.round(microsecondsPerMinute / change.microsecondsPerBeat) - Config.modulators.dictionary["tempo"].convertRealFactor));
                            const note = new Note(tempoModPitch, noteStartPart, noteEndPart, newBPM, false);
                            pattern.notes.push(note);
                        }
                    }
                    prevChangeEndPart = changeEndPart;
                }
            }
            function compactChannels(channels, maxLength) {
                while (channels.length > maxLength) {
                    let bestChannelIndexA = channels.length - 2;
                    let bestChannelIndexB = channels.length - 1;
                    let fewestConflicts = Number.MAX_VALUE;
                    let fewestGaps = Number.MAX_VALUE;
                    for (let channelIndexA = 0; channelIndexA < channels.length - 1; channelIndexA++) {
                        for (let channelIndexB = channelIndexA + 1; channelIndexB < channels.length; channelIndexB++) {
                            const channelA = channels[channelIndexA];
                            const channelB = channels[channelIndexB];
                            let conflicts = 0;
                            let gaps = 0;
                            for (let barIndex = 0; barIndex < channelA.bars.length && barIndex < channelB.bars.length; barIndex++) {
                                if (channelA.bars[barIndex] != 0 && channelB.bars[barIndex] != 0)
                                    conflicts++;
                                if (channelA.bars[barIndex] == 0 && channelB.bars[barIndex] == 0)
                                    gaps++;
                            }
                            if (conflicts <= fewestConflicts) {
                                if (conflicts < fewestConflicts || gaps < fewestGaps) {
                                    bestChannelIndexA = channelIndexA;
                                    bestChannelIndexB = channelIndexB;
                                    fewestConflicts = conflicts;
                                    fewestGaps = gaps;
                                }
                            }
                        }
                    }
                    const channelA = channels[bestChannelIndexA];
                    const channelB = channels[bestChannelIndexB];
                    const channelAInstrumentCount = channelA.instruments.length;
                    const channelAPatternCount = channelA.patterns.length;
                    for (const instrument of channelB.instruments) {
                        channelA.instruments.push(instrument);
                    }
                    for (const pattern of channelB.patterns) {
                        pattern.instruments[0] += channelAInstrumentCount;
                        channelA.patterns.push(pattern);
                    }
                    for (let barIndex = 0; barIndex < channelA.bars.length && barIndex < channelB.bars.length; barIndex++) {
                        if (channelA.bars[barIndex] == 0 && channelB.bars[barIndex] != 0) {
                            channelA.bars[barIndex] = channelB.bars[barIndex] + channelAPatternCount;
                        }
                    }
                    channels.splice(bestChannelIndexB, 1);
                }
            }
            compactChannels(pitchChannels, Config.pitchChannelCountMax);
            compactChannels(noiseChannels, Config.noiseChannelCountMax);
            compactChannels(modChannels, Config.modChannelCountMax);
            class ChangeImportMidi extends ChangeGroup {
                constructor(doc) {
                    super();
                    const song = doc.song;
                    song.tempo = beatsPerMinute;
                    song.beatsPerBar = beatsPerBar;
                    song.key = key;
                    song.scale = 0;
                    song.rhythm = 2;
                    song.layeredInstruments = false;
                    song.patternInstruments = pitchChannels.some(channel => channel.instruments.length > 1) || noiseChannels.some(channel => channel.instruments.length > 1);
                    removeDuplicatePatterns(pitchChannels);
                    removeDuplicatePatterns(noiseChannels);
                    removeDuplicatePatterns(modChannels);
                    this.append(new ChangeReplacePatterns(doc, pitchChannels, noiseChannels, modChannels));
                    song.loopStart = 0;
                    song.loopLength = song.barCount;
                    this._didSomething();
                    doc.notifier.changed();
                }
            }
            this._doc.goBackToStart();
            for (const channel of this._doc.song.channels)
                channel.muted = false;
            this._doc.prompt = null;
            this._doc.record(new ChangeImportMidi(this._doc), true, true);
        }
    }

    class Box {
        constructor(channel, color) {
            this._text = document.createTextNode("");
            this._label = HTML.div({ class: "channelBoxLabel" }, this._text);
            this.container = HTML.div({ class: "channelBox", style: `margin: 1px; height: ${ChannelRow.patternHeight - 2}px;` }, this._label);
            this._renderedIndex = [-1,0];
            this._renderedLabelColor = "?";
            this._renderedVisibility = "?";
            this._renderedBorderLeft = "?";
            this._renderedBorderRight = "?";
            this._renderedBackgroundColor = "?";
            this.container.style.background = ColorConfig.uiWidgetBackground;
            this._label.style.color = color;
        }
        setWidth(width) {
            this.container.style.width = (width - 2) + "px";
        }
        setHeight(height) {
            this.container.style.height = (height - 2) + "px";
        }
        setIndex(index, selected, dim, color, isNoise, isMod) {
            if (this._renderedIndex[0] != index || (ColorConfig.getComputed("--hex-channel-label") == 'true'&&this._renderedIndex[1]==0) || (ColorConfig.getComputed("--hex-channel-label") !== 'true'&&this._renderedIndex[1]==2) ) {
                if (index >= 11 && ColorConfig.getComputed("--hex-channel-label") == 'true' ) {
                    this._label.setAttribute("font-size", "10");
                    this._label.style.fontSize="10px";
                    this._label.style.setProperty("transform", "translate(0px, -1.5px)");
                }else if (index >= 32) {
                    this._label.setAttribute("font-size", "16");
                    this._label.style.fontSize="16px";
                    this._label.style.setProperty("transform", "translate(0px, -1.5px)");
                }
                else {
                    this._label.setAttribute("font-size", "20");
                    this._label.style.fontSize="20px";
                    this._label.style.setProperty("transform", "translate(0px, 0px)");
                }
                
               if( ColorConfig.getComputed("--hex-channel-label") == 'true' ){ function uhex(v){let g16=0;let arr=[];for(let i=0;i<v;i++){g16++;if(g16==16){arr.push(16);g16=1}};if(g16!==16){arr.push(g16)};let out="";for(let i=0; i<arr.length;i++){out+= "-0123456789ABCDEFF"[arr[i]] };return out; }this._text.data = uhex(String(index));this._renderedIndex = [index,2] ;  }else{ this._text.data = String(index); this._renderedIndex = [index,0] ; }
               
            }
            let useColor = selected ? ColorConfig.c_invertedText : color;
            if (this._renderedLabelColor != useColor) {
                this._label.style.color = useColor;
                this._renderedLabelColor = useColor;
            }
            if (!selected) {
                if (isNoise)
                    color = dim ? ColorConfig.c_trackEditorBgNoiseDim : ColorConfig.c_trackEditorBgNoise;
                else if (isMod)
                    color = dim ? ColorConfig.c_trackEditorBgModDim : ColorConfig.c_trackEditorBgMod;
                else
                    color = dim ? ColorConfig.c_trackEditorBgPitchDim : ColorConfig.c_trackEditorBgPitch;
            }
            color = selected ? color : (index == 0) ? "none" : color;
            if (this._renderedBackgroundColor != color) {
                this.container.style.background = color;
                this._renderedBackgroundColor = color;
            }
        }
        setVisibility(visibility) {
            if (this._renderedVisibility != visibility) {
                this.container.style.visibility = visibility;
                this._renderedVisibility = visibility;
            }
        }
        setBorderLeft(borderLeft) {
            if (this._renderedBorderLeft != borderLeft) {
                this.container.style.setProperty("border-left", borderLeft);
                this._renderedBorderLeft = borderLeft;
            }
        }
        setBorderRight(borderRight) {
            if (this._renderedBorderRight != borderRight) {
                this.container.style.setProperty("border-right", borderRight);
                this._renderedBorderRight = borderRight;
            }
        }
    }
    class ChannelRow {
        constructor(_doc, index) {
            this._doc = _doc;
            this.index = index;
            this._renderedBarWidth = -1;
            this._renderedBarHeight = -1;
            this._boxes = [];
            this.container = HTML.div({ class: "channelRow" });
        }
        render() {
            ChannelRow.patternHeight = this._doc.getChannelHeight();
            const barWidth = this._doc.getBarWidth();
            if (this._boxes.length != this._doc.song.barCount) {
                for (let x = this._boxes.length; x < this._doc.song.barCount; x++) {
                    const box = new Box(this.index, ColorConfig.getChannelColor(this._doc.song, this.index).secondaryChannel);
                    box.setWidth(barWidth);
                    this.container.appendChild(box.container);
                    this._boxes[x] = box;
                }
                for (let x = this._doc.song.barCount; x < this._boxes.length; x++) {
                    this.container.removeChild(this._boxes[x].container);
                }
                this._boxes.length = this._doc.song.barCount;
            }
            if (this._renderedBarWidth != barWidth) {
                this._renderedBarWidth = barWidth;
                for (let x = 0; x < this._boxes.length; x++) {
                    this._boxes[x].setWidth(barWidth);
                }
            }
            if (this._renderedBarHeight != ChannelRow.patternHeight) {
                this._renderedBarHeight = ChannelRow.patternHeight;
                for (let x = 0; x < this._boxes.length; x++) {
                    this._boxes[x].setHeight(ChannelRow.patternHeight);
                }
            }
            for (let i = 0; i < this._boxes.length; i++) {
                const pattern = this._doc.song.getPattern(this.index, i);
                const selected = (i == this._doc.bar && this.index == this._doc.channel);
                const dim = (pattern == null || pattern.notes.length == 0);
                const box = this._boxes[i];
                if (i < this._doc.song.barCount) {
                    const colors = ColorConfig.getChannelColor(this._doc.song, this.index);
                    box.setIndex(this._doc.song.channels[this.index].bars[i], selected, dim, dim && !selected ? colors.secondaryChannel : colors.primaryChannel, this.index >= this._doc.song.pitchChannelCount && this.index < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount, this.index >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount);
                    box.setVisibility("visible");
                }
                else {
                    box.setVisibility("hidden");
                }
                if (i == this._doc.synth.loopBarStart) {
                    box.setBorderLeft(`1px dashed ${ColorConfig.uiWidgetFocus}`);
                }
                else {
                    box.setBorderLeft("none");
                }
                if (i == this._doc.synth.loopBarEnd) {
                    box.setBorderRight(`1px dashed ${ColorConfig.uiWidgetFocus}`);
                }
                else {
                    box.setBorderRight("none");
                }
            }
        }
    }
    ChannelRow.patternHeight = 28;

    const { button: button$f, label: label$1, div: div$f, form, h2: h2$e, input: input$a } = HTML;
    class LayoutPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._fileInput = input$a({ type: "file", accept: ".json,application/json,.mid,.midi,audio/midi,audio/x-midi" });
           
            this._okayButton = button$f({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._cancelButton = button$f({ class: "cancelButton" });
            this._form = form({ style: "display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;" }, label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "small" }), SVG(`\
					<svg viewBox="-4 -1 28 22">
						<rect x="0" y="0" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="11" height="10" fill="currentColor"/>
						<rect x="14" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="2" y="13" width="11" height="5" fill="currentColor"/>
					</svg>
				`), div$f("Small")), label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "long" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="12" height="10" fill="currentColor"/>
						<rect x="15" y="2" width="4" height="10" fill="currentColor"/>
						<rect x="20" y="2" width="4" height="10" fill="currentColor"/>
						<rect x="2" y="13" width="22" height="5" fill="currentColor"/>
					</svg>
				`), div$f("Long")), label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "tall" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="11" y="2" width="8" height="16" fill="currentColor"/>
						<rect x="20" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="2" y="2" width="8" height="16" fill="currentColor"/>
					</svg>
				`), div$f("Tall")), label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "wide" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="18" y="2" width="2.5" height="16" fill="currentColor"/>
						<rect x="21.5" y="2" width="2.5" height="16" fill="currentColor"/>
						<rect x="7" y="2" width="10" height="16" fill="currentColor"/>
					</svg>
				`), div$f("Wide (JB)")), label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "wide long" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="12" height="10" fill="currentColor"/>
						<rect x="15" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="20" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="2" y="13" width="12" height="5" fill="currentColor"/>
					</svg>
				`), div$f("Wide Long (AB)")), label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "flipped long" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="22" height="2" fill="currentColor"/>
						<rect x="2" y="5" width="4" height="8" fill="currentColor"/>
						<rect x="7" y="5" width="17" height="8" fill="currentColor"/>
						<rect x="2" y="14" width="22" height="4" fill="currentColor"/>
					</svg>
				`), div$f("Flipped Long (AB)")), label$1({ class: "layout-option" }, input$a({ type: "radio", name: "layout", value: "focused long" }), SVG(`\
					<svg viewBox="-1 -1 28 22">
						<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>
						<rect x="2" y="2" width="17" height="10" fill="currentColor"/>
						<rect x="20" y="2" width="4" height="16" fill="currentColor"/>
						<rect x="2" y="13" width="17" height="5" fill="currentColor"/>
					</svg>
				`), div$f("Focused long (AB)")));
            this.container = div$f({ class: "prompt noSelection", style: "width: 300px;" }, h2$e("Layout"), this._form, div$f({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._confirm);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._confirm();
                }
            };
            this._confirm = () => {
                this._doc.prefs.layout = this._form.elements["layout"].value;
                this._doc.prefs.save();
                Layout.setLayout(this._doc.prefs.layout);
                this._close();
            };
            this._fileInput.select();
            setTimeout(() => this._fileInput.focus());
            this._okayButton.addEventListener("click", this._confirm);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._form.elements["layout"].value = this._doc.prefs.layout;
        }
    }

    class EnvelopeEditor {
        constructor(_doc, _extraSettingsDropdown, _openPrompt) {
            this._doc = _doc;
            this._extraSettingsDropdown = _extraSettingsDropdown;
            this._openPrompt = _openPrompt;
            this.container = HTML.div({ class: "envelopeEditor" });
            this._rows = [];
            this._targetSelects = [];
            this._envelopeSelects = [];
            this._deleteButtons = [];
            this.extraSettingsDropdowns = [];
            this.extraPitchSettingsGroups = [];
            this.extraSettingsDropdownGroups = [];
            this.extraRandomSettingsGroups = [];
            this.extraLFODropdownGroups = [];
            this.openExtraSettingsDropdowns = [];
            this.perEnvelopeSpeedGroups = [];
            this._pitchStartSliders = [];
            this.pitchStartBoxes = [];
            this._pitchEndSliders = [];
            this.pitchEndBoxes = [];
            this._startNoteDisplays = [];
            this._endNoteDisplays = [];
            this._inverters = [];
            this._discreters = [];
            this.perEnvelopeSpeedSliders = [];
            this._perEnvelopeSpeedDisplays = [];
            this.perEnvelopeLowerBoundBoxes = [];
            this.perEnvelopeUpperBoundBoxes = [];
            this.perEnvelopeLowerBoundSliders = [];
            this.perEnvelopeUpperBoundSliders = [];
            this.randomStepsBoxes = [];
            this.randomSeedBoxes = [];
            this._randomStepsSliders = [];
            this._randomSeedSliders = [];
            this._randomEnvelopeTypeSelects = [];
            this._randomStepsWrappers = [];
            this._envelopeCopyButtons = [];
            this._envelopePasteButtons = [];
            this._waveformSelects = [];
            this.LFOStepsBoxes = [];
            this._LFOStepsSliders = [];
            this._LFOStepsWrappers = [];
            this._renderedEnvelopeCount = 0;
            this._renderedEqFilterCount = -1;
            this._renderedNoteFilterCount = -1;
            this._renderedEffects = 0;
            this._lastChange = null;
            this._onChange = (event) => {
                const targetSelectIndex = this._targetSelects.indexOf(event.target);
                const envelopeSelectIndex = this._envelopeSelects.indexOf(event.target);
                const inverterIndex = this._inverters.indexOf(event.target);
                const discreterIndex = this._discreters.indexOf(event.target);
                const startBoxIndex = this.pitchStartBoxes.indexOf(event.target);
                const endBoxIndex = this.pitchEndBoxes.indexOf(event.target);
                const startSliderIndex = this._pitchStartSliders.indexOf(event.target);
                const endSliderIndex = this._pitchEndSliders.indexOf(event.target);
                const lowerBoundBoxIndex = this.perEnvelopeLowerBoundBoxes.indexOf(event.target);
                const upperBoundBoxIndex = this.perEnvelopeUpperBoundBoxes.indexOf(event.target);
                const randomStepsBoxIndex = this.randomStepsBoxes.indexOf(event.target);
                const randomSeedBoxIndex = this.randomSeedBoxes.indexOf(event.target);
                const randomStepsSliderIndex = this._randomStepsSliders.indexOf(event.target);
                const randomSeedSliderIndex = this._randomSeedSliders.indexOf(event.target);
                const waveformSelectIndex = this._waveformSelects.indexOf(event.target);
                const randomTypeSelectIndex = this._randomEnvelopeTypeSelects.indexOf(event.target);
                const LFOStepsBoxIndex = this.LFOStepsBoxes.indexOf(event.target);
                const LFOStepsSliderIndex = this._LFOStepsSliders.indexOf(event.target);
                if (targetSelectIndex != -1) {
                    const combinedValue = parseInt(this._targetSelects[targetSelectIndex].value);
                    const target = combinedValue % Config.instrumentAutomationTargets.length;
                    const index = (combinedValue / Config.instrumentAutomationTargets.length) >>> 0;
                    this._doc.record(new ChangeSetEnvelopeTarget(this._doc, targetSelectIndex, target, index));
                }
                else if (envelopeSelectIndex != -1) {
                    const envelopeIndex = this._envelopeSelects.indexOf(event.target);
                    this._doc.record(new ChangeSetEnvelopeType(this._doc, envelopeIndex, this._envelopeSelects[envelopeIndex].selectedIndex));
                    this.rerenderExtraSettings(envelopeSelectIndex);
                    this.render();
                }
                else if (waveformSelectIndex != -1) {
                    this._doc.record(new ChangeSetEnvelopeWaveform(this._doc, this._waveformSelects[waveformSelectIndex].value, waveformSelectIndex));
                }
                else if (randomTypeSelectIndex != -1) {
                    this._doc.record(new ChangeSetEnvelopeWaveform(this._doc, this._randomEnvelopeTypeSelects[randomTypeSelectIndex].value, randomTypeSelectIndex));
                }
                else if (inverterIndex != -1) {
                    this._doc.record(new ChangeEnvelopeInverse(this._doc, this._inverters[inverterIndex].checked, inverterIndex));
                }
                else if (discreterIndex != -1) {
                    this._doc.record(new ChangeDiscreteEnvelope(this._doc, this._discreters[discreterIndex].checked, discreterIndex));
                }
                else if (startBoxIndex != -1 || endBoxIndex != -1 || startSliderIndex != -1 || endSliderIndex != -1 ||
                    lowerBoundBoxIndex != -1 || upperBoundBoxIndex != -1 || randomStepsBoxIndex != -1 || randomSeedBoxIndex != -1 ||
                    randomStepsSliderIndex != -1 || randomSeedSliderIndex != -1 || LFOStepsBoxIndex != -1 || LFOStepsSliderIndex != -1) {
                    if (this._lastChange != null) {
                        this._doc.record(this._lastChange);
                        this._lastChange = null;
                    }
                }
            };
            this._onClick = (event) => {
                const deleteButtonIndex = this._deleteButtons.indexOf(event.target);
                const envelopeCopyButtonIndex = this._envelopeCopyButtons.indexOf(event.target);
                const envelopePasteButtonIndex = this._envelopePasteButtons.indexOf(event.target);
                if (deleteButtonIndex != -1) {
                    this._doc.record(new ChangeRemoveEnvelope(this._doc, deleteButtonIndex));
                    this.extraSettingsDropdownGroups[deleteButtonIndex].style.display = "none";
                }
                else if (envelopeCopyButtonIndex != -1) {
                    const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                    window.localStorage.setItem("envelopeCopy", JSON.stringify(instrument.envelopes[envelopeCopyButtonIndex].toJsonObject()));
                }
                else if (envelopePasteButtonIndex != -1) {
                    const envelopeCopy = window.localStorage.getItem("envelopeCopy");
                    this._doc.record(new PasteEnvelope(this._doc, JSON.parse(String(envelopeCopy)), envelopePasteButtonIndex));
                }
            };
            this._onInput = (event) => {
                const startBoxIndex = this.pitchStartBoxes.indexOf(event.target);
                const endBoxIndex = this.pitchEndBoxes.indexOf(event.target);
                const startSliderIndex = this._pitchStartSliders.indexOf(event.target);
                const endSliderIndex = this._pitchEndSliders.indexOf(event.target);
                const lowerBoundBoxIndex = this.perEnvelopeLowerBoundBoxes.indexOf(event.target);
                const upperBoundBoxIndex = this.perEnvelopeUpperBoundBoxes.indexOf(event.target);
                const randomStepsBoxIndex = this.randomStepsBoxes.indexOf(event.target);
                const randomSeedBoxIndex = this.randomSeedBoxes.indexOf(event.target);
                const randomStepsSliderIndex = this._randomStepsSliders.indexOf(event.target);
                const randomSeedSliderIndex = this._randomSeedSliders.indexOf(event.target);
                const LFOStepsBoxIndex = this.LFOStepsBoxes.indexOf(event.target);
                const LFOStepsSliderIndex = this._LFOStepsSliders.indexOf(event.target);
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                if (startBoxIndex != -1) {
                    this._lastChange = new ChangeEnvelopePitchStart(this._doc, parseInt(this.pitchStartBoxes[startBoxIndex].value), startBoxIndex);
                }
                else if (endBoxIndex != -1) {
                    this._lastChange = new ChangeEnvelopePitchEnd(this._doc, parseInt(this.pitchEndBoxes[endBoxIndex].value), endBoxIndex);
                }
                else if (startSliderIndex != -1) {
                    this._lastChange = new ChangeEnvelopePitchStart(this._doc, parseInt(this._pitchStartSliders[startSliderIndex].value), startSliderIndex);
                }
                else if (endSliderIndex != -1) {
                    this._lastChange = new ChangeEnvelopePitchEnd(this._doc, parseInt(this._pitchEndSliders[endSliderIndex].value), endSliderIndex);
                }
                else if (lowerBoundBoxIndex != -1) {
                    this._lastChange = new ChangeEnvelopeLowerBound(this._doc, instrument.envelopes[lowerBoundBoxIndex].perEnvelopeLowerBound, parseFloat(this.perEnvelopeLowerBoundBoxes[lowerBoundBoxIndex].value), lowerBoundBoxIndex);
                }
                else if (upperBoundBoxIndex != -1) {
                    this._lastChange = new ChangeEnvelopeUpperBound(this._doc, instrument.envelopes[upperBoundBoxIndex].perEnvelopeUpperBound, parseFloat(this.perEnvelopeUpperBoundBoxes[upperBoundBoxIndex].value), upperBoundBoxIndex);
                }
                else if (randomStepsBoxIndex != -1) {
                    this._lastChange = new ChangeRandomEnvelopeSteps(this._doc, parseFloat(this.randomStepsBoxes[randomStepsBoxIndex].value), randomStepsBoxIndex);
                }
                else if (randomSeedBoxIndex != -1) {
                    this._lastChange = new ChangeRandomEnvelopeSeed(this._doc, parseFloat(this.randomSeedBoxes[randomSeedBoxIndex].value), randomSeedBoxIndex);
                }
                else if (randomStepsSliderIndex != -1) {
                    this._lastChange = new ChangeRandomEnvelopeSteps(this._doc, parseFloat(this._randomStepsSliders[randomStepsSliderIndex].value), randomStepsSliderIndex);
                }
                else if (randomSeedSliderIndex != -1) {
                    this._lastChange = new ChangeRandomEnvelopeSeed(this._doc, parseFloat(this._randomSeedSliders[randomSeedSliderIndex].value), randomSeedSliderIndex);
                }
                else if (LFOStepsBoxIndex != -1) {
                    this._lastChange = new ChangeRandomEnvelopeSteps(this._doc, parseFloat(this.LFOStepsBoxes[LFOStepsBoxIndex].value), LFOStepsBoxIndex);
                }
                else if (LFOStepsSliderIndex != -1) {
                    this._lastChange = new ChangeRandomEnvelopeSteps(this._doc, parseFloat(this._LFOStepsSliders[LFOStepsSliderIndex].value), LFOStepsSliderIndex);
                }
            };
            this.container.addEventListener("change", this._onChange);
            this.container.addEventListener("click", this._onClick);
            this.container.addEventListener("input", this._onInput);
        }
        _makeOption(target, index) {
            let displayName = Config.instrumentAutomationTargets[target].displayName;
            if (Config.instrumentAutomationTargets[target].maxCount > 1) {
                if (displayName.indexOf("#") != -1) {
                    displayName = displayName.replace("#", String(index + 1));
                }
                else {
                    displayName += " " + (index + 1);
                }
            }
            return HTML.option({ value: target + index * Config.instrumentAutomationTargets.length }, displayName);
        }
        _updateTargetOptionVisibility(menu, instrument) {
            for (let optionIndex = 0; optionIndex < menu.childElementCount; optionIndex++) {
                const option = menu.children[optionIndex];
                const combinedValue = parseInt(option.value);
                const target = combinedValue % Config.instrumentAutomationTargets.length;
                const index = (combinedValue / Config.instrumentAutomationTargets.length) >>> 0;
                option.hidden = !instrument.supportsEnvelopeTarget(target, index);
            }
        }
        _pitchToNote(value, isNoise) {
            let text = "";
            if (isNoise) {
                value = value * 6 + 12;
            }
            const offset = Config.keys[this._doc.song.key].basePitch % Config.pitchesPerOctave;
            const keyValue = (value + offset) % Config.pitchesPerOctave;
            if (Config.keys[keyValue].isWhiteKey) {
                text = Config.keys[keyValue].name;
            }
            else {
                const shiftDir = Config.blackKeyNameParents[value % Config.pitchesPerOctave];
                text = Config.keys[(keyValue + Config.pitchesPerOctave + shiftDir) % Config.pitchesPerOctave].name;
                if (shiftDir == 1) {
                    text += "";
                }
                else if (shiftDir == -1) {
                    text += "";
                }
            }
            return "[" + text + Math.floor((value + Config.pitchesPerOctave) / 12 + this._doc.song.octave - 1) + "]";
        }
        rerenderExtraSettings(index = 0) {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            for (let i = index; i < Config.maxEnvelopeCount; i++) {
                if (i >= instrument.envelopeCount) {
                    if (this.extraSettingsDropdowns[i]) {
                        this.extraSettingsDropdowns[i].style.display = "none";
                    }
                    if (this.extraSettingsDropdownGroups[i]) {
                        this.extraSettingsDropdownGroups[i].style.display = "none";
                    }
                    if (this.extraPitchSettingsGroups[i]) {
                        this.extraPitchSettingsGroups[i].style.display = "none";
                    }
                    if (this.extraPitchSettingsGroups[i]) {
                        this.perEnvelopeSpeedGroups[i].style.display = "none";
                    }
                    if (this.extraLFODropdownGroups[i]) {
                        this.extraLFODropdownGroups[i].style.display = "none";
                    }
                }
                else if (this.openExtraSettingsDropdowns[i]) {
                    this.extraSettingsDropdownGroups[i].style.display = "flex";
                    this.extraSettingsDropdowns[i].style.display = "inline";
                    this.updateSpeedDisplay(i);
                    if (Config.newEnvelopes[instrument.envelopes[i].envelope].name == "pitch") {
                        this.pitchStartBoxes[i].value = instrument.envelopes[i].pitchEnvelopeStart.toString();
                        this.pitchEndBoxes[i].value = instrument.envelopes[i].pitchEnvelopeEnd.toString();
                        this._pitchStartSliders[i].max = (instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch).toString();
                        this.pitchStartBoxes[i].max = (instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch).toString();
                        this._pitchEndSliders[i].max = (instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch).toString();
                        this.pitchEndBoxes[i].max = (instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch).toString();
                        if (instrument.isNoiseInstrument && parseInt(this.pitchStartBoxes[i].value) > Config.drumCount - 1) {
                            this.pitchStartBoxes[i].value = (Config.drumCount - 1).toString();
                        }
                        if (instrument.isNoiseInstrument && parseInt(this.pitchEndBoxes[i].value) > Config.drumCount - 1) {
                            this.pitchEndBoxes[i].value = (Config.drumCount - 1).toString();
                        }
                        this._startNoteDisplays[i].textContent = "Start " + this._pitchToNote(parseInt(this.pitchStartBoxes[i].value), instrument.isNoiseInstrument) + ": ";
                        this._endNoteDisplays[i].textContent = "End " + this._pitchToNote(parseInt(this.pitchEndBoxes[i].value), instrument.isNoiseInstrument) + ": ";
                        this.extraPitchSettingsGroups[i].style.display = "flex";
                        this.perEnvelopeSpeedGroups[i].style.display = "none";
                        this.extraRandomSettingsGroups[i].style.display = "none";
                        this.extraLFODropdownGroups[i].style.display = "none";
                    }
                    else if (Config.newEnvelopes[instrument.envelopes[i].envelope].name == "random") {
                        const isRandomTime = instrument.envelopes[i].waveform == 0 || instrument.envelopes[i].waveform == 3;
                        this.randomStepsBoxes[i].value = instrument.envelopes[i].steps.toString();
                        this.randomSeedBoxes[i].value = instrument.envelopes[i].seed.toString();
                        this._randomStepsSliders[i].value = instrument.envelopes[i].steps.toString();
                        this._randomSeedSliders[i].value = instrument.envelopes[i].seed.toString();
                        this.perEnvelopeSpeedSliders[i].updateValue(EnvelopeEditor.convertIndexSpeed(instrument.envelopes[i].perEnvelopeSpeed, "index"));
                        if (instrument.envelopes[i].waveform > 4)
                            instrument.envelopes[i].waveform = 0;
                        this._randomStepsWrappers[i].style.display = instrument.envelopes[i].waveform == 0 || instrument.envelopes[i].waveform == 2 ? "flex" : "none";
                        this._randomEnvelopeTypeSelects[i].selectedIndex = instrument.envelopes[i].waveform;
                        this.perEnvelopeSpeedGroups[i].style.display = isRandomTime ? "" : "none";
                        this.extraSettingsDropdownGroups[i].style.display = "flex";
                        this.extraSettingsDropdowns[i].style.display = "inline";
                        this.extraPitchSettingsGroups[i].style.display = "none";
                        this.extraRandomSettingsGroups[i].style.display = "";
                        this.extraLFODropdownGroups[i].style.display = "none";
                    }
                    else if (Config.newEnvelopes[instrument.envelopes[i].envelope].name == "lfo") {
                        this._waveformSelects[i].value = instrument.envelopes[i].waveform.toString();
                        this.perEnvelopeSpeedSliders[i].updateValue(EnvelopeEditor.convertIndexSpeed(instrument.envelopes[i].perEnvelopeSpeed, "index"));
                        if (instrument.envelopes[i].waveform == 5 || instrument.envelopes[i].waveform == 6) {
                            this._LFOStepsWrappers[i].style.display = "flex";
                        }
                        else {
                            this._LFOStepsWrappers[i].style.display = "none";
                        }
                        this.extraLFODropdownGroups[i].style.display = "";
                        this.perEnvelopeSpeedGroups[i].style.display = "flex";
                        this.extraSettingsDropdownGroups[i].style.display = "flex";
                        this.extraSettingsDropdowns[i].style.display = "inline";
                        this.extraPitchSettingsGroups[i].style.display = "none";
                        this.extraRandomSettingsGroups[i].style.display = "none";
                    }
                    else {
                        this.extraPitchSettingsGroups[i].style.display = "none";
                        this.extraRandomSettingsGroups[i].style.display = "none";
                        this.extraLFODropdownGroups[i].style.display = "none";
                        if (Config.newEnvelopes[instrument.envelopes[i].envelope].name == "punch" || Config.newEnvelopes[instrument.envelopes[i].envelope].name == "none" || Config.newEnvelopes[instrument.envelopes[i].envelope].name == "note size") {
                            this.perEnvelopeSpeedGroups[i].style.display = "none";
                        }
                        else {
                            this.perEnvelopeSpeedGroups[i].style.display = "flex";
                            this.perEnvelopeSpeedSliders[i].updateValue(EnvelopeEditor.convertIndexSpeed(instrument.envelopes[i].perEnvelopeSpeed, "index"));
                        }
                    }
                    this._inverters[i].checked = instrument.envelopes[i].inverse;
                    this._discreters[i].checked = instrument.envelopes[i].discrete;
                    this.perEnvelopeLowerBoundBoxes[i].value = instrument.envelopes[i].perEnvelopeLowerBound.toString();
                    this.perEnvelopeUpperBoundBoxes[i].value = instrument.envelopes[i].perEnvelopeUpperBound.toString();
                    this.perEnvelopeLowerBoundSliders[i].updateValue(instrument.envelopes[i].perEnvelopeLowerBound);
                    this.perEnvelopeUpperBoundSliders[i].updateValue(instrument.envelopes[i].perEnvelopeUpperBound);
                }
                else if (this.openExtraSettingsDropdowns[i] == false) {
                    this.extraSettingsDropdownGroups[i].style.display = "none";
                    this.extraPitchSettingsGroups[i].style.display = "none";
                    this.extraSettingsDropdowns[i].style.display = "inline";
                    this.perEnvelopeSpeedGroups[i].style.display = "none";
                }
                else {
                    if (this.extraSettingsDropdowns[i]) {
                        this.extraSettingsDropdowns[i].style.display = "none";
                    }
                    if (this.extraSettingsDropdownGroups[i]) {
                        this.extraSettingsDropdownGroups[i].style.display = "none";
                    }
                    if (this.extraPitchSettingsGroups[i]) {
                        this.extraPitchSettingsGroups[i].style.display = "none";
                    }
                    if (this.extraPitchSettingsGroups[i]) {
                        this.perEnvelopeSpeedGroups[i].style.display = "none";
                    }
                    if (this.extraLFODropdownGroups[i]) {
                        this.extraLFODropdownGroups[i].style.display = "none";
                    }
                    if (this.extraRandomSettingsGroups[i]) {
                        this.extraRandomSettingsGroups[i].style.display = "none";
                    }
                }
            }
        }
        static convertIndexSpeed(value, convertTo) {
            switch (convertTo) {
                case "index":
                    return Config.perEnvelopeSpeedToIndices[value] != null ? Config.perEnvelopeSpeedToIndices[value] : 23;
                case "speed":
                    return Config.perEnvelopeSpeedIndices[value] != null ? Config.perEnvelopeSpeedIndices[value] : 1;
            }
            return 0;
        }
        updateSpeedDisplay(envelopeIndex) {
            this._perEnvelopeSpeedDisplays[envelopeIndex].textContent = "Spd: x" + prettyNumber(this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].envelopes[envelopeIndex].perEnvelopeSpeed);
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            for (let envelopeIndex = this._rows.length; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                const targetSelect = HTML.select();
                for (let target = 0; target < Config.instrumentAutomationTargets.length; target++) {
                    const interleaved = (Config.instrumentAutomationTargets[target].interleave);
                    for (let index = 0; index < Config.instrumentAutomationTargets[target].maxCount; index++) {
                        targetSelect.appendChild(this._makeOption(target, index));
                        if (interleaved) {
                            targetSelect.appendChild(this._makeOption(target + 1, index));
                        }
                    }
                    if (interleaved)
                        target++;
                }
                const envelopeSelect = HTML.select({ id: "envelopeSelect" });
                for (let envelope = 0; envelope < Config.newEnvelopes.length; envelope++) {
                    envelopeSelect.appendChild(HTML.option({ value: envelope }, Config.newEnvelopes[envelope].name));
                }
                const deleteButton = HTML.button({ type: "button", class: "delete-envelope", style: "flex: 0.2" });
                const pitchStartNoteSlider = HTML.input({ value: instrument.envelopes[envelopeIndex].pitchEnvelopeStart ? instrument.envelopes[envelopeIndex].pitchEnvelopeStart : 0, style: "width: 113px; margin-left: 0px;", type: "range", min: "0", max: instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch, step: "1" });
                const pitchStartNoteBox = HTML.input({ value: instrument.envelopes[envelopeIndex].pitchEnvelopeStart ? instrument.envelopes[envelopeIndex].pitchEnvelopeStart : 0, style: "width: 4em; font-size: 80%; ", id: "startNoteBox", type: "number", step: "1", min: "0", max: instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch });
                const pitchEndNoteSlider = HTML.input({ value: instrument.envelopes[envelopeIndex].pitchEnvelopeEnd ? instrument.envelopes[envelopeIndex].pitchEnvelopeEnd : instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch, style: "width: 113px; margin-left: 0px;", type: "range", min: "0", max: instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch, step: "1" });
                const pitchEndNoteBox = HTML.input({ value: instrument.envelopes[envelopeIndex].pitchEnvelopeEnd ? instrument.envelopes[envelopeIndex].pitchEnvelopeEnd : instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch, style: "width: 4em; font-size: 80%; ", id: "endNoteBox", type: "number", step: "1", min: "0", max: instrument.isNoiseInstrument ? Config.drumCount - 1 : Config.maxPitch });
                const pitchStartNoteDisplay = HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("pitchRange") }, "Start " + this._pitchToNote(parseInt(pitchStartNoteBox.value), instrument.isNoiseInstrument) + ": ");
                const pitchEndNoteDisplay = HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("pitchRange") }, "End " + this._pitchToNote(parseInt(pitchEndNoteBox.value), instrument.isNoiseInstrument) + ": ");
                const pitchStartBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, pitchStartNoteDisplay, pitchStartNoteBox);
                const pitchEndBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, pitchEndNoteDisplay, pitchEndNoteBox);
                const pitchStartNoteWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, pitchStartBoxWrapper, pitchStartNoteSlider);
                const pitchEndNoteWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, pitchEndBoxWrapper, pitchEndNoteSlider);
                const extraPitchSettingsGroup = HTML.div({ class: "editor-controls", style: "flex-direction:column; align-items:center;" }, pitchStartNoteWrapper, pitchEndNoteWrapper);
                extraPitchSettingsGroup.style.display = "none";
                const randomStepsBox = HTML.input({ value: instrument.envelopes[envelopeIndex].steps, type: "number", min: 1, max: Config.randomEnvelopeStepsMax, step: 1, style: "width: 4em; font-size: 80%; " });
                const randomStepsSlider = HTML.input({ value: instrument.envelopes[envelopeIndex].steps, type: "range", min: 1, max: Config.randomEnvelopeStepsMax, step: 1, style: "width: 113px; margin-left: 0px;" });
                const randomSeedBox = HTML.input({ value: instrument.envelopes[envelopeIndex].seed, type: "number", min: 1, max: Config.randomEnvelopeSeedMax, step: 1, style: "width: 4em; font-size: 80%; " });
                const randomSeedSlider = HTML.input({ value: instrument.envelopes[envelopeIndex].seed, type: "range", min: 1, max: Config.randomEnvelopeSeedMax, step: 1, style: "width: 113px; margin-left: 0px;" });
                const randomStepsBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("randomSteps") }, "Steps: "), randomStepsBox);
                const randomSeedBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("randomSeed") }, "Seed: "), randomSeedBox);
                const randomStepsWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, randomStepsBoxWrapper, randomStepsSlider);
                const randomSeedWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, randomSeedBoxWrapper, randomSeedSlider);
                const randomTypeSelect = HTML.select({ style: "width: 115px;" });
                const randomNames = ["time", "pitch", "note", "time smooth"];
                for (let waveform = 0; waveform < 4; waveform++) {
                    randomTypeSelect.appendChild(HTML.option({ value: waveform }, randomNames[waveform]));
                }
                const randomTypeSelectWrapper = HTML.div({ class: "editor-controls selectContainer", style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, HTML.span({ style: "font-size: smaller; margin-right: 35px;", class: "tip", onclick: () => this._openPrompt("randomEnvelopeType") }, "Type: "), randomTypeSelect);
                const extraRandomSettingsGroup = HTML.div({ class: "editor-controls", style: "flex-direction:column; align-items:center;" }, randomTypeSelectWrapper, randomStepsWrapper, randomSeedWrapper);
                extraRandomSettingsGroup.style.display = "none";
                const waveformSelect = HTML.select({ style: "width: 115px;" });
                const LFOStepsBox = HTML.input({ value: instrument.envelopes[envelopeIndex].steps, type: "number", min: 1, max: Config.randomEnvelopeStepsMax, step: 1, style: "width: 4em; font-size: 80%; " });
                const LFOStepsSlider = HTML.input({ value: instrument.envelopes[envelopeIndex].steps, type: "range", min: 1, max: Config.randomEnvelopeStepsMax, step: 1, style: "width: 113px; margin-left: 0px;" });
                const LFOStepsBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("randomSteps") }, "Steps: "), LFOStepsBox);
                const LFOStepsWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, LFOStepsBoxWrapper, LFOStepsSlider);
                const wavenames = ["sine", "square", "triangle", "sawtooth", "trapezoid", "stepped saw", "stepped tri"];
                for (let waveform = 0; waveform < 7; waveform++) {
                    waveformSelect.appendChild(HTML.option({ value: waveform }, wavenames[waveform]));
                }
                const waveformWrapper = HTML.div({ class: "editor-controls selectContainer", style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, HTML.span({ style: "font-size: smaller; margin-right: 10px;", class: "tip", onclick: () => this._openPrompt("lfoEnvelopeWaveform") }, "Waveform: "), waveformSelect);
                const extraLFOSettingsGroup = HTML.div({ class: "editor-controls", style: "margin-top: 3px; flex:1; display:flex; flex-direction: column; align-items:center; justify-content:right;" }, waveformWrapper, LFOStepsWrapper);
                extraLFOSettingsGroup.style.display = "none";
                const perEnvelopeSpeedSlider = new Slider(HTML.input({ oninput: () => this.updateSpeedDisplay(envelopeIndex), style: "margin: 0; width: 113px", type: "range", min: 0, max: Config.perEnvelopeSpeedIndices.length - 1, value: EnvelopeEditor.convertIndexSpeed(instrument.envelopes[envelopeIndex].perEnvelopeSpeed, "index"), step: "1" }), this._doc, (oldSpeed, newSpeed) => new ChangePerEnvelopeSpeed(this._doc, EnvelopeEditor.convertIndexSpeed(oldSpeed, "speed"), EnvelopeEditor.convertIndexSpeed(newSpeed, "speed"), envelopeIndex), false);
                const perEnvelopeSpeedDisplay = HTML.span({ class: "tip", style: `width:58px; flex:1; height:1em; font-size: smaller; margin-left: 10px;`, onclick: () => this._openPrompt("perEnvelopeSpeed") }, "Spd: x" + prettyNumber(EnvelopeEditor.convertIndexSpeed(perEnvelopeSpeedSlider.getValueBeforeProspectiveChange(), "speed")));
                const perEnvelopeSpeedWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, perEnvelopeSpeedDisplay, perEnvelopeSpeedSlider.container);
                const perEnvelopeSpeedGroup = HTML.div({ class: "editor-controls", style: "flex-direction:column; align-items:center;" }, perEnvelopeSpeedWrapper);
                const lowerBoundBox = HTML.input({ value: instrument.envelopes[envelopeIndex].perEnvelopeLowerBound, type: "number", min: Config.perEnvelopeBoundMin, max: Config.perEnvelopeBoundMax, step: 0.1, style: "width: 4em; font-size: 80%; " });
                const lowerBoundSlider = new Slider(HTML.input({ value: instrument.envelopes[envelopeIndex].perEnvelopeLowerBound, type: "range", min: Config.perEnvelopeBoundMin, max: Config.perEnvelopeBoundMax, step: 0.1, style: "width: 113px; margin-left: 0px;" }), this._doc, (oldBound, newBound) => new ChangeEnvelopeLowerBound(this._doc, oldBound, newBound, envelopeIndex), false);
                const upperBoundBox = HTML.input({ value: instrument.envelopes[envelopeIndex].perEnvelopeUpperBound, type: "number", min: Config.perEnvelopeBoundMin, max: Config.perEnvelopeBoundMax, step: 0.1, style: "width: 4em; font-size: 80%; " });
                const upperBoundSlider = new Slider(HTML.input({ value: instrument.envelopes[envelopeIndex].perEnvelopeUpperBound, type: "range", min: Config.perEnvelopeBoundMin, max: Config.perEnvelopeBoundMax, step: 0.1, style: "width: 113px; margin-left: 0px;" }), this._doc, (oldBound, newBound) => new ChangeEnvelopeUpperBound(this._doc, oldBound, newBound, envelopeIndex), false);
                const lowerBoundBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("envelopeRange") }, "Lwr bnd: "), lowerBoundBox);
                const upperBoundBoxWrapper = HTML.div({ style: "flex: 1; display: flex; flex-direction: column; align-items: center;" }, HTML.span({ class: "tip", style: `width:68px; flex:1; height:1em; font-size: smaller;`, onclick: () => this._openPrompt("envelopeRange") }, "Upr bnd: "), upperBoundBox);
                const lowerBoundWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, lowerBoundBoxWrapper, lowerBoundSlider.container);
                const upperBoundWrapper = HTML.div({ style: "margin-top: 3px; flex:1; display:flex; flex-direction: row; align-items:center; justify-content:right;" }, upperBoundBoxWrapper, upperBoundSlider.container);
                const invertBox = HTML.input({ "checked": instrument.envelopes[envelopeIndex].inverse, type: "checkbox", style: "width: 1em; padding: 0.5em;", id: "invertBox" });
                const discreteEnvelopeBox = HTML.input({ "checked": instrument.envelopes[envelopeIndex].discrete, type: "checkbox", style: "width: 1em; padding: 0.5em;" });
                const checkboxWrapper = HTML.div({ style: "margin: 0.1em; align-items:center; justify-content:right;" }, HTML.span({ class: "tip", onclick: () => this._openPrompt("envelopeInvert") }, " Invert: "), invertBox, HTML.span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("discreteEnvelope") }, " Discrete:"), discreteEnvelopeBox);
                const envelopeCopyButton = HTML.button({ style: "margin-left:0px; max-width:86px; width: 86px; height: 26px; padding-left: 22px", class: "copyButton", title: "Copy Envelope" }, [
                    "Copy Env",
                    SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "26px", height: "26px", viewBox: "-5 -21 26 26" }, [
                        SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                    ]),
                ]);
                const envelopePasteButton = HTML.button({ style: "margin-left:2px; max-width:89px; width: 89px; height: 26px; padding-left: 22px", class: "pasteButton", title: "Paste Envelope" }, [
                    "Paste Env",
                    SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "26px", height: "26px", viewBox: "0 0 26 26" }, [
                        SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                        SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                    ]),
                ]);
                const copyPasteContainer = HTML.div({ class: "editor-controls", style: "margin: 0.5em; display: flex; flex-direction:row; align-items:center;" }, envelopeCopyButton, envelopePasteButton);
                const extraSettingsDropdown = HTML.button({ style: "margin-left:0em; margin-right: 0.3em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => { const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()]; this._extraSettingsDropdown(8, envelopeIndex, Config.newEnvelopes[instrument.envelopes[envelopeIndex].envelope].name); } }, "");
                extraSettingsDropdown.style.display = "inline";
                const extraSettingsDropdownGroup = HTML.div({ class: "editor-controls", style: "flex-direction:column; align-items:center;" }, extraRandomSettingsGroup, extraLFOSettingsGroup, extraPitchSettingsGroup, perEnvelopeSpeedGroup, lowerBoundWrapper, upperBoundWrapper, checkboxWrapper, copyPasteContainer);
                extraSettingsDropdownGroup.style.display = "none";
                const row = HTML.div({ class: "envelope-row" }, extraSettingsDropdown, HTML.div({ class: "selectContainer", style: "width: 0; flex: 1;" }, targetSelect), HTML.div({ class: "selectContainer", style: "width: 0; flex: 0.85" }, envelopeSelect), deleteButton);
                this.container.appendChild(row);
                this.container.appendChild(extraSettingsDropdownGroup);
                this._rows[envelopeIndex] = row;
                this._targetSelects[envelopeIndex] = targetSelect;
                this._envelopeSelects[envelopeIndex] = envelopeSelect;
                this._deleteButtons[envelopeIndex] = deleteButton;
                this.extraSettingsDropdowns[envelopeIndex] = extraSettingsDropdown;
                this.extraSettingsDropdownGroups[envelopeIndex] = extraSettingsDropdownGroup;
                this._inverters[envelopeIndex] = invertBox;
                this._discreters[envelopeIndex] = discreteEnvelopeBox;
                this.perEnvelopeLowerBoundBoxes[envelopeIndex] = lowerBoundBox;
                this.perEnvelopeUpperBoundBoxes[envelopeIndex] = upperBoundBox;
                this.perEnvelopeLowerBoundSliders[envelopeIndex] = lowerBoundSlider;
                this.perEnvelopeUpperBoundSliders[envelopeIndex] = upperBoundSlider;
                this._perEnvelopeSpeedDisplays[envelopeIndex] = perEnvelopeSpeedDisplay;
                this.perEnvelopeSpeedSliders[envelopeIndex] = perEnvelopeSpeedSlider;
                this.perEnvelopeSpeedGroups[envelopeIndex] = perEnvelopeSpeedGroup;
                this.extraPitchSettingsGroups[envelopeIndex] = extraPitchSettingsGroup;
                this._pitchStartSliders[envelopeIndex] = pitchStartNoteSlider;
                this.pitchStartBoxes[envelopeIndex] = pitchStartNoteBox;
                this._pitchEndSliders[envelopeIndex] = pitchEndNoteSlider;
                this.pitchEndBoxes[envelopeIndex] = pitchEndNoteBox;
                this._startNoteDisplays[envelopeIndex] = pitchStartNoteDisplay;
                this._endNoteDisplays[envelopeIndex] = pitchEndNoteDisplay;
                this.extraRandomSettingsGroups[envelopeIndex] = extraRandomSettingsGroup;
                this.randomStepsBoxes[envelopeIndex] = randomStepsBox;
                this.randomSeedBoxes[envelopeIndex] = randomSeedBox;
                this._randomStepsSliders[envelopeIndex] = randomStepsSlider;
                this._randomSeedSliders[envelopeIndex] = randomSeedSlider;
                this._randomStepsWrappers[envelopeIndex] = randomStepsWrapper;
                this._randomEnvelopeTypeSelects[envelopeIndex] = randomTypeSelect;
                this.extraLFODropdownGroups[envelopeIndex] = extraLFOSettingsGroup;
                this._waveformSelects[envelopeIndex] = waveformSelect;
                this.LFOStepsBoxes[envelopeIndex] = LFOStepsBox;
                this._LFOStepsSliders[envelopeIndex] = LFOStepsSlider;
                this._LFOStepsWrappers[envelopeIndex] = LFOStepsWrapper;
                this._envelopeCopyButtons[envelopeIndex] = envelopeCopyButton;
                this._envelopePasteButtons[envelopeIndex] = envelopePasteButton;
            }
            for (let envelopeIndex = this._renderedEnvelopeCount; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                this._rows[envelopeIndex].style.display = "";
                this._updateTargetOptionVisibility(this._targetSelects[envelopeIndex], instrument);
            }
            for (let envelopeIndex = instrument.envelopeCount; envelopeIndex < this._renderedEnvelopeCount; envelopeIndex++) {
                this._rows[envelopeIndex].style.display = "none";
            }
            let useControlPointCount = instrument.noteFilter.controlPointCount;
            if (instrument.noteFilterType)
                useControlPointCount = 1;
            if (this._renderedEqFilterCount != instrument.eqFilter.controlPointCount ||
                this._renderedNoteFilterCount != useControlPointCount ||
                this._renderedInstrumentType != instrument.type ||
                this._renderedEffects != instrument.effects) {
                for (let envelopeIndex = 0; envelopeIndex < this._renderedEnvelopeCount; envelopeIndex++) {
                    this._updateTargetOptionVisibility(this._targetSelects[envelopeIndex], instrument);
                }
            }
            for (let envelopeIndex = 0; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {
                this._targetSelects[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].target + instrument.envelopes[envelopeIndex].index * Config.instrumentAutomationTargets.length);
                this._envelopeSelects[envelopeIndex].selectedIndex = instrument.envelopes[envelopeIndex].envelope;
                this.pitchStartBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].pitchEnvelopeStart);
                this.pitchEndBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].pitchEnvelopeEnd);
                this._pitchStartSliders[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].pitchEnvelopeStart);
                this._pitchEndSliders[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].pitchEnvelopeEnd);
                this._inverters[envelopeIndex].checked = instrument.envelopes[envelopeIndex].inverse;
                this._discreters[envelopeIndex].checked = instrument.envelopes[envelopeIndex].discrete;
                this.perEnvelopeSpeedSliders[envelopeIndex].updateValue(EnvelopeEditor.convertIndexSpeed(instrument.envelopes[envelopeIndex].perEnvelopeSpeed, "index"));
                this.updateSpeedDisplay(envelopeIndex);
                this.perEnvelopeLowerBoundBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].perEnvelopeLowerBound);
                this.perEnvelopeUpperBoundBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].perEnvelopeUpperBound);
                this.perEnvelopeLowerBoundSliders[envelopeIndex].updateValue(instrument.envelopes[envelopeIndex].perEnvelopeLowerBound);
                this.perEnvelopeUpperBoundSliders[envelopeIndex].updateValue(instrument.envelopes[envelopeIndex].perEnvelopeUpperBound);
                this.randomStepsBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].steps);
                this.randomSeedBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].seed);
                this._randomStepsSliders[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].steps);
                this._randomSeedSliders[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].seed);
                this.LFOStepsBoxes[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].steps);
                this._LFOStepsSliders[envelopeIndex].value = String(instrument.envelopes[envelopeIndex].steps);
                this.openExtraSettingsDropdowns[envelopeIndex] = this.openExtraSettingsDropdowns[envelopeIndex] ? true : false;
            }
            this._renderedEnvelopeCount = instrument.envelopeCount;
            this._renderedEqFilterCount = instrument.eqFilter.controlPointCount;
            this._renderedNoteFilterCount = useControlPointCount;
            this._renderedInstrumentType = instrument.type;
            this._renderedEffects = instrument.effects;
        }
    }

    class FadeInOutEditor {
        constructor(_doc) {
            this._doc = _doc;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._fadeCurve = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._dottedLinePath = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 1, "stroke-dasharray": "3, 2", "pointer-events": "none" });
            this._controlCurve = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 2, "pointer-events": "none" });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._fadeCurve, this._dottedLinePath, this._controlCurve);
            this.container = HTML.div({ class: "fadeInOut", style: "height: 100%;" }, this._svg);
            this._mouseX = 0;
            this._mouseXStart = 0;
            this._mouseDown = false;
            this._mouseDragging = false;
            this._draggingFadeIn = false;
            this._dragChange = null;
            this._renderedFadeIn = -1;
            this._renderedFadeOut = -1;
            this._whenMousePressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left);
                this._whenCursorPressed();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left);
                this._whenCursorPressed();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (this._mouseDown && this._doc.lastChangeWas(this._dragChange) && this._dragChange != null) {
                    if (!this._mouseDragging) {
                        const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                        if (this._draggingFadeIn) {
                            this._doc.record(new ChangeFadeInOut(this._doc, this._xToFadeIn(this._mouseX), instrument.fadeOut));
                        }
                        else {
                            this._doc.record(new ChangeFadeInOut(this._doc, instrument.fadeIn, this._xToFadeOut(this._mouseX)));
                        }
                    }
                    else {
                        this._doc.record(this._dragChange);
                    }
                }
                this._dragChange = null;
                this._mouseDragging = false;
                this._mouseDown = false;
            };
            const dottedLineX = this._fadeOutToX(Config.fadeOutNeutral);
            this._dottedLinePath.setAttribute("d", `M ${dottedLineX} 0 L ${dottedLineX} ${this._editorHeight}`);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _fadeInToX(fadeIn) {
            return 1.0 + (this._editorWidth - 2.0) * 0.4 * fadeIn / (Config.fadeInRange - 1);
        }
        _xToFadeIn(x) {
            return clamp(0, Config.fadeInRange, Math.round((x - 1.0) * (Config.fadeInRange - 1) / (0.4 * this._editorWidth - 2.0)));
        }
        _fadeOutToX(fadeOut) {
            return 1.0 + (this._editorWidth - 2.0) * (0.5 + 0.5 * fadeOut / (Config.fadeOutTicks.length - 1));
        }
        _xToFadeOut(x) {
            return clamp(0, Config.fadeOutTicks.length, Math.round((Config.fadeOutTicks.length - 1) * ((x - 1.0) / (this._editorWidth - 2.0) - 0.5) / 0.5));
        }
        _whenCursorPressed() {
            if (isNaN(this._mouseX))
                this._mouseX = 0;
            this._mouseXStart = this._mouseX;
            this._mouseDown = true;
            this._mouseDragging = false;
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const fadeInX = this._fadeInToX(instrument.fadeIn);
            const fadeOutX = this._fadeOutToX(instrument.fadeOut);
            this._draggingFadeIn = this._mouseXStart < (fadeInX + fadeOutX) / 2.0;
            this._dragChange = new ChangeSequence();
            this._doc.setProspectiveChange(this._dragChange);
        }
        _whenCursorMoved() {
            if (this._dragChange != null && this._doc.lastChangeWas(this._dragChange)) {
                this._dragChange.undo();
            }
            else {
                this._mouseDown = false;
            }
            this._dragChange = null;
            if (this._mouseDown) {
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._doc.setProspectiveChange(this._dragChange);
                if (Math.abs(this._mouseX - this._mouseXStart) > 4.0) {
                    this._mouseDragging = true;
                }
                if (this._mouseDragging) {
                    const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                    if (this._draggingFadeIn) {
                        sequence.append(new ChangeFadeInOut(this._doc, this._xToFadeIn(this._fadeInToX(instrument.fadeIn) + this._mouseX - this._mouseXStart), instrument.fadeOut));
                    }
                    else {
                        sequence.append(new ChangeFadeInOut(this._doc, instrument.fadeIn, this._xToFadeOut(this._fadeOutToX(instrument.fadeOut) + this._mouseX - this._mouseXStart)));
                    }
                }
            }
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            if (this._renderedFadeIn == instrument.fadeIn && this._renderedFadeOut == instrument.fadeOut) {
                return;
            }
            const fadeInX = this._fadeInToX(instrument.fadeIn);
            const fadeOutX = this._fadeOutToX(instrument.fadeOut);
            this._controlCurve.setAttribute("d", `M ${fadeInX} 0 L ${fadeInX} ${this._editorHeight} M ${fadeOutX} 0 L ${fadeOutX} ${this._editorHeight}`);
            const dottedLineX = this._fadeOutToX(Config.fadeOutNeutral);
            let fadePath = "";
            fadePath += `M 0 ${this._editorHeight} `;
            fadePath += `L ${fadeInX} 0 `;
            if (Synth.fadeOutSettingToTicks(instrument.fadeOut) > 0) {
                fadePath += `L ${dottedLineX} 0 `;
                fadePath += `L ${fadeOutX} ${this._editorHeight} `;
            }
            else {
                fadePath += `L ${fadeOutX} 0 `;
                fadePath += `L ${dottedLineX} ${this._editorHeight} `;
            }
            fadePath += "z";
            this._fadeCurve.setAttribute("d", fadePath);
        }
    }

    const { button: button$e, div: div$e, h2: h2$d, input: input$9 } = HTML;
    class LimiterCanvas {
        constructor(lim) {
            this._editorWidth = 200;
            this._editorHeight = 52;
            this._fill = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._ticks = SVG.svg({ "pointer-events": "none" });
            this._subticks = SVG.svg({ "pointer-events": "none" });
            this._boostCurve = SVG.path({ fill: "none", stroke: ColorConfig.textSelection, "stroke-width": 2, "pointer-events": "none" });
            this._boostDot = SVG.circle({ fill: ColorConfig.textSelection, stroke: "none", r: "3" });
            this._midCurve = SVG.path({ fill: "none", stroke: ColorConfig.primaryText, "stroke-width": 2, "pointer-events": "none" });
            this._limitCurve = SVG.path({ fill: "none", stroke: ColorConfig.linkAccent, "stroke-width": 2, "pointer-events": "none" });
            this._limitDot = SVG.circle({ fill: ColorConfig.linkAccent, stroke: "none", r: "3" });
            this._label0 = SVG.text({ x: "-1.5%", y: "148.5%", "pointer-events": "none", "font-size": "7pt", fill: "var(--secondary-text)" }, "0");
            this._label1 = SVG.text({ x: "48.2%", y: "148.5%", "pointer-events": "none", "font-size": "7pt", fill: "var(--secondary-text)" }, "1");
            this._label2 = SVG.text({ x: "98.2%", y: "148.5%", "pointer-events": "none", "font-size": "7pt", fill: "var(--secondary-text)" }, "2");
            this._inLabel = SVG.text({ x: "-5%", y: "113.5%", "pointer-events": "none", "font-size": "6pt", fill: "var(--secondary-text)" }, "In");
            this._outLabel = SVG.text({ x: "-9%", y: "131%", "pointer-events": "none", "font-size": "6pt", fill: "var(--secondary-text)" }, "Out");
            this._xAxisLabel = SVG.text({ x: "42%", y: "172%", "pointer-events": "none", "font-size": "7pt", fill: "var(--primary-text)" }, "Volume");
            this._yAxisLabel = SVG.text({ x: "55.2%", y: "160%", "pointer-events": "none", "font-size": "7pt", transform: "rotate(-90 30,120)", fill: "var(--primary-text)" }, "Gain");
            this._inVolumeBg = SVG.rect({ "pointer-events": "none", width: "100%", height: "6px", x: "0%", y: "105%", fill: ColorConfig.uiWidgetBackground });
            this._outVolumeBg = SVG.rect({ "pointer-events": "none", width: "100%", height: "6px", x: "0%", y: "120%", fill: ColorConfig.uiWidgetBackground });
            this._inVolumeBar = SVG.rect({ "pointer-events": "none", height: "6px", x: "0%", y: "105%", fill: "url('#volumeGrad')" });
            this._inVolumeCap = SVG.rect({ "pointer-events": "none", width: "2px", height: "6px", y: "105%", fill: ColorConfig.uiWidgetFocus });
            this._outVolumeBar = SVG.rect({ "pointer-events": "none", height: "6px", x: "0%", y: "120%", fill: "url('#volumeGrad')" });
            this._outVolumeCap = SVG.rect({ "pointer-events": "none", width: "2px", height: "6px", y: "120%", fill: ColorConfig.uiWidgetFocus });
            this._stop1 = SVG.stop({ "stop-color": "lime", offset: "30%" });
            this._stop2 = SVG.stop({ "stop-color": "orange", offset: "45%" });
            this._stop3 = SVG.stop({ "stop-color": "red", offset: "50%" });
            this._gradient = SVG.linearGradient({ id: "volumeGrad", gradientUnits: "userSpaceOnUse" }, this._stop1, this._stop2, this._stop3);
            this._defs = SVG.defs({}, this._gradient);
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; overflow: visible;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._defs, this._fill, this._ticks, this._subticks, this._boostCurve, this._midCurve, this._limitCurve, this._boostDot, this._limitDot, this._label0, this._label1, this._label2, this._inLabel, this._outLabel, this._xAxisLabel, this._yAxisLabel, this._inVolumeBg, this._outVolumeBg, this._inVolumeBar, this._outVolumeBar, this._inVolumeCap, this._outVolumeCap);
            this.container = HTML.div({ class: "", style: "height: 4em; width: 80%; padding-bottom: 1.5em;" }, this._svg);
            for (let i = 0; i <= 2; i++) {
                this._ticks.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i * this._editorWidth / 2) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 1; i <= 3; i += 2) {
                this._subticks.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i * this._editorWidth / 4) - 1, y: 0, width: 1, height: this._editorHeight }));
            }
            this._limiterPrompt = lim;
        }
        animateVolume(inVolumeCap, historicInCap, outVolumeCap, historicOutCap) {
            this._inVolumeBar.setAttribute("width", "" + Math.min(this._editorWidth, inVolumeCap * (this._editorWidth / 2.0)));
            this._inVolumeCap.setAttribute("x", "" + Math.min(this._editorWidth, historicInCap * (this._editorWidth / 2.0)));
            this._outVolumeBar.setAttribute("width", "" + Math.min(this._editorWidth, outVolumeCap * (this._editorWidth / 2.0)));
            this._outVolumeCap.setAttribute("x", "" + Math.min(this._editorWidth, historicOutCap * (this._editorWidth / 2.0)));
        }
        render() {
            const controlPointToHeight = (point) => {
                return Math.max(0, (1 - (point / 5)) * (this._editorHeight - 1) + 1);
            };
            let lastValue = 0;
            let currentSubpathIdx = 0;
            let lastSubpathIdx = -1;
            let path = "";
            let subPaths = ["", "", ""];
            for (let i = 0; i < 64; i++) {
                let limiterRatio = +this._limiterPrompt.limitRatioSlider.value;
                limiterRatio = (limiterRatio < 10 ? limiterRatio / 10 : (limiterRatio - 9));
                let compressorRatio = +this._limiterPrompt.compressionRatioSlider.value;
                compressorRatio = (compressorRatio < 10 ? compressorRatio / 10 : (1 + (compressorRatio - 10) / 60));
                let limiterThreshold = +this._limiterPrompt.limitThresholdSlider.value;
                let compressorThreshold = +this._limiterPrompt.compressionThresholdSlider.value;
                let useVol = i * 2.0 / 64.0;
                let nextValue = 1 / 1.05;
                if (useVol >= limiterThreshold) {
                    nextValue = 1 / (1.05 * (useVol + 1 - limiterThreshold) * limiterRatio + (1 - limiterRatio));
                }
                else if (useVol < compressorThreshold) {
                    nextValue = 1 / (((useVol + 1 - compressorThreshold) * 0.8 + 0.25) * compressorRatio + 1.05 * (1 - compressorRatio));
                }
                if (i == 0) {
                    path += "M 0 " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                }
                if (currentSubpathIdx > lastSubpathIdx) {
                    if (lastSubpathIdx >= 0) {
                        subPaths[lastSubpathIdx] += "L " + prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                    }
                    subPaths[currentSubpathIdx] += "M " + prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                    if (currentSubpathIdx == 1 || (lastSubpathIdx == 0 && currentSubpathIdx == 2)) {
                        this._boostDot.setAttribute("cx", prettyNumber(i * this._editorWidth / 64));
                        this._boostDot.setAttribute("cy", prettyNumber(controlPointToHeight(nextValue)));
                    }
                    if (currentSubpathIdx == 2) {
                        this._limitDot.setAttribute("cx", prettyNumber(i * this._editorWidth / 64));
                        this._limitDot.setAttribute("cy", prettyNumber(controlPointToHeight(nextValue)));
                    }
                    lastSubpathIdx = currentSubpathIdx;
                }
                if (lastValue != 0 || nextValue != 0) {
                    path += "L ";
                    subPaths[currentSubpathIdx] += "L ";
                }
                else {
                    path += "M ";
                    subPaths[currentSubpathIdx] += "M ";
                }
                path += prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                subPaths[currentSubpathIdx] += prettyNumber(i * this._editorWidth / 64) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                lastValue = nextValue;
                if (currentSubpathIdx == 0 && (i >= compressorThreshold * 32 - 2)) {
                    currentSubpathIdx++;
                }
                if (currentSubpathIdx == 1 && (i >= limiterThreshold * 32 - 2)) {
                    currentSubpathIdx++;
                }
            }
            const lastHeight = controlPointToHeight(lastValue);
            if (lastValue > 0) {
                path += "L " + (this._editorWidth - 1) + " " + prettyNumber(lastHeight) + " ";
                subPaths[currentSubpathIdx] += "L " + (this._editorWidth - 1) + " " + prettyNumber(lastHeight) + " ";
            }
            this._boostCurve.setAttribute("d", subPaths[0]);
            this._midCurve.setAttribute("d", subPaths[1]);
            this._limitCurve.setAttribute("d", subPaths[2]);
            this._fill.setAttribute("d", path + "L " + this._editorWidth + " " + prettyNumber(lastHeight) + " L " + this._editorWidth + " " + prettyNumber(this._editorHeight) + " L 0 " + prettyNumber(this._editorHeight) + " z ");
        }
    }
    class LimiterPrompt {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this.limiterCanvas = new LimiterCanvas(this);
            this._playButton = button$e({ style: "width: 55%;", type: "button" });
            this.limitDecaySlider = input$9({ title: "limit decay", style: `width: 5em; flex-grow: 1; margin: 0;`, type: "range", min: "1", max: "30", value: "4", step: "1" });
            this.limitRiseSlider = input$9({ title: "limit rise", style: `width: 5em; flex-grow: 1; margin: 0;`, type: "range", min: "2000", max: "10000", value: "4000", step: "250" });
            this.compressionThresholdSlider = input$9({ title: "compressor threshold", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "1.1", value: "1", step: "0.05" });
            this.limitThresholdSlider = input$9({ title: "limiter threshold", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "2", value: "1", step: "0.05" });
            this.compressionRatioSlider = input$9({ title: "compressor ratio", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "20", value: "10", step: "1" });
            this.limitRatioSlider = input$9({ title: "limiter ratio", style: `width: 100%; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "20", value: "10", step: "1" });
            this.masterGainSlider = input$9({ title: "master gain", style: `width: 5em; flex-grow: 1; margin: 0;`, type: "range", min: "0", max: "5", value: "1", step: "0.02" });
            this.inVolumeHistoricTimer = 0.0;
            this.inVolumeHistoricCap = 0.0;
            this.outVolumeHistoricTimer = 0.0;
            this.outVolumeHistoricCap = 0.0;
            this._cancelButton = button$e({ class: "cancelButton" });
            this._okayButton = button$e({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._resetButton = button$e({ style: "width:45%;" }, "Reset");
            this.container = div$e({ class: "prompt noSelection", style: "width: 250px;" }, h2$d("Limiter Options"), div$e({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), div$e({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center;" }, this.limiterCanvas.container), div$e({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; margin-top: 1.5em; justify-content: flex-end;" }, div$e({ style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${ColorConfig.primaryText};` }, ""), div$e({ style: `text-align: center; width: 33%; margin-right: 4.5%; color: ${ColorConfig.textSelection};` }, "Boost"), div$e({ style: `text-align: center; width: 33%; margin-right: 0%; color: ${ColorConfig.linkAccent};` }, "Cutoff")), div$e({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; margin-top: 0.5em; justify-content: flex-end;" }, div$e({ style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${ColorConfig.primaryText};` }, "Threshold:"), div$e({ style: `width: 33%; margin-right: 4.5%;` }, this.compressionThresholdSlider), div$e({ style: `width: 33%; margin-right: 0%;` }, this.limitThresholdSlider)), div$e({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$e({ style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${ColorConfig.primaryText};` }, "Ratio:"), div$e({ style: `width: 33%; margin-right: 4.5%;` }, this.compressionRatioSlider), div$e({ style: `width: 33%; margin-right: 0%;` }, this.limitRatioSlider)), div$e({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$e({ style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${ColorConfig.primaryText};` }, "Limit Decay:"), this.limitDecaySlider), div$e({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$e({ style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${ColorConfig.primaryText};` }, "Limit Rise:"), this.limitRiseSlider), div$e({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$e({ style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${ColorConfig.primaryText};` }, "Master Gain:"), this.masterGainSlider), div$e({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this._resetButton), this._cancelButton);
            this._volumeUpdate = () => {
                this.inVolumeHistoricTimer--;
                if (this.inVolumeHistoricTimer <= 0) {
                    this.inVolumeHistoricCap -= 0.03;
                }
                if (this._doc.song.inVolumeCap > this.inVolumeHistoricCap) {
                    this.inVolumeHistoricCap = this._doc.song.inVolumeCap;
                    this.inVolumeHistoricTimer = 50;
                }
                this.outVolumeHistoricTimer--;
                if (this.outVolumeHistoricTimer <= 0) {
                    this.outVolumeHistoricCap -= 0.03;
                }
                if (this._doc.song.outVolumeCap > this.outVolumeHistoricCap) {
                    this.outVolumeHistoricCap = this._doc.song.outVolumeCap;
                    this.outVolumeHistoricTimer = 50;
                }
                this.limiterCanvas.animateVolume(this._doc.song.inVolumeCap, this.inVolumeHistoricCap, this._doc.song.outVolumeCap, this.outVolumeHistoricCap);
                window.requestAnimationFrame(this._volumeUpdate);
            };
            this._togglePlay = () => {
                this._songEditor.togglePlay();
                this.updatePlayButton();
            };
            this._whenInput = () => {
                if (+this.limitThresholdSlider.value < +this.compressionThresholdSlider.value) {
                    this.limitThresholdSlider.removeEventListener("input", this._whenInputFavorLimitThreshold);
                    this.limitThresholdSlider.value = this.compressionThresholdSlider.value;
                    this.limitThresholdSlider.addEventListener("input", this._whenInputFavorLimitThreshold);
                }
                this.limiterCanvas.render();
                this._updateLimiter();
            };
            this._whenInputFavorLimitThreshold = () => {
                if (+this.limitThresholdSlider.value < +this.compressionThresholdSlider.value) {
                    this.compressionThresholdSlider.removeEventListener("input", this._whenInput);
                    this.compressionThresholdSlider.value = this.limitThresholdSlider.value;
                    this.compressionThresholdSlider.addEventListener("input", this._whenInput);
                }
                this.limiterCanvas.render();
                this._updateLimiter();
            };
            this._close = () => {
                this.limitRatioSlider.value = "" + this.startingLimitRatio;
                this.compressionRatioSlider.value = "" + this.startingCompressionRatio;
                this.limitThresholdSlider.value = "" + this.startingLimitThreshold;
                this.compressionThresholdSlider.value = "" + this.startingCompressionThreshold;
                this.limitDecaySlider.value = "" + this.startingLimitDecay;
                this.limitRiseSlider.value = "" + this.startingLimitRise;
                this.masterGainSlider.value = "" + this.startingMasterGain;
                this._updateLimiter();
                this._doc.prompt = null;
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._resetButton.removeEventListener("click", this._resetDefaults);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this.limitDecaySlider.removeEventListener("input", this._whenInput);
                this.limitRiseSlider.removeEventListener("input", this._whenInput);
                this.limitThresholdSlider.removeEventListener("input", this._whenInputFavorLimitThreshold);
                this.limitRatioSlider.removeEventListener("input", this._whenInput);
                this.compressionRatioSlider.removeEventListener("input", this._whenInput);
                this.compressionThresholdSlider.removeEventListener("input", this._whenInput);
                this.masterGainSlider.removeEventListener("input", this._whenInput);
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
            };
            this._resetDefaults = () => {
                if (this.limitRatioSlider.value != "10" || this.limitRiseSlider.value != "4000" || this.limitDecaySlider.value != "4" || this.limitThresholdSlider.value != "1" || this.compressionRatioSlider.value != "10" || this.compressionThresholdSlider.value != "1" || this.masterGainSlider.value != "1") {
                    this.limitRatioSlider.value = "10";
                    this.limitRiseSlider.value = "4000";
                    this.limitDecaySlider.value = "4";
                    this.limitThresholdSlider.value = "1";
                    this.compressionRatioSlider.value = "10";
                    this.compressionThresholdSlider.value = "1";
                    this.masterGainSlider.value = "1";
                    this._whenInput();
                }
            };
            this._updateLimiter = () => {
                this._doc.record(new ChangeLimiterSettings(this._doc, (+this.limitRatioSlider.value < 10 ? +this.limitRatioSlider.value / 10 : (+this.limitRatioSlider.value - 9)), (+this.compressionRatioSlider.value < 10 ? +this.compressionRatioSlider.value / 10 : (1 + (+this.compressionRatioSlider.value - 10) / 60)), +this.limitThresholdSlider.value, +this.compressionThresholdSlider.value, +this.limitRiseSlider.value, +this.limitDecaySlider.value, +this.masterGainSlider.value), true);
            };
            this._saveChanges = () => {
                this._updateLimiter();
                this._doc.prompt = null;
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._resetButton.addEventListener("click", this._resetDefaults);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this.whenKeyPressed);
            this.limitRatioSlider.value = "" + (this._doc.song.limitRatio < 1 ? this._doc.song.limitRatio * 10 : 9 + this._doc.song.limitRatio);
            this.compressionRatioSlider.value = "" + (this._doc.song.compressionRatio < 1 ? this._doc.song.compressionRatio * 10 : 10 + (this._doc.song.compressionRatio - 1) * 60);
            this.limitThresholdSlider.value = "" + this._doc.song.limitThreshold;
            this.compressionThresholdSlider.value = "" + this._doc.song.compressionThreshold;
            this.limitDecaySlider.value = "" + this._doc.song.limitDecay;
            this.limitRiseSlider.value = "" + this._doc.song.limitRise;
            this.masterGainSlider.value = "" + this._doc.song.masterGain;
            this.startingLimitRatio = +this.limitRatioSlider.value;
            this.startingCompressionRatio = +this.compressionRatioSlider.value;
            this.startingLimitThreshold = +this.limitThresholdSlider.value;
            this.startingCompressionThreshold = +this.compressionThresholdSlider.value;
            this.startingLimitDecay = +this.limitDecaySlider.value;
            this.startingLimitRise = +this.limitRiseSlider.value;
            this.startingMasterGain = +this.masterGainSlider.value;
            this.limitDecaySlider.addEventListener("input", this._whenInput);
            this.limitRiseSlider.addEventListener("input", this._whenInput);
            this.limitRatioSlider.addEventListener("input", this._whenInput);
            this.limitThresholdSlider.addEventListener("input", this._whenInputFavorLimitThreshold);
            this.compressionRatioSlider.addEventListener("input", this._whenInput);
            this.compressionThresholdSlider.addEventListener("input", this._whenInput);
            this.masterGainSlider.addEventListener("input", this._whenInput);
            this._playButton.addEventListener("click", this._togglePlay);
            window.requestAnimationFrame(this._volumeUpdate);
            this.updatePlayButton();
            setTimeout(() => this._playButton.focus());
            this.limiterCanvas.render();
        }
        updatePlayButton() {
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            }
        }
    }

    const { button: button$d, div: div$d, h2: h2$c, input: input$8, p: p$5 } = HTML;
    class CustomScalePrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._flags = [];
            this._scaleFlags = [];
            this._scaleRows = [];
            this._cancelButton = button$d({ class: "cancelButton" });
            this._okayButton = button$d({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                for (var i = 1; i < this._scaleFlags.length; i++) {
                    this._flags[i] = this._scaleFlags[i].checked;
                }
                this._doc.prompt = null;
                this._doc.record(new ChangeCustomScale(this._doc, this._flags));
            };
            this._flags = _doc.song.scaleCustom.slice();
            let scaleHolder = div$d({});
            for (var i = 1; i < Config.pitchesPerOctave; i++) {
                this._scaleFlags[i] = input$8({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;", "checked": this._flags[i], "value": i });
                this._scaleRows[i] = div$d({ style: "text-align: right; height: 2em;" }, "Note " + i + ":", this._scaleFlags[i]);
                scaleHolder.appendChild(this._scaleRows[i]);
            }
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container = div$d({ class: "prompt noSelection", style: "width: 250px;" }, h2$c("Custom Scale"), p$5("Here, you can make your own scale to use in your song. Press the checkboxes below to toggle which notes of an octave are in the scale. For this to work, you'll need to have the \"Custom\" scale selected."), div$d({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;" }, scaleHolder), div$d({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this.container.addEventListener("keydown", this.whenKeyPressed);
        }
    }

    class LoopEditor {   
        constructor(_doc, _trackEditor) {
            this._doc = _doc; 
            this._trackEditor = _trackEditor;
            this._editorHeight = 20;
            this._startMode = 0; 
            this._endMode = 1;
            this._bothMode = 2;
            this._loopMode = 3;
            this._loopAtPointStart = -1;
            this._loopAtPointEnd = -1;
            this._loop = SVG.path({ fill: "none", stroke: ColorConfig.loopAccent, "stroke-width": 4 });
            this._barLoop = SVG.path({ fill: "none", stroke: ColorConfig.uiWidgetFocus, "stroke-width": 2 });
            this._highlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._svg = SVG.svg({ style: `touch-action: pan-y; position: absolute;`, height: this._editorHeight }, this._loop, this._highlight, this._barLoop);
            this.container = HTML.div({ class: "loopEditor" }, this._svg);
            this._barWidth = 32;
            this._change = null;
            this._cursor = { startBar: -1, mode: -1 };
            this._mouseX = 0;
            this._clientStartX = 0;
            this._clientStartY = 0;
            this._startedScrolling = false;
            this._draggingHorizontally = false;
            this._mouseDown = false;
            this._mouseOver = false;
            this._renderedLoopStart = -1;
            this._renderedLoopStop = -1;
            this._renderedBarCount = 0;
            this._renderedBarWidth = -1;
            this._renderedBarLoopStart = -1;
            this._renderedBarLoopEnd = -1;
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._updatePreview();
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
                this._updatePreview();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
                this._updateCursorStatus();
                this._updatePreview();
                this._whenMouseMoved(event);
            };
            this._whenTouchPressed = (event) => {
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = event.touches[0].clientX - boundingRect.left;
                this._updateCursorStatus();
                this._updatePreview();
                this._clientStartX = event.touches[0].clientX;
                this._clientStartY = event.touches[0].clientY;
                this._draggingHorizontally = false;
                this._startedScrolling = false;
            };
            this._whenMouseMoved = (event) => {
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = event.touches[0].clientX - boundingRect.left;
                if (!this._draggingHorizontally && !this._startedScrolling) {
                    if (Math.abs(event.touches[0].clientY - this._clientStartY) > 10) {
                        this._startedScrolling = true;
                    }
                    else if (Math.abs(event.touches[0].clientX - this._clientStartX) > 10) {
                        this._draggingHorizontally = true;
                    }
                }
                if (this._draggingHorizontally) {
                    this._whenCursorMoved();
                    event.preventDefault();
                }
            };
            this._whenTouchReleased = (event) => {
                event.preventDefault();
                if (!this._startedScrolling) {
                    this._whenCursorMoved();
                    this._mouseOver = false;
                    this._whenCursorReleased(event);
                    this._updatePreview();
                }
                this._mouseDown = false;
            };
            this._whenCursorReleased = (event) => {
                if (this._change != null)
                    this._doc.record(this._change);
                this._change = null;
                this._mouseDown = false;
                this._updateCursorStatus();
                this._render();
            };
            this._documentChanged = () => {
                this._render();
            };
            this._updateCursorStatus();
            this._render();
            this._doc.notifier.watch(this._documentChanged);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenTouchReleased);
            this.container.addEventListener("touchcancel", this._whenTouchReleased);
        }
        _updateCursorStatus() {
            const bar = this._mouseX / this._barWidth;
            this._cursor.startBar = bar;
            if (bar >= this._loopAtPointStart && bar <= this._loopAtPointEnd + 1) {
                this._cursor.mode = this._loopMode;
            }
            else if (bar > this._doc.song.loopStart - 0.25 && bar < this._doc.song.loopStart + this._doc.song.loopLength + 0.25) {
                if (bar - this._doc.song.loopStart < this._doc.song.loopLength * 0.5) {
                    this._cursor.mode = this._startMode;
                }
                else {
                    this._cursor.mode = this._endMode;
                }
            }
            else {
                this._cursor.mode = this._bothMode;
            }
        }
        _findEndPoints(middle) {
            let start = Math.round(middle - this._doc.song.loopLength / 2);
            let end = start + this._doc.song.loopLength;
            if (start < 0) {
                end -= start;
                start = 0;
            }
            if (end > this._doc.song.barCount) {
                start -= end - this._doc.song.barCount;
                end = this._doc.song.barCount;
            }
            return { start: start, length: end - start };
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                let oldStart = this._doc.song.loopStart;
                let oldEnd = this._doc.song.loopStart + this._doc.song.loopLength;
                if (this._change != null && this._doc.lastChangeWas(this._change)) {
                    oldStart = this._change.oldStart;
                    oldEnd = oldStart + this._change.oldLength;
                }
                const bar = this._mouseX / this._barWidth;
                let start;
                let end;
                let temp;
                if (this._cursor.mode == this._startMode) {
                    start = oldStart + Math.round(bar - this._cursor.startBar);
                    end = oldEnd;
                    if (start < 0)
                        start = 0;
                    if (start >= this._doc.song.barCount)
                        start = this._doc.song.barCount;
                    if (start == end) {
                        start = end - 1;
                    }
                    else if (start > end) {
                        temp = start;
                        start = end;
                        end = temp;
                    }
                    this._change = new ChangeLoop(this._doc, oldStart, oldEnd - oldStart, start, end - start);
                }
                else if (this._cursor.mode == this._endMode) {
                    start = oldStart;
                    end = oldEnd + Math.round(bar - this._cursor.startBar);
                    if (end < 0)
                        end = 0;
                    if (end >= this._doc.song.barCount)
                        end = this._doc.song.barCount;
                    if (end == start) {
                        end = start + 1;
                    }
                    else if (end < start) {
                        temp = start;
                        start = end;
                        end = temp;
                    }
                    this._change = new ChangeLoop(this._doc, oldStart, oldEnd - oldStart, start, end - start);
                }
                else if (this._cursor.mode == this._bothMode) {
                    const endPoints = this._findEndPoints(bar);
                    this._change = new ChangeLoop(this._doc, oldStart, oldEnd - oldStart, endPoints.start, endPoints.length);
                }
                else if (this._cursor.mode == this._loopMode) {
                    this._doc.synth.loopBarStart = -1;
                    this._doc.synth.loopBarEnd = -1;
                    this.setLoopAt(this._doc.synth.loopBarStart, this._doc.synth.loopBarEnd);
                }
                this._doc.synth.jumpIntoLoop();
                if (this._doc.prefs.autoFollow) {
                    new ChangeChannelBar(this._doc, this._doc.channel, Math.floor(this._doc.synth.playhead), true);
                }
                this._doc.setProspectiveChange(this._change);
            }
            else {
                this._updateCursorStatus();
                this._updatePreview();
            }
        }
        _updatePreview() {
            const showHighlight = this._mouseOver && !this._mouseDown;
            this._highlight.style.visibility = showHighlight ? "visible" : "hidden";
            if (showHighlight) {
                const radius = this._editorHeight / 2;
                let highlightStart = (this._doc.song.loopStart) * this._barWidth;
                let highlightStop = (this._doc.song.loopStart + this._doc.song.loopLength) * this._barWidth;
                if (this._cursor.mode == this._startMode) {
                    highlightStop = (this._doc.song.loopStart) * this._barWidth + radius * 2;
                }
                else if (this._cursor.mode == this._endMode) {
                    highlightStart = (this._doc.song.loopStart + this._doc.song.loopLength) * this._barWidth - radius * 2;
                } 
                else if (this._cursor.mode == this._bothMode) {
                    const endPoints = this._findEndPoints(this._cursor.startBar);
                    highlightStart = (endPoints.start) * this._barWidth;
                    highlightStop = (endPoints.start + endPoints.length) * this._barWidth;
                }
                if (this._cursor.mode == this._loopMode) {
                    const barLoopStart = (this._loopAtPointStart + 0.5) * this._barWidth;
                    const barLoopEnd = (this._loopAtPointEnd + 0.5) * this._barWidth;
                    this._highlight.setAttribute("d", `M ${barLoopStart} ${radius * 1.7} ` +
                        `L ${barLoopStart - radius * 1.5} ${radius}` +
                        `L ${barLoopStart} ${radius * 0.3}` +
                        `L ${barLoopEnd} ${radius * 0.3}` +
                        `L ${barLoopEnd + radius * 1.5} ${radius}` +
                        `L ${barLoopEnd} ${radius * 1.7}` +
                        `z`);
                }
                else {
                    this._highlight.setAttribute("d", `M ${highlightStart + radius} ${4} ` +
                        `L ${highlightStop - radius} ${4} ` +
                        `A ${radius - 4} ${radius - 4} ${0} ${0} ${1} ${highlightStop - radius} ${this._editorHeight - 4} ` +
                        `L ${highlightStart + radius} ${this._editorHeight - 4} ` +
                        `A ${radius - 4} ${radius - 4} ${0} ${0} ${1} ${highlightStart + radius} ${4} ` +
                        `z`);
                }
            }
        }
        setLoopAt(startBar, endBar) {
            this._loopAtPointStart = startBar;
            this._loopAtPointEnd = endBar;
            this._trackEditor.render();
            this._render();
        }
        _render() {
            this._barWidth = this._doc.getBarWidth();
            const radius = this._editorHeight / 2;
            const loopStart = (this._doc.song.loopStart) * this._barWidth;
            const loopStop = (this._doc.song.loopStart + this._doc.song.loopLength) * this._barWidth;
            if (this._renderedBarCount != this._doc.song.barCount || this._renderedBarWidth != this._barWidth) {
                this._renderedBarCount = this._doc.song.barCount;
                this._renderedBarWidth = this._barWidth;
                const editorWidth = this._barWidth * this._doc.song.barCount;
                this.container.style.width = editorWidth + "px";
                this._svg.setAttribute("width", editorWidth + "");
            }
            if (this._renderedLoopStart != loopStart || this._renderedLoopStop != loopStop) {
                this._renderedLoopStart = loopStart;
                this._renderedLoopStop = loopStop;
                this._loop.setAttribute("d", `M ${loopStart + radius} ${2} ` +
                    `L ${loopStop - radius} ${2} ` +
                    `A ${radius - 2} ${radius - 2} ${0} ${0} ${1} ${loopStop - radius} ${this._editorHeight - 2} ` +
                    `L ${loopStart + radius} ${this._editorHeight - 2} ` +
                    `A ${radius - 2} ${radius - 2} ${0} ${0} ${1} ${loopStart + radius} ${2} ` +
                    `z`);
            }
            const barLoopStart = (this._loopAtPointStart + 0.5) * this._barWidth;
            const barLoopEnd = (this._loopAtPointEnd + 0.5) * this._barWidth;
            if (this._renderedBarLoopStart != barLoopStart || this._renderedBarLoopEnd != barLoopEnd) {
                if (barLoopStart < 0 || barLoopEnd < 0) {
                    this._barLoop.setAttribute("d", "");
                }
                else {
                    this._barLoop.setAttribute("d", `M ${barLoopStart} ${radius * 1.5} ` +
                        `L ${barLoopStart - radius} ${radius}` +
                        `L ${barLoopStart} ${radius * 0.5}` +
                        `L ${barLoopEnd} ${radius * 0.5}` +
                        `L ${barLoopEnd + radius} ${radius}` +
                        `L ${barLoopEnd} ${radius * 1.5}` +
                        `z`);
                }
                this._renderedBarLoopStart = barLoopStart;
                this._renderedBarLoopEnd = barLoopEnd;
            }
            this._updatePreview();
        }
    }

    const { button: button$c, div: div$c, span: span$4, h2: h2$b, input: input$7, br: br$1, select: select$9, option: option$9 } = HTML;
    class MoveNotesSidewaysPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._beatsStepper = input$7({ style: "width: 3em; margin-left: 1em;", type: "number", step: "0.01", value: "0" });
            this._conversionStrategySelect = select$9({ style: "width: 100%;" }, option$9({ value: "overflow" }, "Overflow notes across bars."), option$9({ value: "wrapAround" }, "Wrap notes around within bars."));
            this._cancelButton = button$c({ class: "cancelButton" });
            this._okayButton = button$c({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$c({ class: "prompt noSelection", style: "width: 250px;" }, h2$b("Move Notes Sideways"), div$c({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$c({ style: "text-align: right;" }, "Beats to move:", br$1(), span$4({ style: `font-size: smaller; color: ${ColorConfig.secondaryText};` }, "(Negative is left, positive is right)")), this._beatsStepper), div$c({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$c({ class: "selectContainer", style: "width: 100%;" }, this._conversionStrategySelect)), div$c({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._beatsStepper.removeEventListener("blur", MoveNotesSidewaysPrompt._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("moveNotesSidewaysStrategy", this._conversionStrategySelect.value);
                this._doc.prompt = null;
                this._doc.record(new ChangeMoveNotesSideways(this._doc, +this._beatsStepper.value, this._conversionStrategySelect.value), true);
            };
            this._beatsStepper.min = (-this._doc.song.beatsPerBar) + "";
            this._beatsStepper.max = this._doc.song.beatsPerBar + "";
            const lastStrategy = window.localStorage.getItem("moveNotesSidewaysStrategy");
            if (lastStrategy != null) {
                this._conversionStrategySelect.value = lastStrategy;
            }
            this._beatsStepper.select();
            setTimeout(() => this._beatsStepper.focus(), 100);
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._beatsStepper.addEventListener("blur", MoveNotesSidewaysPrompt._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
        static _validateNumber(event) {
            const input = event.target;
            let value = +input.value;
            value = Math.round(value * Config.partsPerBeat) / Config.partsPerBeat;
            value = Math.round(value * 100) / 100;
            input.value = Math.max(+input.min, Math.min(+input.max, value)) + "";
        }
    }

    class MuteEditor {
        constructor(_doc, _editor) {
            this._doc = _doc;
            this._editor = _editor;
            this._cornerFiller = HTML.div({ style: `background: ${ColorConfig.editorBackground}; position: absolute; bottom: -4px; left: 0px; width: 32px; height: 32px;` });
            this._buttons = [];
            this._channelCounts = [];
            this._channelNameDisplay = HTML.div({ style: `background-color: ${ColorConfig.uiWidgetFocus}; white-space:nowrap; display: none; transform:translate(20px); width: auto; pointer-events: none; position: absolute; border-radius: 0.2em; z-index: 2;`, "color": ColorConfig.primaryText }, "");
            this._channelNameInput = new InputBox(HTML.input({ style: `color: ${ColorConfig.primaryText}; background-color: ${ColorConfig.uiWidgetFocus}; margin-top: -2px; display: none; width: 6em; position: absolute; border-radius: 0.2em; z-index: 2;`, "color": ColorConfig.primaryText }, ""), this._doc, (oldValue, newValue) => new ChangeChannelName(this._doc, oldValue, newValue));
            this._channelDropDown = HTML.select({ style: "width: 0px; left: 19px; height: 19px; position:absolute; opacity:0" }, HTML.option({ value: "rename" }, "Rename..."), HTML.option({ value: "chnUp" }, "Move Channel Up"), HTML.option({ value: "chnDown" }, "Move Channel Down"), HTML.option({ value: "chnMute" }, "Mute Channel"), HTML.option({ value: "chnSolo" }, "Solo Channel"), HTML.option({ value: "chnInsert" }, "Insert Channel Below"), HTML.option({ value: "chnDelete" }, "Delete This Channel"));
            this.container = HTML.div({ class: "muteEditor", style: "position: sticky; padding-top: " + Config.barEditorHeight + "px;" }, this._channelNameDisplay, this._channelNameInput.input, this._channelDropDown);
            this._editorHeight = 128;
            this._renderedPitchChannels = 0;
            this._renderedNoiseChannels = 0;
            this._renderedChannelHeight = -1;
            this._renderedModChannels = 0;
            this._channelDropDownChannel = 0;
            this._channelDropDownOpen = false;
            this._channelDropDownLastState = false;
            this._channelNameInputWhenInput = () => {
                let newValue = this._channelNameInput.input.value;
                if (newValue.length > 15) {
                    this._channelNameInput.input.value = newValue.substring(0, 15);
                }
            };
            this._channelNameInputClicked = (event) => {
                event.stopPropagation();
            };
            this._channelNameInputHide = () => {
                this._channelNameInput.input.style.setProperty("display", "none");
                this._channelNameDisplay.style.setProperty("display", "none");
            };
            this._channelDropDownClick = (event) => {
                this._channelDropDownOpen = !this._channelDropDownLastState;
                this._channelDropDownGetOpenedPosition(event);
            };
            this._channelDropDownBlur = () => {
                this._channelDropDownOpen = false;
                this._channelNameDisplay.style.setProperty("display", "none");
            };
            this._channelDropDownGetOpenedPosition = (event) => {
                this._channelDropDownLastState = this._channelDropDownOpen;
                this._channelDropDownChannel = Math.floor(Math.min(this._buttons.length, Math.max(0, parseInt(this._channelDropDown.style.getPropertyValue("top")) / ChannelRow.patternHeight)));
                this._doc.muteEditorChannel = this._channelDropDownChannel;
                this._channelNameDisplay.style.setProperty("display", "");
                if ((this._channelDropDownChannel < this._doc.song.pitchChannelCount && this._doc.song.pitchChannelCount == Config.pitchChannelCountMax)
                    || (this._channelDropDownChannel >= this._doc.song.pitchChannelCount && this._channelDropDownChannel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount && this._doc.song.noiseChannelCount == Config.noiseChannelCountMax)
                    || (this._channelDropDownChannel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount && this._doc.song.modChannelCount == Config.modChannelCountMax)) {
                    this._channelDropDown.options[5].disabled = true;
                }
                else {
                    this._channelDropDown.options[5].disabled = false;
                }
                if (this._channelDropDownChannel == 0 || this._channelDropDownChannel == this._doc.song.pitchChannelCount || this._channelDropDownChannel == this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                    this._channelDropDown.options[1].disabled = true;
                }
                else {
                    this._channelDropDown.options[1].disabled = false;
                }
                if (this._channelDropDownChannel == this._doc.song.pitchChannelCount - 1 || this._channelDropDownChannel == this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount - 1 || this._channelDropDownChannel == this._doc.song.getChannelCount() - 1) {
                    this._channelDropDown.options[2].disabled = true;
                }
                else {
                    this._channelDropDown.options[2].disabled = false;
                }
                if (this._doc.song.pitchChannelCount == 1 && this._channelDropDownChannel == 0) {
                    this._channelDropDown.options[6].disabled = true;
                }
                else {
                    this._channelDropDown.options[6].disabled = false;
                }
            };
            this._channelDropDownHandler = (event) => {
                this._channelNameDisplay.style.setProperty("display", "none");
                this._channelDropDown.style.setProperty("display", "none");
                this._channelDropDownOpen = false;
                event.stopPropagation();
                switch (this._channelDropDown.value) {
                    case "rename":
                        this._channelNameInput.input.style.setProperty("display", "");
                        this._channelNameInput.input.style.setProperty("transform", this._channelNameDisplay.style.getPropertyValue("transform"));
                        if (this._channelNameDisplay.textContent != null) {
                            this._channelNameInput.input.value = this._channelNameDisplay.textContent;
                        }
                        else {
                            this._channelNameInput.input.value = "";
                        }
                        this._channelNameInput.input.select();
                        break;
                    case "chnUp":
                        this._doc.record(new ChangeChannelOrder(this._doc, this._channelDropDownChannel, this._channelDropDownChannel, -1));
                        break;
                    case "chnDown":
                        this._doc.record(new ChangeChannelOrder(this._doc, this._channelDropDownChannel, this._channelDropDownChannel, 1));
                        break;
                    case "chnMute":
                        this._doc.song.channels[this._channelDropDownChannel].muted = !this._doc.song.channels[this._channelDropDownChannel].muted;
                        this.render();
                        break;
                    case "chnSolo": {
                        let shouldSolo = false;
                        for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                            if (this._doc.song.channels[channel].muted == (channel == this._channelDropDownChannel)) {
                                shouldSolo = true;
                                channel = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount;
                            }
                        }
                        if (shouldSolo) {
                            for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                                this._doc.song.channels[channel].muted = (channel != this._channelDropDownChannel);
                            }
                        }
                        else {
                            for (let channel = 0; channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channel++) {
                                this._doc.song.channels[channel].muted = false;
                            }
                        }
                        this.render();
                        break;
                    }
                    case "chnInsert": {
                        this._doc.channel = this._channelDropDownChannel;
                        this._doc.selection.resetBoxSelection();
                        this._doc.selection.insertChannel();
                        break;
                    }
                    case "chnDelete": {
                        this._doc.record(new ChangeRemoveChannel(this._doc, this._channelDropDownChannel, this._channelDropDownChannel));
                        break;
                    }
                }
                if (this._channelDropDown.value != "rename")
                    this._editor.refocusStage();
                this._channelDropDown.selectedIndex = -1;
            };
            this._onClick = (event) => {
                const index = this._buttons.indexOf(event.target);
                if (index == -1)
                    return;
                let xPos = event.clientX - this._buttons[0].getBoundingClientRect().left;
                if (xPos < 21.0) {
                    this._doc.song.channels[index].muted = !this._doc.song.channels[index].muted;
                }
                this._doc.notifier.changed();
            };
            this._onMouseMove = (event) => {
                const index = this._buttons.indexOf(event.target);
                if (index == -1) {
                    if (!this._channelDropDownOpen && event.target != this._channelNameDisplay && event.target != this._channelDropDown) {
                        this._channelNameDisplay.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("width", "0px");
                    }
                    return;
                }
                if (this._channelDropDownOpen && this._channelNameDisplay.style.getPropertyValue("display") == "none" && this._channelNameInput.input.style.getPropertyValue("display") == "none") {
                    this._channelDropDownOpen = false;
                }
                let xPos = event.clientX - this._buttons[0].getBoundingClientRect().left;
                if (xPos >= 21.0) {
                    if (!this._channelDropDownOpen) {
                        this._channelDropDown.style.setProperty("display", "");
                        var height = ChannelRow.patternHeight;
                        this._channelNameDisplay.style.setProperty("transform", "translate(20px, " + (height / 4 + height * index) + "px)");
                        if (this._doc.song.channels[index].name != "") {
                            this._channelNameDisplay.textContent = this._doc.song.channels[index].name;
                            this._channelNameDisplay.style.setProperty("display", "");
                        }
                        else {
                            if (index < this._doc.song.pitchChannelCount) {
                                this._channelNameDisplay.textContent = "Pitch " + (index + 1);
                            }
                            else if (index < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                                this._channelNameDisplay.textContent = "Noise " + (index - this._doc.song.pitchChannelCount + 1);
                            }
                            else {
                                this._channelNameDisplay.textContent = "Mod " + (index - this._doc.song.pitchChannelCount - this._doc.song.noiseChannelCount + 1);
                            }
                            this._channelNameDisplay.style.setProperty("display", "none");
                        }
                        this._channelDropDown.style.top = (Config.barEditorHeight + 2 + index * ChannelRow.patternHeight) + "px";
                        this._channelDropDown.style.setProperty("width", "15px");
                    }
                }
                else {
                    if (!this._channelDropDownOpen) {
                        this._channelNameDisplay.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("display", "none");
                        this._channelDropDown.style.setProperty("width", "0px");
                    }
                }
            };
            this._onMouseLeave = (event) => {
                if (!this._channelDropDownOpen) {
                    this._channelNameDisplay.style.setProperty("display", "none");
                    this._channelDropDown.style.setProperty("width", "0px");
                }
            };
            this.container.addEventListener("click", this._onClick);
            this.container.addEventListener("mousemove", this._onMouseMove);
            this.container.addEventListener("mouseleave", this._onMouseLeave);
            this._channelDropDown.selectedIndex = -1;
            this._channelDropDown.addEventListener("change", this._channelDropDownHandler);
            this._channelDropDown.addEventListener("mousedown", this._channelDropDownGetOpenedPosition);
            this._channelDropDown.addEventListener("blur", this._channelDropDownBlur);
            this._channelDropDown.addEventListener("click", this._channelDropDownClick);
            this._channelNameInput.input.addEventListener("change", this._channelNameInputHide);
            this._channelNameInput.input.addEventListener("blur", this._channelNameInputHide);
            this._channelNameInput.input.addEventListener("mousedown", this._channelNameInputClicked);
            this._channelNameInput.input.addEventListener("input", this._channelNameInputWhenInput);
        }
        onKeyUp(event) {
            switch (event.keyCode) {
                case 27:
                case 13:
                    this._channelDropDownOpen = false;
                    this._channelNameDisplay.style.setProperty("display", "none");
                    break;
            }
        }
        render() {
            if (!this._doc.prefs.enableChannelMuting)
                return;
            let startingChannelCount = this._buttons.length;
            if (this._buttons.length != this._doc.song.getChannelCount()) {
                for (let y = this._buttons.length; y < this._doc.song.getChannelCount(); y++) {
                    const channelCountText = HTML.div({ class: "noSelection muteButtonText", style: "display: table-cell; -webkit-text-stroke: 1.5px; vertical-align: middle; text-align: center; -webkit-user-select: none; -webkit-touch-callout: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none; width: 12px; height: 20px; transform: translate(0px, 1px);" });
                    const muteButton = HTML.div({ class: "mute-button", title: "Mute (M), Mute All (M), Solo (S), Exclude (S)", style: `display: block; pointer-events: none; width: 16px; height: 20px; transform: translate(2px, 1px);` });
                    const muteContainer = HTML.div({ style: `align-items: center; height: 20px; margin: 0px; display: table; flex-direction: row; justify-content: space-between;` }, [
                        muteButton,
                        channelCountText,
                    ]);
                    this.container.appendChild(muteContainer);
                    this._buttons[y] = muteContainer;
                    this._channelCounts[y] = channelCountText;
                }
                for (let y = this._doc.song.getChannelCount(); y < this._buttons.length; y++) {
                    this.container.removeChild(this._buttons[y]);
                }
                this._buttons.length = this._doc.song.getChannelCount();
                this.container.appendChild(this._cornerFiller);
            }
            for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                if (this._doc.song.channels[y].muted) {
                    this._buttons[y].children[0].classList.add("muted");
                    if (y < this._doc.song.pitchChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgPitchDim;
                    else if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgNoiseDim;
                    else
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgModDim;
                }
                else {
                    this._buttons[y].children[0].classList.remove("muted");
                    if (y < this._doc.song.pitchChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgPitch;
                    else if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount)
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgNoise;
                    else
                        this._channelCounts[y].style.color = ColorConfig.trackEditorBgMod;
                }
            }
            if (this._renderedChannelHeight != ChannelRow.patternHeight || startingChannelCount != this._buttons.length) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    this._buttons[y].style.marginTop = ((ChannelRow.patternHeight - 20) / 2) + "px";
                    this._buttons[y].style.marginBottom = ((ChannelRow.patternHeight - 20) / 2) + "px";
                }
            }
            if (this._renderedModChannels != this._doc.song.modChannelCount || startingChannelCount != this._buttons.length) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        this._buttons[y].children[0].classList.remove("modMute");
                    }
                    else {
                        this._buttons[y].children[0].classList.add("modMute");
                    }
                }
            }
            if (this._renderedModChannels != this._doc.song.modChannelCount || this._renderedPitchChannels != this._doc.song.pitchChannelCount || this._renderedNoiseChannels != this._doc.song.noiseChannelCount) {
                for (let y = 0; y < this._doc.song.getChannelCount(); y++) {
                    if (y < this._doc.song.pitchChannelCount) {
                        let val = (y + 1);
                        this._channelCounts[y].textContent = val + "";
                        this._channelCounts[y].style.fontSize = (val >= 10) ? "xx-small" : "inherit";
                    }
                    else if (y < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                        let val = (y - this._doc.song.pitchChannelCount + 1);
                        this._channelCounts[y].textContent = val + "";
                        this._channelCounts[y].style.fontSize = (val >= 10) ? "xx-small" : "inherit";
                    }
                    else {
                        let val = (y - this._doc.song.pitchChannelCount - this._doc.song.noiseChannelCount + 1);
                        this._channelCounts[y].textContent = val + "";
                        this._channelCounts[y].style.fontSize = (val >= 10) ? "xx-small" : "inherit";
                    }
                }
                this._renderedPitchChannels = this._doc.song.pitchChannelCount;
                this._renderedNoiseChannels = this._doc.song.noiseChannelCount;
                this._renderedModChannels = this._doc.song.modChannelCount;
            }
            if (startingChannelCount != this._buttons.length || this._renderedChannelHeight != ChannelRow.patternHeight) {
                this._renderedChannelHeight = ChannelRow.patternHeight;
                this._editorHeight = Config.barEditorHeight + this._doc.song.getChannelCount() * ChannelRow.patternHeight;
                this._channelNameDisplay.style.setProperty("display", "none");
                this.container.style.height = (this._editorHeight + 16) + "px";
                if (ChannelRow.patternHeight < 27) {
                    this._channelNameDisplay.style.setProperty("margin-top", "-2px");
                    this._channelDropDown.style.setProperty("margin-top", "-4px");
                    this._channelNameInput.input.style.setProperty("margin-top", "-4px");
                }
                else if (ChannelRow.patternHeight < 30) {
                    this._channelNameDisplay.style.setProperty("margin-top", "-1px");
                    this._channelDropDown.style.setProperty("margin-top", "-3px");
                    this._channelNameInput.input.style.setProperty("margin-top", "-3px");
                }
                else {
                    this._channelNameDisplay.style.setProperty("margin-top", "0px");
                    this._channelDropDown.style.setProperty("margin-top", "0px");
                    this._channelNameInput.input.style.setProperty("margin-top", "-2px");
                }
            }
        }
    }

    class OctaveScrollBar {
        constructor(_doc, _piano) {
            this._doc = _doc;
            this._piano = _piano;
            this._editorWidth = 20;
            this._editorHeight = 481;
            this._notchHeight = 4.0;
            this._octaveCount = Config.pitchOctaves;
            this._octaveHeight = (this._editorHeight - this._notchHeight) / this._octaveCount;
            this._handle = SVG.rect({ fill: ColorConfig.uiWidgetBackground, x: 2, y: 0, width: this._editorWidth - 4 });
            this._handleHighlight = SVG.rect({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": 2, "pointer-events": "none", x: 1, y: 0, width: this._editorWidth - 2 });
            this._upHighlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._downHighlight = SVG.path({ fill: ColorConfig.hoverPreview, "pointer-events": "none" });
            this._svg = SVG.svg({ style: "background-color: ${ColorConfig.editorBackground}; touch-action: pan-x; position: absolute;", width: this._editorWidth, height: "100%", viewBox: "0 0 20 " + this._editorHeight, preserveAspectRatio: "none" });
            this.container = HTML.div({ id: "octaveScrollBarContainer", style: "width: 20px; height: 100%; overflow: hidden; position: relative; flex-shrink: 0;" }, this._svg);
            this._mouseY = 0;
            this._mouseDown = false;
            this._mouseOver = false;
            this._dragging = false;
            this._renderedBarBottom = -1;
            this._renderedVisibleOctaveCount = -1;
            this._change = null;
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._updatePreview();
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
                this._updatePreview();
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel))
                    return;
                this._updatePreview();
                if (this._mouseY >= this._barBottom - this._barHeight && this._mouseY <= this._barBottom) {
                    this._dragging = true;
                    this._change = null;
                    this._dragStart = this._mouseY;
                }
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                if (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel))
                    return;
                this._updatePreview();
                if (this._mouseY >= this._barBottom - this._barHeight && this._mouseY <= this._barBottom) {
                    this._dragging = true;
                    this._change = null;
                    this._dragStart = this._mouseY;
                }
            };
            this._whenMouseMoved = (event) => {
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (!this._doc.song.getChannelIsNoise(this._doc.channel) && !this._doc.song.getChannelIsMod(this._doc.channel) && this._mouseDown) {
                    if (this._dragging) {
                        if (this._change != null)
                            this._doc.record(this._change);
                    }
                    else {
                        const visibleOctaveCount = this._doc.getVisibleOctaveCount();
                        const scrollableOctaves = Config.pitchOctaves - visibleOctaveCount;
                        const canReplaceLastChange = this._doc.lastChangeWas(this._change);
                        const oldValue = canReplaceLastChange ? this._change.oldValue : this._doc.song.channels[this._doc.channel].octave;
                        const currentOctave = this._doc.getBaseVisibleOctave(this._doc.channel);
                        if (this._mouseY < this._barBottom - this._barHeight * 0.5) {
                            if (currentOctave < scrollableOctaves) {
                                this._change = new ChangeOctave(this._doc, oldValue, Math.floor(currentOctave + 1 + visibleOctaveCount * 0.5));
                                this._doc.record(this._change, canReplaceLastChange);
                            }
                        }
                        else {
                            if (currentOctave > 0) {
                                this._change = new ChangeOctave(this._doc, oldValue, Math.floor(currentOctave - 1 + visibleOctaveCount * 0.5));
                                this._doc.record(this._change, canReplaceLastChange);
                            }
                        }
                    }
                }
                this._mouseDown = false;
                this._dragging = false;
                this._updatePreview();
            };
            this._documentChanged = () => {
                this._barBottom = this._editorHeight - (this._octaveHeight * this._doc.getBaseVisibleOctave(this._doc.channel));
                this._svg.style.visibility = (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel)) ? "hidden" : "visible";
                const visibleOctaveCount = this._doc.getVisibleOctaveCount();
                if (this._renderedBarBottom != this._barBottom || this._renderedVisibleOctaveCount != visibleOctaveCount) {
                    this._renderedBarBottom = this._barBottom;
                    this._renderedVisibleOctaveCount = visibleOctaveCount;
                    this._barHeight = (this._octaveHeight * visibleOctaveCount + this._notchHeight);
                    this._handle.setAttribute("height", String(this._barHeight));
                    this._handleHighlight.setAttribute("height", String(this._barHeight));
                    this._handle.setAttribute("y", String(this._barBottom - this._barHeight));
                    this._handleHighlight.setAttribute("y", String(this._barBottom - this._barHeight));
                    this._piano.forceRender();
                }
                this._updatePreview();
            };
            this._doc.notifier.watch(this._documentChanged);
            this._documentChanged();
            this._svg.appendChild(this._handle);
            for (let i = 0; i <= this._octaveCount; i++) {
                this._svg.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: 0, y: i * this._octaveHeight, width: this._editorWidth, height: this._notchHeight }));
            }
            this._svg.appendChild(this._handleHighlight);
            this._svg.appendChild(this._upHighlight);
            this._svg.appendChild(this._downHighlight);
            const center = this._editorWidth * 0.5;
            const base = 20;
            const tip = 9;
            const arrowWidth = 6;
            this._upHighlight.setAttribute("d", `M ${center} ${tip} L ${center + arrowWidth} ${base} L ${center - arrowWidth} ${base} z`);
            this._downHighlight.setAttribute("d", `M ${center} ${this._editorHeight - tip} L ${center + arrowWidth} ${this._editorHeight - base} L ${center - arrowWidth} ${this._editorHeight - base} z`);
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("mouseover", this._whenMouseOver);
            this.container.addEventListener("mouseout", this._whenMouseOut);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _whenCursorMoved() {
            if (this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel))
                return;
            if (this._dragging) {
                const visibleOctaveCount = this._doc.getVisibleOctaveCount();
                const scrollableOctaves = Config.pitchOctaves - visibleOctaveCount;
                const continuingProspectiveChange = this._doc.lastChangeWas(this._change);
                const oldValue = continuingProspectiveChange ? this._change.oldValue : this._doc.song.channels[this._doc.channel].octave;
                const currentOctave = this._doc.getBaseVisibleOctave(this._doc.channel);
                let octave = currentOctave;
                while (this._mouseY - this._dragStart < -this._octaveHeight * 0.5) {
                    if (octave < scrollableOctaves) {
                        octave++;
                        this._dragStart -= this._octaveHeight;
                    }
                    else {
                        break;
                    }
                }
                while (this._mouseY - this._dragStart > this._octaveHeight * 0.5) {
                    if (octave > 0) {
                        octave--;
                        this._dragStart += this._octaveHeight;
                    }
                    else {
                        break;
                    }
                }
                this._change = new ChangeOctave(this._doc, oldValue, Math.floor(octave + visibleOctaveCount * 0.5));
                this._doc.setProspectiveChange(this._change);
            }
            if (this._mouseOver)
                this._updatePreview();
        }
        _updatePreview() {
            const showHighlight = this._mouseOver && !this._mouseDown;
            let showUpHighlight = false;
            let showDownHighlight = false;
            let showHandleHighlight = false;
            if (showHighlight) {
                if (this._mouseY < this._barBottom - this._barHeight) {
                    showUpHighlight = true;
                }
                else if (this._mouseY > this._barBottom) {
                    showDownHighlight = true;
                }
                else {
                    showHandleHighlight = true;
                }
            }
            this._upHighlight.style.visibility = showUpHighlight ? "inherit" : "hidden";
            this._downHighlight.style.visibility = showDownHighlight ? "inherit" : "hidden";
            this._handleHighlight.style.visibility = showHandleHighlight ? "inherit" : "hidden";
        }
    }

    var __awaiter = (exports && exports.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    const id = ((Math.random() * 0xffffffff) >>> 0).toString(16);
    class MidiInputHandler {
        constructor(_doc) {
            this._doc = _doc;
            this._takeMidiHandlerFocus = (event) => {
                localStorage.setItem("midiHandlerId", id);
            };
            this._handleStateChange = (event) => {
                if (event.port.type !== "input")
                    return;
                switch (event.port.state) {
                    case "connected":
                        this._registerMidiInput(event.port);
                        break;
                    case "disconnected":
                        this._unregisterMidiInput(event.port);
                        break;
                }
            };
            this._registerMidiInput = (midiInput) => {
                midiInput.addEventListener("midimessage", this._onMidiMessage);
            };
            this._unregisterMidiInput = (midiInput) => {
                midiInput.removeEventListener("midimessage", this._onMidiMessage);
                this._doc.performance.clearAllPitches();
            };
            this._onMidiMessage = (event) => {
                if (!this._doc.prefs.enableMidi || localStorage.getItem("midiHandlerId") != id)
                    return;
                const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
                let [eventType, key, velocity] = event.data;
                eventType &= 0xF0;
                if (isDrum) {
                    const drum = analogousDrumMap[key];
                    if (drum != undefined) {
                        key = drum.frequency;
                    }
                    else {
                        return;
                    }
                }
                else {
                    key -= Config.keys[this._doc.song.key].basePitch;
                    if (key < 0 || key > Config.maxPitch)
                        return;
                }
                if (eventType == 144 && velocity == 0) {
                    eventType = 128;
                }
                switch (eventType) {
                    case 144:
                        this._doc.synth.preferLowerLatency = true;
                        this._doc.performance.addPerformedPitch(key);
                        break;
                    case 128:
                        this._doc.performance.removePerformedPitch(key);
                        break;
                }
            };
            this.registerMidiAccessHandler();
        }
        registerMidiAccessHandler() {
            return __awaiter(this, void 0, void 0, function* () {
                if (navigator.requestMIDIAccess == null)
                    return;
                try {
                    const midiAccess = yield navigator.requestMIDIAccess();
                    midiAccess.inputs.forEach(this._registerMidiInput);
                    midiAccess.addEventListener("statechange", this._handleStateChange);
                    this._takeMidiHandlerFocus();
                    window.addEventListener("focus", this._takeMidiHandlerFocus);
                }
                catch (e) {
                    console.error("Failed to get MIDI access", e);
                }
            });
        }
    }

    class KeyboardLayout { 
        static keyPosToPitch(doc, x, y, keyboardLayout) {
            let pitchOffset = null;
            let forcedKey = null;
            switch (keyboardLayout) {
                case "wickiHayden":
                    pitchOffset = y * 5 + x * 2 - 2;
                    break;
                case "songScale":
                    const scaleFlags = doc.song.scale == Config.scales.dictionary["Custom"].index ? doc.song.scaleCustom : Config.scales[doc.song.scale].flags;
                    const scaleIndices = scaleFlags.map((flag, index) => flag ? index : null).filter((index) => index != null);
                    pitchOffset = (y - 1 + Math.floor(x / scaleIndices.length)) * Config.pitchesPerOctave + scaleIndices[(x + scaleIndices.length) % scaleIndices.length];
                    break;
                case "pianoAtC":
                    pitchOffset = KeyboardLayout._pianoAtC[y][x];
                    forcedKey = Config.keys.dictionary["C"].basePitch;
                    break;
                case "pianoAtA":
                    pitchOffset = KeyboardLayout._pianoAtA[y][x];
                    forcedKey = Config.keys.dictionary["A"].basePitch;
                    break;
                case "pianoTransposingC":
                    pitchOffset = KeyboardLayout._pianoAtC[y][x];
                    break;
                case "pianoTransposingA":
                    pitchOffset = KeyboardLayout._pianoAtA[y][x];
                    break;
            }
            if (pitchOffset == null)
                return null;
            const octaveOffset = Math.max(0, doc.song.channels[doc.channel].octave - 1) * Config.pitchesPerOctave;
            let keyOffset = 0;
            if (forcedKey != null) {
                const keyBasePitch = Config.keys[doc.song.key].basePitch;
                keyOffset = (forcedKey - keyBasePitch + 144) % 12;
            }
            const pitch = octaveOffset + keyOffset + pitchOffset;
            if (pitch < 0 || pitch > Config.maxPitch)
                return null;
            return pitch;
        }
        constructor(_doc) {
            this._doc = _doc;
            this._possiblyPlayingPitchesFromKeyboard = false;
            this._onWindowBlur = (event) => {
                if (this._possiblyPlayingPitchesFromKeyboard) {
                    this._doc.performance.clearAllPitches();
                    this._possiblyPlayingPitchesFromKeyboard = false;
                }
            };
            window.addEventListener("blur", this._onWindowBlur);
        }
        handleKeyEvent(event, pressed) {
            switch (event.code) {
                case "Backquote":
                    this.handleKey(-1, 3, pressed);
                    break;
                case "Digit1":
                    this.handleKey(0, 3, pressed);
                    break;
                case "Digit2":
                    this.handleKey(1, 3, pressed);
                    break;
                case "Digit3":
                    this.handleKey(2, 3, pressed);
                    break;
                case "Digit4":
                    this.handleKey(3, 3, pressed);
                    break;
                case "Digit5":
                    this.handleKey(4, 3, pressed);
                    break;
                case "Digit6":
                    this.handleKey(5, 3, pressed);
                    break;
                case "Digit7":
                    this.handleKey(6, 3, pressed);
                    break;
                case "Digit8":
                    this.handleKey(7, 3, pressed);
                    break;
                case "Digit9":
                    this.handleKey(8, 3, pressed);
                    break;
                case "Digit0":
                    this.handleKey(9, 3, pressed);
                    break;
                case "Minus":
                    this.handleKey(10, 3, pressed);
                    break;
                case "Equal":
                    this.handleKey(11, 3, pressed);
                    break;
                case "IntlYen":
                    this.handleKey(12, 3, pressed);
                    break;
                case "KeyQ":
                    this.handleKey(0, 2, pressed);
                    break;
                case "KeyW":
                    this.handleKey(1, 2, pressed);
                    break;
                case "KeyE":
                    this.handleKey(2, 2, pressed);
                    break;
                case "KeyR":
                    this.handleKey(3, 2, pressed);
                    break;
                case "KeyT":
                    this.handleKey(4, 2, pressed);
                    break;
                case "KeyY":
                    this.handleKey(5, 2, pressed);
                    break;
                case "KeyU":
                    this.handleKey(6, 2, pressed);
                    break;
                case "KeyI":
                    this.handleKey(7, 2, pressed);
                    break;
                case "KeyO":
                    this.handleKey(8, 2, pressed);
                    break;
                case "KeyP":
                    this.handleKey(9, 2, pressed);
                    break;
                case "BracketLeft":
                    this.handleKey(10, 2, pressed);
                    break;
                case "BracketRight":
                    this.handleKey(11, 2, pressed);
                    break;
                case "Backslash":
                    if (event.key == "\\" || event.key == "|") {
                        this.handleKey(12, 2, pressed);
                    }
                    else {
                        this.handleKey(11, 1, pressed);
                    }
                    break;
                case "KeyA":
                    this.handleKey(0, 1, pressed);
                    break;
                case "KeyS":
                    this.handleKey(1, 1, pressed);
                    break;
                case "KeyD":
                    this.handleKey(2, 1, pressed);
                    break;
                case "KeyF":
                    this.handleKey(3, 1, pressed);
                    break;
                case "KeyG":
                    this.handleKey(4, 1, pressed);
                    break;
                case "KeyH":
                    this.handleKey(5, 1, pressed);
                    break;
                case "KeyJ":
                    this.handleKey(6, 1, pressed);
                    break;
                case "KeyK":
                    this.handleKey(7, 1, pressed);
                    break;
                case "KeyL":
                    this.handleKey(8, 1, pressed);
                    break;
                case "Semicolon":
                    this.handleKey(9, 1, pressed);
                    break;
                case "Quote":
                    this.handleKey(10, 1, pressed);
                    break;
                case "IntlHash":
                    this.handleKey(11, 1, pressed);
                    break;
                case "IntlBackslash":
                    this.handleKey(-1, 0, pressed);
                    break;
                case "KeyZ":
                    this.handleKey(0, 0, pressed);
                    break;
                case "KeyX":
                    this.handleKey(1, 0, pressed);
                    break;
                case "KeyC":
                    this.handleKey(2, 0, pressed);
                    break;
                case "KeyV":
                    this.handleKey(3, 0, pressed);
                    break;
                case "KeyB":
                    this.handleKey(4, 0, pressed);
                    break;
                case "KeyN":
                    this.handleKey(5, 0, pressed);
                    break;
                case "KeyM":
                    this.handleKey(6, 0, pressed);
                    break;
                case "Comma":
                    this.handleKey(7, 0, pressed);
                    break;
                case "Period":
                    this.handleKey(8, 0, pressed);
                    break;
                case "Slash":
                    this.handleKey(9, 0, pressed);
                    break;
                case "IntlRo":
                    this.handleKey(10, 0, pressed);
                    break;
                default: return;
            }
            event.preventDefault();
        }
        handleKey(x, y, pressed) {
            const isDrum = this._doc.song.getChannelIsNoise(this._doc.channel);
            if (isDrum) {
                if (x >= 0 && x < Config.drumCount) {
                    if (pressed) {
                        this._doc.synth.preferLowerLatency = true;
                        this._doc.performance.addPerformedPitch(x);
                        this._possiblyPlayingPitchesFromKeyboard = true;
                    }
                    else {
                        this._doc.performance.removePerformedPitch(x);
                    }
                }
                return;
            }
            const pitch = KeyboardLayout.keyPosToPitch(this._doc, x, y, this._doc.prefs.keyboardLayout);
            if (pitch != null) {
                if (pressed) {
                    this._doc.synth.preferLowerLatency = true;
                    this._doc.performance.addPerformedPitch(pitch);
                    this._possiblyPlayingPitchesFromKeyboard = true;
                }
                else {
                    this._doc.performance.removePerformedPitch(pitch);
                }
            }
        }
    }
    KeyboardLayout._pianoAtC = [
        [0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17],
        [null, 1, 3, null, 6, 8, 10, null, 13, 15, null, 18],
        [12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33],
        [null, 13, 15, null, 18, 20, 22, null, 25, 27, null, 30, 32],
    ];
    KeyboardLayout._pianoAtA = [
        [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17],
        [-1, 1, null, 4, 6, null, 9, 11, 13, null, 16, 18],
        [12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32],
        [11, 13, null, 16, 18, null, 21, 23, 25, null, 28, 30, null],
    ]; 

    function makeEmptyReplacementElement(node) {
        const clone = node.cloneNode(false);
        node.parentNode.replaceChild(clone, node);
        return clone;
    }
    class PatternCursor {
        constructor() {
            this.valid = false;
            this.prevNote = null;
            this.curNote = null;
            this.nextNote = null;
            this.pitch = 0;
            this.pitchIndex = -1;
            this.curIndex = 0;
            this.start = 0;
            this.end = 0;
            this.part = 0;
            this.exactPart = 0;
            this.nearPinIndex = 0;
            this.pins = [];
        }
    }
    class PatternEditor {
        constructor(_doc, _interactive, _barOffset) {
            this._doc = _doc;
            this._interactive = _interactive;
            this._barOffset = _barOffset;
            this.controlMode = false;
            this.shiftMode = false;
            this._defaultModBorder = 34;
            this._backgroundPitchRows = [];
            this._backgroundDrumRow = SVG.rect();
            this._backgroundModRow = SVG.rect();
            this._modDragValueLabelLeft = 0;
            this._modDragValueLabelTop = 0;
            this._modDragValueLabelWidth = 0;
            this.editingModLabel = false;
            this._modDragStartValue = 0;
            this._modDragLowerBound = 0;
            this._modDragUpperBound = 6;
            this._pitchHeight = -1;
            this._mouseX = 0;
            this._mouseY = 0;
            this._mouseDown = false;
            this._mouseOver = false;
            this._mouseDragging = false;
            this._mouseHorizontal = false;
            this._usingTouch = false;
            this._copiedPinChannels = [];
            this._mouseXStart = 0;
            this._mouseYStart = 0;
            this._touchTime = 0;
            this._shiftHeld = false;
            this._dragConfirmed = false;
            this._draggingStartOfSelection = false;
            this._draggingEndOfSelection = false;
            this._draggingSelectionContents = false;
            this._dragTime = 0;
            this._dragPitch = 0;
            this._dragSize = 0;
            this._dragVisible = false;
            this._dragChange = null;
            this._changePatternSelection = null;
            this._lastChangeWasPatternSelection = false;
            this._cursor = new PatternCursor();
            this._stashCursorPinVols = [];
            this._pattern = null;
            this._playheadX = 0.0;
            this._octaveOffset = 0;
            this._renderedWidth = -1;
            this._renderedHeight = -1;
            this._renderedBeatWidth = -1;
            this._renderedPitchHeight = -1;
            this._renderedFifths = false;
            this._renderedDrums = false;
            this._renderedMod = false;
            this._renderedRhythm = -1;
            this._renderedPitchChannelCount = -1;
            this._renderedNoiseChannelCount = -1;
            this._renderedModChannelCount = -1;
            this._followPlayheadBar = -1;
            this._validateModDragLabelInput = (event) => {
                const label = event.target;
                let converted = Number(label.innerText);
                if (!isNaN(converted) && converted >= 0 && converted < this._modDragLowerBound)
                    return;
                if (label.innerText != "" && label.innerText != "-") {
                    if (isNaN(converted)) {
                        converted = this._modDragLowerBound;
                        label.innerText = "" + this._modDragLowerBound;
                    }
                    let presValue = Math.floor(Math.max(Number(this._modDragLowerBound), Math.min(Number(this._modDragUpperBound), converted)));
                    if (label.innerText != presValue + "")
                        label.innerText = presValue + "";
                    let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                    this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * (this._modDragNote.start + this._modDragPin.time) - 4 - xOffset * 4), 2));
                    this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                    const sequence = new ChangeSequence();
                    this._dragChange = sequence;
                    this._doc.setProspectiveChange(this._dragChange);
                    sequence.append(new ChangeSizeBend(this._doc, this._modDragNote, this._modDragPin.time, presValue - Config.modulators[this._modDragSetting].convertRealFactor, this._modDragPin.interval, this.shiftMode));
                }
            };
            this.resetCopiedPins = () => {
                const maxDivision = this._getMaxDivision();
                let cap = this._doc.song.getVolumeCap(false);
                this._copiedPinChannels.length = this._doc.song.getChannelCount();
                this._stashCursorPinVols.length = this._doc.song.getChannelCount();
                for (let i = 0; i < this._doc.song.pitchChannelCount; i++) {
                    this._copiedPinChannels[i] = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, cap)];
                    this._stashCursorPinVols[i] = [cap, cap];
                }
                for (let i = this._doc.song.pitchChannelCount; i < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; i++) {
                    this._copiedPinChannels[i] = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, 0)];
                    this._stashCursorPinVols[i] = [cap, 0];
                }
                for (let i = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; i < this._doc.song.getChannelCount(); i++) {
                    this._copiedPinChannels[i] = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, 0)];
                    this._stashCursorPinVols[i] = [cap, 0];
                }
            };
            this._animatePlayhead = (timestamp) => {
                if (this._usingTouch && !this.shiftMode && !this._mouseDragging && this._mouseDown && performance.now() > this._touchTime + 1000 && this._cursor.valid && this._doc.lastChangeWas(this._dragChange)) {
                    this._dragChange.undo();
                    this._shiftHeld = true;
                    this._dragConfirmed = false;
                    this._whenCursorPressed();
                    this._doc.notifier.notifyWatchers();
                }
                const playheadBar = Math.floor(this._doc.synth.playhead);
                const noteFlashElements = this._svgNoteContainer.querySelectorAll('.note-flash');
                if (this._doc.synth.playing && ((this._pattern != null && this._doc.song.getPattern(this._doc.channel, Math.floor(this._doc.synth.playhead)) == this._pattern) || Math.floor(this._doc.synth.playhead) == this._doc.bar + this._barOffset)) {
                    this._svgPlayhead.setAttribute("visibility", "visible");
                    const modPlayhead = this._doc.synth.playhead - playheadBar;
                    for (var i = 0; i < noteFlashElements.length; i++) {
                        var element = noteFlashElements[i];
                        const noteStart = Number(element.getAttribute("note-start")) / (this._doc.song.beatsPerBar * Config.partsPerBeat);
                        const noteEnd = Number(element.getAttribute("note-end")) / (this._doc.song.beatsPerBar * Config.partsPerBeat);
                        if ((modPlayhead >= noteStart) && this._doc.prefs.notesFlashWhenPlayed) {
                            const dist = noteEnd - noteStart;
                            element.style.opacity = String((1 - (((modPlayhead - noteStart) - (dist / 2)) / (dist / 2))));
                        }
                        else {
                            element.style.opacity = "0";
                        }
                    }
                    if (Math.abs(modPlayhead - this._playheadX) > 0.1) {
                        this._playheadX = modPlayhead;
                    }
                    else {
                        this._playheadX += (modPlayhead - this._playheadX) * 0.2;
                    }
                    this._svgPlayhead.setAttribute("x", "" + prettyNumber(this._playheadX * this._editorWidth - 2));
                }
                else {
                    this._svgPlayhead.setAttribute("visibility", "hidden");
                    for (var i = 0; i < noteFlashElements.length; i++) {
                        var element = noteFlashElements[i];
                        element.style.opacity = "0";
                    }
                }
                if (this._doc.synth.playing && (this._doc.synth.recording || this._doc.prefs.autoFollow) && this._followPlayheadBar != playheadBar) {
                    new ChangeChannelBar(this._doc, this._doc.channel, playheadBar);
                    this._doc.notifier.notifyWatchers();
                }
                this._followPlayheadBar = playheadBar;
                if (this._doc.currentPatternIsDirty) {
                    this._redrawNotePatterns();
                }
                window.requestAnimationFrame(this._animatePlayhead);
            };
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
                this._usingTouch = false;
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._usingTouch = false;
                this._shiftHeld = event.shiftKey;
                this._dragConfirmed = false;
                this._whenCursorPressed();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._usingTouch = true;
                this._shiftHeld = event.shiftKey;
                this._dragConfirmed = false;
                this._touchTime = performance.now();
                this._whenCursorPressed();
            };
            this._whenMouseMoved = (event) => {
                this.controlMode = event.ctrlKey;
                this.shiftMode = event.shiftKey;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._usingTouch = false;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenCursorReleased = (event) => {
                if (!this._cursor.valid)
                    return;
                const continuousState = this._doc.lastChangeWas(this._dragChange);
                if (this._mouseDown && continuousState && this._dragChange != null) {
                    if (this._draggingSelectionContents) {
                        this._doc.record(this._dragChange);
                        this._dragChange = null;
                        if (this._pattern != null && this._doc.song.getChannelIsMod(this._doc.channel))
                            this._pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                    }
                    else if (this._draggingStartOfSelection || this._draggingEndOfSelection || this._shiftHeld) {
                        this._setPatternSelection(this._dragChange);
                        this._dragChange = null;
                    }
                    else if (this._mouseDragging || this._cursor.curNote == null || !this._dragChange.isNoop() || this._draggingStartOfSelection || this._draggingEndOfSelection || this._draggingSelectionContents || this._shiftHeld) {
                        this._doc.record(this._dragChange);
                        this._dragChange = null;
                        if (this._pattern != null && this._doc.song.getChannelIsMod(this._doc.channel))
                            this._pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                    }
                    else {
                        if (this._pattern == null)
                            throw new Error();
                        const sequence = new ChangeSequence();
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        if (this._cursor.pitchIndex == -1) {
                            if (this._cursor.curNote.pitches.length == Config.maxChordSize) {
                                sequence.append(new ChangePitchAdded(this._doc, this._cursor.curNote, this._cursor.curNote.pitches[0], 0, true));
                            }
                            sequence.append(new ChangePitchAdded(this._doc, this._cursor.curNote, this._cursor.pitch, this._cursor.curNote.pitches.length));
                            this._copyPins(this._cursor.curNote);
                            if (this._doc.prefs.enableNotePreview && !this._doc.synth.playing) {
                                const duration = Math.min(Config.partsPerBeat, this._cursor.end - this._cursor.start);
                                this._doc.performance.setTemporaryPitches(this._cursor.curNote.pitches, duration);
                            }
                        }
                        else {
                            if (this._cursor.curNote.pitches.length == 1) {
                                sequence.append(new ChangeNoteAdded(this._doc, this._pattern, this._cursor.curNote, this._cursor.curIndex, true));
                            }
                            else {
                                sequence.append(new ChangePitchAdded(this._doc, this._cursor.curNote, this._cursor.pitch, this._cursor.curNote.pitches.indexOf(this._cursor.pitch), true));
                            }
                        }
                        this._doc.record(sequence);
                    }
                }
                this._mouseDown = false;
                this._mouseDragging = false;
                this._draggingStartOfSelection = false;
                this._draggingEndOfSelection = false;
                this._draggingSelectionContents = false;
                this._lastChangeWasPatternSelection = false;
                this.modDragValueLabel.setAttribute("fill", ColorConfig.secondaryText);
                this._updateCursorStatus();
                this._updatePreview();
            };
            this._svgNoteBackground = SVG.pattern({ id: "patternEditorNoteBackground" + this._barOffset, x: "0", y: "0", patternUnits: "userSpaceOnUse" });
            this._svgDrumBackground = SVG.pattern({ id: "patternEditorDrumBackground" + this._barOffset, x: "0", y: "0", patternUnits: "userSpaceOnUse" });
            this._svgModBackground = SVG.pattern({ id: "patternEditorModBackground" + this._barOffset, x: "0", y: "0", patternUnits: "userSpaceOnUse" });
            this._svgBackground = SVG.rect({ x: "0", y: "0", "pointer-events": "none", fill: "url(#patternEditorNoteBackground" + this._barOffset + ")" });
            this._svgNoteContainer = SVG.svg();
            this._svgPlayhead = SVG.rect({ x: "0", y: "0", width: "2", fill: ColorConfig.playhead, "pointer-events": "none" });
            this._selectionRect = SVG.rect({ class: "dashed-line dash-move", fill: ColorConfig.boxSelectionFill, stroke: ColorConfig.hoverPreview, "stroke-width": 2, "stroke-dasharray": "5, 3", "fill-opacity": "0.4", "pointer-events": "none", visibility: "hidden" });
            this._svgPreview = SVG.path({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": "2", "pointer-events": "none" });
            this.modDragValueLabel = HTML.div({ width: "90", "text-anchor": "start", contenteditable: "true", style: "display: flex, justify-content: center; align-items:center; position:absolute; pointer-events: none;", "dominant-baseline": "central", });
            this._svg = SVG.svg({ id: 'firstImage', style: `background-image: url(${getLocalStorageItem("customTheme", "")}); background-repeat: no-repeat; background-size: 100% 100%; background-color: ${ColorConfig.patternBackground|| ColorConfig.editorBackground }; touch-action: none; position: absolute;`, width: "100%", height: "100%" }, SVG.defs(this._svgNoteBackground, this._svgDrumBackground, this._svgModBackground), this._svgBackground, this._selectionRect, this._svgNoteContainer, this._svgPreview, this._svgPlayhead);
            this.container = HTML.div({ style: "height: 100%; overflow:hidden; position: relative; flex-grow: 1;" }, this._svg, this.modDragValueLabel);
            for (let i = 0; i < Config.pitchesPerOctave; i++) {
                const rectangle = SVG.rect();
                rectangle.setAttribute("x", "1");
                rectangle.setAttribute("fill", (i == 0) ? ColorConfig.tonic : ColorConfig.pitchBackground);
                this._svgNoteBackground.appendChild(rectangle);
                this._backgroundPitchRows[i] = rectangle;
            }
            this._backgroundDrumRow.setAttribute("x", "1");
            this._backgroundDrumRow.setAttribute("y", "1");
            this._backgroundDrumRow.setAttribute("fill", ColorConfig.pitchBackground);
            this._svgDrumBackground.appendChild(this._backgroundDrumRow);
            this._backgroundModRow.setAttribute("fill", ColorConfig.pitchBackground);
            this._svgModBackground.appendChild(this._backgroundModRow);
            if (this._interactive) {
                this._updateCursorStatus();
                this._updatePreview();
                window.requestAnimationFrame(this._animatePlayhead);
                this._svg.addEventListener("mousedown", this._whenMousePressed);
                document.addEventListener("mousemove", this._whenMouseMoved);
                document.addEventListener("mouseup", this._whenCursorReleased);
                this._svg.addEventListener("mouseover", this._whenMouseOver);
                this._svg.addEventListener("mouseout", this._whenMouseOut);
                this._svg.addEventListener("touchstart", this._whenTouchPressed);
                this._svg.addEventListener("touchmove", this._whenTouchMoved);
                this._svg.addEventListener("touchend", this._whenCursorReleased);
                this._svg.addEventListener("touchcancel", this._whenCursorReleased);
                this.modDragValueLabel.addEventListener("input", this._validateModDragLabelInput);
            }
            else {
                this._svgPlayhead.style.display = "none";
                this._svg.appendChild(SVG.rect({ x: 0, y: 0, width: 10000, height: 10000, fill: ColorConfig.editorBackground, style: "opacity: 0.5;" }));
            }
            this.resetCopiedPins();
        }
        _getMaxPitch() {
            return this._doc.song.getChannelIsMod(this._doc.channel) ? Config.modCount - 1 : (this._doc.song.getChannelIsNoise(this._doc.channel) ? Config.drumCount - 1 : Config.maxPitch);
        }
        _getMaxDivision() {
            if (this.controlMode && this._mouseHorizontal)
                return Config.partsPerBeat;
            const rhythmStepsPerBeat = Config.rhythms[this._doc.song.rhythm].stepsPerBeat;
            if (rhythmStepsPerBeat % 4 == 0) {
                return Config.partsPerBeat / 2;
            }
            else if (rhythmStepsPerBeat % 3 == 0) {
                return Config.partsPerBeat / 3;
            }
            else if (rhythmStepsPerBeat % 2 == 0) {
                return Config.partsPerBeat / 2;
            }
            return Config.partsPerBeat;
        }
        _getMinDivision() {
            if (this.controlMode && this._mouseHorizontal)
                return 1;
            return Config.partsPerBeat / Config.rhythms[this._doc.song.rhythm].stepsPerBeat;
        }
        _snapToMinDivision(input) {
            const minDivision = this._getMinDivision();
            return Math.floor(input / minDivision) * minDivision;
        }
        _updateCursorStatus() {
            this._cursor = new PatternCursor();
            if (this._mouseX < 0 || this._mouseX > this._editorWidth || this._mouseY < 0 || this._mouseY > this._editorHeight || this._pitchHeight <= 0)
                return;
            const minDivision = this._getMinDivision();
            this._cursor.exactPart = this._mouseX / this._partWidth;
            this._cursor.part =
                Math.floor(Math.max(0, Math.min(this._doc.song.beatsPerBar * Config.partsPerBeat - minDivision, this._cursor.exactPart))
                    / minDivision) * minDivision;
            let foundNote = false;
            if (this._pattern != null) {
                for (const note of this._pattern.notes) {
                    if (note.end <= this._cursor.exactPart) {
                        if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                            if (note.pitches[0] == Math.floor(this._findMousePitch(this._mouseY))) {
                                this._cursor.prevNote = note;
                            }
                            if (!foundNote)
                                this._cursor.curIndex++;
                        }
                        else {
                            this._cursor.prevNote = note;
                            this._cursor.curIndex++;
                        }
                    }
                    else if (note.start <= this._cursor.exactPart && note.end > this._cursor.exactPart) {
                        if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                            if (note.pitches[0] == Math.floor(this._findMousePitch(this._mouseY))) {
                                this._cursor.curNote = note;
                                foundNote = true;
                            }
                            else if (!foundNote || (this._cursor.curNote != null && note.start < this._cursor.curNote.start))
                                this._cursor.curIndex++;
                        }
                        else {
                            this._cursor.curNote = note;
                        }
                    }
                    else if (note.start > this._cursor.exactPart) {
                        if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                            if (note.pitches[0] == Math.floor(this._findMousePitch(this._mouseY))) {
                                this._cursor.nextNote = note;
                                break;
                            }
                        }
                        else {
                            this._cursor.nextNote = note;
                            break;
                        }
                    }
                }
                if (this._doc.song.getChannelIsMod(this._doc.channel) && !this.editingModLabel) {
                    if (this._pattern.notes[this._cursor.curIndex] != null && this._cursor.curNote != null) {
                        let pinIdx = 0;
                        while (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx].time < this._cursor.exactPart && pinIdx < this._cursor.curNote.pins.length) {
                            pinIdx++;
                        }
                        if (pinIdx > 0) {
                            if (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx].time - this._cursor.exactPart > this._cursor.exactPart - (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx - 1].time)) {
                                pinIdx--;
                            }
                        }
                        this.modDragValueLabel.style.setProperty("color", "#666688");
                        this.modDragValueLabel.style.setProperty("display", "");
                        const mod = Math.max(0, Config.modCount - 1 - this._cursor.curNote.pitches[0]);
                        let setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[mod];
                        let presValue = this._cursor.curNote.pins[pinIdx].size + Config.modulators[setting].convertRealFactor;
                        let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                        this._modDragValueLabelWidth = 8 + xOffset * 8;
                        this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * (this._cursor.curNote.start + this._cursor.curNote.pins[pinIdx].time) - 4 - xOffset * 4), 2));
                        this._modDragValueLabelTop = +prettyNumber(this._pitchToPixelHeight(this._cursor.curNote.pitches[0] - this._octaveOffset) - 17 - (this._pitchHeight - this._pitchBorder) / 2);
                        this._modDragStartValue = this._cursor.curNote.pins[pinIdx].size;
                        this._modDragNote = this._cursor.curNote;
                        this._modDragPin = this._cursor.curNote.pins[pinIdx];
                        this._modDragLowerBound = Config.modulators[setting].convertRealFactor;
                        this._modDragUpperBound = Config.modulators[setting].convertRealFactor + this._doc.song.getVolumeCapForSetting(true, setting, this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modFilterTypes[mod]);
                        this._modDragSetting = setting;
                        this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                        this.modDragValueLabel.style.setProperty("top", "" + this._modDragValueLabelTop + "px");
                        this.modDragValueLabel.textContent = "" + presValue;
                    }
                    else {
                        this.modDragValueLabel.style.setProperty("display", "none");
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                    }
                }
                else if (!this.editingModLabel) {
                    this.modDragValueLabel.style.setProperty("display", "none");
                    this.modDragValueLabel.style.setProperty("pointer-events", "none");
                    this.modDragValueLabel.setAttribute("contenteditable", "false");
                }
            }
            else {
                this.modDragValueLabel.style.setProperty("display", "none");
                this.modDragValueLabel.style.setProperty("pointer-events", "none");
                this.modDragValueLabel.setAttribute("contenteditable", "false");
            }
            let mousePitch = this._findMousePitch(this._mouseY);
            if (this._cursor.curNote != null) {
                this._cursor.start = this._cursor.curNote.start;
                this._cursor.end = this._cursor.curNote.end;
                this._cursor.pins = this._cursor.curNote.pins;
                let interval = 0;
                let error = 0;
                let prevPin;
                let nextPin = this._cursor.curNote.pins[0];
                for (let j = 1; j < this._cursor.curNote.pins.length; j++) {
                    prevPin = nextPin;
                    nextPin = this._cursor.curNote.pins[j];
                    const leftSide = this._partWidth * (this._cursor.curNote.start + prevPin.time);
                    const rightSide = this._partWidth * (this._cursor.curNote.start + nextPin.time);
                    if (this._mouseX > rightSide)
                        continue;
                    if (this._mouseX < leftSide)
                        throw new Error();
                    const intervalRatio = (this._mouseX - leftSide) / (rightSide - leftSide);
                    const arc = Math.sqrt(1.0 / Math.sqrt(4.0) - Math.pow(intervalRatio - 0.5, 2.0)) - 0.5;
                    const bendHeight = Math.abs(nextPin.interval - prevPin.interval);
                    interval = prevPin.interval * (1.0 - intervalRatio) + nextPin.interval * intervalRatio;
                    error = arc * bendHeight + 0.95;
                    break;
                }
                let minInterval = Number.MAX_VALUE;
                let maxInterval = -Number.MAX_VALUE;
                let bestDistance = Number.MAX_VALUE;
                for (const pin of this._cursor.curNote.pins) {
                    if (minInterval > pin.interval)
                        minInterval = pin.interval;
                    if (maxInterval < pin.interval)
                        maxInterval = pin.interval;
                    const pinDistance = Math.abs(this._cursor.curNote.start + pin.time - this._mouseX / this._partWidth);
                    if (bestDistance > pinDistance) {
                        bestDistance = pinDistance;
                        this._cursor.nearPinIndex = this._cursor.curNote.pins.indexOf(pin);
                    }
                }
                mousePitch -= interval;
                this._cursor.pitch = this._snapToPitch(mousePitch, -minInterval, this._getMaxPitch() - maxInterval);
                if (!this._doc.song.getChannelIsNoise(this._doc.channel) && !this._doc.song.getChannelIsMod(this._doc.channel)) {
                    let nearest = error;
                    for (let i = 0; i < this._cursor.curNote.pitches.length; i++) {
                        const distance = Math.abs(this._cursor.curNote.pitches[i] - mousePitch + 0.5);
                        if (distance > nearest)
                            continue;
                        nearest = distance;
                        this._cursor.pitch = this._cursor.curNote.pitches[i];
                    }
                }
                for (let i = 0; i < this._cursor.curNote.pitches.length; i++) {
                    if (this._cursor.curNote.pitches[i] == this._cursor.pitch) {
                        this._cursor.pitchIndex = i;
                        break;
                    }
                }
            }
            else {
                this._cursor.pitch = this._snapToPitch(mousePitch, 0, this._getMaxPitch());
                const defaultLength = this._copiedPins[this._copiedPins.length - 1].time;
                const fullBeats = Math.floor(this._cursor.part / Config.partsPerBeat);
                const maxDivision = this._getMaxDivision();
                const modMouse = this._cursor.part % Config.partsPerBeat;
                if (defaultLength == 1) {
                    this._cursor.start = this._cursor.part;
                }
                else if (defaultLength > Config.partsPerBeat) {
                    this._cursor.start = fullBeats * Config.partsPerBeat;
                }
                else if (defaultLength == Config.partsPerBeat) {
                    this._cursor.start = fullBeats * Config.partsPerBeat;
                    if (maxDivision < Config.partsPerBeat && modMouse > maxDivision) {
                        this._cursor.start += Math.floor(modMouse / maxDivision) * maxDivision;
                    }
                }
                else {
                    this._cursor.start = fullBeats * Config.partsPerBeat;
                    let division = Config.partsPerBeat % defaultLength == 0 ? defaultLength : Math.min(defaultLength, maxDivision);
                    while (division < maxDivision && Config.partsPerBeat % division != 0) {
                        division++;
                    }
                    this._cursor.start += Math.floor(modMouse / division) * division;
                }
                this._cursor.end = this._cursor.start + defaultLength;
                let forceStart = 0;
                let forceEnd = this._doc.song.beatsPerBar * Config.partsPerBeat;
                if (this._cursor.prevNote != null) {
                    forceStart = this._cursor.prevNote.end;
                }
                if (this._cursor.nextNote != null) {
                    forceEnd = this._cursor.nextNote.start;
                }
                if (this._cursor.start < forceStart) {
                    this._cursor.start = forceStart;
                    this._cursor.end = this._cursor.start + defaultLength;
                    if (this._cursor.end > forceEnd) {
                        this._cursor.end = forceEnd;
                    }
                }
                else if (this._cursor.end > forceEnd) {
                    this._cursor.end = forceEnd;
                    this._cursor.start = this._cursor.end - defaultLength;
                    if (this._cursor.start < forceStart) {
                        this._cursor.start = forceStart;
                    }
                }
                if (this._cursor.end - this._cursor.start == defaultLength) {
                    if (this._copiedPinChannels.length > this._doc.channel) {
                        this._copiedPins = this._copiedPinChannels[this._doc.channel];
                        this._cursor.pins = this._copiedPins;
                    }
                    else {
                        const cap = this._doc.song.getVolumeCap(false);
                        this._cursor.pins = [makeNotePin(0, 0, cap), makeNotePin(0, maxDivision, cap)];
                    }
                }
                else {
                    this._cursor.pins = [];
                    for (const oldPin of this._copiedPins) {
                        if (oldPin.time <= this._cursor.end - this._cursor.start) {
                            this._cursor.pins.push(makeNotePin(0, oldPin.time, oldPin.size));
                            if (oldPin.time == this._cursor.end - this._cursor.start)
                                break;
                        }
                        else {
                            this._cursor.pins.push(makeNotePin(0, this._cursor.end - this._cursor.start, oldPin.size));
                            break;
                        }
                    }
                }
                if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                    this._cursor.pitch = Math.max(0, Math.min(Config.modCount - 1, this._cursor.pitch));
                    if (this._stashCursorPinVols != null && this._stashCursorPinVols[this._doc.channel] != null) {
                        for (let pin = 0; pin < this._cursor.pins.length; pin++) {
                            this._cursor.pins[pin].size = this._stashCursorPinVols[this._doc.channel][pin];
                        }
                    }
                    let maxHeight = this._doc.song.getVolumeCap(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), this._cursor.pitch);
                    let maxFoundHeight = 0;
                    for (const pin of this._cursor.pins) {
                        if (pin.size > maxFoundHeight) {
                            maxFoundHeight = pin.size;
                        }
                    }
                    if (maxFoundHeight > maxHeight) {
                        for (const pin of this._cursor.pins) {
                            pin.size = Math.round(pin.size * (maxHeight / maxFoundHeight));
                        }
                    }
                }
            }
            this._cursor.valid = true;
        }
        _cursorIsInSelection() {
            return this._cursor.valid && this._doc.selection.patternSelectionActive && this._doc.selection.patternSelectionStart <= this._cursor.exactPart && this._cursor.exactPart <= this._doc.selection.patternSelectionEnd;
        }
        _cursorAtStartOfSelection() {
            return this._cursor.valid && this._doc.selection.patternSelectionActive && this._cursor.pitchIndex == -1 && this._doc.selection.patternSelectionStart - 3 <= this._cursor.exactPart && this._cursor.exactPart <= this._doc.selection.patternSelectionStart + 1.25;
        }
        _cursorAtEndOfSelection() {
            return this._cursor.valid && this._doc.selection.patternSelectionActive && this._cursor.pitchIndex == -1 && this._doc.selection.patternSelectionEnd - 1.25 <= this._cursor.exactPart && this._cursor.exactPart <= this._doc.selection.patternSelectionEnd + 3;
        }
        _findMousePitch(pixelY) {
            return Math.max(0, Math.min(this._pitchCount - 1, this._pitchCount - (pixelY / this._pitchHeight))) + this._octaveOffset;
        }
        _snapToPitch(guess, min, max) {
            if (guess < min)
                guess = min;
            if (guess > max)
                guess = max;
            const scale = this._doc.prefs.notesOutsideScale ? Config.scales.dictionary["Free"].flags : this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
            if (scale[Math.floor(guess) % Config.pitchesPerOctave] || this._doc.song.getChannelIsNoise(this._doc.channel) || this._doc.song.getChannelIsMod(this._doc.channel)) {
                return Math.floor(guess);
            }
            else {
                let topPitch = Math.floor(guess) + 1;
                let bottomPitch = Math.floor(guess) - 1;
                while (!scale[topPitch % Config.pitchesPerOctave]) {
                    topPitch++;
                }
                while (!scale[(bottomPitch) % Config.pitchesPerOctave]) {
                    bottomPitch--;
                }
                if (topPitch > max) {
                    if (bottomPitch < min) {
                        return min;
                    }
                    else {
                        return bottomPitch;
                    }
                }
                else if (bottomPitch < min) {
                    return topPitch;
                }
                let topRange = topPitch;
                let bottomRange = bottomPitch + 1;
                if (topPitch % Config.pitchesPerOctave == 0 || topPitch % Config.pitchesPerOctave == 7) {
                    topRange -= 0.5;
                }
                if (bottomPitch % Config.pitchesPerOctave == 0 || bottomPitch % Config.pitchesPerOctave == 7) {
                    bottomRange += 0.5;
                }
                return guess - bottomRange > topRange - guess ? topPitch : bottomPitch;
            }
        }
        _copyPins(note) {
            this._copiedPins = [];
            for (const oldPin of note.pins) {
                this._copiedPins.push(makeNotePin(0, oldPin.time, oldPin.size));
            }
            for (let i = 1; i < this._copiedPins.length - 1;) {
                if (this._copiedPins[i - 1].size == this._copiedPins[i].size &&
                    this._copiedPins[i].size == this._copiedPins[i + 1].size) {
                    this._copiedPins.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            this._copiedPinChannels[this._doc.channel] = this._copiedPins;
            this._stashCursorPinVols[this._doc.channel] = [];
            for (let pin = 0; pin < this._copiedPins.length; pin++) {
                this._stashCursorPinVols[this._doc.channel].push(this._copiedPins[pin].size);
            }
        }
        movePlayheadToMouse() {
            if (this._mouseOver) {
                this._doc.synth.playhead = this._doc.bar + this._barOffset + (this._mouseX / this._editorWidth);
                return true;
            }
            return false;
        }
        setModSettingsForChange(change, songEditor) {
            const thisRef = this;
            const timeQuantum = Math.max(4, (Config.partsPerBeat / Config.rhythms[this._doc.song.rhythm].stepsPerBeat));
            const currentBar = Math.floor(this._doc.synth.playhead);
            const realPart = this._doc.synth.getCurrentPart();
            let changedPatterns = false;
            const currentPart = (realPart < timeQuantum / 2) ? 0 : Math.ceil(realPart / timeQuantum) * timeQuantum;
            function getMatchingInstrumentAndMod(applyToMod, modChannel, modInsIndex, modFilterIndex, modEnvIndex) {
                let startIndex = (modInsIndex == undefined) ? 0 : modInsIndex;
                let endIndex = (modInsIndex == undefined) ? modChannel.instruments.length - 1 : modInsIndex;
                for (let instrumentIndex = startIndex; instrumentIndex <= endIndex; instrumentIndex++) {
                    let instrument = modChannel.instruments[instrumentIndex];
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        if (instrument.modulators[mod] == applyToMod && !Config.modulators[instrument.modulators[mod]].forSong && (instrument.modChannels[mod] == thisRef._doc.channel)) {
                            if (thisRef._doc.getCurrentInstrument() == instrument.modInstruments[mod]
                                || instrument.modInstruments[mod] >= thisRef._doc.song.channels[thisRef._doc.channel].instruments.length) {
                                if (modFilterIndex != undefined && (applyToMod == Config.modulators.dictionary["eq filter"].index || applyToMod == Config.modulators.dictionary["note filter"].index)) {
                                    if (instrument.modFilterTypes[mod] == modFilterIndex)
                                        return [instrumentIndex, mod];
                                }
                                else if (modEnvIndex != undefined && applyToMod == Config.modulators.dictionary["individual envelope speed"].index ||
                                    applyToMod == Config.modulators.dictionary["individual envelope lower bound"].index ||
                                    applyToMod == Config.modulators.dictionary["individual envelope upper bound"].index) {
                                    if (instrument.modEnvelopeNumbers[mod] == modEnvIndex)
                                        return [instrumentIndex, mod];
                                }
                                else
                                    return [instrumentIndex, mod];
                            }
                        }
                        else if (instrument.modulators[mod] == applyToMod && Config.modulators[instrument.modulators[mod]].forSong && (instrument.modChannels[mod] == -1)) {
                            if (modFilterIndex != undefined && (applyToMod == Config.modulators.dictionary["song eq"].index)) {
                                if (instrument.modFilterTypes[mod] == modFilterIndex)
                                    return [instrumentIndex, mod];
                            }
                            else
                                return [instrumentIndex, mod];
                        }
                    }
                }
                return [-1, -1];
            }
            function sanitizeInterval(doc, startPart, endPart, pattern, forMod, sequence) {
                if (startPart >= endPart)
                    return;
                for (let noteIndex = 0; noteIndex < pattern.notes.length; noteIndex++) {
                    const note = pattern.notes[noteIndex];
                    if (note.pitches[0] != forMod)
                        continue;
                    if (note.start < endPart && note.end > startPart) {
                        let couldIntersectStart = false;
                        let intersectsEnd = false;
                        let firstInteriorPin = -1;
                        let interiorPinCount = 0;
                        if (note.start <= startPart && note.end >= endPart) {
                            for (let pinIndex = 0; pinIndex < note.pins.length; pinIndex++) {
                                const pin = note.pins[pinIndex];
                                if (note.start + pin.time > startPart && note.start + pin.time < endPart) {
                                    if (firstInteriorPin < 0)
                                        firstInteriorPin = pinIndex;
                                    interiorPinCount++;
                                }
                            }
                            if (interiorPinCount > 0)
                                note.pins.splice(firstInteriorPin, interiorPinCount);
                            return;
                        }
                        for (let pinIndex = 0; pinIndex < note.pins.length; pinIndex++) {
                            const pin = note.pins[pinIndex];
                            if (note.start + pin.time >= startPart && note.start + pin.time <= endPart) {
                                if (firstInteriorPin < 0)
                                    firstInteriorPin = pinIndex;
                                interiorPinCount++;
                            }
                            else {
                                if (interiorPinCount == 0)
                                    couldIntersectStart = true;
                                if (interiorPinCount > 0)
                                    intersectsEnd = true;
                            }
                        }
                        if (couldIntersectStart && interiorPinCount > 0) {
                            note.pins[firstInteriorPin].time = startPart - note.start;
                            firstInteriorPin++;
                            interiorPinCount--;
                        }
                        if (intersectsEnd && interiorPinCount > 0) {
                            note.pins[firstInteriorPin + interiorPinCount - 1].time = endPart - note.start;
                            interiorPinCount--;
                        }
                        note.pins.splice(firstInteriorPin, interiorPinCount);
                        if (note.pins.length < 2) {
                            sequence.append(new ChangeNoteAdded(doc, pattern, note, noteIndex, true));
                            noteIndex--;
                            continue;
                        }
                        let timeAdjust = 0;
                        timeAdjust = note.pins[0].time;
                        note.start += timeAdjust;
                        for (let i = 0; i < note.pins.length; i++) {
                            note.pins[i].time -= timeAdjust;
                        }
                        note.end = note.start + note.pins[note.pins.length - 1].time;
                        if (note.end <= note.start) {
                            sequence.append(new ChangeNoteAdded(doc, pattern, note, noteIndex, true));
                            noteIndex--;
                        }
                    }
                }
            }
            const sequence = new ChangeSequence();
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            let applyToMods = [];
            let applyToFilterTargets = [];
            let applyToEnvelopeTargets = [];
            let applyValues = [];
            let toApply = true;
            let slider = null;
            if (change == null) {
                var modulator = Config.modulators.dictionary["song volume"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(this._doc.prefs.volume - modulator.convertRealFactor);
            }
            else if (this._doc.continuingModRecordingChange != null && this._doc.continuingModRecordingChange.storedChange == null && this._doc.continuingModRecordingChange.storedSlider == null) {
                var modulator = Config.modulators.dictionary["song volume"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(this._doc.continuingModRecordingChange.storedValues[0]);
            }
            else if (change instanceof ChangeTempo) {
                var modulator = Config.modulators.dictionary["tempo"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(this._doc.song.tempo - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    this._doc.song.tempo = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeSequence && change.checkFirst() instanceof ChangeSongFilterMovePoint && !change.isCommitted()) {
                const useChange = change.checkFirst();
                const preMoveData = useChange.getMoveData(true);
                const postMoveData = useChange.getMoveData(false);
                const song = this._doc.song;
                let useFilter = song.eqFilter;
                var modulatorIndex = Config.modulators.dictionary["song eq"].index;
                if (song.tmpEqFilterEnd == null) {
                    song.tmpEqFilterStart = new FilterSettings();
                    song.tmpEqFilterStart.fromJsonObject(song.eqFilter.toJsonObject());
                    song.tmpEqFilterEnd = song.tmpEqFilterStart;
                }
                const modifyPoint = song.tmpEqFilterEnd.controlPoints[useChange.pointIndex];
                if (modifyPoint != null && modifyPoint.type == useChange.pointType) {
                    modifyPoint.freq = postMoveData.freq;
                    modifyPoint.gain = postMoveData.gain;
                }
                applyToMods.push(modulatorIndex);
                applyToMods.push(modulatorIndex);
                if (toApply)
                    applyValues.push(postMoveData.freq);
                if (toApply)
                    applyValues.push(postMoveData.gain);
                applyToFilterTargets.push(1 + useChange.pointIndex * 2);
                applyToFilterTargets.push(1 + useChange.pointIndex * 2 + 1);
                for (let i = 0; i < useFilter.controlPointCount; i++) {
                    var point = useFilter.controlPoints[i];
                    if (Object.is(point, preMoveData.point)) {
                        point.freq = preMoveData.freq;
                        point.gain = preMoveData.gain;
                    }
                }
            }
            else if (change instanceof ChangeVolume) {
                var modulator = Config.modulators.dictionary["mix volume"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.volume - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null)
                    instrument.volume = slider.getValueBeforeProspectiveChange();
            }
            else if (change instanceof ChangePan) {
                var modulator = Config.modulators.dictionary["pan"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.pan - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.pan = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeReverb) {
                var modulator = Config.modulators.dictionary["reverb"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.reverb - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.reverb = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeDistortion) {
                var modulator = Config.modulators.dictionary["distortion"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.distortion - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.distortion = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeRingMod) {
                var modulator = Config.modulators.dictionary["ring modulation"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.ringModulation - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.ringModulation = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeRingModHz) {
                var modulator = Config.modulators.dictionary["ring mod hertz"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.ringModulationHz - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.ringModulationHz = slider.getValueBeforeProspectiveChange();
                    songEditor.ringModHzNum.innerHTML = "(" + instrument.ringModulationHz + ")";
                }
            }/*else if (change instanceof ChangeRingModHz) {
	var modulator = Config.modulators.dictionary["unisonExpression"];
	applyToMods.push(modulator.index);
	if (toApply)
		applyValues.push(instrument.unisonExpression - modulator.convertRealFactor);
	slider = songEditor.getSliderForModSetting(modulator.index);
	if (slider != null) {
		instrument.unisonExpression = slider.getValueBeforeProspectiveChange();
	}
}*/
            else if (change instanceof ChangeGranular) {
                var modulator = Config.modulators.dictionary["granular"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.granular - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.granular = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeGrainAmounts) {
                var modulator = Config.modulators.dictionary["grain freq"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.grainAmounts - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.grainAmounts = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeGrainSize) {
                var modulator = Config.modulators.dictionary["grain size"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.grainSize - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.grainSize = slider.getValueBeforeProspectiveChange();
                    songEditor.grainSizeNum.innerHTML = "(" + (instrument.grainSize * Config.grainSizeStep) + ")";
                }
            }
            else if (change instanceof ChangeGrainRange) {
                var modulator = Config.modulators.dictionary["grain range"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.grainRange - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.grainRange = slider.getValueBeforeProspectiveChange();
                    songEditor.grainRangeNum.innerHTML = "(" + (instrument.grainRange * Config.grainSizeStep) + ")";
                }
            }
            else if (change instanceof ChangeOperatorAmplitude) {
                var modulator = Config.modulators.dictionary["fm slider " + (change.operatorIndex + 1)];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.operators[change.operatorIndex].amplitude - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.operators[change.operatorIndex].amplitude = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeFeedbackAmplitude) {
                var modulator = Config.modulators.dictionary["fm feedback"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.feedbackAmplitude - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.feedbackAmplitude = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangePulseWidth) {
                var modulator = Config.modulators.dictionary["pulse width"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.pulseWidth - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.pulseWidth = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeDecimalOffset) {
                var modulator = Config.modulators.dictionary["decimal offset"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.decimalOffset - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.decimalOffset = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeDetune) {
                var modulator = Config.modulators.dictionary["detune"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.detune - modulator.convertRealFactor - Config.detuneCenter);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.detune = slider.getValueBeforeProspectiveChange() + Config.detuneCenter;
                }
            }
            else if (change instanceof ChangeVibratoDepth) {
                var modulator = Config.modulators.dictionary["vibrato depth"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.vibratoDepth * 25 - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.vibratoDepth = slider.getValueBeforeProspectiveChange() / 25;
                }
            }
            else if (change instanceof ChangeVibratoSpeed) {
                var modulator = Config.modulators.dictionary["vibrato speed"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.vibratoSpeed - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.vibratoSpeed = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeVibratoDelay) {
                var modulator = Config.modulators.dictionary["vibrato delay"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.vibratoDelay - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.vibratoDelay = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeArpeggioSpeed) {
                var modulator = Config.modulators.dictionary["arp speed"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.arpeggioSpeed - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.arpeggioSpeed = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangePanDelay) {
                var modulator = Config.modulators.dictionary["pan delay"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.panDelay - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.panDelay = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeSequence && change.checkFirst() instanceof ChangeFilterMovePoint && !change.isCommitted()) {
                const useChange = change.checkFirst();
                const preMoveData = useChange.getMoveData(true);
                const postMoveData = useChange.getMoveData(false);
                let useFilter = instrument.eqFilter;
                let modulatorIndex;
                if (useChange.useNoteFilter) {
                    modulatorIndex = Config.modulators.dictionary["note filter"].index;
                    useFilter = instrument.noteFilter;
                    if (instrument.tmpNoteFilterEnd == null) {
                        instrument.tmpNoteFilterStart = new FilterSettings();
                        instrument.tmpNoteFilterStart.fromJsonObject(instrument.noteFilter.toJsonObject());
                        instrument.tmpNoteFilterEnd = instrument.tmpNoteFilterStart;
                    }
                    const modifyPoint = instrument.tmpNoteFilterEnd.controlPoints[useChange.pointIndex];
                    if (modifyPoint != null && modifyPoint.type == useChange.pointType) {
                        modifyPoint.freq = postMoveData.freq;
                        modifyPoint.gain = postMoveData.gain;
                    }
                }
                else {
                    modulatorIndex = Config.modulators.dictionary["eq filter"].index;
                    if (instrument.tmpEqFilterEnd == null) {
                        instrument.tmpEqFilterStart = new FilterSettings();
                        instrument.tmpEqFilterStart.fromJsonObject(instrument.eqFilter.toJsonObject());
                        instrument.tmpEqFilterEnd = instrument.tmpEqFilterStart;
                    }
                    const modifyPoint = instrument.tmpEqFilterEnd.controlPoints[useChange.pointIndex];
                    if (modifyPoint != null && modifyPoint.type == useChange.pointType) {
                        modifyPoint.freq = postMoveData.freq;
                        modifyPoint.gain = postMoveData.gain;
                    }
                }
                applyToMods.push(modulatorIndex);
                applyToMods.push(modulatorIndex);
                if (toApply)
                    applyValues.push(postMoveData.freq);
                if (toApply)
                    applyValues.push(postMoveData.gain);
                applyToFilterTargets.push(1 + useChange.pointIndex * 2);
                applyToFilterTargets.push(1 + useChange.pointIndex * 2 + 1);
                for (let i = 0; i < useFilter.controlPointCount; i++) {
                    var point = useFilter.controlPoints[i];
                    if (Object.is(point, preMoveData.point)) {
                        point.freq = preMoveData.freq;
                        point.gain = preMoveData.gain;
                    }
                }
            }
            else if (change instanceof ChangeBitcrusherQuantization) {
                var modulator = Config.modulators.dictionary["bit crush"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.bitcrusherQuantization - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.bitcrusherQuantization = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeBitcrusherFreq) {
                var modulator = Config.modulators.dictionary["freq crush"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.bitcrusherFreq - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.bitcrusherFreq = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeEchoSustain) {
                var modulator = Config.modulators.dictionary["echo"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.echoSustain - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.echoSustain = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeChorus) {
                var modulator = Config.modulators.dictionary["chorus"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.chorus - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.chorus = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeEQFilterSimpleCut) {
                var modulator = Config.modulators.dictionary["eq filt cut"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.eqFilterSimpleCut - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.eqFilterSimpleCut = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeEQFilterSimplePeak) {
                var modulator = Config.modulators.dictionary["eq filt peak"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.eqFilterSimplePeak - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.eqFilterSimplePeak = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeNoteFilterSimpleCut) {
                var modulator = Config.modulators.dictionary["note filt cut"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.noteFilterSimpleCut - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.noteFilterSimpleCut = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeNoteFilterSimplePeak) {
                var modulator = Config.modulators.dictionary["note filt peak"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.noteFilterSimplePeak - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.noteFilterSimplePeak = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangePitchShift) {
                var modulator = Config.modulators.dictionary["pitch shift"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.pitchShift - Config.pitchShiftCenter - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.pitchShift = slider.getValueBeforeProspectiveChange();
                }
            }else if (change instanceof ChangeOctaveShift) {
                var modulator = Config.modulators.dictionary["octave shift"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.octaveShift - Config.pitchShiftCenter - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.octaveShift = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeStringSustain) {
                var modulator = Config.modulators.dictionary["sustain"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.stringSustain - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.stringSustain = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeEnvelopeSpeed) {
                var modulator = Config.modulators.dictionary["envelope speed"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.envelopeSpeed - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.envelopeSpeed = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeSupersawDynamism) {
                var modulator = Config.modulators.dictionary["dynamism"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.supersawDynamism - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.supersawDynamism = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeSupersawSpread) {
                var modulator = Config.modulators.dictionary["spread"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.supersawSpread - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.supersawSpread = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangeSupersawShape) {
                var modulator = Config.modulators.dictionary["saw shape"];
                applyToMods.push(modulator.index);
                if (toApply)
                    applyValues.push(instrument.supersawShape - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index);
                if (slider != null) {
                    instrument.supersawShape = slider.getValueBeforeProspectiveChange();
                }
            }
            else if (change instanceof ChangePerEnvelopeSpeed) {
                var modulator = Config.modulators.dictionary["individual envelope speed"];
                applyToMods.push(modulator.index);
                const envelopeIndex = change.getIndex();
                if (toApply)
                    applyValues.push(EnvelopeEditor.convertIndexSpeed(instrument.envelopes[envelopeIndex].perEnvelopeSpeed, "index") - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index, envelopeIndex);
                if (slider != null) {
                    instrument.envelopes[envelopeIndex].perEnvelopeSpeed = EnvelopeEditor.convertIndexSpeed(slider.getValueBeforeProspectiveChange(), "speed");
                }
                applyToEnvelopeTargets.push(envelopeIndex);
            }
            else if (change instanceof ChangeEnvelopeLowerBound) {
                var modulator = Config.modulators.dictionary["individual envelope lower bound"];
                applyToMods.push(modulator.index);
                const envelopeIndex = change.getIndex();
                if (toApply)
                    applyValues.push(instrument.envelopes[envelopeIndex].perEnvelopeLowerBound * 10 - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index, envelopeIndex);
                if (slider != null) {
                    instrument.envelopes[envelopeIndex].perEnvelopeLowerBound = slider.getValueBeforeProspectiveChange();
                }
                applyToEnvelopeTargets.push(envelopeIndex);
            }
            else if (change instanceof ChangeEnvelopeUpperBound) {
                var modulator = Config.modulators.dictionary["individual envelope upper bound"];
                applyToMods.push(modulator.index);
                const envelopeIndex = change.getIndex();
                if (toApply)
                    applyValues.push(instrument.envelopes[envelopeIndex].perEnvelopeUpperBound * 10 - modulator.convertRealFactor);
                slider = songEditor.getSliderForModSetting(modulator.index, envelopeIndex);
                if (slider != null) {
                    instrument.envelopes[envelopeIndex].perEnvelopeUpperBound = slider.getValueBeforeProspectiveChange();
                }
                applyToEnvelopeTargets.push(envelopeIndex);
            }
            for (let applyIndex = 0; applyIndex < applyValues.length; applyIndex++) {
                applyValues[applyIndex] = Math.round(applyValues[applyIndex]);
            }
            if (this._doc.continuingModRecordingChange != null && applyToFilterTargets.length == 0) {
                if (slider == null && this._doc.continuingModRecordingChange.storedSlider != null)
                    slider = this._doc.continuingModRecordingChange.storedSlider;
                if (slider != null && +slider.input.value == slider.getValueBeforeProspectiveChange()) {
                    applyValues = this._doc.continuingModRecordingChange.storedValues;
                    toApply = false;
                }
                this._doc.continuingModRecordingChange = null;
            }
            if (slider != null)
                slider.updateValue(slider.getValueBeforeProspectiveChange());
            for (let applyIndex = 0; applyIndex < applyToMods.length; applyIndex++) {
                let usedPatterns = [];
                let usedInstruments = [];
                let usedInstrumentIndices = [];
                let usedModIndices = [];
                for (let channelIndex = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex < this._doc.song.getChannelCount(); channelIndex++) {
                    const channel = this._doc.song.channels[channelIndex];
                    let pattern = this._doc.song.getPattern(channelIndex, currentBar);
                    let useInstrumentIndex = 0;
                    let useModIndex = 0;
                    if (pattern == null) {
                        var rtn;
                        if (applyToFilterTargets.length > applyIndex)
                            rtn = getMatchingInstrumentAndMod(applyToMods[applyIndex], channel, undefined, applyToFilterTargets[applyIndex]);
                        else if (applyToEnvelopeTargets.length > applyIndex)
                            rtn = getMatchingInstrumentAndMod(applyToMods[applyIndex], channel, undefined, undefined, applyToEnvelopeTargets[applyIndex]);
                        else
                            rtn = getMatchingInstrumentAndMod(applyToMods[applyIndex], channel);
                        useInstrumentIndex = rtn[0];
                        useModIndex = rtn[1];
                        if (useInstrumentIndex != -1) {
                            sequence.append(new ChangeEnsurePatternExists(this._doc, channelIndex, currentBar));
                            new ChangeDuplicateSelectedReusedPatterns(this._doc, currentBar, 1, channelIndex, 1, false);
                            pattern = this._doc.song.getPattern(channelIndex, currentBar);
                            pattern.instruments[0] = useInstrumentIndex;
                            changedPatterns = true;
                        }
                    }
                    else {
                        var rtn;
                        if (applyToFilterTargets.length > applyIndex)
                            rtn = getMatchingInstrumentAndMod(applyToMods[applyIndex], channel, pattern.instruments[0], applyToFilterTargets[applyIndex]);
                        else if (applyToEnvelopeTargets.length > applyIndex)
                            rtn = getMatchingInstrumentAndMod(applyToMods[applyIndex], channel, pattern.instruments[0], undefined, applyToEnvelopeTargets[applyIndex]);
                        else
                            rtn = getMatchingInstrumentAndMod(applyToMods[applyIndex], channel, pattern.instruments[0]);
                        useInstrumentIndex = rtn[0];
                        useModIndex = rtn[1];
                        if (useInstrumentIndex != -1) {
                            new ChangeDuplicateSelectedReusedPatterns(this._doc, currentBar, 1, channelIndex, 1, false);
                            pattern = this._doc.song.getPattern(channelIndex, currentBar);
                            changedPatterns = true;
                        }
                    }
                    if (useInstrumentIndex != -1) {
                        usedPatterns.push(pattern);
                        usedInstrumentIndices.push(useInstrumentIndex);
                        usedInstruments.push(channel.instruments[useInstrumentIndex]);
                        usedModIndices.push(useModIndex);
                    }
                }
                if (usedInstrumentIndices.length == 0) {
                    for (let channelIndex = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount; channelIndex < this._doc.song.getChannelCount(); channelIndex++) {
                        const channel = this._doc.song.channels[channelIndex];
                        let pattern = this._doc.song.getPattern(channelIndex, currentBar);
                        let useInstrument = -1;
                        if (pattern != null) {
                            useInstrument = pattern.instruments[0];
                        }
                        else {
                            for (let instrumentIndex = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {
                                for (let mod = 0; mod < Config.modCount; mod++) {
                                    if (channel.instruments[instrumentIndex].modulators[mod] == Config.modulators.dictionary["none"].index) {
                                        useInstrument = instrumentIndex;
                                        sequence.append(new ChangeEnsurePatternExists(this._doc, channelIndex, currentBar));
                                        pattern = this._doc.song.getPattern(channelIndex, currentBar);
                                        pattern.instruments[0] = instrumentIndex;
                                        mod = Config.modCount;
                                        instrumentIndex = channel.instruments.length;
                                        channelIndex = this._doc.song.getChannelCount();
                                        changedPatterns = true;
                                    }
                                }
                            }
                        }
                        if (useInstrument != -1) {
                            let instrument = channel.instruments[useInstrument];
                            for (let mod = 0; mod < Config.modCount; mod++) {
                                if (instrument.modulators[mod] == Config.modulators.dictionary["none"].index) {
                                    instrument.modulators[mod] = applyToMods[applyIndex];
                                    if (Config.modulators[applyToMods[applyIndex]].forSong) {
                                        if (applyToFilterTargets.length > applyIndex) {
                                            instrument.modFilterTypes[mod] = applyToFilterTargets[applyIndex];
                                        }
                                        instrument.modChannels[mod] = -1;
                                    }
                                    else {
                                        instrument.modChannels[mod] = this._doc.channel;
                                        if (this._doc.song.channels[this._doc.channel].instruments.length > 1) {
                                            if (!this.controlMode || !this.shiftMode)
                                                instrument.modInstruments[mod] = this._doc.song.channels[this._doc.channel].instruments.length + 1;
                                            else
                                                instrument.modInstruments[mod] = this._doc.getCurrentInstrument();
                                        }
                                        else
                                            instrument.modInstruments[mod] = 0;
                                        if (applyToFilterTargets.length > applyIndex) {
                                            instrument.modFilterTypes[mod] = applyToFilterTargets[applyIndex];
                                        }
                                        else if (applyToEnvelopeTargets.length > applyIndex)
                                            instrument.modEnvelopeNumbers[mod] = applyToEnvelopeTargets[applyIndex];
                                    }
                                    usedPatterns.push(pattern);
                                    usedInstrumentIndices.push(useInstrument);
                                    usedInstruments.push(instrument);
                                    usedModIndices.push(mod);
                                    mod = Config.modCount;
                                    channelIndex = this._doc.song.getChannelCount();
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < usedPatterns.length; i++) {
                    const addLength = (applyToFilterTargets.length == 0) ? 0 : 24;
                    const newNoteDist = +(timeQuantum >= 6) * 6 + 12;
                    let latestPart = -1;
                    let latestNote = null;
                    let latestPin = null;
                    let latestPinIdx = -1;
                    let prevNotePart = -1;
                    let prevNote = null;
                    const modNoteIndex = Config.modCount - 1 - usedModIndices[i];
                    const usedInstrument = usedInstruments[i];
                    if (usedInstrument.modChannels[usedModIndices[i]] >= -1) {
                        let usedNewInstrumentIndices = [];
                        if (Config.modulators[applyToMods[applyIndex]].forSong) {
                            usedNewInstrumentIndices.push(0);
                        }
                        else {
                            if (usedInstrument.modInstruments[usedModIndices[i]] == this._doc.synth.song.channels[usedInstrument.modChannels[usedModIndices[i]]].instruments.length) {
                                for (let k = 0; k < this._doc.synth.song.channels[usedInstrument.modChannels[usedModIndices[i]]].instruments.length; k++) {
                                    usedNewInstrumentIndices.push(k);
                                }
                            }
                            else if (usedInstrument.modInstruments[usedModIndices[i]] > this._doc.synth.song.channels[usedInstrument.modChannels[usedModIndices[i]]].instruments.length) {
                                if (this._doc.synth.song.getPattern(usedInstrument.modChannels[usedModIndices[i]], currentBar) != null)
                                    usedNewInstrumentIndices = this._doc.synth.song.getPattern(usedInstrument.modChannels[usedModIndices[i]], currentBar).instruments;
                            }
                            else {
                                usedNewInstrumentIndices.push(usedInstrument.modInstruments[usedModIndices[i]]);
                            }
                        }
                        for (let instrumentIndex = 0; instrumentIndex < usedNewInstrumentIndices.length; instrumentIndex++) {
                            this._doc.synth.setModValue(applyValues[applyIndex], applyValues[applyIndex], usedInstruments[i].modChannels[usedModIndices[i]], usedNewInstrumentIndices[instrumentIndex], applyToMods[applyIndex]);
                            this._doc.synth.forceHoldMods(applyValues[applyIndex], usedInstruments[i].modChannels[usedModIndices[i]], usedNewInstrumentIndices[instrumentIndex], applyToMods[applyIndex]);
                        }
                    }
                    for (let j = 0; j < usedPatterns[i].notes.length; j++) {
                        const note = usedPatterns[i].notes[j];
                        if (note.pitches[0] == modNoteIndex && note.start <= currentPart) {
                            for (let pinIdx = 0; pinIdx < note.pins.length; pinIdx++) {
                                const pin = note.pins[pinIdx];
                                if (note.start + pin.time <= currentPart && (note.start + pin.time > latestPart || (note.start == latestPart))) {
                                    latestPart = note.start + pin.time;
                                    latestPin = pin;
                                    latestPinIdx = pinIdx;
                                    latestNote = note;
                                }
                            }
                        }
                        if (note.pitches[0] == modNoteIndex && note.end <= currentPart && note.end > prevNotePart) {
                            prevNotePart = note.end;
                            prevNote = note;
                        }
                    }
                    let prevPart = Math.max(0, currentPart - timeQuantum);
                    let endPart = Math.min(currentPart + timeQuantum + addLength, Config.partsPerBeat * this._doc.song.beatsPerBar);
                    let continuous = (toApply == false);
                    if (latestNote == null || currentPart - latestNote.end >= newNoteDist) {
                        if (currentPart == endPart)
                            continue;
                        sanitizeInterval(this._doc, currentPart, endPart, usedPatterns[i], modNoteIndex, sequence);
                        latestNote = new Note(modNoteIndex, currentPart, endPart, applyValues[applyIndex], this._doc.song.getChannelIsNoise(this._doc.channel));
                        sequence.append(new ChangeNoteAdded(this._doc, usedPatterns[i], latestNote, usedPatterns[i].notes.length));
                    }
                    else if (latestPart == currentPart) {
                        sanitizeInterval(this._doc, prevPart, currentPart, usedPatterns[i], modNoteIndex, sequence);
                        sanitizeInterval(this._doc, currentPart, endPart, usedPatterns[i], modNoteIndex, sequence);
                        latestPin.size = applyValues[applyIndex];
                        if (continuous) {
                            for (let usePin = 0; usePin < latestNote.pins.length; usePin++) {
                                if (latestNote.pins[usePin].time >= prevPart && latestNote.pins[usePin].time <= currentPart)
                                    latestNote.pins[usePin].size = applyValues[applyIndex];
                            }
                        }
                        if (prevNote != null && prevNote.pins.length >= 2) {
                            if (prevNote.end == currentPart) {
                                prevNote.pins[prevNote.pins.length - 1].size = applyValues[applyIndex];
                                if (continuous) {
                                    for (let usePin = 0; usePin < prevNote.pins.length; usePin++) {
                                        if (prevNote.pins[usePin].time + prevNote.start >= prevPart)
                                            prevNote.pins[usePin].size = applyValues[applyIndex];
                                    }
                                }
                            }
                            else if (prevNote.end == prevPart && latestNote.start == currentPart) {
                                prevNote.pins.push(makeNotePin(0, currentPart - prevNote.start, applyValues[applyIndex]));
                                prevNote.end = currentPart;
                            }
                        }
                    }
                    else if (currentPart - latestPart < 8 && latestNote.pins[latestPinIdx].size == applyValues[applyIndex]) {
                        if (continuous) {
                            for (let usePin = 0; usePin < latestNote.pins.length; usePin++) {
                                if (latestNote.pins[usePin].time >= prevPart && latestNote.pins[usePin].time <= currentPart)
                                    latestNote.pins[usePin].size = applyValues[applyIndex];
                            }
                        }
                    }
                    else {
                        if (latestNote.pins.length - 1 > latestPinIdx) {
                            sanitizeInterval(this._doc, prevPart, currentPart, usedPatterns[i], modNoteIndex, sequence);
                            sanitizeInterval(this._doc, currentPart, endPart, usedPatterns[i], modNoteIndex, sequence);
                            let k;
                            let usePin = null;
                            for (k = 0; k < latestNote.pins.length; k++) {
                                if (latestNote.pins[k].time == currentPart - latestNote.start) {
                                    usePin = latestNote.pins[k];
                                    break;
                                }
                                else if (latestNote.pins[k].time > currentPart - latestNote.start)
                                    break;
                            }
                            if (usePin != null)
                                usePin.size = applyValues[applyIndex];
                            else
                                latestNote.pins.splice(k, 0, makeNotePin(0, currentPart - latestNote.start, applyValues[applyIndex]));
                        }
                        else {
                            sanitizeInterval(this._doc, prevPart, currentPart, usedPatterns[i], modNoteIndex, sequence);
                            sanitizeInterval(this._doc, currentPart, endPart, usedPatterns[i], modNoteIndex, sequence);
                            latestNote.pins.push(makeNotePin(0, currentPart - latestNote.start, applyValues[applyIndex]));
                            latestNote.end = currentPart;
                        }
                        if (continuous) {
                            for (let usePin = 0; usePin < latestNote.pins.length; usePin++) {
                                if (latestNote.pins[usePin].time >= prevPart && latestNote.pins[usePin].time <= currentPart)
                                    latestNote.pins[usePin].size = applyValues[applyIndex];
                            }
                        }
                    }
                    let lastNoteEnds = [-1, -1, -1, -1, -1, -1];
                    usedPatterns[i].notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                    for (let checkIndex = 0; checkIndex < usedPatterns[i].notes.length; checkIndex++) {
                        const note = usedPatterns[i].notes[checkIndex];
                        if (note.start < lastNoteEnds[note.pitches[0]])
                            throw new Error("Error in mod note recording!");
                        lastNoteEnds[note.pitches[0]] = note.end;
                        if (note.pins.length < 2 || note.pins[0].time > 0 || note.start == note.end
                            || note.pins[note.pins.length - 1].time != note.end - note.start) {
                            throw new Error("Error in mod note recording!");
                        }
                        let latestPinTime = -1;
                        for (let k = 0; k < note.pins.length; k++) {
                            if (note.pins[k].time <= latestPinTime) {
                                throw new Error("Error in mod note recording!");
                            }
                            latestPinTime = note.pins[k].time;
                        }
                    }
                }
            }
            if (this._doc.channel >= this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount) {
                this._doc.currentPatternIsDirty = true;
            }
            if (applyValues.length > 0) {
                this._doc.continuingModRecordingChange = new ChangeHoldingModRecording(this._doc, change, applyValues, slider);
            }
            return changedPatterns;
        }
        stopEditingModLabel(discardChanges) {
            if (this.editingModLabel) {
                this.editingModLabel = false;
                this.modDragValueLabel.style.setProperty("pointer-events", "none");
                if (window.getSelection) {
                    let sel = window.getSelection();
                    if (sel != null)
                        sel.removeAllRanges();
                }
                if (discardChanges) {
                    this._modDragPin.size = this._modDragStartValue;
                    let presValue = this._modDragStartValue + Config.modulators[this._modDragSetting].convertRealFactor;
                    let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                    this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * (this._modDragNote.start + this._modDragPin.time) - 4 - xOffset * 4), 2));
                    this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                    const sequence = new ChangeSequence();
                    this._dragChange = sequence;
                    this._doc.setProspectiveChange(this._dragChange);
                    sequence.append(new ChangeSizeBend(this._doc, this._modDragNote, this._modDragPin.time, this._modDragStartValue, this._modDragPin.interval, this.shiftMode));
                    this._dragChange = null;
                }
                const continuousState = this._doc.lastChangeWas(this._dragChange);
                if (continuousState) {
                    if (this._dragChange != null) {
                        this._doc.record(this._dragChange);
                        this._dragChange = null;
                    }
                }
            }
        }
        _whenCursorPressed() {
            if (this._doc.song.getChannelIsMod(this._doc.channel) && this.modDragValueLabel.style.getPropertyValue("display") != "none" &&
                this._mouseX > +this._modDragValueLabelLeft - 6 &&
                this._mouseX < +this._modDragValueLabelLeft + this._modDragValueLabelWidth + 6 &&
                this._mouseY > +this._modDragValueLabelTop - 8 &&
                this._mouseY < +this._modDragValueLabelTop + 11) {
                this.modDragValueLabel.style.setProperty("pointer-events", "fill");
                this.modDragValueLabel.setAttribute("contenteditable", "true");
                if (window.getSelection) {
                    let sel = window.getSelection();
                    if (sel != null)
                        sel.selectAllChildren(this.modDragValueLabel);
                }
                window.setTimeout(() => { this.modDragValueLabel.focus(); });
                this.editingModLabel = true;
            }
            else {
                this.stopEditingModLabel(false);
                if (this._doc.prefs.enableNotePreview)
                    this._doc.synth.maintainLiveInput();
                this._mouseDown = true;
                this._mouseXStart = this._mouseX;
                this._mouseYStart = this._mouseY;
                this._updateCursorStatus();
                this._updatePreview();
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._lastChangeWasPatternSelection = this._doc.lastChangeWas(this._changePatternSelection);
                this._doc.setProspectiveChange(this._dragChange);
                if (this._cursorAtStartOfSelection()) {
                    this._draggingStartOfSelection = true;
                }
                else if (this._cursorAtEndOfSelection()) {
                    this._draggingEndOfSelection = true;
                }
                else if (this._shiftHeld) {
                    if ((this._doc.selection.patternSelectionActive && this._cursor.pitchIndex == -1) || this._cursorIsInSelection()) {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                    }
                    else {
                        if (this._cursor.curNote != null) {
                            sequence.append(new ChangePatternSelection(this._doc, this._cursor.curNote.start, this._cursor.curNote.end));
                        }
                        else {
                            const start = Math.max(0, Math.min((this._doc.song.beatsPerBar - 1) * Config.partsPerBeat, Math.floor(this._cursor.exactPart / Config.partsPerBeat) * Config.partsPerBeat));
                            const end = start + Config.partsPerBeat;
                            sequence.append(new ChangePatternSelection(this._doc, start, end));
                        }
                    }
                }
                else if (this._cursorIsInSelection()) {
                    this._draggingSelectionContents = true;
                }
                else if (this._cursor.valid && this._cursor.curNote == null) {
                    sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                    const note = new Note(this._cursor.pitch, this._cursor.start, this._cursor.end, Config.noteSizeMax, this._doc.song.getChannelIsNoise(this._doc.channel));
                    note.pins = [];
                    for (const oldPin of this._cursor.pins) {
                        note.pins.push(makeNotePin(0, oldPin.time, oldPin.size));
                    }
                    sequence.append(new ChangeEnsurePatternExists(this._doc, this._doc.channel, this._doc.bar));
                    const pattern = this._doc.getCurrentPattern(this._barOffset);
                    if (pattern == null)
                        throw new Error();
                    sequence.append(new ChangeNoteAdded(this._doc, pattern, note, this._cursor.curIndex));
                    if (this._doc.prefs.enableNotePreview && !this._doc.synth.playing) {
                        const duration = Math.min(Config.partsPerBeat, this._cursor.end - this._cursor.start);
                        this._doc.performance.setTemporaryPitches([this._cursor.pitch], duration);
                    }
                }
                this._updateSelection();
            }
        }
        _whenCursorMoved() {
            if (this._doc.prefs.enableNotePreview && this._mouseOver)
                this._doc.synth.maintainLiveInput();
            const continuousState = this._doc.lastChangeWas(this._dragChange);
            if (!this._mouseDragging && this._mouseDown && this._cursor.valid && continuousState) {
                const dx = this._mouseX - this._mouseXStart;
                const dy = this._mouseY - this._mouseYStart;
                if (Math.sqrt(dx * dx + dy * dy) > 5) {
                    this._mouseDragging = true;
                    this._mouseHorizontal = Math.abs(dx) >= Math.abs(dy);
                }
            }
            if (this._shiftHeld && this._mouseHorizontal && Math.abs(this._mouseXStart - this._mouseX) > 5) {
                this._dragConfirmed = true;
            }
            if (this._mouseDragging && this._mouseDown && this._cursor.valid && continuousState) {
                this._dragChange.undo();
                const sequence = new ChangeSequence();
                this._dragChange = sequence;
                this._doc.setProspectiveChange(this._dragChange);
                const minDivision = this._getMinDivision();
                const currentPart = this._snapToMinDivision(this._mouseX / this._partWidth);
                if (this._draggingStartOfSelection) {
                    sequence.append(new ChangePatternSelection(this._doc, Math.max(0, Math.min(this._doc.song.beatsPerBar * Config.partsPerBeat, currentPart)), this._doc.selection.patternSelectionEnd));
                    this._updateSelection();
                }
                else if (this._draggingEndOfSelection) {
                    sequence.append(new ChangePatternSelection(this._doc, this._doc.selection.patternSelectionStart, Math.max(0, Math.min(this._doc.song.beatsPerBar * Config.partsPerBeat, currentPart))));
                    this._updateSelection();
                }
                else if (this._draggingSelectionContents) {
                    const pattern = this._doc.getCurrentPattern(this._barOffset);
                    if (this._mouseDragging && pattern != null) {
                        this._dragChange.undo();
                        const sequence = new ChangeSequence();
                        this._dragChange = sequence;
                        this._doc.setProspectiveChange(this._dragChange);
                        let scale = this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
                        const notesInScale = scale.filter(x => x).length;
                        const pitchRatio = this._doc.song.getChannelIsNoise(this._doc.channel) ? 1 : 12 / notesInScale;
                        const draggedParts = Math.round((this._mouseX - this._mouseXStart) / (this._partWidth * minDivision)) * minDivision;
                        const draggedTranspose = Math.round((this._mouseYStart - this._mouseY) / (this._pitchHeight * pitchRatio));
                        sequence.append(new ChangeDragSelectedNotes(this._doc, this._doc.channel, pattern, draggedParts, draggedTranspose));
                    }
                }
                else if (this._shiftHeld && this._dragConfirmed) {
                    if (this._mouseDragging) {
                        let start = Math.max(0, Math.min((this._doc.song.beatsPerBar - 1) * Config.partsPerBeat, Math.floor(this._cursor.exactPart / Config.partsPerBeat) * Config.partsPerBeat));
                        let end = start + Config.partsPerBeat;
                        if (this._cursor.curNote != null) {
                            start = Math.max(start, this._cursor.curNote.start);
                            end = Math.min(end, this._cursor.curNote.end);
                        }
                        if (currentPart < start) {
                            start = 0;
                            const pattern = this._doc.getCurrentPattern(this._barOffset);
                            if (pattern != null) {
                                for (let i = 0; i < pattern.notes.length; i++) {
                                    if (pattern.notes[i].start <= currentPart) {
                                        start = pattern.notes[i].start;
                                    }
                                    if (pattern.notes[i].end <= currentPart) {
                                        start = pattern.notes[i].end;
                                    }
                                }
                            }
                            for (let beat = 0; beat <= this._doc.song.beatsPerBar; beat++) {
                                const part = beat * Config.partsPerBeat;
                                if (start <= part && part <= currentPart) {
                                    start = part;
                                }
                            }
                        }
                        if (currentPart > end) {
                            end = Config.partsPerBeat * this._doc.song.beatsPerBar;
                            const pattern = this._doc.getCurrentPattern(this._barOffset);
                            if (pattern != null) {
                                for (let i = 0; i < pattern.notes.length; i++) {
                                    if (pattern.notes[i].start >= currentPart) {
                                        end = pattern.notes[i].start;
                                        break;
                                    }
                                    if (pattern.notes[i].end >= currentPart) {
                                        end = pattern.notes[i].end;
                                        break;
                                    }
                                }
                            }
                            for (let beat = 0; beat <= this._doc.song.beatsPerBar; beat++) {
                                const part = beat * Config.partsPerBeat;
                                if (currentPart < part && part < end) {
                                    end = part;
                                }
                            }
                        }
                        sequence.append(new ChangePatternSelection(this._doc, start, end));
                        this._updateSelection();
                    }
                }
                else {
                    if (this._cursor.curNote == null) {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        let backwards;
                        let directLength;
                        if (currentPart < this._cursor.start) {
                            backwards = true;
                            directLength = this._cursor.start - currentPart;
                        }
                        else {
                            backwards = false;
                            directLength = currentPart - this._cursor.start + minDivision;
                        }
                        let defaultLength = minDivision;
                        for (let i = minDivision; i <= this._doc.song.beatsPerBar * Config.partsPerBeat; i += minDivision) {
                            if (minDivision == 1) {
                                if (i < 5) ;
                                else if (i <= Config.partsPerBeat / 2.0) {
                                    if (i % 3 != 0 && i % 4 != 0) {
                                        continue;
                                    }
                                }
                                else if (i <= Config.partsPerBeat * 1.5) {
                                    if (i % 6 != 0 && i % 8 != 0) {
                                        continue;
                                    }
                                }
                                else if (i % Config.partsPerBeat != 0) {
                                    continue;
                                }
                            }
                            else {
                                if (i >= 5 * minDivision &&
                                    i % Config.partsPerBeat != 0 &&
                                    i != Config.partsPerBeat * 3.0 / 4.0 &&
                                    i != Config.partsPerBeat * 3.0 / 2.0 &&
                                    i != Config.partsPerBeat * 4.0 / 3.0) {
                                    continue;
                                }
                            }
                            const blessedLength = i;
                            if (blessedLength == directLength) {
                                defaultLength = blessedLength;
                                break;
                            }
                            if (blessedLength < directLength) {
                                defaultLength = blessedLength;
                            }
                            if (blessedLength > directLength) {
                                if (defaultLength < directLength - minDivision) {
                                    defaultLength = blessedLength;
                                }
                                break;
                            }
                        }
                        let start;
                        let end;
                        if (backwards) {
                            end = this._cursor.start;
                            start = end - defaultLength;
                        }
                        else {
                            start = this._cursor.start;
                            end = start + defaultLength;
                        }
                        const continuesLastPattern = (start < 0 && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount);
                        if (start < 0)
                            start = 0;
                        if (end > this._doc.song.beatsPerBar * Config.partsPerBeat)
                            end = this._doc.song.beatsPerBar * Config.partsPerBeat;
                        if (start < end) {
                            sequence.append(new ChangeEnsurePatternExists(this._doc, this._doc.channel, this._doc.bar));
                            const pattern = this._doc.getCurrentPattern(this._barOffset);
                            if (pattern == null)
                                throw new Error();
                            sequence.append(new ChangeNoteTruncate(this._doc, pattern, start, end, new Note(this._cursor.pitch, 0, 0, 0)));
                            let i;
                            for (i = 0; i < pattern.notes.length; i++) {
                                if (pattern.notes[i].start >= end)
                                    break;
                            }
                            const theNote = new Note(this._cursor.pitch, start, end, this._doc.song.getNewNoteVolume(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), this._cursor.pitch), this._doc.song.getChannelIsNoise(this._doc.channel));
                            theNote.continuesLastPattern = continuesLastPattern;
                            sequence.append(new ChangeNoteAdded(this._doc, pattern, theNote, i));
                            this._copyPins(theNote);
                            this._dragTime = backwards ? start : end;
                            this._dragPitch = this._cursor.pitch;
                            this._dragSize = theNote.pins[backwards ? 0 : 1].size;
                            this._dragVisible = true;
                        }
                        let prevPattern = this._pattern;
                        this._pattern = this._doc.getCurrentPattern(this._barOffset);
                        if (this._pattern != null && this._doc.song.getChannelIsMod(this._doc.channel) && this._interactive && prevPattern != this._pattern) {
                            this._pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                        }
                    }
                    else if (this._mouseHorizontal) {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        const shift = (this._mouseX - this._mouseXStart) / this._partWidth;
                        const shiftedPin = this._cursor.curNote.pins[this._cursor.nearPinIndex];
                        let shiftedTime = Math.round((this._cursor.curNote.start + shiftedPin.time + shift) / minDivision) * minDivision;
                        const continuesLastPattern = (shiftedTime < 0.0 && this._doc.channel < this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount);
                        if (shiftedTime < 0)
                            shiftedTime = 0;
                        if (shiftedTime > this._doc.song.beatsPerBar * Config.partsPerBeat)
                            shiftedTime = this._doc.song.beatsPerBar * Config.partsPerBeat;
                        if (this._pattern == null)
                            throw new Error();
                        if (shiftedTime <= this._cursor.curNote.start && this._cursor.nearPinIndex == this._cursor.curNote.pins.length - 1 ||
                            shiftedTime >= this._cursor.curNote.end && this._cursor.nearPinIndex == 0) {
                            sequence.append(new ChangeNoteAdded(this._doc, this._pattern, this._cursor.curNote, this._cursor.curIndex, true));
                            this._dragVisible = false;
                        }
                        else {
                            const start = Math.min(this._cursor.curNote.start, shiftedTime);
                            const end = Math.max(this._cursor.curNote.end, shiftedTime);
                            this._dragTime = shiftedTime;
                            this._dragPitch = this._cursor.curNote.pitches[this._cursor.pitchIndex == -1 ? 0 : this._cursor.pitchIndex] + this._cursor.curNote.pins[this._cursor.nearPinIndex].interval;
                            this._dragSize = this._cursor.curNote.pins[this._cursor.nearPinIndex].size;
                            this._dragVisible = true;
                            sequence.append(new ChangeNoteTruncate(this._doc, this._pattern, start, end, this._cursor.curNote));
                            sequence.append(new ChangePinTime(this._doc, this._cursor.curNote, this._cursor.nearPinIndex, shiftedTime, continuesLastPattern));
                            this._copyPins(this._cursor.curNote); 
                        }
                    }
                    else if (this._cursor.pitchIndex == -1 || this._doc.song.getChannelIsMod(this._doc.channel)) {
                        if (!this._mouseDragging)
                            sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        const bendPart = Math.max(this._cursor.curNote.start, Math.min(this._cursor.curNote.end, Math.round(this._mouseX / (this._partWidth * minDivision)) * minDivision)) - this._cursor.curNote.start;
                        let prevPin;
                        let nextPin = this._cursor.curNote.pins[0];
                        let bendSize = 0;
                        let bendInterval = 0;
                        let cap = this._doc.song.getVolumeCap(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), this._cursor.pitch);
                        let dragFactorSlow = 25.0 / Math.pow(cap, 0.4);
                        let dragFactorFast = 22.0 / Math.pow(cap, 0.5);
                        let dragSign = (this._mouseYStart > this._mouseY ? 1 : -1);
                        let dragCounts = Math.min(Math.abs(this._mouseYStart - this._mouseY) / dragFactorSlow, 8) + Math.max(0, Math.abs(this._mouseYStart - this._mouseY) / dragFactorFast - 8);
                        if (dragCounts > 0) {
                            this._shiftHeld = false;
                        }
                        for (let i = 1; i < this._cursor.curNote.pins.length; i++) {
                            prevPin = nextPin;
                            nextPin = this._cursor.curNote.pins[i];
                            if (bendPart > nextPin.time)
                                continue;
                            if (bendPart < prevPin.time)
                                throw new Error();
                            const sizeRatio = (bendPart - prevPin.time) / (nextPin.time - prevPin.time);
                            bendSize = Math.round(prevPin.size * (1.0 - sizeRatio) + nextPin.size * sizeRatio + dragSign * dragCounts);
                            if (!this.controlMode && !this._doc.prefs.alwaysFineNoteVol && !this._doc.song.getChannelIsMod(this._doc.channel)) {
                                bendSize = Math.floor(bendSize / 2) * 2;
                            }
                            if (bendSize < 0)
                                bendSize = 0;
                            if (bendSize > cap)
                                bendSize = cap;
                            bendInterval = this._snapToPitch(prevPin.interval * (1.0 - sizeRatio) + nextPin.interval * sizeRatio + this._cursor.curNote.pitches[0], 0, this._getMaxPitch()) - this._cursor.curNote.pitches[0];
                            break;
                        }
                        if (this._doc.song.getChannelIsMod(this._doc.channel) && this.controlMode) {
                            if (bendPart >= this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1].time) {
                                if (this._cursor.curNote.start + this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1].time < this._doc.song.beatsPerBar * Config.partsPerBeat) {
                                    for (const note of this._pattern.notes) {
                                        if (note.start == this._cursor.curNote.start + this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1].time && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                            sequence.append(new ChangeSizeBend(this._doc, note, note.pins[0].time, bendSize, bendInterval, this.shiftMode));
                                        }
                                    }
                                }
                                else {
                                    const nextPattern = this._doc.getCurrentPattern(1);
                                    if (nextPattern != null && nextPattern.instruments[0] == this._pattern.instruments[0]) {
                                        for (const note of nextPattern.notes) {
                                            if (note.start == 0 && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                                sequence.append(new ChangeSizeBend(this._doc, note, note.pins[0].time, bendSize, bendInterval, this.shiftMode));
                                            }
                                        }
                                    }
                                }
                            }
                            else if (bendPart <= this._cursor.curNote.pins[0].time) {
                                if (this._cursor.curNote.start > 0) {
                                    for (const note of this._pattern.notes) {
                                        if (note.end == this._cursor.curNote.start && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                            sequence.append(new ChangeSizeBend(this._doc, note, note.pins[note.pins.length - 1].time, bendSize, bendInterval, this.shiftMode));
                                        }
                                    }
                                }
                                else {
                                    const prevPattern = this._doc.getCurrentPattern(-1);
                                    if (prevPattern != null && prevPattern.instruments[0] == this._pattern.instruments[0]) {
                                        for (const note of prevPattern.notes) {
                                            if (note.end == this._doc.song.beatsPerBar * Config.partsPerBeat && note.pitches[0] == this._cursor.curNote.pitches[0]) {
                                                sequence.append(new ChangeSizeBend(this._doc, note, note.pins[note.pins.length - 1].time, bendSize, bendInterval, this.shiftMode));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        this._dragTime = this._cursor.curNote.start + bendPart;
                        this._dragPitch = this._cursor.curNote.pitches[this._cursor.pitchIndex == -1 ? 0 : this._cursor.pitchIndex] + bendInterval;
                        this._dragSize = bendSize;
                        this._dragVisible = true;
this._dragTime = this._cursor.curNote.start + bendPart;
this._dragPitch = this._cursor.curNote.pitches[this._cursor.pitchIndex == -1 ? 0 : this._cursor.pitchIndex] + bendInterval;
this._dragSize = bendSize;
this._dragVisible = true;
if (this._doc.prefs.increaseAllPins) {
	let targetPin = null;
	for (let i = 1; i < this._cursor.curNote.pins.length; i++) {
		if (bendPart <= this._cursor.curNote.pins[i].time) {
			targetPin = this._cursor.curNote.pins[i];
			break;
		}
	}
	if (!targetPin) targetPin = this._cursor.curNote.pins[this._cursor.curNote.pins.length - 1];
	const delta = bendSize - targetPin.size;
	for (const pin of this._cursor.curNote.pins) {
		let newSize = pin.size + delta;
		if (newSize < 0) newSize = 0;
		if (newSize > cap) newSize = cap;
		sequence.append(new ChangeSizeBend(
			this._doc,
			this._cursor.curNote,
			pin.time,
			newSize,
			pin.interval,
			this.shiftMode
		));
	}
} else {
	sequence.append(new ChangeSizeBend(
		this._doc,
		this._cursor.curNote,
		bendPart,
		bendSize,
		bendInterval,
		this.shiftMode
	));
}
this._copyPins(this._cursor.curNote);
                        this._copyPins(this._cursor.curNote);
                    }
                    else {
                        sequence.append(new ChangePatternSelection(this._doc, 0, 0));
                        this._dragSize = this._cursor.curNote.pins[this._cursor.nearPinIndex].size;
                        if (this._pattern == null)
                            throw new Error();
                        let bendStart;
                        let bendEnd;
                        if (this._mouseX >= this._mouseXStart) {
                            bendStart = Math.max(this._cursor.curNote.start, this._cursor.part);
                            bendEnd = currentPart + minDivision;
                        }
                        else {
                            bendStart = Math.min(this._cursor.curNote.end, this._cursor.part + minDivision);
                            bendEnd = currentPart;
                        }
                        if (bendEnd < 0)
                            bendEnd = 0;
                        if (bendEnd > this._doc.song.beatsPerBar * Config.partsPerBeat)
                            bendEnd = this._doc.song.beatsPerBar * Config.partsPerBeat;
                        if (bendEnd > this._cursor.curNote.end) {
                            sequence.append(new ChangeNoteTruncate(this._doc, this._pattern, this._cursor.curNote.start, bendEnd, this._cursor.curNote));
                        }
                        if (bendEnd < this._cursor.curNote.start) {
                            sequence.append(new ChangeNoteTruncate(this._doc, this._pattern, bendEnd, this._cursor.curNote.end, this._cursor.curNote));
                        }
                        let minPitch = Number.MAX_VALUE;
                        let maxPitch = -Number.MAX_VALUE;
                        for (const pitch of this._cursor.curNote.pitches) {
                            if (minPitch > pitch)
                                minPitch = pitch;
                            if (maxPitch < pitch)
                                maxPitch = pitch;
                        }
                        minPitch -= this._cursor.curNote.pitches[this._cursor.pitchIndex];
                        maxPitch -= this._cursor.curNote.pitches[this._cursor.pitchIndex];
                        if (!this._doc.song.getChannelIsMod(this._doc.channel)) {
                            const bendTo = this._snapToPitch(this._findMousePitch(this._mouseY), -minPitch, this._getMaxPitch() - maxPitch);
                            sequence.append(new ChangePitchBend(this._doc, this._cursor.curNote, bendStart, bendEnd, bendTo, this._cursor.pitchIndex));
                            this._dragPitch = bendTo;
                        }
                        else {
                            const bendTo = this._snapToPitch(this._dragPitch, -minPitch, Config.modCount - 1);
                            sequence.append(new ChangePitchBend(this._doc, this._cursor.curNote, bendStart, bendEnd, bendTo, this._cursor.pitchIndex));
                            this._dragPitch = bendTo;
                        }
                        this._copyPins(this._cursor.curNote);
                        this._dragTime = bendEnd;
                        this._dragVisible = true;
                    }
                }
            }
            if (!(this._mouseDown && this._cursor.valid && continuousState)) {
                this._updateCursorStatus();
                this._updatePreview();
            }
        }
        _setPatternSelection(change) {
            this._changePatternSelection = change;
            this._doc.record(this._changePatternSelection, this._lastChangeWasPatternSelection);
        }
        _updatePreview() {
            if (this._usingTouch) {
                if (!this._mouseDown || !this._cursor.valid || !this._mouseDragging || !this._dragVisible || this._shiftHeld || this._draggingStartOfSelection || this._draggingEndOfSelection || this._draggingSelectionContents) {
                    this._svgPreview.setAttribute("visibility", "hidden");
                    if (!this.editingModLabel) {
                        this.modDragValueLabel.style.setProperty("display", "none");
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                    }
                }
                else {
	
	this._svgPreview.setAttribute("visibility", "visible");
	this._svgPreview.style.opacity = "0.8";
	const x = this._partWidth * this._dragTime;
	const radius = (this._pitchHeight - this._pitchBorder) / 2;
	const cap = this._doc.song.getVolumeCap(
		this._doc.song.getChannelIsMod(this._doc.channel),
		this._doc.channel,
		this._doc.getCurrentInstrument(this._barOffset),
		this._cursor.pitch
	); 
	
	if (this._doc.prefs.differentMod && this._doc.song.getChannelIsMod(this._doc.channel)) {
		const yStart = this._pitchToPixelHeight(this._dragPitch - this._octaveOffset) + radius + 10;
		const yEnd = yStart - (radius * (this._dragSize / cap)) - 20;
		let pathString = "";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart);
		pathString += " L " + prettyNumber(x) + " " + prettyNumber(yEnd);
		this._svgPreview.setAttribute("d", pathString);
	} else {
		const yStart = this._pitchToPixelHeight(this._dragPitch - this._octaveOffset);
		const height = 60;
		let pathString = "";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
		pathString += "L " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap) - height) + " ";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
		pathString += "L " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap) + height) + " ";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
		pathString += "L " + prettyNumber(x + 80) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
		pathString += "L " + prettyNumber(x + 80) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
		pathString += "L " + prettyNumber(x - 80) + " " + prettyNumber(yStart - radius * (this._dragSize / cap)) + " ";
		pathString += "M " + prettyNumber(x) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
		pathString += "L " + prettyNumber(x - 80) + " " + prettyNumber(yStart + radius * (this._dragSize / cap)) + " ";
		this._svgPreview.setAttribute("d", pathString);
	}
	
	
}
            }
            else {
                if (!this._mouseOver || this._mouseDown || !this._cursor.valid) {
                    this._svgPreview.setAttribute("visibility", "hidden");
                    if (!this.editingModLabel) {
                        this.modDragValueLabel.style.setProperty("display", "none");
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                    }
                }
                else {
                    this._svgPreview.setAttribute("visibility", "visible");
                    if (this._cursorAtStartOfSelection()) {
                        const center = this._partWidth * this._doc.selection.patternSelectionStart;
                        const left = prettyNumber(center - 4);
                        const right = prettyNumber(center + 4);
                        const bottom = this._pitchToPixelHeight(-0.5);
                        this._svgPreview.setAttribute("d", "M " + left + " 0 L " + left + " " + bottom + " L " + right + " " + bottom + " L " + right + " 0 z");
                    }
                    else if (this._cursorAtEndOfSelection()) {
                        const center = this._partWidth * this._doc.selection.patternSelectionEnd;
                        const left = prettyNumber(center - 4);
                        const right = prettyNumber(center + 4);
                        const bottom = this._pitchToPixelHeight(-0.5);
                        this._svgPreview.setAttribute("d", "M " + left + " 0 L " + left + " " + bottom + " L " + right + " " + bottom + " L " + right + " 0 z");
                    }
                    else if (this._cursorIsInSelection()) {
                        const left = prettyNumber(this._partWidth * this._doc.selection.patternSelectionStart - 2);
                        const right = prettyNumber(this._partWidth * this._doc.selection.patternSelectionEnd + 2);
                        const bottom = this._pitchToPixelHeight(-0.5);
                        this._svgPreview.setAttribute("d", "M " + left + " 0 L " + left + " " + bottom + " L " + right + " " + bottom + " L " + right + " 0 z");
                    }
                    else {
                        this._drawNote(this._svgPreview, this._cursor.pitch, this._cursor.start, this._cursor.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
                    }
                }
            }
        }
        _updateSelection() {
            if (this._doc.selection.patternSelectionActive) {
                this._selectionRect.setAttribute("visibility", "visible");
                this._selectionRect.setAttribute("x", String(this._partWidth * this._doc.selection.patternSelectionStart));
                this._selectionRect.setAttribute("width", String(this._partWidth * (this._doc.selection.patternSelectionEnd - this._doc.selection.patternSelectionStart)));
            }
            else {
                this._selectionRect.setAttribute("visibility", "hidden");
            }
        }
        render() {
            const nextPattern = this._doc.getCurrentPattern(this._barOffset);
            if (this._pattern != nextPattern) {
                if (this._doc.song.getChannelIsMod(this._doc.channel) && this._interactive && nextPattern != null) {
                    nextPattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });
                }
                if (this._pattern != null) {
                    this._dragChange = null;
                    this._whenCursorReleased(null);
                }
            }
            this._pattern = nextPattern;
            this._editorWidth = this.container.clientWidth;
            this._editorHeight = this.container.clientHeight;
            this._partWidth = this._editorWidth / (this._doc.song.beatsPerBar * Config.partsPerBeat);
            this._octaveOffset = (this._doc.channel >= this._doc.song.pitchChannelCount) ? 0 : this._doc.song.channels[this._doc.channel].octave * Config.pitchesPerOctave;
            if (this._doc.song.getChannelIsNoise(this._doc.channel)) {
                this._pitchBorder = 0;
                this._pitchCount = Config.drumCount;
            }
            else if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                this._pitchBorder = this._defaultModBorder;
                this._pitchCount = Config.modCount;
                if (this._pattern != null) {
                    for (const note of this._pattern.notes) {
                        let pitch = note.pitches[0];
                        let maxHeight = this._doc.song.getVolumeCap(true, this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), pitch);
                        let maxFoundHeight = 0;
                        for (const pin of note.pins) {
                            if (pin.size > maxFoundHeight) {
                                maxFoundHeight = pin.size;
                            }
                        }
                        if (maxFoundHeight > maxHeight) {
                            for (const pin of note.pins) {
                                pin.size = Math.round(pin.size * (maxHeight / maxFoundHeight));
                            }
                        }
                    }
                }
            }
            else {
                this._pitchBorder = 0;
                this._pitchCount = this._doc.getVisiblePitchCount();
            }
            this._pitchHeight = this._editorHeight / this._pitchCount;
            this._octaveOffset = (this._doc.channel >= this._doc.song.pitchChannelCount) ? 0 : this._doc.getBaseVisibleOctave(this._doc.channel) * Config.pitchesPerOctave;
            if (this._renderedRhythm != this._doc.song.rhythm ||
                this._renderedPitchChannelCount != this._doc.song.pitchChannelCount ||
                this._renderedNoiseChannelCount != this._doc.song.noiseChannelCount ||
                this._renderedModChannelCount != this._doc.song.modChannelCount) {
                this._renderedRhythm = this._doc.song.rhythm;
                this._renderedPitchChannelCount = this._doc.song.pitchChannelCount;
                this._renderedNoiseChannelCount = this._doc.song.noiseChannelCount;
                this._renderedModChannelCount = this._doc.song.modChannelCount;
                this.resetCopiedPins();
            }
            this._copiedPins = this._copiedPinChannels[this._doc.channel];
            if (this._renderedWidth != this._editorWidth || this._renderedHeight != this._editorHeight) {
                this._renderedWidth = this._editorWidth;
                this._renderedHeight = this._editorHeight;
                this._svgBackground.setAttribute("width", "" + this._editorWidth);
                this._svgBackground.setAttribute("height", "" + this._editorHeight);
                this._svgPlayhead.setAttribute("height", "" + this._editorHeight);
                this._selectionRect.setAttribute("y", "0");
                this._selectionRect.setAttribute("height", "" + this._editorHeight);
            }
            const beatWidth = this._editorWidth / this._doc.song.beatsPerBar;
            if (this._renderedBeatWidth != beatWidth || this._renderedPitchHeight != this._pitchHeight) {
                this._renderedBeatWidth = beatWidth;
                this._renderedPitchHeight = this._pitchHeight;
                this._svgNoteBackground.setAttribute("width", "" + beatWidth);
                this._svgNoteBackground.setAttribute("height", "" + (this._pitchHeight * Config.pitchesPerOctave));
                this._svgDrumBackground.setAttribute("width", "" + beatWidth);
                this._svgDrumBackground.setAttribute("height", "" + this._pitchHeight);
                this._svgModBackground.setAttribute("width", "" + beatWidth);
                this._svgModBackground.setAttribute("height", "" + (this._pitchHeight));
                this._svgModBackground.setAttribute("y", "" + (this._pitchBorder / 2));
                this._backgroundDrumRow.setAttribute("width", "" + (beatWidth - 2));
                this._backgroundDrumRow.setAttribute("height", "" + (this._pitchHeight - 2));
                if (this._pitchHeight > this._pitchBorder) {
                    this._backgroundModRow.setAttribute("width", "" + (beatWidth - 2));
                    this._backgroundModRow.setAttribute("height", "" + (this._pitchHeight - this._pitchBorder));
                }
                for (let j = 0; j < Config.pitchesPerOctave; j++) {
                    const rectangle = this._backgroundPitchRows[j];
                    const y = (Config.pitchesPerOctave - j) % Config.pitchesPerOctave;
                    rectangle.setAttribute("width", "" + (beatWidth - 2));
                    rectangle.setAttribute("y", "" + (y * this._pitchHeight + 1));
                    rectangle.setAttribute("height", "" + (this._pitchHeight - 2));
                }
            }
            if (this._interactive) {
                if (!this._mouseDown)
                    this._updateCursorStatus();
                this._updatePreview();
                this._updateSelection();
            }
            if (this._renderedFifths != this._doc.prefs.showFifth) {
                this._renderedFifths = this._doc.prefs.showFifth;
                this._backgroundPitchRows[7].setAttribute("fill", this._doc.prefs.showFifth ? ColorConfig.fifthNote : ColorConfig.pitchBackground);
            }
            for (let j = 0; j < Config.pitchesPerOctave; j++) {
                let scale = this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
                this._backgroundPitchRows[j].style.visibility = scale[j] ? "visible" : "hidden";
            }
            if (this._doc.song.getChannelIsNoise(this._doc.channel)) {
                if (!this._renderedDrums) {
                    this._renderedDrums = true;
                    this._renderedMod = false;
                    this._svgBackground.setAttribute("fill", "url(#patternEditorDrumBackground" + this._barOffset + ")");
                }
            }
            else if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                if (!this._renderedMod) {
                    this._renderedDrums = false;
                    this._renderedMod = true;
                    this._svgBackground.setAttribute("fill", "url(#patternEditorModBackground" + this._barOffset + ")");
                }
            }
            else {
                if (this._renderedDrums || this._renderedMod) {
                    this._renderedDrums = false;
                    this._renderedMod = false;
                    this._svgBackground.setAttribute("fill", "url(#patternEditorNoteBackground" + this._barOffset + ")");
                }
            }
            this._redrawNotePatterns();
        }
        _redrawNotePatterns() {
            this._svgNoteContainer = makeEmptyReplacementElement(this._svgNoteContainer);
            if (this._doc.prefs.showChannels) {
                if (!this._doc.song.getChannelIsMod(this._doc.channel)) {
                    let noteFlashColor = "#ffffff77";
                    if (this._doc.prefs.notesFlashWhenPlayed)
                        noteFlashColor = ColorConfig.getComputed("--note-flash-secondary");
                    for (let channel = this._doc.song.pitchChannelCount + this._doc.song.noiseChannelCount - 1; channel >= 0; channel--) {
                        if (channel == this._doc.channel)
                            continue;
                        if (this._doc.song.getChannelIsNoise(channel) != this._doc.song.getChannelIsNoise(this._doc.channel))
                            continue;
                        const pattern2 = this._doc.song.getPattern(channel, this._doc.bar + this._barOffset);
                        if (pattern2 == null)
                            continue;
                        const octaveOffset = this._doc.getBaseVisibleOctave(channel) * Config.pitchesPerOctave;
                        for (const note of pattern2.notes) {
                            for (const pitch of note.pitches) {
                                let notePath = SVG.path();
                                notePath.setAttribute("fill", ColorConfig.getChannelColor(this._doc.song, channel).secondaryNote);
                                notePath.setAttribute("pointer-events", "none");
                                this._drawNote(notePath, pitch, note.start, note.pins, this._pitchHeight * 0.19, false, octaveOffset);
                                this._svgNoteContainer.appendChild(notePath);
                                if (this._doc.prefs.notesFlashWhenPlayed) {
                                    notePath = SVG.path();
                                    notePath.setAttribute("fill", noteFlashColor);
                                    notePath.setAttribute("pointer-events", "none");
                                    this._drawNote(notePath, pitch, note.start, note.pins, this._pitchHeight * 0.19, false, octaveOffset);
                                    this._svgNoteContainer.appendChild(notePath);
                                    notePath.classList.add('note-flash');
                                    notePath.style.opacity = "0";
                                    notePath.setAttribute('note-start', String(note.start));
                                    notePath.setAttribute('note-end', String(note.end));
                                }
                            }
                        }
                    }
                }
            }
            if (this._pattern != null) {
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)];
                const chord = instrument.getChord();
                const transition = instrument.getTransition();
                const displayNumberedChords = chord.customInterval || chord.arpeggiates || chord.strumParts > 0 || transition.slides || chord.name == "monophonic";
                let noteFlashColor = "#ffffff";
                if (this._doc.prefs.notesFlashWhenPlayed)
                    noteFlashColor = ColorConfig.getComputed("--note-flash");
                for (const note of this._pattern.notes) {
                    let disabled = false;
                    if (this._doc.song.getChannelIsMod(this._doc.channel)) {
                        const modIndex = instrument.modulators[Config.modCount - 1 - note.pitches[0]]; 
                        
                        if ((modIndex == Config.modulators.dictionary["none"].index)
                            || instrument.invalidModulators[Config.modCount - 1 - note.pitches[0]])
                            disabled = true;
                    }
                    for (let i = 0; i < note.pitches.length; i++) {
                        const pitch = note.pitches[i];
                        let notePath = SVG.path();
                        let colorPrimary = (disabled ? ColorConfig.disabledNotePrimary : ColorConfig.getChannelColor(this._doc.song, this._doc.channel).primaryNote);
                        let colorSecondary = (disabled ? ColorConfig.disabledNoteSecondary : ColorConfig.getChannelColor(this._doc.song, this._doc.channel).secondaryNote);
                        notePath.setAttribute("fill", colorSecondary);
                        notePath.setAttribute("pointer-events", "none");
                        this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, false, this._octaveOffset);
                        this._svgNoteContainer.appendChild(notePath);
                        notePath = SVG.path();
                        notePath.setAttribute("fill", colorPrimary);
                        notePath.setAttribute("pointer-events", "none");

if (this._doc.song.getChannelIsMod(this._doc.channel) && this._doc.prefs.differentMod) {
	this._drawNote2(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
} else {
	this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
}

this._svgNoteContainer.appendChild(notePath);
if (this._doc.song.getChannelIsMod(this._doc.channel) && this._doc.prefs.differentMod) {
	for (let p = 0; p < note.pins.length; p++) {
		const pin = note.pins[p];
		if (p === 0 || pin.size !== note.pins[p - 1].size) {
			const cap = this._doc.song.getVolumeCap(
				true,
				this._doc.channel,
				this._doc.getCurrentInstrument(this._barOffset),
				pitch
			);
			let x = this._partWidth * (note.start + pin.time);
			const topY = this._pitchToPixelHeight(pitch + pin.interval - this._octaveOffset) -
				((this._pitchHeight - this._pitchBorder) / 2 + 1) * (pin.size / cap);
			const y = topY - 10;
			if (p === 0) x += 10;
			if (p === note.pins.length - 1) x -= 10;
			
			const textEl = document.createElementNS(svgNS, "text");
			textEl.setAttribute("x", prettyNumber(x));
			textEl.setAttribute("y", prettyNumber(y));
			textEl.setAttribute("fill", "white");
			textEl.setAttribute("font-size", "5");
			textEl.setAttribute("text-anchor", "middle");
			const setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[Config.modCount - 1 - note.pitches[0]];
			
			if (Config.modulators[setting].divider && (Config.modulators[setting].valueRealAdd || (!isNaN(Config.modulators[setting].valueRealAdd) && Config.modulators[setting].valueRealAdd == 0))) {
				textEl.textContent = (((pin.size + Config.modulators[setting].convertRealFactor + Config.modulators[setting].valueRealAdd) / Config.modulators[setting].divider) - 0.2).toFixed(1);
			} else if (Config.modulators[setting].valueRealAdd) {
				textEl.textContent = ((pin.size + Config.modulators[setting].convertRealFactor + Config.modulators[setting].valueRealAdd));
			} else if (Config.modulators[setting].divider) {
				function floorTo1(num) {
					return Math.floor(num * 10) / 10;
				}
				textEl.textContent = floorTo1(
					(pin.size + Config.modulators[setting].convertRealFactor) / Config.modulators[setting].divider
				);
				const mod = Config.modulators[setting];
if (mod.displayMin !== undefined) {
    const norm = (pin.size + Config.modulators[setting].convertRealFactor) / mod.rawMax;
    const val = mod.displayMin + norm * (mod.displayMax - mod.displayMin);
    textEl.textContent = val.toFixed(1);
} 

			} else {
				textEl.textContent = ((pin.size + Config.modulators[setting].convertRealFactor));
			}
			this._svgNoteContainer.appendChild(textEl);
		}
	}
}

                        if (this._doc.prefs.notesFlashWhenPlayed && !disabled) {
                            notePath = SVG.path();
                            notePath.setAttribute("fill", noteFlashColor);
                            notePath.setAttribute("pointer-events", "none");
                            this._drawNote(notePath, pitch, note.start, note.pins, (this._pitchHeight - this._pitchBorder) / 2 + 1, true, this._octaveOffset);
                            this._svgNoteContainer.appendChild(notePath);
                            notePath.classList.add('note-flash');
                            notePath.style.opacity = "0";
                            notePath.setAttribute('note-start', String(note.start));
                            notePath.setAttribute('note-end', String(note.end));
                        }
                        let indicatorOffset = 2;
                        if (note.continuesLastPattern) {
                            const arrowHeight = Math.min(this._pitchHeight, 20);
                            let arrowPath;
                            arrowPath = "M " + prettyNumber(this._partWidth * note.start + indicatorOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.1 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) + 0.3 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 12) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset));
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.3 * arrowHeight);
                            arrowPath += "L " + prettyNumber(this._partWidth * note.start + indicatorOffset + 4) + " " + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset) - 0.1 * arrowHeight);
                            const arrow = SVG.path();
                            arrow.setAttribute("d", arrowPath);
                            arrow.setAttribute("fill", ColorConfig.invertedText);
                            this._svgNoteContainer.appendChild(arrow);
                            indicatorOffset += 12;
                        }
                        if (note.pitches.length > 1) {
                            if (displayNumberedChords) {
                                const oscillatorLabel = SVG.text();
                                oscillatorLabel.setAttribute("x", "" + prettyNumber(this._partWidth * note.start + indicatorOffset));
                                oscillatorLabel.setAttribute("y", "" + prettyNumber(this._pitchToPixelHeight(pitch - this._octaveOffset)));
                                oscillatorLabel.setAttribute("width", "30");
                                oscillatorLabel.setAttribute("fill", ColorConfig.invertedText);
                                oscillatorLabel.setAttribute("text-anchor", "start");
                                oscillatorLabel.setAttribute("dominant-baseline", "central");
                                oscillatorLabel.setAttribute("pointer-events", "none");
                                oscillatorLabel.textContent = "" + (i + 1);
                                this._svgNoteContainer.appendChild(oscillatorLabel);
                            }
                        }
                    }
                    if (this._doc.song.getChannelIsMod(this._doc.channel) && this._mouseDragging && !this._mouseHorizontal && note == this._cursor.curNote) {
                        this.modDragValueLabel.style.setProperty("display", "");
																					if (this._doc.prefs.differentMod) {
																					this.modDragValueLabel.style.setProperty("display", "none");
																					}
                        this.modDragValueLabel.style.setProperty("pointer-events", "none");
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                        this.modDragValueLabel.style.setProperty("color", "#FFFFFF");
                        let setting = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument(this._barOffset)].modulators[Config.modCount - 1 - note.pitches[0]];
                        let presValue = this._dragSize + Config.modulators[setting].convertRealFactor;
                        let xOffset = (+(presValue >= 10.0)) + (+(presValue >= 100.0)) + (+(presValue < 0.0)) + (+(presValue <= -10.0));
                        this._modDragValueLabelWidth = 8 + xOffset * 8;
                        this._modDragValueLabelLeft = +prettyNumber(Math.max(Math.min(this._editorWidth - 10 - xOffset * 8, this._partWidth * this._dragTime - 4 - xOffset * 4), 2));
                        this._modDragValueLabelTop = +prettyNumber(this._pitchToPixelHeight(note.pitches[0] - this._octaveOffset) - 17 - (this._pitchHeight - this._pitchBorder) / 2);
                        this.modDragValueLabel.style.setProperty("left", "" + this._modDragValueLabelLeft + "px");
                        this.modDragValueLabel.style.setProperty("top", "" + this._modDragValueLabelTop + "px");
                        this.modDragValueLabel.textContent = "" + presValue;
const mod = Config.modulators[setting];
if (mod.displayMin !== undefined) {
    const norm = presValue / mod.rawMax;
    const val = mod.displayMin + norm * (mod.displayMax - mod.displayMin);
    this.modDragValueLabel.textContent = val.toFixed(1);
} 

                    }
                }
            }
            this._doc.currentPatternIsDirty = false;
        }
        
_drawNote2(svgElement, pitch, start, pins, radius, showSize, offset) {
	const totalWidth = this._partWidth * (pins[pins.length - 1].time + pins[0].time);
	const endOffset = 0.5 * Math.min(2, totalWidth - 1);
	let nextPin = pins[0];
	let cap = this._doc.song.getVolumeCap(true, this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), pitch);
	const getY = (interval, size) => {
		const bottom = this._pitchToPixelHeight(pitch + interval - offset) + radius;
		const height = radius * (showSize ? size * 1.8 / cap : 1.0);
		return bottom - height;
	};
	let pathString = "M " + prettyNumber(this._partWidth * (start + nextPin.time) + endOffset) + " " + prettyNumber(getY(nextPin.interval, nextPin.size)) + " ";
	let linePathString = "M " + prettyNumber(this._partWidth * (start + nextPin.time)) + " " + prettyNumber(getY(nextPin.interval, nextPin.size)) + " ";
	for (let i = 1; i < pins.length; i++) {
		let prevPin = nextPin;
		nextPin = pins[i];
		let prevSide = this._partWidth * (start + prevPin.time) + (i == 1 ? endOffset : 0);
		let nextSide = this._partWidth * (start + nextPin.time) - (i == pins.length - 1 ? endOffset : 0);
		let prevY = getY(prevPin.interval, prevPin.size);
		let nextY = getY(nextPin.interval, nextPin.size);
		pathString += "L " + prettyNumber(prevSide) + " " + prettyNumber(prevY) + " ";
		pathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextY) + " ";
		linePathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextY) + " ";
	}
	for (let i = pins.length - 1; i >= 0; i--) {
		const pin = pins[i];
		let x = this._partWidth * (start + pin.time);
		let bottomY = this._pitchToPixelHeight(pitch + pin.interval - offset) + radius;
		pathString += "L " + prettyNumber(x) + " " + prettyNumber(bottomY) + " ";
	}
	pathString += "z";
	svgElement.setAttribute("d", pathString);
	let lineEl = document.createElementNS(svgNS, "path");
	lineEl.setAttribute("d", linePathString);
	lineEl.setAttribute("stroke", "rgba(255,255,255,0.5)");
	lineEl.setAttribute("stroke-width", "1");
	lineEl.setAttribute("fill", "none");
	this._svgNoteContainer.appendChild(lineEl);
	
}
        
_drawNote(svgElement, pitch, start, pins, radius, showSize, offset) {
	const totalWidth = this._partWidth * (pins[pins.length - 1].time + pins[0].time);
	const endOffset = 0.5 * Math.min(2, totalWidth - 1);
	let nextPin = pins[0];
	let cap = this._doc.song.getVolumeCap(this._doc.song.getChannelIsMod(this._doc.channel), this._doc.channel, this._doc.getCurrentInstrument(this._barOffset), pitch);
	let pathString = "M " + prettyNumber(this._partWidth * (start + nextPin.time) + endOffset) + " " + prettyNumber(this._pitchToPixelHeight(pitch - offset) + radius * (showSize ? nextPin.size / cap : 1.0)) + " ";
	for (let i = 1; i < pins.length; i++) {
		let prevPin = nextPin;
		nextPin = pins[i];
		let prevSide = this._partWidth * (start + prevPin.time) + (i == 1 ? endOffset : 0);
		let nextSide = this._partWidth * (start + nextPin.time) - (i == pins.length - 1 ? endOffset : 0);
		let prevHeight = this._pitchToPixelHeight(pitch + prevPin.interval - offset);
		let nextHeight = this._pitchToPixelHeight(pitch + nextPin.interval - offset);
		let prevSize = showSize ? prevPin.size / cap : 1.0;
		let nextSize = showSize ? nextPin.size / cap : 1.0;
		pathString += "L " + prettyNumber(prevSide) + " " + prettyNumber(prevHeight - radius * prevSize) + " ";
		if (prevPin.interval > nextPin.interval)
			pathString += "L " + prettyNumber(prevSide + 1) + " " + prettyNumber(prevHeight - radius * prevSize) + " ";
		if (prevPin.interval < nextPin.interval)
			pathString += "L " + prettyNumber(nextSide - 1) + " " + prettyNumber(nextHeight - radius * nextSize) + " ";
		pathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextHeight - radius * nextSize) + " ";
	}
	for (let i = pins.length - 2; i >= 0; i--) {
		let prevPin = nextPin;
		nextPin = pins[i];
		let prevSide = this._partWidth * (start + prevPin.time) - (i == pins.length - 2 ? endOffset : 0);
		let nextSide = this._partWidth * (start + nextPin.time) + (i == 0 ? endOffset : 0);
		let prevHeight = this._pitchToPixelHeight(pitch + prevPin.interval - offset);
		let nextHeight = this._pitchToPixelHeight(pitch + nextPin.interval - offset)
		let prevSize = showSize ? prevPin.size / cap : 1.0;
		let nextSize = showSize ? nextPin.size / cap : 1.0;
		pathString += "L " + prettyNumber(prevSide) + " " + prettyNumber(prevHeight + radius * prevSize) + " ";
		if (prevPin.interval < nextPin.interval)
			pathString += "L " + prettyNumber(prevSide - 1) + " " + prettyNumber(prevHeight + radius * prevSize) + " ";
		if (prevPin.interval > nextPin.interval)
			pathString += "L " + prettyNumber(nextSide + 1) + " " + prettyNumber(nextHeight + radius * nextSize) + " ";
		pathString += "L " + prettyNumber(nextSide) + " " + prettyNumber(nextHeight + radius * nextSize) + " ";
	}
	pathString += "z";
	svgElement.setAttribute("d", pathString);
}
        _pitchToPixelHeight(pitch) {
            return this._pitchHeight * (this._pitchCount - (pitch) - 0.5);
        }
    }

    const { button: button$b, div: div$b, span: span$3, h2: h2$a, input: input$6, br, select: select$8, option: option$8 } = HTML;
    class SongDurationPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._computedSamplesLabel = div$b({ style: "width: 10em;" }, new Text("0:00"));
            this._barsStepper = input$6({ style: "width: 3em; margin-left: 1em;", type: "number", step: "1" });
            this._positionSelect = select$8({ style: "width: 100%;" }, option$8({ value: "end" }, "Apply change at end of song."), option$8({ value: "beginning" }, "Apply change at beginning of song."));
            this._cancelButton = button$b({ class: "cancelButton" });
            this._okayButton = button$b({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$b({ class: "prompt noSelection", style: "width: 250px;" }, h2$a("Song Length"), div$b({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;" }, "Length:", this._computedSamplesLabel), div$b({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$b({ style: "display: inline-block; text-align: right;" }, "Bars per song:", br(), span$3({ style: `font-size: smaller; color: ${ColorConfig.secondaryText};` }, "(Multiples of 4 are recommended)")), this._barsStepper), div$b({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$b({ class: "selectContainer", style: "width: 100%;" }, this._positionSelect)), div$b({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._barsStepper.removeEventListener("keypress", SongDurationPrompt._validateKey);
                this._barsStepper.removeEventListener("blur", SongDurationPrompt._validateNumber);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("barCountPosition", this._positionSelect.value);
                const group = new ChangeGroup();
                group.append(new ChangeBarCount(this._doc, SongDurationPrompt._validate(this._barsStepper), this._positionSelect.value == "beginning"));
                this._doc.prompt = null;
                this._doc.record(group, true);
            };
            this._barsStepper.value = this._doc.song.barCount + "";
            this._barsStepper.min = Config.barCountMin + "";
            this._barsStepper.max = Config.barCountMax + "";
            const lastPosition = window.localStorage.getItem("barCountPosition");
            if (lastPosition != null) {
                this._positionSelect.value = lastPosition;
            }
            this._barsStepper.select();
            setTimeout(() => this._barsStepper.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._barsStepper.addEventListener("keypress", SongDurationPrompt._validateKey);
            this._barsStepper.addEventListener("blur", SongDurationPrompt._validateNumber);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._barsStepper.addEventListener("input", () => { this._computedSamplesLabel.firstChild.textContent = this._predictFutureLength(); });
            this._positionSelect.addEventListener("change", () => { this._computedSamplesLabel.firstChild.textContent = this._predictFutureLength(); });
            this._computedSamplesLabel.firstChild.textContent = ExportPrompt.samplesToTime(this._doc, this._doc.synth.getTotalSamples(true, true, 0));
        }
        static _validateKey(event) {
            const charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 46 && charCode > 31 && (charCode < 48 || charCode > 57)) {
                event.preventDefault();
                return true;
            }
            return false;
        }
        static _validateNumber(event) {
            const input = event.target;
            input.value = String(SongDurationPrompt._validate(input));
        }
        static _validate(input) {
            return Math.floor(Math.max(Number(input.min), Math.min(Number(input.max), Number(input.value))));
        }
        _predictFutureLength() {
            var _a, _b, _c;
            const futureDoc = new SongDocument();
            (_a = futureDoc.synth.song) === null || _a === void 0 ? void 0 : _a.fromBase64String(((_b = this._doc.synth.song) === null || _b === void 0 ? void 0 : _b.toBase64String()) ? (_c = this._doc.synth.song) === null || _c === void 0 ? void 0 : _c.toBase64String() : "");
            new ChangeBarCount(futureDoc, SongDurationPrompt._validate(this._barsStepper), this._positionSelect.value == "beginning");
            return ExportPrompt.samplesToTime(futureDoc, futureDoc.synth.getTotalSamples(true, true, 0));
        }
    }

    const { button: button$a, div: div$a, h2: h2$9, p: p$4, select: select$7, option: option$7 } = HTML;
    class SustainPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._typeSelect = select$7({ style: "width: 100%;" }, option$7({ value: "acoustic" }, "(A) Acoustic"), option$7({ value: "bright" }, "(B) Bright"));
            this._cancelButton = button$a({ class: "cancelButton" });
            this._okayButton = button$a({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$a({ class: "prompt", style: "width: 300px;" }, div$a(h2$9("String Sustain"), p$4("This setting controls how quickly the picked string vibration decays."), p$4("Unlike most of BeepBox's instrument synthesizer features, a picked string cannot change frequency suddenly while maintaining its decay. If a tone's pitch changes suddenly (e.g. if the chord type is set to \"arpeggio\" or the transition type is set to \"continues\") then the string will be re-picked and start decaying from the beginning again, even if the envelopes don't otherwise restart.")), div$a({ style: { display: Config.enableAcousticSustain ? undefined : "none" } }, p$4("BeepBox comes with two slightly different sustain designs. You can select one here and press \"Okay\" to confirm it."), div$a({ class: "selectContainer", style: "width: 100%;" }, this._typeSelect)), div$a({ style: { display: Config.enableAcousticSustain ? "flex" : "none", "flex-direction": "row-reverse", "justify-content": "space-between" } }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                if (Config.enableAcousticSustain) {
                    const group = new ChangeGroup();
                    group.append(new ChangeStringSustainType(this._doc, Config.sustainTypeNames.indexOf(this._typeSelect.value)));
                    this._doc.prompt = null;
                    this._doc.record(group, true);
                }
                else {
                    this._close();
                }
            };
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            this._typeSelect.value = Config.sustainTypeNames[instrument.stringSustainType];
            setTimeout(() => this._cancelButton.focus());
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
    }

    const { button: button$9, div: div$9, h2: h2$8, p: p$3, select: select$6, option: option$6, iframe } = HTML;
    class SongRecoveryPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._songContainer = div$9();
            this._cancelButton = button$9({ class: "cancelButton" });
            this.clearreco = button$9({ class: "button" });
            this.clearreco.innerText="Clear Recovery "
this.clearrec = () => {
	showConfirmPopup(innerWidth / 2 - 150,
	innerHeight / 2 - 100 + window.scrollY, "Clear Recovery?", () => {
	SongRecovery.clearAllRecoveredSongs();
});
};
            this.container = div$9({ class: "prompt", style: "width: 300px;" }, h2$8("Song Recovery"), div$9({ style: "max-height: 385px; overflow-y: auto;" }, p$3("This is a TEMPORARY list of songs you have recently modified. Please keep your own backups of songs you care about! "), this._songContainer, p$3("(If \"Display Song Data in URL\" is enabled in your preferences, then you may also be able to find song versions in your browser history. However, song recovery won't work if you were browsing in private/incognito mode.) . Do not open to many iframes if you have samples program may crash lmfao .")), this.clearreco, this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._cancelButton.removeEventListener("click", this._close);
            };
            this.clearreco.addEventListener("click", this.clearrec);
            this._cancelButton.addEventListener("click", this._close);
            const songs = SongRecovery.getAllRecoveredSongs();
            if (songs.length == 0) {
                this._songContainer.appendChild(p$3("There are no recovered songs available yet. Try making a song!"));
            }
            for (const song of songs) {
    const versionMenu = select$6({ style: "width: 100%;" });

    for (const version of song.versions) {
        versionMenu.appendChild(
            option$6(
                { value: version.time },
                version.name + ": " + new Date(version.time).toLocaleString()
            )
        );
    }

    const loadBtn = button$6(
        {
            style: `
                width: calc(100% - 40%);
                height: 60px;
                display: flex;
                justify-content: center;
                align-items: center;
                border: 2px dashed #111;
                border-radius: 8px;
                cursor: pointer;
                float:left;
                background: #1c1c1c;
            `
        },
        "Load iframe"
    );
    const editBtn = button$6(
      	{
           		style: `
                width: 40%;
                height: 60px;
                display: flex;
                float:left;
                justify-content: center;
                align-items: center;
                border: 2px dashed #111;
                border-radius: 8px;
                cursor: pointer;
                background: #1c1c1c;
            `
      	},
      	"Edit Song"
    );
    const container = div$9(
        { style: "margin: 4px 0; background:black;" },
        div$9({ class: "selectContainer", style: "width: 100%; margin: 2px 0; " }, versionMenu),
        loadBtn,
        editBtn
    );

    this._songContainer.appendChild(container);


editBtn.addEventListener("click", () => {
	const firstVersion = song.versions[0];
	location.href = (OFFLINE ? "" : "") + "#" +window.localStorage.getItem(versionToKey(firstVersion));
});

    loadBtn.addEventListener("click", () => {
        const player = iframe({
            style: "width: 100%; height: 60px; border: none; display: block;"
        });
       editBtn.style.display="none"
        const firstVersion = song.versions[0];
        player.src = (OFFLINE ? "player.html" : "") + "#song=" + 
                     window.localStorage.getItem(versionToKey(firstVersion));

        container.replaceChild(player, loadBtn);

        versionMenu.addEventListener("change", () => {
            const version = song.versions[versionMenu.selectedIndex];
            player.contentWindow.location.replace(
                (OFFLINE ? "player.html" : "") +
                "#song=" + window.localStorage.getItem(versionToKey(version))
            );
            player.contentWindow.dispatchEvent(new Event("hashchange"));
        });
    });
}
 
        }
    }
 
    const { button: button$8, label, div: div$8, p: p$2, a: a$2, h2: h2$7, input: input$5, select: select$5, option: option$5 } = HTML;
    class RecordingSetupPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._keyboardMode = select$5({ style: "width: 100%;" }, option$5({ value: "useCapsLockForNotes" }, "simple shortcuts, use caps lock to play notes"), option$5({ value: "pressControlForShortcuts" }, "simple notes, press " + EditorConfig.ctrlName + " for shortcuts"));
            this._keyboardLayout = select$5({ style: "width: 100%;" }, option$5({ value: "wickiHayden" }, "Wicki-Hayden"), option$5({ value: "songScale" }, "selected song scale"), option$5({ value: "pianoAtC" }, "piano starting at C"), option$5({ value: "pianoAtA" }, "piano starting at A"), option$5({ value: "pianoTransposingC" }, "piano transposing C to song key"), option$5({ value: "pianoTransposingA" }, "piano transposing A to song key"));
            this._bassOffset = select$5({ style: "width: 100%;" }, option$5({ value: "0" }, "disabled"), option$5({ value: "-1" }, "before"), option$5({ value: "1" }, "after"));
            this._keyboardLayoutPreview = div$8({ style: "display: grid; row-gap: 4px; margin: 4px auto; font-size: 10px;" });
            this._enableMidi = input$5({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
            this._showRecordButton = input$5({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
            this._snapRecordedNotesToRhythm = input$5({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
            this._ignorePerformedNotesNotInScale = input$5({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
            this._metronomeCountIn = input$5({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
            this._metronomeWhileRecording = input$5({ style: "width: 2em; margin-left: 1em;", type: "checkbox" });
            this._okayButton = button$8({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._cancelButton = button$8({ class: "cancelButton" });
            this.container = div$8({ class: "prompt noSelection recordingSetupPrompt", style: "width: 600px; text-align: right; max-height: 90%;" }, h2$7({ style: "align-self: center;" }, "Note Recording Setup"), div$8({ style: "display: grid; overflow-y: auto; overflow-x: hidden; flex-shrink: 1;" }, p$2("UltraBox can record notes as you perform them. You can start recording by pressing Ctrl+Space (or " + EditorConfig.ctrlSymbol + "P)."), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Add  record button next to  play button:", this._showRecordButton), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Snap recorded notes to the song's rhythm:", this._snapRecordedNotesToRhythm), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Ignore notes not in the song's scale:", this._ignorePerformedNotesNotInScale), p$2("While recording, you can perform notes on your keyboard!"), label({ style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em; height: 2em; justify-content: center;" }, "Keyboard layout:", div$8({ class: "selectContainer", style: "width: 50%; margin-left: 1em;" }, this._keyboardLayout)), this._keyboardLayoutPreview, p$2("When not recording, you can use the computer keyboard either for shortcuts (like C and V for copy and paste) or for performing notes, depending on this mode:"), label({ style: "display: flex; margin-top: 0.5em; margin-bottom: 0.5em; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, div$8({ class: "selectContainer", style: "width: 50%;" }, this._keyboardMode)), p$2("Performing music takes practice! Try slowing the tempo and using this metronome to help you keep a rhythm."), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Hear metronome while recording:", this._metronomeWhileRecording), label({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;" }, "Count-in 1 bar of metronome before recording:", this._metronomeCountIn),   label({ style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; height: 2em; justify-content: center;" }, "Enable MIDI performance:", this._enableMidi), p$2("The range of pitches available to play via your computer keyboard is affected by the octave scrollbar of the currently selected channel."), p$2("If you set the channel offset below to 'before' or 'after', notes below the middle octave in the view will be 'bass' notes, and placed in the channel before or after the viewed one. Using this, you can play bass and lead at the same time!"), label({ style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em; height: 2em; justify-content: center;" }, "Bass Offset:", div$8({ class: "selectContainer", style: "width: 50%; margin-left: 1em;" }, this._bassOffset)), p$2("Once you enable the setting, the keyboard layout above will darken to denote the new bass notes. The notes will be recorded with independent timing and this works with MIDI devices, too. Be aware that the octave offset of both used channels will impact how high/low the bass/lead are relative to one another."), p$2("Recorded notes often overlap such that one note ends after the next note already started. In UltraBox, these notes get split into multiple notes which may sound different when re-played than they did when you were recording. To fix the sound, you can either manually clean up the notes in the pattern editor, or you could try enabling the \"transition type\" effect on the instrument and setting it to \"continue\"."), div$8({ style: `width: 100%; height: 80px; background: linear-gradient(rgba(0,0,0,0), ${ColorConfig.editorBackground}); position: sticky; bottom: 0; pointer-events: none;` })), div$8({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._confirm);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._confirm();
                }
            };
            this._confirm = () => {
                this._doc.prefs.pressControlForShortcuts = (this._keyboardMode.value == "pressControlForShortcuts");
                this._doc.prefs.keyboardLayout = this._keyboardLayout.value;
                this._doc.prefs.bassOffset = Number(this._bassOffset.value);
                this._doc.prefs.enableMidi = this._enableMidi.checked;
                this._doc.prefs.showRecordButton = this._showRecordButton.checked;
                this._doc.prefs.snapRecordedNotesToRhythm = this._snapRecordedNotesToRhythm.checked;
                this._doc.prefs.ignorePerformedNotesNotInScale = this._ignorePerformedNotesNotInScale.checked;
                this._doc.prefs.metronomeCountIn = this._metronomeCountIn.checked;
                this._doc.prefs.metronomeWhileRecording = this._metronomeWhileRecording.checked;
                this._doc.prefs.save();
                this._close();
            };
            this._renderKeyboardLayoutPreview = () => {
                while (this._keyboardLayoutPreview.firstChild) {
                    this._keyboardLayoutPreview.removeChild(this._keyboardLayoutPreview.firstChild);
                }
                const rowLengths = [12, 12, 11, 10];
                const scale = this._doc.song.scale == Config.scales.dictionary["Custom"].index ? this._doc.song.scaleCustom : Config.scales[this._doc.song.scale].flags;
                for (let rowIndex = 0; rowIndex < 4; rowIndex++) {
                    const row = div$8({ style: "display: flex;" });
                    this._keyboardLayoutPreview.appendChild(row);
                    const spacer = div$8({ style: "width: " + (rowIndex * 12) + "px; height: 20px; flex-shrink: 0;" });
                    row.appendChild(spacer);
                    for (let colIndex = 0; colIndex < rowLengths[rowIndex]; colIndex++) {
                        const key = div$8({ style: `width: 20px; height: 20px; margin: 0 2px; box-sizing: border-box; flex-shrink: 0; display: flex; justify-content: center; align-items: center;` });
                        row.appendChild(key);
                        const pitch = KeyboardLayout.keyPosToPitch(this._doc, colIndex, 3 - rowIndex, this._keyboardLayout.value);
                        if (pitch != null) {
                            const scalePitch = pitch % 12;
                            if (scale[scalePitch]) {
                                if (scalePitch == 0) {
                                    key.style.background = ColorConfig.tonic;
                                }
                                else if (scalePitch == 7 && this._doc.prefs.showFifth) {
                                    key.style.background = ColorConfig.fifthNote;
                                }
                                else {
                                    key.style.background = ColorConfig.pitchBackground;
                                }
                            }
                            else {
                                key.style.border = "2px solid " + ColorConfig.pitchBackground;
                            }
                            if (this._bassOffset.selectedIndex != 0 && pitch <= Piano.getBassCutoffPitch(this._doc)) {
                                key.style.setProperty("filter", "hue-rotate(60deg) brightness(0.5)");
                            }
                            else {
                                key.style.setProperty("filter", "");
                            }
                            const pitchNameIndex = (scalePitch + Config.keys[this._doc.song.key].basePitch) % Config.pitchesPerOctave;
                            key.textContent = Piano.getPitchName(pitchNameIndex, scalePitch, Math.floor(pitch / 12));
                        }
                    }
                }
            };
            this._keyboardMode.value = this._doc.prefs.pressControlForShortcuts ? "pressControlForShortcuts" : "useCapsLockForNotes";
            this._keyboardLayout.value = this._doc.prefs.keyboardLayout;
            this._bassOffset.value = String(this._doc.prefs.bassOffset);
            this._enableMidi.checked = this._doc.prefs.enableMidi;
            this._showRecordButton.checked = this._doc.prefs.showRecordButton;
            this._snapRecordedNotesToRhythm.checked = this._doc.prefs.snapRecordedNotesToRhythm;
            this._ignorePerformedNotesNotInScale.checked = this._doc.prefs.ignorePerformedNotesNotInScale;
            this._metronomeCountIn.checked = this._doc.prefs.metronomeCountIn;
            this._metronomeWhileRecording.checked = this._doc.prefs.metronomeWhileRecording;
            setTimeout(() => this._showRecordButton.focus());
            this._okayButton.addEventListener("click", this._confirm);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._renderKeyboardLayoutPreview();
            this._keyboardLayout.addEventListener("change", this._renderKeyboardLayoutPreview);
            this._bassOffset.addEventListener("change", this._renderKeyboardLayoutPreview);
        }
    }

    class SpectrumEditor {
        constructor(_doc, _spectrumIndex, _isPrompt = false) {
            this._spectrumIndex = _spectrumIndex;
            this._isPrompt = _isPrompt;
            this._editorWidth = 120;
            this._editorHeight = 26;
            this._fill = SVG.path({ fill: ColorConfig.uiWidgetBackground, "pointer-events": "none" });
            this._octaves = SVG.svg({ "pointer-events": "none" });
            this._fifths = SVG.svg({ "pointer-events": "none" });
            this._curve = SVG.path({ fill: "none", stroke: "currentColor", "stroke-width": 2, "pointer-events": "none" });
            this._arrow = SVG.path({ fill: "currentColor", "pointer-events": "none" });
            this._svg = SVG.svg({ style: `background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;`, width: "100%", height: "100%", viewBox: "0 0 " + this._editorWidth + " " + this._editorHeight, preserveAspectRatio: "none" }, this._fill, this._octaves, this._fifths, this._curve, this._arrow);
            this.container = HTML.div({ class: "spectrum", style: "height: 100%;" }, this._svg);
            this._mouseX = 0;
            this._mouseY = 0;
            this._freqPrev = 0;
            this._ampPrev = 0;
            this._mouseDown = false;
            this._change = null;
            this._renderedPath = "";
            this._renderedFifths = true;
            this._undoHistoryState = 0;
            this._changeQueue = [];
            this.storeChange = () => {
                var sameCheck = true;
                if (this._changeQueue.length > 0) {
                    for (var i = 0; i < Config.spectrumControlPoints; i++) {
                        if (this._changeQueue[this._undoHistoryState][i] != this.instrument.spectrumWave.spectrum[i]) {
                            sameCheck = false;
                            i = Config.spectrumControlPoints;
                        }
                    }
                }
                if (sameCheck == false || this._changeQueue.length == 0) {
                    this._changeQueue.splice(0, this._undoHistoryState);
                    this._undoHistoryState = 0;
                    this._changeQueue.unshift(this.instrument.spectrumWave.spectrum.slice());
                    if (this._changeQueue.length > 32) {
                        this._changeQueue.pop();
                    }
                }
            };
            this.undo = () => {
                if (this._undoHistoryState < this._changeQueue.length - 1) {
                    this._undoHistoryState++;
                    const spectrum = this._changeQueue[this._undoHistoryState].slice();
                    this.setSpectrumWave(spectrum);
                }
            };
            this.redo = () => {
                if (this._undoHistoryState > 0) {
                    this._undoHistoryState--;
                    const spectrum = this._changeQueue[this._undoHistoryState].slice();
                    this.setSpectrumWave(spectrum);
                }
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenTouchPressed = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._freqPrev = this._xToFreq(this._mouseX);
                this._ampPrev = this._yToAmp(this._mouseY);
                this._whenCursorMoved();
            };
            this._whenMouseMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = ((event.clientX || event.pageX) - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = ((event.clientY || event.pageY) - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
            };
            this._whenTouchMoved = (event) => {
                if (this.container.offsetParent == null)
                    return;
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const boundingRect = this._svg.getBoundingClientRect();
                this._mouseX = (event.touches[0].clientX - boundingRect.left) * this._editorWidth / (boundingRect.right - boundingRect.left);
                this._mouseY = (event.touches[0].clientY - boundingRect.top) * this._editorHeight / (boundingRect.bottom - boundingRect.top);
                if (isNaN(this._mouseX))
                    this._mouseX = 0;
                if (isNaN(this._mouseY))
                    this._mouseY = 0;
                this._whenCursorMoved();
                this.render();
            };
            this._whenCursorReleased = (event) => {
                if (this._mouseDown) {
                    if (!this._isPrompt) {
                        this._doc.record(this._change);
                    }
                    this.storeChange();
                    this._change = null;
                }
                this._mouseDown = false;
            };
            this._doc = _doc;
            this.instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            for (let i = 0; i < Config.spectrumControlPoints; i += Config.spectrumControlPointsPerOctave) {
                this._octaves.appendChild(SVG.rect({ fill: ColorConfig.tonic, x: (i + 1) * this._editorWidth / (Config.spectrumControlPoints + 2) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            for (let i = 4; i <= Config.spectrumControlPoints; i += Config.spectrumControlPointsPerOctave) {
                this._fifths.appendChild(SVG.rect({ fill: ColorConfig.fifthNote, x: (i + 1) * this._editorWidth / (Config.spectrumControlPoints + 2) - 1, y: 0, width: 2, height: this._editorHeight }));
            }
            this.storeChange();
            this.container.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenCursorReleased);
            this.container.addEventListener("touchstart", this._whenTouchPressed);
            this.container.addEventListener("touchmove", this._whenTouchMoved);
            this.container.addEventListener("touchend", this._whenCursorReleased);
            this.container.addEventListener("touchcancel", this._whenCursorReleased);
        }
        _xToFreq(x) {
            return (Config.spectrumControlPoints + 2) * x / this._editorWidth - 1;
        }
        _yToAmp(y) {
            return Config.spectrumMax * (1 - (y - 1) / (this._editorHeight - 2));
        }
        _whenCursorMoved() {
            if (this._mouseDown) {
                const freq = this._xToFreq(this._mouseX);
                const amp = this._yToAmp(this._mouseY);
                const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                const spectrumWave = (this._spectrumIndex == null) ? instrument.spectrumWave : instrument.drumsetSpectrumWaves[this._spectrumIndex];
                if (freq != this._freqPrev) {
                    const slope = (amp - this._ampPrev) / (freq - this._freqPrev);
                    const offset = this._ampPrev - this._freqPrev * slope;
                    const lowerFreq = Math.ceil(Math.min(this._freqPrev, freq));
                    const upperFreq = Math.floor(Math.max(this._freqPrev, freq));
                    for (let i = lowerFreq; i <= upperFreq; i++) {
                        if (i < 0 || i >= Config.spectrumControlPoints)
                            continue;
                        spectrumWave.spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(i * slope + offset)));
                    }
                }
                spectrumWave.spectrum[Math.max(0, Math.min(Config.spectrumControlPoints - 1, Math.round(freq)))] = Math.max(0, Math.min(Config.spectrumMax, Math.round(amp)));
                this._freqPrev = freq;
                this._ampPrev = amp;
                this._change = new ChangeSpectrum(this._doc, instrument, spectrumWave);
                this._doc.setProspectiveChange(this._change);
            }
        }
        getSpectrumWave() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            if (this._spectrumIndex == null) {
                return instrument.spectrumWave;
            }
            else {
                return instrument.drumsetSpectrumWaves[this._spectrumIndex];
            }
        }
        setSpectrumWave(spectrum, saveHistory = false) {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            if (this._spectrumIndex == null) {
                for (let i = 0; i < Config.spectrumControlPoints; i++) {
                    instrument.spectrumWave.spectrum[i] = spectrum[i];
                }
                const spectrumChange = new ChangeSpectrum(this._doc, instrument, instrument.spectrumWave);
                if (saveHistory) {
                    this._doc.record(spectrumChange);
                }
            }
            else {
                for (let i = 0; i < Config.spectrumControlPoints; i++) {
                    instrument.drumsetSpectrumWaves[this._spectrumIndex].spectrum[i] = spectrum[i];
                }
                const spectrumChange = new ChangeSpectrum(this._doc, instrument, instrument.drumsetSpectrumWaves[this._spectrumIndex]);
                if (saveHistory) {
                    this._doc.record(spectrumChange);
                }
            }
            this.render();
        }
        saveSettings() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            if (this._spectrumIndex == null || this._spectrumIndex == undefined) {
                return new ChangeSpectrum(this._doc, instrument, instrument.spectrumWave);
            }
            else {
                return new ChangeSpectrum(this._doc, instrument, instrument.drumsetSpectrumWaves[this._spectrumIndex]);
            }
        }
        resetToInitial() {
            this._changeQueue = [];
            this._undoHistoryState = 0;
        }
        render() {
            const instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const spectrumWave = (this._spectrumIndex == null) ? instrument.spectrumWave : instrument.drumsetSpectrumWaves[this._spectrumIndex];
            const controlPointToHeight = (point) => {
                return (1 - (point / Config.spectrumMax)) * (this._editorHeight - 1) + 1;
            };
            let lastValue = 0;
            let path = "M 0 " + prettyNumber(this._editorHeight) + " ";
            for (let i = 0; i < Config.spectrumControlPoints; i++) {
                let nextValue = spectrumWave.spectrum[i];
                if (lastValue != 0 || nextValue != 0) {
                    path += "L ";
                }
                else {
                    path += "M ";
                }
                path += prettyNumber((i + 1) * this._editorWidth / (Config.spectrumControlPoints + 2)) + " " + prettyNumber(controlPointToHeight(nextValue)) + " ";
                lastValue = nextValue;
            }
            const lastHeight = controlPointToHeight(lastValue);
            if (lastValue > 0) {
                path += "L " + (this._editorWidth - 1) + " " + prettyNumber(lastHeight) + " ";
            }
            if (this._renderedPath != path) {
                this._renderedPath = path;
                this._curve.setAttribute("d", path);
                this._fill.setAttribute("d", path + "L " + this._editorWidth + " " + prettyNumber(lastHeight) + " L " + this._editorWidth + " " + prettyNumber(this._editorHeight) + " L 0 " + prettyNumber(this._editorHeight) + " z ");
                this._arrow.setAttribute("d", "M " + this._editorWidth + " " + prettyNumber(lastHeight) + " L " + (this._editorWidth - 4) + " " + prettyNumber(lastHeight - 4) + " L " + (this._editorWidth - 4) + " " + prettyNumber(lastHeight + 4) + " z");
                this._arrow.style.display = (lastValue > 0) ? "" : "none";
            }
            if (this._renderedFifths != this._doc.prefs.showFifth) {
                this._renderedFifths = this._doc.prefs.showFifth;
                this._fifths.style.display = this._doc.prefs.showFifth ? "" : "none";
            }
        }
    }
    class SpectrumEditorPrompt {
        constructor(_doc, _songEditor, _isDrumset) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._isDrumset = _isDrumset;
            this.spectrumEditor = new SpectrumEditor(this._doc, null, true);
            this.spectrumEditors = [];
            this._drumsetSpectrumIndex = 0;
            this._playButton = HTML.button({ style: "width: 55%;", type: "button" });
            this._drumsetButtons = [];
            this._drumsetButtonContainer = HTML.div({ class: "instrument-bar", style: "justify-content: center;" });
            this._cancelButton = HTML.button({ class: "cancelButton" });
            this._okayButton = HTML.button({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.copyButton = HTML.button({ style: "width:86px; margin-right: 5px;", class: "copyButton" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this.pasteButton = HTML.button({ style: "width:86px;", class: "pasteButton" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this.copyPasteContainer = HTML.div({ style: "width: 185px;" }, this.copyButton, this.pasteButton);
            this.container = HTML.div({ class: "prompt noSelection", style: "width: 500px;" }, HTML.h2("Edit Spectrum Instrument"), HTML.div({ style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;" }, this._playButton), this._drumsetButtonContainer, HTML.div({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center; height: 80%" }, this.spectrumEditor.container), HTML.div({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton, this.copyPasteContainer), this._cancelButton);
            this._setDrumSpectrum = (index) => {
                this._drumsetButtons[this._drumsetSpectrumIndex].classList.remove("selected-instrument");
                this.spectrumEditors[this._drumsetSpectrumIndex].setSpectrumWave(this.spectrumEditor.getSpectrumWave().spectrum);
                this._drumsetSpectrumIndex = index;
                this._drumsetButtons[index].classList.add("selected-instrument");
                this.spectrumEditor.setSpectrumWave(this.spectrumEditors[this._drumsetSpectrumIndex].getSpectrumWave().spectrum);
                this.spectrumEditor.render();
            };
            this._togglePlay = () => {
                this._songEditor.togglePlay();
                this.updatePlayButton();
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this.whenKeyPressed);
                this.spectrumEditor.container.removeEventListener("mousemove", () => this.spectrumEditor.render());
                this._playButton.removeEventListener("click", this._togglePlay);
            };
            this._copySettings = () => {
                const spectrumCopy = this.spectrumEditor.getSpectrumWave();
                window.localStorage.setItem("spectrumCopy", JSON.stringify(spectrumCopy.spectrum));
            };
            this._pasteSettings = () => {
                const storedSpectrumWave = JSON.parse(String(window.localStorage.getItem("spectrumCopy")));
                this.spectrumEditor.setSpectrumWave(storedSpectrumWave);
            };
            this.whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                else if (event.keyCode == 32) {
                    this._togglePlay();
                    event.preventDefault();
                }
                else if (event.keyCode == 90) {
                    this.spectrumEditor.undo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 89) {
                    this.spectrumEditor.redo();
                    event.stopPropagation();
                }
                else if (event.keyCode == 219) {
                    this._doc.synth.goToPrevBar();
                }
                else if (event.keyCode == 221) {
                    this._doc.synth.goToNextBar();
                }
                else if (event.keyCode >= 49 && event.keyCode <= 57) {
                    if (event.shiftKey && this._isDrumset) {
                        this._setDrumSpectrum(event.keyCode - 49);
                    }
                }
                else if (event.keyCode == 48) {
                    if (event.shiftKey && this._isDrumset) {
                        this._setDrumSpectrum(9);
                    }
                }
                else if (event.keyCode == 189 || event.keyCode == 173) {
                    if (event.shiftKey && this._isDrumset) {
                        this._setDrumSpectrum(10);
                    }
                }
                else if (event.keyCode == 187 || event.keyCode == 61 || event.keyCode == 171) {
                    if (event.shiftKey && this._isDrumset) {
                        this._setDrumSpectrum(11);
                    }
                }
            };
            this._saveChanges = () => {
                const group = new ChangeGroup();
                for (let i = 0; i < this.spectrumEditors.length; i++) {
                    group.append(this.spectrumEditors[i].saveSettings());
                }
                this._doc.record(group, true);
                this._doc.prompt = null;
            };
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this.whenKeyPressed);
            this.copyButton.addEventListener("click", this._copySettings);
            this.pasteButton.addEventListener("click", this._pasteSettings);
            this._playButton.addEventListener("click", this._togglePlay);
            this.container.addEventListener("mousemove", () => {
                this.spectrumEditor.render();
                this.spectrumEditors[this._drumsetSpectrumIndex].setSpectrumWave(this.spectrumEditor.getSpectrumWave().spectrum);
            });
            this.container.addEventListener("mousedown", this.spectrumEditor.render);
            this.spectrumEditor.container.addEventListener("mousemove", () => {
                this.spectrumEditor.render();
                this.spectrumEditors[this._drumsetSpectrumIndex].setSpectrumWave(this.spectrumEditor.getSpectrumWave().spectrum);
            });
            this.spectrumEditor.container.addEventListener("mousedown", this.spectrumEditor.render);
            this.updatePlayButton();
            if (this._isDrumset) {
                for (let i = Config.drumCount - 1; i >= 0; i--) {
                    this.spectrumEditors[i] = new SpectrumEditor(this._doc, Config.drumCount - 1 - i, true);
                    this.spectrumEditors[i].setSpectrumWave(this._songEditor._drumsetSpectrumEditors[Config.drumCount - 1 - i].getSpectrumWave().spectrum);
                }
                let colors = ColorConfig.getChannelColor(this._doc.song, this._doc.channel);
                for (let i = 0; i < Config.drumCount; i++) {
                    let newSpectrumButton = HTML.button({ class: "no-underline", style: "max-width: 2em;" }, "" + (i + 1));
                    this._drumsetButtons.push(newSpectrumButton);
                    this._drumsetButtonContainer.appendChild(newSpectrumButton);
                    newSpectrumButton.addEventListener("click", () => { this._setDrumSpectrum(i); });
                }
                this._drumsetButtons[Config.drumCount - 1].classList.add("last-button");
                this._drumsetButtons[0].classList.add("selected-instrument");
                this._drumsetButtonContainer.style.setProperty("--text-color-lit", colors.primaryNote);
                this._drumsetButtonContainer.style.setProperty("--text-color-dim", colors.secondaryNote);
                this._drumsetButtonContainer.style.setProperty("--background-color-lit", colors.primaryChannel);
                this._drumsetButtonContainer.style.setProperty("--background-color-dim", colors.secondaryChannel);
                this._drumsetButtonContainer.style.display = "";
                this.spectrumEditor.container.style.display = "";
                this.spectrumEditor.setSpectrumWave(this.spectrumEditors[this._drumsetSpectrumIndex].getSpectrumWave().spectrum);
            }
            else {
                this._drumsetButtonContainer.style.display = "none";
                this.spectrumEditors[0] = this.spectrumEditor;
            }
            setTimeout(() => this._playButton.focus());
            this.spectrumEditor.render();
        }
        updatePlayButton() {
            if (this._doc.synth.playing) {
                this._playButton.classList.remove("playButton");
                this._playButton.classList.add("pauseButton");
                this._playButton.title = "Pause (Space)";
                this._playButton.innerText = "Pause";
            }
            else {
                this._playButton.classList.remove("pauseButton");
                this._playButton.classList.add("playButton");
                this._playButton.title = "Play (Space)";
                this._playButton.innerText = "Play";
            }
        }
    }

    const { button: button$7, div: div$7, h2: h2$6, input: input$4, p: p$1, a: a$1 } = HTML;
    let doReload = false;
    
async function autoTranslatePage(targetLang,opts={api:"https://libretranslate.de/translate",proxy:null,chunkSize:20}) {
  const dbName="autoLangCache"
  const storeName="texts"
  function openDB(){
    return new Promise((res,rej)=>{
      const req=indexedDB.open(dbName,1)
      req.onupgradeneeded=e=>e.target.result.createObjectStore(storeName)
      req.onsuccess=e=>res(e.target.result)
      req.onerror=e=>rej(e)
    })
  }
  function idbGet(db,key){
    return new Promise(res=>{
      const tx=db.transaction(storeName,"readonly")
      const rq=tx.objectStore(storeName).get(key)
      rq.onsuccess=()=>res(rq.result)
      rq.onerror=()=>res(null)
    })
  }
  function idbPut(db,key,val){
    return new Promise((res,rej)=>{
      const tx=db.transaction(storeName,"readwrite")
      const rq=tx.objectStore(storeName).put(val,key)
      rq.onsuccess=()=>res(true)
      rq.onerror=e=>rej(e)
    })
  }
  const db=await openDB()
  const badTags=new Set(["SCRIPT","STYLE","TEXTAREA","INPUT","SELECT","OPTION","NOSCRIPT"])
  const walker=document.createTreeWalker(document.body,NodeFilter.SHOW_TEXT)
  const nodes=[]
  while(walker.nextNode()){
    const p=walker.currentNode.parentNode
    if(!p||!p.tagName) continue
    if(badTags.has(p.tagName)) continue
    const txt=walker.currentNode.nodeValue
    if(!txt) continue
    if(!txt.trim()||txt.trim().length<2) continue
    nodes.push(walker.currentNode)
  }
  const uniqueMap=new Map()
  nodes.forEach(n=>{
    const k=n.nodeValue
    if(!uniqueMap.has(k)) uniqueMap.set(k,[])
    uniqueMap.get(k).push(n)
  })
  const uniqueTexts=[...uniqueMap.keys()]
  const resultMap=new Map()
  const toTranslate=[]
  for(const t of uniqueTexts){
    const cached=await idbGet(db,t)
    if(cached) resultMap.set(t,cached)
    else toTranslate.push(t)
  }
  async function postTranslateBatch(texts){
    const body={q:texts,source:"en",target:targetLang,format:"text"}
    const url=opts.proxy?opts.proxy+opts.api:opts.api
    const r=await fetch(url,{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify(body)
    })
    if(!r.ok) throw new Error("translate failed")
    const j=await r.json()
    if(Array.isArray(j)) return j.map(x=>x.translatedText||x) 
    if(typeof j.translatedText==="string") return [j.translatedText]
    throw new Error("unexpected response")
  }
  const chunkSize=opts.chunkSize||20
  for(let i=0;i<toTranslate.length;i+=chunkSize){
    const chunk=toTranslate.slice(i,i+chunkSize)
    try{
      const translated=await postTranslateBatch(chunk)
      for(let k=0;k<chunk.length;k++){
        const orig=chunk[k]
        const tr=translated[k]||orig
        resultMap.set(orig,tr)
        await idbPut(db,orig,tr)
      }
    }catch{
      for(const t of chunk){
        try{
          const body={q:t,source:"en",target:targetLang,format:"text"}
          const url=opts.proxy?opts.proxy+opts.api:opts.api
          const r=await fetch(url,{
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify(body)
          })
          if(!r.ok) throw new Error("single fail")
          const j=await r.json()
          const tr=j.translatedText||t
          resultMap.set(t,tr)
          await idbPut(db,t,tr)
        }catch{
          resultMap.set(t,t)
        }
      }
    }
  }
  for(const [orig,nodesArr] of uniqueMap){
    const tr=resultMap.get(orig)||orig
    for(const n of nodesArr) n.nodeValue=n.nodeValue.replace(orig,tr)
  }
}
class PluginContainer {
  constructor(title, contentHtml, onClose, _doc) {
   	this._doc = _doc;
    this.onClose = onClose;
    this.closeBtn = button$6({
      style: "position: absolute; top: 8px; right: 8px; width: 32px; height: 32px;"
    }, "x");
    this.fullBtn = button$6({
      style: "position: absolute; top: 8px; right: 48px; width: 32px; height: 32px;"
    }, "");
    this.content = div$6({ class: "pluginContent" });
    this.content.innerHTML = contentHtml;
    this.container = div$6(
      { class: "prompt noSelection pluginWindow", style:"max-width:300px; width:calc(100% - 80px); padding:0;"},
      h2$5({style:"width:calc(100% - 80px); overflow: hidden;"},title),
      this.fullBtn,
      this.closeBtn,
      this.content
    );
    this._originalStyle = {
      width: this.container.style.width || this.container.offsetWidth + "px",
      height: this.container.style.height || this.container.offsetHeight + "px",
      maxHeight:this.container.style.maxHeight, 
      maxWidth:this.container.style.maxWidth, 
      borderRadius: this.container.style.borderRadius || getComputedStyle(this.container).borderRadius
    };
    this._isFullscreen = false;
    this._close = () => {
      this._doc.prompt = null;
      this._doc.undo();
      if (doReload) {
       setTimeout(() => {reloadsite() }, 50);
      }
    };
    this._cancelHandler = this._close
    this._fullHandler = () => this.toggleFull();
    this.closeBtn.addEventListener("click", this._cancelHandler);
    this.fullBtn.addEventListener("click", this._fullHandler);
  }
  toggleFull() {
    if (!this._isFullscreen) {
      this.container.style.width = "100%";
      this.container.style.height = "100vh";
      this.container.style.maxHeight = "100vh";
      this.container.style.maxWidth = "100vw";
      this.container.style.borderRadius = "0px";
    } else {
      this.container.style.width = "";
      this.container.style.height = "";
      this.container.style.maxHeight = this._originalStyle.maxHeight;
      this.container.style.maxWidth = this._originalStyle.maxWidth;
      this.container.style.width = "100%";
      this.container.style.borderRadius = this._originalStyle.borderRadius;
    }
    this._isFullscreen = !this._isFullscreen;
  }
  cleanUp() {
    this.closeBtn.removeEventListener("click", this._closeHandler);
    this.fullBtn.removeEventListener("click", this._fullHandler);
  }
}

class SamplesOfflinePlugin {
static title = "Sample Manager";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `
<style>
.white-key{color:#3B3B3B !important;}
    .file-item {
background: #FFFFFF;margin: 0.5rem 0;padding: 1rem;color:#000000;border: 1px solid #F6F6F6;border-radius: 6px;display: flex;justify-content: space-between;align-items: center;}
.file-item span {flex: 1;}
.file-item button {margin-left: 1rem;}
.menu {margin-top: 1rem;}
#fileList{background:#252525;min-width:100%;min-height:50px;max-height:400px; overflow: hidden scroll;}
#fileList button{background:#dedede;color:white;}
#themeList{background:#252525;min-width:90vw;min-height:50px;max-height:400px; overflow: hidden scroll;}
</style><button id="generateSample" >Sample File</button><input type="file" style="display:none;" id="fileInput" accept=".mp3,.wav,.ogg,.m4a"><div class="menu"><label>Sample name:</label><input id="varname" type="text"><label>Compression larger number smaller compression:</label><input id="compressionLevel" type="number" min="2" max="1000" value="10000"><label>Max Sample Length:</label><input id="audiolength" type="number" min="100" max="2500000" value="250000" placeholder="250000">
<label><input type="checkbox" onclick="let truety=this.checked; document.getElementById('notetron').style.display=!truety?'block':'none';document.getElementById('detunator').style.display=truety?'block':'none'; if(isFileIn==1){ container.querySelector('#generateButton').disabled = !truety; container.querySelector('#generateButton2').disabled = truety;}" id="rootNoteMode"> Mode </label><label id="notetron" style="display:block;"  >Root Note:<input id="rootnotekey" type="number" oninput="document.getElementById('rootNote').innerText=_noteNameFromPitchNumber(this.value)" min="0" max="127" value="60" placeholder="MIDI root key"> <text id="rootNote">C4</text></label><label id="detunator" style="display:none;" >Detune:<input id="detunesample"   type="number" min="-55" max="55" placeholder="detune" value="-55"></label><text id="detectednote"> </text><input id="expressions" type="number" min="0.5" max="5" placeholder="expression" value="1.0"><button id="generateButton2" disabled>Create with root</button><button id="generateButton" disabled>Create</button><button id="reload" >Reload</button></div> all your samples will be generated in wave for chipwave at the bottom <div id="fileList"><div id="loadingMsg" style="opacity:0.6;font-size:14px;display:block">Loading Your Last Samples... Please Be Patient.</div></div><div><button id="generateZip" >Save As Zip</button><button id="importZipReplace" >Import Zip And Remove All</button><button id="importZip" >Import Zip Add</button></div>after creating a sample please wait to load sample in the chip wave section share zip file with samples and json music. please be patient when youre exporting your samples as zip it takes some time 
        `;
    }
script(container) {
function renderFileList() {
const list = container.querySelector('#fileList');
const loading = container.querySelector('#loadingMsg');
requestAnimationFrame(() => {
Object.keys(filesMap).forEach(id => {
	if (document.getElementById(`file-${id}`)) return;
const div = document.createElement('div');
div.className = 'file-item';
div.style.position = 'relative';
div.id = `file-${id}`;
const span = document.createElement('span');
span.textContent = filesMap[id].name;
const sizeSpan = document.createElement('span');
const bytes = filesMap[id].buffer.length * 4;
sizeSpan.textContent = formatSize(bytes);
sizeSpan.style.position = 'absolute';
sizeSpan.style.right = '4px';
sizeSpan.style.bottom = '2px';
sizeSpan.style.fontSize = '11px';
sizeSpan.style.opacity = '0.7';
const btn = document.createElement('button');
btn.textContent = 'X';
btn.onclick = () => {
delete filesMap[id];
deleteFile(Number(id));
document.getElementById(`file-${id}`).remove();
};
div.appendChild(span);
div.appendChild(btn);
div.appendChild(sizeSpan)
list.appendChild(div);
});
loading.style.display="none"
});
}
let selectedFile = null;
let audioContext = new AudioContext({ sampleRate: 44100 });
let isFileIn = 0
container.querySelector('#generateSample').addEventListener('click', (event) => { container.querySelector('#fileInput').click() })
container.querySelector('#fileInput').addEventListener('change', (event) => {
selectedFile = event.target.files[0];
container.querySelector('#generateButton').disabled = false;
container.querySelector('#generateButton2').disabled = false;
isFileIn=1
const truety=document.getElementById('rootNoteMode').checked; document.getElementById('notetron').style.display=!truety?'block':'none';document.getElementById('detunator').style.display=truety?'block':'none'; if(isFileIn==1){ container.querySelector('#generateButton').disabled = !truety; container.querySelector('#generateButton2').disabled = truety;}
const nameField = container.querySelector('#varname');
nameField.value = selectedFile.name.replace(/\.(mp3|wav|ogg)$/i, '');
});
container.querySelector('#generateButton2').addEventListener('click', async () => {
if (!selectedFile) return;
const fileId = Date.now();
const arrayBuffer = await selectedFile.arrayBuffer();
const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
const samples = Array.from(audioBuffer.getChannelData(0));
const sampleArray = samples.map(s => parseFloat(s.toFixed(5)));
const nameInput = container.querySelector('#varname').value.trim();
const fileName = nameInput ? nameInput : selectedFile.name.replace(/\.(mp3|wav|ogg|m4a)$/i, '');
let detunesample1 = parseInt(container.querySelector('#detunesample').value);
let rootnotesample1 = parseInt(container.querySelector('#rootnotekey').value);
let expression1 = parseInt(container.querySelector('#expressions').value);
if (container.querySelector('#rootNoteMode').checked) {
    POPUP(innerWidth/2-150, innerHeight/2-100 + window.scrollY
     ,"Generating Error",
    		"<text style='color:black'>This S Only For Root Note</text>",
    		"#00afdf"
   	); return;
} else {
filesMap[fileId] = { name: fileName, buffer: sampleArray, rootNote: rootnotesample1, expression: expression1 };
saveBuffer(fileId, fileName, sampleArray, null, expression1, rootnotesample1);
}
renderFileList();
container.querySelector('#varname').value = '';
container.querySelector('#fileInput').value = '';
selectedFile = null;
container.querySelector('#generateButton2').disabled = true;
skipsamplesLoading=false
loadFiles();
updateSampledWaves()
isFileIn=0
});
container.querySelector('#generateButton').addEventListener('click', async () => {
if (!selectedFile) return;
const fileId = Date.now();
const arrayBuffer = await selectedFile.arrayBuffer();
const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
const samples = Array.from(audioBuffer.getChannelData(0));
const semitoneShift = -12;
const pitchRatio = Math.pow(2, semitoneShift / 12);
const newLength = Math.floor(samples.length * pitchRatio);
const shiftedSamples = new Array(newLength);
for (let i = 0; i < newLength; i++) {
const srcIndex = i / pitchRatio;
const low = Math.floor(srcIndex);
const high = Math.min(low + 1, samples.length - 1);
const frac = srcIndex - low;
shiftedSamples[i] = samples[low] * (1 - frac) + samples[high] * frac;
}
const compressionLevel = parseInt(container.querySelector('#compressionLevel').value);
const compressedSamples = shiftedSamples.filter((_, index) => index % compressionLevel !== 0);
const maxSamples = parseInt(container.querySelector('#audiolength').value)||250000;
const croppedSamples = compressedSamples.slice(0, maxSamples);

const nameInput = container.querySelector('#varname').value.trim();
const fileName = nameInput ? nameInput : selectedFile.name.replace(/\.(mp3|wav|ogg|m4a)$/i, '');
const sampleArray = croppedSamples.map(s => parseFloat(s.toFixed(6)));
 let detunesample1=parseInt(container.querySelector('#detunesample').value)
 let rootnotesample1=parseInt(container.querySelector('#rootnotekey').value)
  let expression1=parseInt(container.querySelector('#expressions').value)
 if(container.querySelector('#rootNoteMode').checked){
      filesMap[fileId] = { name: fileName, buffer: sampleArray,extradetune:detunesample1, expression: expression1  };
      saveBuffer(fileId, fileName, sampleArray,detunesample1,expression1);
 }else{
      filesMap[fileId] = { name: fileName, buffer: sampleArray,rootNote:rootnotesample1, expression: expression1  };
      saveBuffer(fileId, fileName, sampleArray,null,expression1,rootnotesample1);
 }
renderFileList();
container.querySelector('#varname').value = '';
container.querySelector('#fileInput').value = '';
selectedFile = null; 
container.querySelector('#fileInput').value = '';
container.querySelector('#generateButton').disabled = true;
skipsamplesLoading=false
loadFiles()
updateSampledWaves()
isFileIn=0
    });
container.querySelector('#reload').addEventListener('click', async () => {
	skipsamplesLoading=false
	loadFiles()
	updateSampledWaves()
	renderFileList();
	reloadsite()
});
setTimeout(function(){
renderFileList();
},2);
container.querySelector('#generateZip').addEventListener('click', async () => {
	const zip = new JSZip();
	for (const id in filesMap) {
		const file = filesMap[id];
		const samples = new Int16Array(file.buffer.length)
		for (let i = 0; i < file.buffer.length; i++) {
			let s = Math.max(-1, Math.min(1, file.buffer[i]))
			samples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF
		}
		const encoder = new lamejs.Mp3Encoder(1, 44100, 128)
		let mp3 = []
		let block = 1152
		for (let i = 0; i < samples.length; i += block) {
			let chunk = samples.subarray(i, i + block)
			let buf = encoder.encodeBuffer(chunk)
			if (buf.length > 0) mp3.push(buf)
		}
		let end = encoder.flush()
		if (end.length > 0) mp3.push(end)
		let mp3Blob = new Blob(mp3, { type: "audio/mpeg" })
		zip.file(`${file.name}.mp3`, mp3Blob)
		const meta = {
			extradetune: file.extradetune,
			expression: file.expression,
			rootNote: file.rootNote
		};
		zip.file(`${file.name}.json`, JSON.stringify(meta));
	}
	const blob = await zip.generateAsync({ type: 'blob' });
	const a = document.createElement('a');
	let src = URL.createObjectURL(blob)
	a.href = src;
	a.download = 'fruitysamples.zip';
	a.click();
	if (location.href.startsWith("file:///")) {
		fetch(src)
			.then(response => response.blob())
			.then(blob => blobToBase6422(blob))
			.then(base64data => {
				NativeJava.DownloadFile(base64data, 'fruitysamples.zip');
			});
	}
});
container.querySelector('#importZip').addEventListener('click', () => {
	const input = document.createElement('input');
	input.type = 'file';
	input.accept = '.zip';
	input.onchange = async (e) => {
		const file = e.target.files[0];
		const zip = await JSZip.loadAsync(file);
		const audioCtx = new AudioContext({ sampleRate: 44100 });
		for (const relativePath in zip.files) {
			let extension = relativePath.endsWith('.mp3') || relativePath.endsWith('.wav')
			let extensionname = relativePath.endsWith('.mp3') ? ".mp3" : relativePath.endsWith('.wav') ? ".wav" : ""
			if (extension) {
				const wavFile = zip.files[relativePath];
				const arrayBuffer = await wavFile.async('arraybuffer');
				const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
				const channelData = audioBuffer.getChannelData(0);
				const floatBuffer = Array.from(channelData);
				const baseName = relativePath.replace(extensionname, '');
				let extradetune = 0;
				let expression = 0;
				let rootNote = 0;
				const id = Date.now() + Math.random();
				if (zip.files[baseName + '.json']) {
					const metaStr = await zip.files[baseName + '.json'].async('string');
					const meta = JSON.parse(metaStr);
					extradetune = meta.extradetune || 0;
					expression = meta.expression || 0;
					rootNote = meta.rootNote;
					filesMap[id] = meta.rootNote !== null ? {
						name: baseName,
						buffer: floatBuffer,
						rootNote,
						expression
					} : {
						name: baseName,
						buffer: floatBuffer,
						extradetune,
						expression
					};
				}
				saveBuffer(id, baseName, floatBuffer, extradetune, expression, rootNote);
			}
		}
		renderFileList();
		skipsamplesLoading=false
		loadFiles()
		updateSampledWaves()
	};
	input.click();
});
container.querySelector('#importZipReplace').addEventListener('click', () => {
	const input = document.createElement('input');
	input.type = 'file';
	input.accept = '.zip';
	input.onchange = async (e) => {
		const file = e.target.files[0];
		const zip = await JSZip.loadAsync(file);
		const audioCtx = new AudioContext({ sampleRate: 44100 });
		filesMap = [];
		for (const relativePath in zip.files) {
			let extension = relativePath.endsWith('.mp3') || relativePath.endsWith('.wav')
			let extensionname = relativePath.endsWith('.mp3') ? ".mp3" : relativePath.endsWith('.wav') ? ".wav" : ""
			if (extension) {
				const wavFile = zip.files[relativePath];
				const arrayBuffer = await wavFile.async('arraybuffer');
				const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
				const channelData = audioBuffer.getChannelData(0);
				const floatBuffer = Array.from(channelData);
				const baseName = relativePath.replace(extensionname, '');
				let extradetune = 0;
				let expression = 0;
				let rootNote = 0;
				const id = Date.now() + Math.random();
				if (zip.files[baseName + '.json']) {
					const metaStr = await zip.files[baseName + '.json'].async('string');
					const meta = JSON.parse(metaStr);
					extradetune = meta.extradetune || 0;
					expression = meta.expression || 0;
					rootNote = meta.rootNote;
					filesMap[id] = meta.rootNote !== null ? {
						name: baseName,
						buffer: floatBuffer,
						rootNote,
						expression
					} : {
						name: baseName,
						buffer: floatBuffer,
						extradetune,
						expression
					};
				}
				saveBuffer(id, baseName, floatBuffer, extradetune, expression, rootNote);
			}
		}
		renderFileList();
		skipsamplesLoading=false
		loadFiles()
		updateSampledWaves()
	};
	input.click();
});
}
destroy() {}
}
class SampleEditorPlugin {
static title = "Loop Editor";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `
<style>
#editor_C01 { background: #121212; color: #eee; padding: 0px; font-family: Arial, sans-serif; overflow: hidden scroll;}
#editor_C01 input, #editor_C01 button, #editor_C01 audio, #editor_C01 canvas {
background: #000; border: none; outline: none; box-shadow: none; color: #eee; margin: 5px;
}
</style><h1>SAMPLER EDITOR</h1> 
<div id="editor_C01"><input type="file" id="fileInput_C01" accept="audio/*"><button id="loadBtn_C01" disabled>Load</button><audio id="audio_C01"   controls></audio><span id="duration_C01"></span> <br>start<input type="number" id="startTime_C01" min="0" step="0.01"> <br>end <input type="number" id="endTime_C01" min="0" step="0.01"> <br>repeat<input type="number" id="repeats_C01" min="1" step="1" value="2"> <br><label><input type="checkbox" id="cutOption_C01">Cut only</label> <br>pitchshift in semitones<input type="number" id="pitchShift_C01" value="0" step="1">  <br><button id="loopBtn_C01" disabled>Loop</button><button id="playOutputBtn_C01" disabled>Play</button><button id="exportBtn_C01" disabled>Export</button><audio id="outputAudio_C01" controls style="display:none;width:100%"></audio><canvas id="waveform_C01"></canvas><label>Volume: <input type="number" id="volume_C01" min="0" max="2" step="0.1" value="1"></label><button id="addAudioBtn_C01" disabled>connect Audio</button>
        `;
    }
script(container) {
    let originalBuffer, outputUrl, selection={start:0,end:0,dragging:false};
    var audioCtx = new AudioContext({ sampleRate: 44100 });

const addAudioBtn = container.querySelector('#addAudioBtn_C01');
let outputBuffer;
addAudioBtn.disabled = false;
addAudioBtn.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/*';
    input.onchange = () => {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            audioCtx.decodeAudioData(reader.result).then(newBuf => {
                const ch = Math.min(originalBuffer.numberOfChannels, newBuf.numberOfChannels);
                const sr = audioCtx.sampleRate;
                const combined = audioCtx.createBuffer(
                    ch,
                    originalBuffer.length + newBuf.length,
                    sr
                );
                for (let c = 0; c < ch; c++) {
                    const combinedData = combined.getChannelData(c);
                    combinedData.set(originalBuffer.getChannelData(c), 0);
                    combinedData.set(newBuf.getChannelData(c), originalBuffer.length);
                }
                originalBuffer = combined;
                 drawWaveform()
            });
        };
        reader.readAsArrayBuffer(file);
    };
    input.click();
});
const canvas = container.querySelector('#waveform_C01');
const ctx = canvas.getContext('2d');
function drawWaveform(){
canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight;
const data=originalBuffer.getChannelData(0);
                const step=Math.ceil(data.length/canvas.width);
                const h=canvas.height/2;
                ctx.clearRect(0,0,canvas.width,canvas.height);
                ctx.strokeStyle='#eee'; ctx.beginPath(); ctx.moveTo(0,h);
                for(let i=0;i<canvas.width;i++){
                    let min=1, max=-1;
                    for(let j=0;j<step;j++){ const v=data[i*step+j]; if(v<min) min=v; if(v>max) max=v; }
                    ctx.lineTo(i,(1+min)*h); ctx.lineTo(i,(1+max)*h);
                }
                ctx.stroke();
                if(selection.start!==selection.end){
                    const x1=selection.start/originalBuffer.duration*canvas.width;
                    const x2=selection.end/originalBuffer.duration*canvas.width;
                    ctx.fillStyle='rgba(0,123,255,0.3)';
                    ctx.fillRect(Math.min(x1,x2),0,Math.abs(x2-x1),canvas.height);
                }
            }
        function openAudioLoopEditor_C01(){
            const fileInput=container.querySelector('#fileInput_C01');
            const loadBtn=container.querySelector('#loadBtn_C01');
            const audioEl=container.querySelector('#audio_C01');
            const durationEl=container.querySelector('#duration_C01');
            const startInput=container.querySelector('#startTime_C01');
            const endInput=container.querySelector('#endTime_C01');
            const repeatsInput=container.querySelector('#repeats_C01');
            const cutCheckbox=container.querySelector('#cutOption_C01');
            const pitchInput=container.querySelector('#pitchShift_C01');
            const loopBtn=container.querySelector('#loopBtn_C01');
            const playBtn=container.querySelector('#playOutputBtn_C01');
            const exportBtn=container.querySelector('#exportBtn_C01');
            const outputAudio=container.querySelector('#outputAudio_C01');
            fileInput.addEventListener('change',()=>loadBtn.disabled=!fileInput.files.length);
            loadBtn.addEventListener('click',()=>{
                const file=fileInput.files[0]; if(!file) return;
                audioEl.src=URL.createObjectURL(file);
                audioEl.onloadedmetadata=()=>{
                    durationEl.textContent=`Duration: ${audioEl.duration.toFixed(2)}s`;
                    startInput.max=endInput.max=audioEl.duration;
                    endInput.value=audioEl.duration.toFixed(2);
                    const reader=new FileReader();
                    reader.onload=()=>audioCtx.decodeAudioData(reader.result).then(buf=>{ originalBuffer=buf; drawWaveform(); loopBtn.disabled=false });
                    reader.readAsArrayBuffer(file);
                };
            });
            canvas.addEventListener('mousedown',e=>{ selection.dragging=true; const x=(e.clientX-canvas.getBoundingClientRect().left)/canvas.width*originalBuffer.duration; selection.start=selection.end=x; drawWaveform(); });
            canvas.addEventListener('mousemove',e=>{ if(!selection.dragging) return; const x=(e.clientX-canvas.getBoundingClientRect().left)/canvas.width*originalBuffer.duration; selection.end=x; drawWaveform(); });
            window.addEventListener('mouseup',()=>{ if(selection.dragging){ selection.dragging=false; drawWaveform(); }});
            [startInput,endInput].forEach(inp=>inp.addEventListener('change',()=>{
                if(!originalBuffer) return;
                const s=parseFloat(startInput.value), e=parseFloat(endInput.value);
                selection.start=Math.max(0,Math.min(s,originalBuffer.duration));
                selection.end=Math.max(0,Math.min(e,originalBuffer.duration));
                drawWaveform();
            }));
            loopBtn.addEventListener('click', () => {
    if (!originalBuffer) return;
    audioCtx.resume().then(() => {
        const s = Math.min(selection.start, selection.end);
        const e = Math.max(selection.start, selection.end);
        const r = parseInt(repeatsInput.value, 10);
        const sr = originalBuffer.sampleRate;
        const ss = Math.floor(s * sr), es = Math.floor(e * sr);
        const len = es - ss;
        const ch = originalBuffer.numberOfChannels;
        if (cutCheckbox.checked) {
            outputBuffer = audioCtx.createBuffer(ch, len * r, sr);
            for (let c = 0; c < ch; c++) {
                const seg = originalBuffer.getChannelData(c).slice(ss, es);
                for (let i = 0; i < r; i++) outputBuffer.getChannelData(c).set(seg, i * len);
            }
        } else {
            const before = ss, after = originalBuffer.length - es;
            outputBuffer = audioCtx.createBuffer(ch, before + len * r + after, sr);
            for (let c = 0; c < ch; c++) {
                const od = originalBuffer.getChannelData(c);
                const odr = outputBuffer.getChannelData(c);
                odr.set(od.slice(0, ss), 0);
                const seg = od.slice(ss, es);
                for (let i = 0; i < r; i++) odr.set(seg, before + i * len);
                odr.set(od.slice(es), before + len * r);
            }
        }
        const semitones = parseInt(pitchInput.value, 10);
        const ratio = Math.pow(2, semitones / 12);
        const newLen = Math.floor(outputBuffer.length / ratio);
        const volumeGain = parseFloat(container.getElementById('volume_C01').value) || 1;
        const pitched = audioCtx.createBuffer(outputBuffer.numberOfChannels, newLen, outputBuffer.sampleRate);
        for (let c = 0; c < outputBuffer.numberOfChannels; c++) {
            const inp = outputBuffer.getChannelData(c);
            const out = pitched.getChannelData(c);
            for (let i = 0; i < newLen; i++) {
                const idx = i * ratio;
                const lo = Math.floor(idx);
                const hi = Math.min(lo + 1, inp.length - 1);
                const f = idx - lo;
                out[i] = (inp[lo] * (1 - f) + inp[hi] * f) * volumeGain;
            }
        }
        if (outputUrl) URL.revokeObjectURL(outputUrl);
        outputUrl = URL.createObjectURL(encodeWAV(pitched));
        outputAudio.src = outputUrl;
        outputAudio.style.display = 'block';
        playBtn.disabled = false;
        exportBtn.disabled = false;
        outputAudio.play().catch(() => {});
    });
});
function blobToBase642(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64data = reader.result.split(',')[1];
      resolve(base64data);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}
playBtn.addEventListener('click',()=>{ if(outputAudio.src) outputAudio.play().catch(()=>{}); });
exportBtn.addEventListener('click', () => {
	const outputAudio = container.querySelector('#outputAudio_C01');
	const src = outputAudio.src;
	
	if (!src) return;
	
	const a = document.createElement('a');
	a.href = src;
	a.download = 'output_audio.wav';
	a.click();
	if (location.href.startsWith("file:///")) {
		fetch(src)
			.then(response => response.blob())
			.then(blob => blobToBase642(blob))
			.then(base64data => {
				NativeJava.DownloadFile(base64data, 'output_audio.wav');
			});
	}
});

            function encodeWAV(buf){
                const ch=buf.numberOfChannels, sr=buf.sampleRate, bps=16, samps=buf.length;
                const ba=ch*bps/8, len=44+samps*ch*2; const ab=new ArrayBuffer(len); const dv=new DataView(ab);
                function w(s,o){ for(let i=0;i<s.length;i++) dv.setUint8(o+i,s.charCodeAt(i)); }
                w('RIFF',0); dv.setUint32(4,36+samps*ch*2,true); w('WAVE',8); w('fmt ',12);
                dv.setUint32(16,16,true); dv.setUint16(20,1,true); dv.setUint16(22,ch,true);
                dv.setUint32(24,sr,true); dv.setUint32(28,sr*ba,true); dv.setUint16(32,ba,true); dv.setUint16(34,bps,true);
                w('data',36); dv.setUint32(40,samps*ch*bps/8,true);
                let off=44;
                for(let i=0;i<samps;i++){
                    for(let c=0;c<ch;c++){
                        let v=buf.getChannelData(c)[i];
                        v=Math.max(-1,Math.min(1,v));
                        dv.setInt16(off,v<0?v*0x8000:v*0x7FFF,true);
                        off+=2;
                    }
                }
                return new Blob([ab],{type:'audio/wav'});
            }
        }
        openAudioLoopEditor_C01();
}
destroy() {}
}
class FadeoutPlugin {
static title = "Fade Out Audio";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `<p id="audioLength" style="margin-top:1rem;">Audio Length: <span id="lengthVal">0</span> seconds</p><input type="file" id="fileInput88" accept=".wav" /><div style="margin-top: 1rem; padding: 1rem; background: #222; border-radius: 8px;"><label>Fade End (seconds):<input type="number" id="fadeEnd" value="10" step="0.1" min="0" /></label><br><label>Fade Duration (seconds):<input type="number" id="fadeTime" value="2" step="0.1" min="0" /></label><br><label>End Of Silence (seconds):<input type="number" id="endSilence" value="0" step="0.1" min="0" /></label></div><button id="downloadButton34">Download</button>`;}
script(container) { 
let audioCtx22 = new (window.AudioContext || window.webkitAudioContext)();let audioBuffer22 = null;
container.querySelector('#fileInput88').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return alert("Please select a file.");
  const arrayBuffer = await file.arrayBuffer();
  audioBuffer22 = await audioCtx22.decodeAudioData(arrayBuffer);
  container.querySelector('#lengthVal').textContent = audioBuffer22.duration.toFixed(2);
  alert("File loaded successfully.");
});
container.querySelector('#downloadButton34').addEventListener('click', async () => {
  if (!audioBuffer22) return alert("Please load an audio file first.");
  const duration = audioBuffer22.duration;
  const sampleRate = audioBuffer22.sampleRate;
  const fadeEndSeconds = parseFloat(container.querySelector('#fadeEnd').value);
  const fadeDurationSeconds = parseFloat(container.querySelector('#fadeTime').value);
  const endSilenceSeconds = parseFloat(container.querySelector('#endSilence').value);
  let fadeEnd = duration - fadeEndSeconds;
  if (fadeEnd < 0) fadeEnd = 0;
  let fadeStart = fadeEnd - fadeDurationSeconds;
  if (fadeStart < 0) fadeStart = 0;
  const extraSamples = Math.floor(endSilenceSeconds * sampleRate);
  const totalLength = audioBuffer22.length + extraSamples;
  const ctx = new OfflineAudioContext(
    audioBuffer22.numberOfChannels,
    totalLength,
    sampleRate
  );
  const source = ctx.createBufferSource();
  source.buffer = audioBuffer22;
  const gain = ctx.createGain();
  gain.gain.setValueAtTime(1, 0);
  if (fadeEndSeconds > 0 && fadeDurationSeconds > 0) {
    gain.gain.setValueAtTime(1, fadeStart);
    gain.gain.linearRampToValueAtTime(0, fadeEnd);
  }
  source.connect(gain).connect(ctx.destination);
  source.start();
  const rendered = await ctx.startRendering();
  const wav = encodeWAV(rendered);
  const blob = new Blob([wav], { type: 'audio/wav' });
  if (location.href.startsWith("file:///") ) {
    blob.arrayBuffer().then(buffer => {
      const base64data = arrayBufferToBase64(buffer);
      NativeJava.DownloadFile(base64data, 'output_audio.wav');
    });
  } else {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fadeout.wav';
    a.click();
    URL.revokeObjectURL(url);
  }
});
    function encodeWAV(buffer) {
      const channels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length;
      const bitsPerSample = 16;
      const bytesPerSample = bitsPerSample / 8;
      const blockAlign = channels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = length * blockAlign;
      const bufferView = new DataView(new ArrayBuffer(44 + dataSize));
      let offset = 0;
      const writeString = (str) => {
        for (let i = 0; i < str.length; i++) {
          bufferView.setUint8(offset++, str.charCodeAt(i));
        }
      };
      writeString('RIFF');
      bufferView.setUint32(offset, 36 + dataSize, true); offset += 4;
      writeString('WAVE');
      writeString('fmt ');
      bufferView.setUint32(offset, 16, true); offset += 4;
      bufferView.setUint16(offset, 1, true); offset += 2;
      bufferView.setUint16(offset, channels, true); offset += 2;
      bufferView.setUint32(offset, sampleRate, true); offset += 4;
      bufferView.setUint32(offset, byteRate, true); offset += 4;
      bufferView.setUint16(offset, blockAlign, true); offset += 2;
      bufferView.setUint16(offset, bitsPerSample, true); offset += 2;
      writeString('data');
      bufferView.setUint32(offset, dataSize, true); offset += 4;
      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < channels; ch++) {
          let sample = buffer.getChannelData(ch)[i];
          sample = Math.max(-1, Math.min(1, sample));
          bufferView.setInt16(offset, sample * 32767, true);
          offset += 2;
        }
      }
      return bufferView.buffer;
    }
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
}
destroy() {}
}
class ReversePlugin {
static title = "Reverse Audio";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `
<h1>Reverse Plugin</h1> <div style="font-family: sans-serif; background: #111; color: #fff; padding: 2rem;"><p id="audioLength2" style="margin-top:1rem;">Audio Length:<span id="lengthVal2">0</span> seconds</p><input type="file" id="fileInput882" accept=".wav" /><button id="downloadButton342">Download</button></div>
        `;
    }
script(container) {
    let audioCtx222 = new (window.AudioContext || window.webkitAudioContext)();
    let audioBuffer222 = null;
    container.querySelector('#fileInput882').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return alert("Please select a file.");
      const arrayBuffer = await file.arrayBuffer();
      audioBuffer222 = await audioCtx222.decodeAudioData(arrayBuffer);
      container.querySelector('#lengthVal2').textContent = audioBuffer222.duration.toFixed(2);
      alert("File loaded successfully.");
    });
    container.querySelector('#downloadButton342').addEventListener('click', async () => {
      if (!audioBuffer222) return alert("Please load an audio file first.");
      const reversedBuffer = audioCtx222.createBuffer(
        audioBuffer222.numberOfChannels,
        audioBuffer222.length,
        audioBuffer222.sampleRate
      );
      for (let ch = 0; ch < audioBuffer222.numberOfChannels; ch++) {
        const input = audioBuffer222.getChannelData(ch);
        const output = reversedBuffer.getChannelData(ch);
        for (let i = 0, j = input.length - 1; i < input.length; i++, j--) {
          output[i] = input[j];
        }
      }
      const ctx = new OfflineAudioContext(
        reversedBuffer.numberOfChannels,
        reversedBuffer.length,
        reversedBuffer.sampleRate
      );
      const source = ctx.createBufferSource();
      source.buffer = reversedBuffer;
      source.connect(ctx.destination);
      source.start();
      const rendered = await ctx.startRendering();
      const wav = encodeWAV(rendered);
      const blob = new Blob([wav], { type: 'audio/wav' });
      if (location.href.startsWith("file:///")) {
        blob.arrayBuffer().then(buffer => {
          const base64data = arrayBufferToBase64(buffer);
          NativeJava.DownloadFile(base64data, 'reversed_audio.wav');
        });
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'reversed_audio.wav';
        a.click();
        URL.revokeObjectURL(url);
      }
    });
    function encodeWAV(buffer) {
      const channels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length;
      const bitsPerSample = 16;
      const bytesPerSample = bitsPerSample / 8;
      const blockAlign = channels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = length * blockAlign;
      const bufferView = new DataView(new ArrayBuffer(44 + dataSize));
      let offset = 0;
      const writeString = (str) => {
        for (let i = 0; i < str.length; i++) {
          bufferView.setUint8(offset++, str.charCodeAt(i));
        }
      };
      writeString('RIFF');
      bufferView.setUint32(offset, 36 + dataSize, true); offset += 4;
      writeString('WAVE');
      writeString('fmt ');
      bufferView.setUint32(offset, 16, true); offset += 4;
      bufferView.setUint16(offset, 1, true); offset += 2;
      bufferView.setUint16(offset, channels, true); offset += 2;
      bufferView.setUint32(offset, sampleRate, true); offset += 4;
      bufferView.setUint32(offset, byteRate, true); offset += 4;
      bufferView.setUint16(offset, blockAlign, true); offset += 2;
      bufferView.setUint16(offset, bitsPerSample, true); offset += 2;
      writeString('data');
      bufferView.setUint32(offset, dataSize, true); offset += 4;
      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < channels; ch++) {
          let sample = buffer.getChannelData(ch)[i];
          sample = Math.max(-1, Math.min(1, sample));
          bufferView.setInt16(offset, sample * 32767, true);
          offset += 2;
        }
      }
      return bufferView.buffer;
    }
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
}
destroy() {}
}
class AdvancedEditorPlugin {
static title = "Advanced Audio Editor";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `<div style="font-family: sans-serif; background: #111; color: #fff; padding: 2rem;">
  <style>
    #UUID18289WF { border: none; width: 100%; height: 150px; touch-action: none; background: #000000;}
  </style>
  <input type="file" id="UUID18289FILEINPUT" accept=".wav" /><br /><br>
  <canvas id="UUID18289WF" width="800" height="150"></canvas> <br>
  <label>selected Volume:
    <input type="range" id="UUID18289VOLUMESLIDER" min="0" max="2" step="0.01" value="1" />
    <span id="volumeValue">1.00</span>
  </label> <br><button id="UUID18289UNDO">Undo</button> <br>File Audio <input type="file" id="UUID18289REPLACE" accept=".wav" /> <br>
<button id="UUID18289REMOVE">Remove</button>
<button id="UUID18289REPLBTN" style="display:none;">Replace</button>
<button id="UUID18289AUDBTN">AddAudio</button>
<button id="UUID18289SILENCE" style="display:none;" >AddSilence</button>
<button id="UUID18289PLAYSELECTED">Play Selected</button>
<br><br>
<label>Pitch Shift (semitones): <input type="number" id="UUID18289PITCHSHFT" value="0" step="1" /></label><br>
<label>Detune (Hz): <input type="number" id="UUID18289DETUNE" value="0" step="1" /></label><br>
<button id="UUID18289APPLYPITCHETC">Apply Detune and Pitchshift on Selected Fragment</button>
<br><br>
<button onclick="UUID18289PLAYBUFFER(UUID18289CUBUFF);" >Play</button><br>
  <audio id="UUID18289AUDIOPLAYER" controls></audio>
<button onclick="EXPORTBUFFERUID6()" >Download</button>
        `;
    }
script(container) {
const UUID18289CANVAS = container.querySelector('#UUID18289WF');
const UUID18289CTX = UUID18289CANVAS.getContext('2d');
const UUID18289FILEINPUT = container.querySelector('#UUID18289FILEINPUT');
const UUID18289VOLUMESLIDER = container.querySelector('#UUID18289VOLUMESLIDER');
function floatTo16BitPCM(float32Array) {
    const len = float32Array.length;
    const result = new Int16Array(len);
    for (let i = 0; i < len; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        result[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return result;
}

async function audioBufferToMp3(audioBuffer, bitrate = 192) {
    const numChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const mp3Encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, bitrate);

    const samples = [];
    for (let i = 0; i < numChannels; i++) {
        samples.push(floatTo16BitPCM(audioBuffer.getChannelData(i)));
    }

    const blockSize = 1152;
    const mp3Data = [];

    for (let i = 0; i < samples[0].length; i += blockSize) {
        const left = samples[0].subarray(i, i + blockSize);
        let right = numChannels === 2 ? samples[1].subarray(i, i + blockSize) : null;
        const mp3buf = mp3Encoder.encodeBuffer(left, right);
        if (mp3buf.length > 0) mp3Data.push(mp3buf);
    }

    const mp3buf = mp3Encoder.flush();
    if (mp3buf.length > 0) mp3Data.push(mp3buf);

    return new Blob(mp3Data, { type: 'audio/mp3' });
}

const UUID18289SILENCE=container.querySelector('#UUID18289SILENCE')
const volumeValue = container.querySelector('#volumeValue');
const UUID18289AUDIOPLAYER = container.querySelector('#UUID18289AUDIOPLAYER');
let EXPORTBUFFERUID6;
EXPORTBUFFERUID6 = async function(){
  const outputAudio = container.querySelector('#UUID18289AUDIOPLAYER')
  const src = outputAudio.src
  if (!src) return

  const res = await fetch(src)
  const arrayBuffer = await res.arrayBuffer()

  const ctx = new (window.AudioContext || window.webkitAudioContext)()
  const audioBuffer = await ctx.decodeAudioData(arrayBuffer)

  const mp3Blob = await audioBufferToMp3(audioBuffer, 192);


  if (location.href.startsWith("file:///")) {
    const base64 = await blobToBase6422(mp3Blob)
    NativeJava.DownloadFile(base64, "outputEditedAdvancedAudio.mp3")
    return
  }

  const a = document.createElement("a")
  a.href = URL.createObjectURL(mp3Blob)
  a.download = "outputEditedAdvancedAudio.mp3"
  a.click()
  URL.revokeObjectURL(a.href)
}
window.EXPORTBUFFERUID6 = EXPORTBUFFERUID6
let audioUUID18289CTX = new (window.AudioContext || window.webkitAudioContext)();
let UUID18289OB = null;
let UUID18289SELECTION = null;
let UUID18289CLICKSTATE = 0;
let UUID18289_SCALEX = 1;
let UUID18289_SCROLLX = 0;
let UUID18289CUBUFF = null;
const UUID18289UNDOSTACK = [];

function saveUndo() {
	if (!UUID18289CUBUFF) return;
	if (UUID18289UNDOSTACK.length >= 20) UUID18289UNDOSTACK.shift();
	const copy = audioUUID18289CTX.createBuffer(UUID18289CUBUFF.numberOfChannels, UUID18289CUBUFF.length, UUID18289CUBUFF.sampleRate);
	for (let ch = 0; ch < copy.numberOfChannels; ch++) {
		copy.copyToChannel(UUID18289CUBUFF.getChannelData(ch), ch);
	}
	UUID18289UNDOSTACK.push(copy);
}
container.querySelector('#UUID18289APPLYPITCHETC').addEventListener('click', async () => {
  if (!UUID18289CUBUFF || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;

  const semitones = parseFloat(container.querySelector('#UUID18289PITCHSHFT').value);
  const detuneHz = parseFloat(container.querySelector('#UUID18289DETUNE').value);

  const start = Math.floor(UUID18289SELECTION.x1);
  const end = Math.floor(UUID18289SELECTION.x2);
  const length = end - start;

  const fragment = audioUUID18289CTX.createBuffer(UUID18289CUBUFF.numberOfChannels, length, UUID18289CUBUFF.sampleRate);

  for (let ch = 0; ch < UUID18289CUBUFF.numberOfChannels; ch++) {
    fragment.copyToChannel(UUID18289CUBUFF.getChannelData(ch).slice(start, end), ch);
  }

  const rate = Math.pow(2, semitones / 12);
  const detuneFactor = (detuneHz + UUID18289CUBUFF.sampleRate) / UUID18289CUBUFF.sampleRate;

  const playbackRate = rate * detuneFactor;

  const rendered = await applyPitchDetune(fragment, playbackRate);
  saveUndo();
  const newRenderedLength = rendered.length;
UUID18289SELECTION.x2 = UUID18289SELECTION.x1 + newRenderedLength;
  const newLength = UUID18289CUBUFF.length - length + rendered.length;
  const newBuf = audioUUID18289CTX.createBuffer(UUID18289CUBUFF.numberOfChannels, newLength, UUID18289CUBUFF.sampleRate);

  for (let ch = 0; ch < newBuf.numberOfChannels; ch++) {
    const old = UUID18289CUBUFF.getChannelData(ch);
    const out = newBuf.getChannelData(ch);
    out.set(old.slice(0, start));
    out.set(rendered.getChannelData(ch), start);
    out.set(old.slice(end), start + rendered.length);
  }
  UUID18289CUBUFF = newBuf;
  drawUUID18289WF(UUID18289CUBUFF);
});

async function applyPitchDetune(buffer, playbackRate) {
  const offlineUUID18289CTX = new OfflineAudioContext(
    buffer.numberOfChannels,
    Math.ceil(buffer.length / playbackRate), 
    buffer.sampleRate
  );

  const src = offlineUUID18289CTX.createBufferSource();
  src.buffer = buffer;
  src.playbackRate.value = playbackRate;
  src.connect(offlineUUID18289CTX.destination);
  src.start(0);

  return await offlineUUID18289CTX.startRendering();
}
container.querySelector("#UUID18289SILENCE").addEventListener("click", function () {
  if (!UUID18289CUBUFF || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;

  saveUndo(); 

  const x1 = Math.floor(UUID18289SELECTION.x1);
  const x2 = Math.floor(UUID18289SELECTION.x2);
  const silenceLength = Math.abs(x2 - x1);
  const newLength = UUID18289CUBUFF.length + silenceLength;

  const newBuf = audioUUID18289CTX.createBuffer(
    UUID18289CUBUFF.numberOfChannels,
    newLength,
    UUID18289CUBUFF.sampleRate
  );
  x1fin= x1+silenceLength 
  if(x2<x1){
    x1fin=x1
  }
  
  for (let ch = 0; ch < UUID18289CUBUFF.numberOfChannels; ch++) {
    const old = UUID18289CUBUFF.getChannelData(ch);
    const out = newBuf.getChannelData(ch);
    out.set(old.slice(0, x1fin), 0);
    for (let i = 0; i < silenceLength; i++) {
      out[x1fin + i] = 0;
    }
    out.set(old.slice(x1fin), x1fin + silenceLength);
  }

  UUID18289CUBUFF = newBuf;
  UUID18289SELECTION = null;
  drawUUID18289WF(UUID18289CUBUFF);
});


container.querySelector('#UUID18289PLAYSELECTED').addEventListener('click', () => {
  if (!UUID18289CUBUFF || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;

  const startSample = Math.floor(UUID18289SELECTION.x1);
  const endSample = Math.floor(UUID18289SELECTION.x2);
  const length = endSample - startSample;

  const selectedBuffer = audioUUID18289CTX.createBuffer(
    UUID18289CUBUFF.numberOfChannels,
    length,
    UUID18289CUBUFF.sampleRate
  );

  for (let ch = 0; ch < UUID18289CUBUFF.numberOfChannels; ch++) {
    const src = UUID18289CUBUFF.getChannelData(ch);
    const dst = selectedBuffer.getChannelData(ch);
    dst.set(src.slice(startSample, endSample));
  }

  UUID18289PLAYBUFFER(selectedBuffer);
});

container.querySelector('#UUID18289UNDO').addEventListener('click', () => {
  if (UUID18289UNDOSTACK.length === 0) return;
  UUID18289CUBUFF = UUID18289UNDOSTACK.pop();
  drawUUID18289WF(UUID18289CUBUFF);
});

UUID18289VOLUMESLIDER.addEventListener('change', () => {
  if (!UUID18289OB || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;
  applyVolume();
  drawUUID18289WF(UUID18289CUBUFF);
});

UUID18289VOLUMESLIDER.addEventListener('input', () => {
  volumeValue.textContent = parseFloat(UUID18289VOLUMESLIDER.value).toFixed(2);
});

UUID18289FILEINPUT.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const arrayBuffer = await file.arrayBuffer();
  UUID18289OB = await audioUUID18289CTX.decodeAudioData(arrayBuffer);
  UUID18289CUBUFF = UUID18289OB;
  UUID18289_SCALEX = 1;
  UUID18289_SCROLLX = 0;
  UUID18289SELECTION = null;
  UUID18289CLICKSTATE = 0;
  drawUUID18289WF(UUID18289CUBUFF);
});
container.querySelector('#UUID18289REMOVE').addEventListener('click', () => {
  if (!UUID18289OB || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;
  saveUndo();
  const len = UUID18289CUBUFF.length - (UUID18289SELECTION.x2 - UUID18289SELECTION.x1);
  const newBuf = audioUUID18289CTX.createBuffer(UUID18289CUBUFF.numberOfChannels, len, UUID18289CUBUFF.sampleRate);

  for (let ch = 0; ch < newBuf.numberOfChannels; ch++) {
    const old = UUID18289CUBUFF.getChannelData(ch);
    const out = newBuf.getChannelData(ch);
    out.set(old.slice(0, UUID18289SELECTION.x1));
    out.set(old.slice(UUID18289SELECTION.x2), UUID18289SELECTION.x1);
  }

  UUID18289CUBUFF = newBuf;
  UUID18289SELECTION = null;
  drawUUID18289WF(UUID18289CUBUFF);
});

container.querySelector('#UUID18289REPLACE').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;
  const arrBuf = await file.arrayBuffer();
  const newAudio = await audioUUID18289CTX.decodeAudioData(arrBuf);

  saveUndo();
  const newLen = UUID18289CUBUFF.length - (UUID18289SELECTION.x2 - UUID18289SELECTION.x1) + newAudio.length;
  const newBuf = audioUUID18289CTX.createBuffer(UUID18289CUBUFF.numberOfChannels, newLen, UUID18289CUBUFF.sampleRate);

  for (let ch = 0; ch < newBuf.numberOfChannels; ch++) {
    const old = UUID18289CUBUFF.getChannelData(ch);
    const out = newBuf.getChannelData(ch);
    out.set(old.slice(0, UUID18289SELECTION.x1));
    out.set(newAudio.getChannelData(Math.min(ch, newAudio.numberOfChannels - 1)), UUID18289SELECTION.x1);
    out.set(old.slice(UUID18289SELECTION.x2), UUID18289SELECTION.x1 + newAudio.length);
  }

  UUID18289CUBUFF = newBuf;
  UUID18289SELECTION = null;
  drawUUID18289WF(UUID18289CUBUFF);
  UUID18289PLAYBUFFER(UUID18289CUBUFF);
});

container.querySelector('#UUID18289AUDBTN').addEventListener('click', async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.wav';

  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const arrBuf = await file.arrayBuffer();
    const newAudio = await audioUUID18289CTX.decodeAudioData(arrBuf);

    if (typeof UUID18289SELECTION.x1 !== 'number' || isNaN(UUID18289SELECTION.x1)) {
      alert("Select place to add ...");
      return;
    }

    if (!UUID18289CUBUFF) {
      UUID18289CUBUFF = newAudio;
      drawUUID18289WF(UUID18289CUBUFF);
      return;
    }

    const sampleRate = UUID18289CUBUFF.sampleRate;
    const insertSample = Math.floor(UUID18289SELECTION.x1);
    const len = UUID18289CUBUFF.length + newAudio.length;
    const newBuf = audioUUID18289CTX.createBuffer(
      Math.max(UUID18289CUBUFF.numberOfChannels, newAudio.numberOfChannels),
      len,
      sampleRate
    );

    saveUndo();

    for (let ch = 0; ch < newBuf.numberOfChannels; ch++) {
      const out = newBuf.getChannelData(ch);
      const old = UUID18289CUBUFF.getChannelData(Math.min(ch, UUID18289CUBUFF.numberOfChannels - 1));
      const add = newAudio.getChannelData(Math.min(ch, newAudio.numberOfChannels - 1));
      out.set(old.slice(0, insertSample), 0);
      out.set(add, insertSample);
      out.set(old.slice(insertSample), insertSample + add.length);
    }

    UUID18289CUBUFF = newBuf;
    drawUUID18289WF(UUID18289CUBUFF);
  };

  input.click();
});


function clamp(val, min, max) {
  return Math.min(max, Math.max(min, val));
}

function offsetXToSample(offsetX) {
  const rect = UUID18289CANVAS.getBoundingClientRect();
  const UUID18289CANVASX = offsetX - rect.left;
  const visibleSamples = UUID18289CUBUFF.length / UUID18289_SCALEX;
const samplesPerPixel = visibleSamples / UUID18289CANVAS.width*2.5 ;
return ((UUID18289_SCROLLX * visibleSamples + UUID18289CANVASX * samplesPerPixel)
);
}

UUID18289CANVAS.addEventListener('click', (e) => {
  if (!UUID18289OB) return;
  const samplePos = offsetXToSample(e.clientX);

  if (UUID18289SELECTION && UUID18289SELECTION.x1 !== null && UUID18289SELECTION.x2 !== null && samplePos >= UUID18289SELECTION.x1 && samplePos <= UUID18289SELECTION.x2) {
    UUID18289SELECTION = { x1: samplePos, x2: null };
    UUID18289CLICKSTATE = 1;
    drawUUID18289WF(UUID18289CUBUFF);
    return;
  }

  if (UUID18289CLICKSTATE === 0 || !UUID18289SELECTION) {
    UUID18289SELECTION = { x1: clamp(samplePos, 0, UUID18289CUBUFF.length), x2: null };
    UUID18289CLICKSTATE = 1;
  } else {
    UUID18289SELECTION.x2 = clamp(samplePos, 0, UUID18289CUBUFF.length);
    if (UUID18289SELECTION.x2 < UUID18289SELECTION.x1) [UUID18289SELECTION.x1, UUID18289SELECTION.x2] = [UUID18289SELECTION.x2, UUID18289SELECTION.x1];
    UUID18289CLICKSTATE = 0;
  }
  drawUUID18289WF(UUID18289CUBUFF);
});

UUID18289CANVAS.addEventListener('wheel', (e) => {
  if (!UUID18289OB) return;
  e.preventDefault();
  UUID18289_SCROLLX += e.deltaY / (UUID18289_SCALEX * 10);
  const maxScroll = UUID18289OB.length / UUID18289CANVAS.width / UUID18289_SCALEX - UUID18289CANVAS.width / UUID18289_SCALEX;
  UUID18289_SCROLLX = clamp(UUID18289_SCROLLX, 0, Math.max(maxScroll, 0));
  drawUUID18289WF(UUID18289CUBUFF);
}, { passive: false });

let lastTouchX = null;
let lastTouchDist = null;

UUID18289CANVAS.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    lastTouchX = e.touches[0].clientX;
  } else if (e.touches.length === 2) {
    lastTouchDist = UUID18289GETTOUCHDIST(e);
  }
});
let is2Press=0;
UUID18289CANVAS.addEventListener('touchmove', (e) => {
  if (!UUID18289OB ) return;
  e.preventDefault();
  if (e.touches.length === 1 && !is2Press) {
  const touchX = e.touches[0].clientX;
  const deltaPx = lastTouchX - touchX;
  const visibleSamples = UUID18289OB.length / UUID18289_SCALEX;
  const deltaScroll = deltaPx / UUID18289CANVAS.width * clamp(UUID18289_SCALEX,0,20);

  UUID18289_SCROLLX += deltaScroll;
  const maxScroll = (UUID18289OB.length - UUID18289OB.length / UUID18289_SCALEX) / UUID18289OB.length;
UUID18289_SCROLLX = clamp(UUID18289_SCROLLX, 0, maxScroll*UUID18289_SCALEX);

  drawUUID18289WF(UUID18289CUBUFF);
  lastTouchX = touchX;
}
 else if (e.touches.length === 2) {
  const dist = UUID18289GETTOUCHDIST(e);
  const zoomFactor = dist / lastTouchDist;

  const midX = UUID18289GETMIDTOUCH(e);
  const rect = UUID18289CANVAS.getBoundingClientRect();
  const midUUID18289CANVASX = midX - rect.left;

  const visibleSamples = UUID18289OB.length / UUID18289_SCALEX;
  const samplesPerPixel = visibleSamples / UUID18289CANVAS.width;
  const midSample = UUID18289_SCROLLX * UUID18289OB.length + samplesPerPixel * midUUID18289CANVASX;

  UUID18289_SCALEX = clamp(UUID18289_SCALEX * zoomFactor, 1, 60000);
  is2Press=1
  const newVisibleSamples = UUID18289OB.length / UUID18289_SCALEX;
  const maxScroll = (UUID18289OB.length - UUID18289OB.length / UUID18289_SCALEX) / UUID18289OB.length;
  UUID18289_SCROLLX = clamp( UUID18289_SCROLLX , 0, maxScroll*UUID18289_SCALEX);

  drawUUID18289WF(UUID18289CUBUFF);
  lastTouchDist = dist;
}

});

UUID18289CANVAS.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) lastTouchDist = null;
  if (e.touches.length === 0) {lastTouchX = null;is2Press=0;}
  
  
});
let isDragging = false;
let lastMouseX = 0;

UUID18289CANVAS.addEventListener('mousedown', (e) => {
  isDragging = true;
  lastMouseX = e.clientX;
});

UUID18289CANVAS.addEventListener('mouseup', (e) => {
  isDragging = false;
});

UUID18289CANVAS.addEventListener('mouseleave', (e) => {
  isDragging = false;
});

UUID18289CANVAS.addEventListener('mousemove', (e) => {
  if (!isDragging || !UUID18289OB) return;

  const deltaPx = lastMouseX - e.clientX;
  const deltaScroll = deltaPx / UUID18289CANVAS.width * clamp(UUID18289_SCALEX, 0, 20);

  UUID18289_SCROLLX += deltaScroll;

  const maxScroll = (UUID18289OB.length - UUID18289OB.length / UUID18289_SCALEX) / UUID18289OB.length;
  UUID18289_SCROLLX = clamp(UUID18289_SCROLLX, 0, maxScroll * UUID18289_SCALEX);

  drawUUID18289WF(UUID18289CUBUFF);
  lastMouseX = e.clientX;
});

function UUID18289GETTOUCHDIST(e) {
  const [t1, t2] = e.touches;
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

function UUID18289GETMIDTOUCH(e) {
  const [t1, t2] = e.touches;
  return (t1.clientX + t2.clientX) / 2;
}

function drawUUID18289WF(buffer) {
  if (!buffer) return;
  UUID18289CTX.clearRect(0, 0, UUID18289CANVAS.width, UUID18289CANVAS.height);
  const data = buffer.getChannelData(0);
  const samplesPerPixel = buffer.length / UUID18289CANVAS.width / UUID18289_SCALEX;
  const sampleOffset = UUID18289_SCROLLX * samplesPerPixel * UUID18289CANVAS.width;
  const startSample = Math.floor(sampleOffset);
  const endSample = Math.min(buffer.length, startSample + Math.floor(UUID18289CANVAS.width * samplesPerPixel));
  const amp = UUID18289CANVAS.height / 2;

  UUID18289CTX.beginPath();
  for (let i = 0; i < UUID18289CANVAS.width; i++) {
    const sampleIndex = startSample + Math.floor(i * samplesPerPixel);
    if (sampleIndex >= buffer.length) break;
    let min = 1.0, max = -1.0;
    const step = Math.ceil(samplesPerPixel);
    for (let j = 0; j < step; j++) {
      const idx = sampleIndex + j;
      if (idx >= buffer.length) break;
      const v = data[idx];
      if (v < min) min = v;
      if (v > max) max = v;
    }
    UUID18289CTX.moveTo(i, (1 + min) * amp);
    UUID18289CTX.lineTo(i, (1 + max) * amp);
  }
  UUID18289CTX.strokeStyle = "#fff";
  UUID18289CTX.stroke();

  if (UUID18289SELECTION && UUID18289SELECTION.x1 !== null && UUID18289SELECTION.x2 === null) {
    const x = (UUID18289SELECTION.x1 - startSample) / samplesPerPixel;
    UUID18289CTX.beginPath();
    UUID18289CTX.arc(clamp(x, 0, UUID18289CANVAS.width), UUID18289CANVAS.height / 2, 5, 0, 2 * Math.PI);
    UUID18289CTX.fillStyle = "blue";
    UUID18289CTX.fill();
  }

  if (UUID18289SELECTION && UUID18289SELECTION.x1 !== null && UUID18289SELECTION.x2 !== null) {
    let x1 = (UUID18289SELECTION.x1 - sampleOffset) / samplesPerPixel;
let x2 = (UUID18289SELECTION.x2 - sampleOffset) / samplesPerPixel;

    if (x2 < x1) [x1, x2] = [x2, x1];
    x1 = clamp(x1, 0, UUID18289CANVAS.width);
    x2 = clamp(x2, 0, UUID18289CANVAS.width);
    UUID18289CTX.fillStyle = "rgba(0, 123, 255, 0.4)";
    UUID18289CTX.fillRect(x1, 0, x2 - x1, UUID18289CANVAS.height);
  }
}

function applyVolume() {
  if (!UUID18289OB || !UUID18289SELECTION || UUID18289SELECTION.x2 === null) return;
  saveUndo();
  const volume = parseFloat(UUID18289VOLUMESLIDER.value);
  const newBuffer = audioUUID18289CTX.createBuffer(UUID18289CUBUFF.numberOfChannels, UUID18289CUBUFF.length, UUID18289CUBUFF.sampleRate);
  
  const startSample = Math.floor(UUID18289SELECTION.x1);
  const endSample = Math.floor(UUID18289SELECTION.x2);

  for (let ch = 0; ch < UUID18289CUBUFF.numberOfChannels; ch++) {
    const input = UUID18289CUBUFF.getChannelData(ch);
    const output = newBuffer.getChannelData(ch);
    for (let i = 0; i < input.length; i++) {
      output[i] = (i >= startSample && i <= endSample) ? input[i] * volume : input[i];
    }
  }
  UUID18289CUBUFF = newBuffer;
 UUID18289VOLUMESLIDER.value=1
 volumeValue.textContent = parseFloat(UUID18289VOLUMESLIDER.value).toFixed(2);
}

function UUID18289PLAYBUFFER(buffer) {
  const blob = bufferToWavBlob(buffer);
  if (UUID18289AUDIOPLAYER.src) URL.revokeObjectURL(UUID18289AUDIOPLAYER.src);
  UUID18289AUDIOPLAYER.src = URL.createObjectURL(blob);
  UUID18289AUDIOPLAYER.play();
}
window.UUID18289PLAYBUFFER = (buff) => playMusic(buff);
function bufferToWavBlob(buffer) {
  const interleaved = interleave(buffer);
  const wav = encodeWav(interleaved, buffer.sampleRate, buffer.numberOfChannels);
  return new Blob([wav], { type: "audio/wav" });
}

function interleave(buffer) {
  const length = buffer.length * buffer.numberOfChannels;
  const result = new Float32Array(length);
  for (let i = 0; i < buffer.length; i++) {
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
      result[i * buffer.numberOfChannels + ch] = buffer.getChannelData(ch)[i];
    }
  }
  return result;
}

function encodeWav(samples, sampleRate, numChannels) {
  const buffer = new ArrayBuffer(44 + samples.length * 2);
  const view = new DataView(buffer);
  const writeStr = (v, o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
  const floatTo16 = (out, off, input) => {
    for (let i = 0; i < input.length; i++) {
      const s = Math.max(-1, Math.min(1, input[i]));
      out.setInt16(off + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
  };

  writeStr(view, 0, "RIFF");
  view.setUint32(4, 36 + samples.length * 2, true);
  writeStr(view, 8, "WAVE");
  writeStr(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numChannels * 2, true);
  view.setUint16(32, numChannels * 2, true);
  view.setUint16(34, 16, true);
  writeStr(view, 36, "data");
  view.setUint32(40, samples.length * 2, true);
  floatTo16(view, 44, samples);
  return view;
}
}
destroy() {}
}
class WhistleToNotesPlugin {
static title = "Whistle To Notes";constructor() {this.paused = false;this.ticks = 0; window.loopRunning34 = false;}
render() {return `
<style>
#waveInputsContainer {
  margin: 0;
  width: 100vw;
  overflow-x: scroll;
  overflow-y: hidden;
  position: relative;
  height: 30px;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 5px;
}
  .wave-input{
  	width:25px;
  }
  .keyboard {
    position: relative;
     
    overflow-x: scroll;
    width: 100%;
    max-width: 1050px;
    height: 203px;
    background:#5B5B5B;
    zoom:0.8
  }
  .key {
    position: absolute;
    font-size: 30px;
    display:flex;
    justify-content: center;
    align-items:end ;
    width: 50px;
    height: 200px;
    border: 1px solid #000;
    background-color: #FFFFFF;
  }
  .key:active{
    transform: translate(0,-5px);
    animation: 0.5s blued ;
  }
  @keyframes blued{
    0%{
      background:#898989
    }
    100%{
    }
  }
  .black-key {
    background-color: #000;
    width:35px;
    height: 100px;
    margin-top: -10px;
    margin: 0;
    z-index: 1;
  }
  .active {
    background-color: #4CCDF0;
  }
</style>
<style>
#spectrogram {
  border: 1px solid #333;
  background:#000000;
  display: block;
  position: relative;
  left:50%; 
  transform: translate(-50%,0) ;
  width: 300px;
  height: 300px;
}
.controls {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}
.sens-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}
#volColor {
  width: 18px;
  height: 18px;
  border: 1px solid #333;
  border-radius: 3px;
  display: inline-block;
}
#sensDb {
  width: 72px;
}
</style>
<div class="controls">
  <button id="btnRec2">Record</button>
  <button id="btnStop2" disabled>Stop</button>
  <button id="btnPlay2">PlayGeneratedNotes</button>
  <button id="btnExport2">ExportMM3</button>
  <button id="btnExport3">ExportJSON</button>
  <input type="file" id="fileInput" accept="audio/*">
  <div class="sens-wrap">
    <label for="sensDb">Sensitivity MIN</label>
    <input type="number" id="sensDb" step="1" value="70" min="1000" max="-125">
    <div id="volColor" title="Sensitivity Color"></div>
  </div>
  <br>
</div>
<br>
<canvas id="spectrogram"></canvas>
<br>
  	<label for="STABLE_N">Stable N</label>
  	<input type="number" id="STABLE_N" step="1" value="2" oninput="if(!isNaN(STABLE_N)){STABLE_N=this.value; }"><br>
  	<label for="SILENCE_N">Silence N</label>
  	<input type="number" id="SILENCE_N" step="1" value="3" oninput="if(!isNaN(SILENCE_N)){SILENCE_N=this.value; }"><br>
  	<label for="MIN_NOTE_MS">Min Note MS</label>
  	<input type="number" id="MIN_NOTE_MS" step="1" value="6" oninput="if(!isNaN(MIN_NOTE_MS)){MIN_NOTE_MS=this.value; }"><br>
  	<label for="CHANGE_HOLD_MS">Change Hold MS</label>
  	<input type="number" id="CHANGE_HOLD_MS" step="1" value="5" oninput="if(!isNaN(CHANGE_HOLD_MS)){CHANGE_HOLD_MS=this.value; }"><br>
 <label for="semitoneShift">Semitone Shift</label>
<input type="number" id="semitoneShift" step="0.5" value="-12">
tempo in convertion: <input id="tempoData" type="text" value="120">
        `;
    }
script(container) { 
const audioctx242 = new (window.AudioContext || window.webkitAudioContext)()
let analyser, mediaSource, isRecording3 = false, startTs = 0
let playing = false;
var playingSources2 = [];
var timeouts = [];
let currentNote = null, currentStart = 0
let stableBuf = [], silenceStreak = 0
let pendingNote = null, pendingSince = 0
var STABLE_N = 2, SILENCE_N = 3, MIN_NOTE_MS = 6, CHANGE_HOLD_MS = 5
let audiobuff = [0,1]
let semitoneShift = -12
container.querySelector('#semitoneShift').addEventListener('input', e => {
  const v = parseFloat(e.target.value)
  if (!isNaN(v)) semitoneShift = v
})
const baseFrequencies2 = {
  'c': 261.63, 'c#': 277.18, 'd': 293.66, 'd#': 311.13, 'e': 329.63,
  'f': 349.23, 'f#': 369.99, 'g': 392, 'g#': 415.3, 'a': 440,
  'a#': 466.16, 'h': 493.88
}
const order = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','h']
const octaves = [1,2,3,4,5,6,7]
const bank = buildNoteBank()

var music = { tempo: 1, run: [1], 1: { notes: [], instrument: 'square', nextSection: null, runallnotes: 1 } }

var canvas2 = container.querySelector("#spectrogram")
var ctx2 = canvas2.getContext("2d")
let sensitivityDb = parseFloat(container.querySelector('#sensDb').value) || -50
 
const scale = 1
canvas2.width = 300
canvas2.height = 300
ctx2.scale(scale, scale);
 

const volDiv = container.querySelector('#volColor')

function dbToColor(db) {
  const t = Math.max(0, Math.min(1, db / 100))
  const hue = Math.round((1 - t) * 120)
  return `hsl(${hue},100%,50%)`
}
function updateSensitivityColor() {
  volDiv.style.backgroundColor = dbToColor(sensitivityDb)
}
updateSensitivityColor()

container.querySelector('#sensDb').addEventListener('input', e => {
  const v = parseFloat(e.target.value)
  if (isFinite(v)) {
    sensitivityDb = v
    updateSensitivityColor()
  }
})
function steps(value, step) {
  return ((value % step) + step) % step
}

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max)
}

function buildNoteBank() {
  const rows = []
  for (const o of octaves) {
    for (const n of order) {
      const f = baseFrequencies2[n] * Math.pow(2, o - 4)
      rows.push({ name: n, oct: o, f })
    }
  }
  rows.sort((a, b) => a.f - b.f)
  for (let i = 0; i < rows.length; i++) {
    const prev = rows[i - 1]?.f || rows[i].f / Math.pow(2, 1 / 12)
    const next = rows[i + 1]?.f || rows[i].f * Math.pow(2, 1 / 12)
    rows[i].lo = (prev + rows[i].f) / 2
    rows[i].hi = (rows[i].f + next) / 2
  }
  return rows
}

function quantize(freq) {
  for (const r of bank) {
    const tolerance = r.f * 0.006 
    if (freq >= r.lo + tolerance && freq < r.hi - tolerance) return r
  }
  return null
}


async function initMic2() {
	try {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
  mediaSource = audioctx242.createMediaStreamSource(stream)
  analyser = audioctx242.createAnalyser()
  analyser.fftSize = 1024
  mediaSource.connect(analyser)
	}catch (e){
		POPUP(innerWidth/2-150, innerHeight/2-100 + window.scrollY
     ,"Microphone Access Error",
    		"<text style='color:black'>You must open FruityBox App and allow microphone access.</text>",
    		"#00afdf"
 	);
	}
}
function detectPitch() {
  const N = analyser.fftSize
  const buf = new Float32Array(N)
  analyser.getFloatTimeDomainData(buf)
  let rms = 0
  for (let i = 0; i < N; i++) rms += buf[i] * buf[i]
  rms = Math.sqrt(rms / N)
  let db = 20 * Math.log10(rms + 1e-12)
  db = Math.max(0, Math.min(100, db + 100))
  if (db < sensitivityDb) return { freq: null, clarity: 0, db }

  let minLag = Math.floor(audioctx242.sampleRate / 2000)
  let maxLag = Math.floor(audioctx242.sampleRate / 150)
  let bestLag = -1, bestCorr = 0
  let sumSq = 0
  for (let i = 0; i < N; i++) sumSq += buf[i] * buf[i]
  for (let lag = minLag; lag <= maxLag; lag++) {
    let corr = 0, energy = 0
    for (let i = 0; i < N - lag; i++) {
      corr += buf[i] * buf[i + lag]
      energy += buf[i + lag] * buf[i + lag]
    }
    const norm = corr / Math.sqrt(sumSq * energy || 1)
    if (norm > bestCorr) { bestCorr = norm; bestLag = lag }
  }
  if (bestLag < 0 || bestCorr < 0.6) return { freq: null, clarity: bestCorr, db }

  const c1 = xcorrAt(buf, bestLag - 1), c2 = xcorrAt(buf, bestLag), c3 = xcorrAt(buf, bestLag + 1)
  const shift = (c3 - c1) / (2 * (2 * c2 - c1 - c3) || 1)
  const refinedLag = bestLag + shift
  const freq = audioctx242.sampleRate / refinedLag
  return { freq, clarity: bestCorr, db }
}

function xcorrAt(buf, lag) {
  let N = buf.length, c = 0, ss1 = 0, ss2 = 0
  for (let i = 0; i < N - lag; i++) {
    c += buf[i] * buf[i + lag]
    ss1 += buf[i] * buf[i]
    ss2 += buf[i + lag] * buf[i + lag]
  }
  return c / Math.sqrt(ss1 * ss2 || 1)
}

 

let scrollSpeed = 5
let frameDuration = 1000 / 60;
let activeLabels = []
function pushNote(noteObj) {
  if (!noteObj) return
  if (noteObj.dur < MIN_NOTE_MS) return
  const shiftedF = noteObj.f * Math.pow(2, semitoneShift / 12)
  music[1].notes.push([shiftedF, noteObj.start - startTs, noteObj.dur, 0.5, 1])
  const label = quantize(shiftedF)
  if (label) {
    activeLabels.push({
      text: label.name + label.oct,
      freq: noteObj.f / Math.pow(2, semitoneShift / 12) ,
      ticks: 30
    })
  }
}

function drawSpectrogram() {
  if (!analyser) return
  ctx2 = canvas2.getContext("2d")
  const bufferLength = analyser.frequencyBinCount
  const data = new Uint8Array(bufferLength)
  analyser.getByteFrequencyData(data)
  const h = canvas2.height, w = canvas2.width
  const scroll = scrollSpeed
  const imgData = ctx2.getImageData(scroll, 0, w - scroll, h) 
  ctx2.putImageData(imgData, 0, 0)
  const sr = audioctx242.sampleRate
  const fMin = 300, fMax = 3000
  for (let y = 0; y < h; y++) {
    const frac = y / h
    const f = fMin + (1 - frac) * (fMax - fMin)
    const idx = Math.round(f * bufferLength / (sr / 2))
    if (idx >= 0 && idx < bufferLength) {
      const val = data[idx]
      ctx2.fillStyle = `hsl(${240 - val * 240 / 255},100%,50%)`
      ctx2.fillRect(w - scroll - 30, y, scroll, 1) 
    }
  }
  const barW = 30
  ctx2.fillStyle = "black"
  ctx2.fillRect(w - barW, 0, barW, h)
  ctx2.font = "14px sans-serif"
  ctx2.textAlign = "center"
  ctx2.textBaseline = "middle"
  activeLabels.forEach(l => {
    const alpha = (l.ticks / 30) ** 2
    const frac = (l.freq - fMin) / (fMax - fMin)
    const y = (1 - frac) * h
    ctx2.fillStyle = `rgba(255,255,255,${alpha})`
    ctx2.fillText(l.text, w - barW / 2, y)
    l.ticks--
  })
  activeLabels = activeLabels.filter(l => l.ticks > 0)
}



let lastDrawnNote = null

window.loop2234 = function() {
  if (isRecording3) {
    drawSpectrogram()
const { freq, db } = detectPitch()
let q = null
if (freq && db >= sensitivityDb) {
  const shiftedFreq = freq * Math.pow(2, semitoneShift / 12)
  q = quantize(shiftedFreq)
}
    if (q) {
      stableBuf.push(q)
      if (stableBuf.length > STABLE_N) stableBuf.shift()
      const same = stableBuf.every(x => x && x.name === stableBuf[0].name && x.oct === stableBuf[0].oct)
      if (!currentNote && same) {
        currentNote = { name: q.name, oct: q.oct, f: q.f }
        currentStart = performance.now()
        silenceStreak = 0
        pendingNote = null
      } else if (currentNote && (currentNote.name !== q.name || currentNote.oct !== q.oct) && same) {
        if (!pendingNote) {
          pendingNote = { name: q.name, oct: q.oct, f: q.f }
          pendingSince = performance.now()
        } else if (performance.now() - pendingSince > CHANGE_HOLD_MS) {
          const now = performance.now()
          pushNote({ f: currentNote.f, start: currentStart, dur: now - currentStart })
          currentNote = pendingNote
          currentStart = now
          pendingNote = null
        }
      } else {
        pendingNote = null
        silenceStreak = 0
      }
    } else {
      stableBuf = []
      pendingNote = null
      silenceStreak++
      if (currentNote && silenceStreak >= SILENCE_N) {
        const now = performance.now()
        pushNote({ f: currentNote.f, start: currentStart, dur: now - currentStart })
        currentNote = null
      }
    }
  }
  if (!window.loopRunning34) return;
  setTimeout(function(){ loop2234() }, frameDuration);
}

container.querySelector('#btnRec2').onclick = async () => {
  await audioctx242.resume()
  await initMic2()
  isRecording3 = true
  music[1].notes = []
  currentNote = null
  startTs = performance.now()
  stableBuf = []
  silenceStreak = 0
  pendingNote = null
  ctx2.clearRect(0, 0, canvas2.width, canvas2.height)
  container.querySelector('#btnRec2').disabled = true
  container.querySelector('#btnStop2').disabled = false
  if (!window.loopRunning34) {
  	window.loopRunning34 = true
   loop2234()
  }
}

container.querySelector('#btnStop2').onclick = () => {
	   startTs = 0
  isRecording3 = false
  if (currentNote) {
    const now = performance.now()
    pushNote({ f: currentNote.f, start: currentStart, dur: now - currentStart })
    currentNote = null
  }
  container.querySelector('#btnRec2').disabled = false
  container.querySelector('#btnStop2').disabled = true
}

container.querySelector('#btnExport2').onclick = () => {
  const blob = new Blob([JSON.stringify(music)], { type: 'application/octet-stream' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = 'music.mm3'
  a.click()
  URL.revokeObjectURL(url)
  if (location.href.startsWith("file:///")) {
	NativeJava.DownloadText(JSON.stringify(music), "music.mm3");
}
}
function convertToFruityBox(mm3) {
  		const notes = mm3["1"].notes;
  		notes.sort((a, b) => a[1] - b[1]);
  		const tempo = parseFloat(container.querySelector("#tempoData").value)||200 ;
  		const ticksPerBeat = 8;
  		const beatsPerBar = 8;
  		const ticksPerBar = ticksPerBeat * beatsPerBar;
  		const msPerTick = 60000 / tempo / ticksPerBeat;
  		const channels = [];
  		function createEmptyChannel(numPatterns) {
  const patterns = Array.from({ length: numPatterns }, () => ({ notes: [] }));
  const sequence = [...Array(numPatterns).keys()];
return {
	type: "pitch",
	name: "triangle",
	instruments: [{
		type: "chip",
		volume: 0,
		eqFilter: [],
		eqFilterType: false,
		eqSimpleCut: 10,
		eqSimplePeak: 0,
		eqSubFilters0: [],
		effects: [],
		fadeInSeconds: 0,
		fadeOutTicks: 48,
		wave: "triangle",
		envelopes: []
	}],
	patterns: patterns,
	sequence: sequence,
	octaveScrollBar: 0
};
}
function hasOverlap(existingNotes, startTick, endTick) {
  			return existingNotes.some(note => {
  				const nStart = note.points[0].tick;
  				const nEnd = note.points[1].tick;
  				return (startTick < nEnd && endTick > nStart);
});
}
let maxEndTick = 0;
for (const [freq, startMs, lenMs] of notes) {
	let msLEg = 500;
if (container.querySelector("#TypeSelect").value == "A")  {
	msLEg = parseInt(lenMs / 6)
}else if (container.querySelector("#TypeSelect").value == "B") {
	msLEg = parseInt(lenMs / 8)
}else if ( !isNaN(container.querySelector("#TypeSelect").value) ) {
	msLEg = parseInt(container.querySelector("#TypeSelect").value)
}
const clippedLenMs = Math.max(40, msLEg);
const absEndTick = Math.round((startMs + clippedLenMs) / msPerTick);
  if (absEndTick > maxEndTick) maxEndTick = absEndTick;
}
const numPatterns = Math.ceil(maxEndTick / ticksPerBar)+1;
  		for (const [freq, startMs, lenMs] of notes) {
  			const absStartTick = Math.round(startMs / msPerTick);
let msLEg=500;
if (container.querySelector("#TypeSelect").value == "A") {
	msLEg = parseInt(lenMs / 6)
} else if (container.querySelector("#TypeSelect").value == "B") {
	msLEg = parseInt(lenMs / 8)
} else if (!isNaN(container.querySelector("#TypeSelect").value)) {
	msLEg = parseInt(container.querySelector("#TypeSelect").value)
}
const clippedLenMs = Math.max(40, msLEg );
const absEndTick = Math.round((startMs + clippedLenMs) / msPerTick);
  			const patternIndex = Math.floor(absStartTick / ticksPerBar);
  			const startTick = absStartTick % ticksPerBar;
  			let endTick = absEndTick % ticksPerBar;
if (endTick <= startTick) {
	endTick = startTick + 1;
	if (endTick > ticksPerBar) endTick = ticksPerBar; 
}
const pitch = freqToPitchIndex(freq);
 if (pitch === null) continue;
  			let placed = false;
  			for (let c = 0; c <= channels.length; c++) {
  				if (channels[c] === undefined) channels[c] = createEmptyChannel(numPatterns);
  				const pattern = channels[c].patterns[patternIndex];
  				if (!hasOverlap(pattern.notes, startTick, endTick)) {
  					pattern.notes.push({
  						pitches: [pitch],
  						points: [
  							{ tick: startTick, pitchBend: 0, volume: 100, forMod: false },
  							{ tick: endTick, pitchBend: 0, volume: 100, forMod: false }
  						],
  						continuesLastPattern: false
  					});
  					placed = true;
  					break;
  				}
  			}
if (!placed) {
	const newChan = createEmptyChannel(numPatterns);
	channels.push(newChan);
	const pattern = newChan.patterns[patternIndex];
	pattern.notes.push({
		pitches: [pitch],
		points: [
			{ tick: startTick, pitchBend: 0, volume: 100, forMod: false },
			{ tick: endTick, pitchBend: 0, volume: 100, forMod: false }
		],
		continuesLastPattern: false
	});
}
}
  		return {
  			name: "Studiosong",
  			format: "Studiobox",
  			version: 5,
  			scale: "Free",
  			key: "C",
  			introBars: 0,
  			loopBars: 2,
  			beatsPerBar,
  			ticksPerBeat,
  			beatsPerMinute: tempo,
  			reverb: 0,
  			masterGain: 1,
  			compressionThreshold: 1,
  			limitThreshold: 1,
  			limitDecay: 4,
  			limitRise: 4000,
  			limitRatio: 1,
  			compressionRatio: 1,
  			layeredInstruments: false,
  			patternInstruments: false,
  			channels
  		};
  	}
  	
  	function freqToPitchIndex(freq) {
  		const midi = 69 + 12 * Math.log2(freq / 440);
  		const pitch = Math.round(midi - 12);
  		if (pitch < 0 || pitch > 95*2) return null;
  		return pitch;
  	}
  	
container.querySelector('#btnExport3').onclick = () => {
	let fruitybox=convertToFruityBox(music)
	let	jsonfull=JSON.stringify(fruitybox, null, 2)
	const blob = new Blob([jsonfull], { type: 'application/octet-stream' })
	const url = URL.createObjectURL(blob)
	const a = document.createElement('a')
	a.href = url
	a.download = 'fruit.json'
	a.click()
	URL.revokeObjectURL(url)
	if (location.href.startsWith("file:///")) {
		NativeJava.DownloadText(jsonfull, "fruit.json");
	}
}

container.querySelector('#btnPlay2').onclick = () => playMusic1(music)

 
async function playTone3(audioctx242, frequency, duration, volume, customInstrument, volumeEasing=1) {
	return new Promise(resolve => {
		const sampleRate = audioctx242.sampleRate;
		const frameCount = sampleRate * (((duration+500) / 1000));
		const buffer = audioctx242.createBuffer(1, frameCount, sampleRate);
		const data = buffer.getChannelData(0);
		const waveformLength = audiobuff.length;
		for (let i = 0; i < frameCount; i++) {
			let time = i / sampleRate;
			let amplitude = volume;
			if (volumeEasing === 1) {
				amplitude *= Math.exp(-5 * time / ((duration+500) / 1000)) ;
			} else if (volumeEasing > 1) {
				amplitude *= 1 - Math.exp(-5 * time / (((duration+500) / 1000) * volumeEasing));
			}
			let wavePosition = (i * frequency * waveformLength / sampleRate) % waveformLength;
			let index = Math.floor(wavePosition);
			let nextIndex = (index + 1) % waveformLength;
			let frac = wavePosition - index;
			let sample = audiobuff[index] * (1 - frac) + audiobuff[nextIndex] * frac;
			data[i] = amplitude * sample;
		}
		const source = audioctx242.createBufferSource();
		source.buffer = buffer;
		source.connect(audioctx242.destination);
		playingSources2.push(source);
		source.start();
		source.onended = () => {
			resolve();
		};
	});
}
function playMusic1(score) {
  timeouts.forEach(t => clearTimeout(t))
  timeouts = []
  playingSources2.forEach(s => { try { s.stop() } catch (e) {} })
  playingSources2 = []
  if (playing) { playing = false; return }
  playing = true
  const notes = score[1].notes.slice()
  const tempo = score[1].tempo || score.tempo || 1
  for (const n of notes) {
    const [hz, offset, dur, vol] = n
    const t = setTimeout(() => {
      if (!playing) return
      playTone3(audioctx242, hz, dur / tempo, vol,0,1).then(() => {})
    }, offset / tempo)
    timeouts.push(t)
  }
  if (notes.length) {
    const last = notes[notes.length - 1]
    const total = (last[1] + last[2]) / tempo
    const endT = setTimeout(() => { playing = false }, total + 50)
    timeouts.push(endT)
  } else {
    playing = false
  }
}

container.querySelector('#fileInput').addEventListener('change', async e => {
  const file = e.target.files[0]
  if (!file) return
  try {
    const arrayBuffer = await file.arrayBuffer()
    const audioBuf = await audioctx242.decodeAudioData(arrayBuffer)
    analyser = audioctx242.createAnalyser()
    analyser.fftSize = 1024
    const src = audioctx242.createBufferSource()
    src.buffer = audioBuf
    src.connect(analyser)
    const proc = audioctx242.createScriptProcessor(1024, 1, 1)
    src.connect(proc)
    proc.connect(audioctx242.destination)
    startTs = performance.now()
    stableBuf = []
    currentNote = null
    proc.onaudioprocess = () => {
      const { freq, db } = detectPitch()
      let q = null
if (freq && db >= sensitivityDb) {
  const shiftedFreq = freq * Math.pow(2, semitoneShift / 12)
  q = quantize(shiftedFreq)
}

      if (q) {
        stableBuf.push(q)
        if (stableBuf.length > STABLE_N) stableBuf.shift()
        const same = stableBuf.every(x => x && x.name === stableBuf[0].name && x.oct === stableBuf[0].oct)
        if (!currentNote && same) {
          currentNote = { name: q.name, oct: q.oct, f: q.f }
          currentStart = performance.now()
        } else if (currentNote && (currentNote.name !== q.name || currentNote.oct !== q.oct) && same) {
          const now = performance.now()
          music[1].notes.push([currentNote.f, currentStart - startTs, now - currentStart, 0.5, 1])
          currentNote = { name: q.name, oct: q.oct, f: q.f }
          currentStart = now
        }
      } else {
        if (currentNote) {
          silenceStreak++
          if (silenceStreak >= SILENCE_N) {
            const now = performance.now()
            music[1].notes.push([currentNote.f, currentStart - startTs, now - currentStart, 0.5, 1])
            currentNote = null
            silenceStreak = 0
          }
        }
      }
    }
    src.start()
  } catch (err) {}
})
let togglekeyboardpos=0
}
destroy() { window.loopRunning34=false}
}
class MelMakerPlugin {
static title = "Keyboard";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `
<style>
#waveInputsContainer {
  margin: 0;
  width: 100vw;
  overflow-x: scroll;
  overflow-y: hidden;
  position: relative;
  height: 30px;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 5px;
}
  .wave-input{
  	width:25px;
  }
  .keyboard {
    position: relative;
     
    overflow-x: scroll;
    width: 100%;
    max-width: 1050px;
    height: 203px;
    background:#5B5B5B;
    zoom:0.8
  }
  .key {
    position: absolute;
    font-size: 30px;
    display:flex;
    justify-content: center;
    align-items:end ;
    width: 50px;
    height: 200px;
    border: 1px solid #000;
    background-color: #FFFFFF;
    color:black
  }
  .key:active{
    transform: translate(0,-5px);
    animation: 0.5s blued ;
  }
  @keyframes blued{
    0%{
      background:#898989
    }
    100%{
    }
  }
  .black-key {
    background-color: #000;
    width:35px;
    height: 100px;
    margin-top: -10px;
    margin: 0;
    z-index: 1;
    color:white;
  }
  .active {
    background-color: #4CCDF0;
  }
  #waveInputsContainer{
  	width:100%; overflow: hidden scroll;
  }
</style>
 <move id="main1">
 <move id="keyboard">
  <div style="color:var(--primary-text, black); user-select: none;  background:var(--editor-background, black); min-height:600px">
    duration:
<select id="durationL">
 <option value="100">100</option>
  <option value="200">200</option>
  <option value="500">500</option>
  <option value="1000">1000</option>
  <option value="1500">1500</option>
  <option value="2000">2000</option>
  <option value="2500">2500</option>
  <option value="3000">3000</option>
</select>
<br>
<button id="startRecordingButton">start recording</button>
<button id="btn1ef">Toggle Pos</button>
<button id="stopRecordingButton" disabled>stop recording</button>
Import music <input type="file" id="ImportMusic" accept=".mm3">
<button onclick="playMusic(music)">play recorded music</button>
<button onclick="recordreset()">reset record</button>
<button onclick="saveAsBlob()">SAVE as mm3</button>
<button onclick="removefrombuttonstext()">notext</button>
  Octaves: <input type="number" id="octaves" value="3" min="1" max="7">
  Start Octave: <input type="number" id="startOctave" value="3" min="0" max="8">
  <button id="buildKeyboardButton" >Build Keyboard</button>
  <br>
<label><input type="checkbox" id="metronomeToggle"> Hear Metronome</label>
Metronome Time (ms): <input type="number" style="width:60px" id="metronomeTime" value="4000" min="100">
<label>Tempo (BPM): <input type="number" id="bpmInput" value="120" min="1" max="1000"></label>
<input type="checkbox" id="beepboxpiano"> Use Beepbox Piano </label>
<select  id="MetronomeMode" >
	<option value="0">Hear Metronome After Pattern</option>
	<option value="1">Hear Metronome After 1 Bar</option>
</select> 
<button id="btn2ef">Calculate Metronome Time</button>
  <br><br>
  Keyboard Buffer 
  <form id="waveInputsContainer">
  	<input type="number" class="wave-input" onkeydown="handleWaveInput(event)"></form>
<div class="keyboard" id="keyboardContainer">
</div>
</div> <h2>MM3 TO BEEPBOX JSON</h2>
   input mode <select id="TypeSelect">
	<option value="200">250</option>
	<option value="500">500</option>
	<option value="A">defined/6</option>
	<option value="B">defined/8</option>
</select>
  tempo: <input id="tempoData" type="text" value="120">
  <input type="file" id="ConverterBox" accept=".mm3">
  <button id="convertBtn">Convert</button>
        `;
    }
script(container) {
	container.querySelector("#btn1ef").addEventListener("click", ()=>{togglekeyboardpos = !togglekeyboardpos;
const keyboard = document.getElementById('keyboard');
if (togglekeyboardpos) document.getElementById('main2').appendChild(keyboard);
else document.getElementById('main1').appendChild(keyboard);
});
container.querySelector("#btn2ef").addEventListener("click", ()=>{   calculateMetronome() });

let metronomeInterval = null;
function calculateMetronome() {
  const bpm = parseFloat(container.querySelector("#bpmInput").value);
  const beatsPerBar = 8;
  if (isNaN(bpm) || bpm <= 0 || isNaN(beatsPerBar) || beatsPerBar <= 0) {
    alert("Please enter valid BPM and beats per bar.");
    return;
  }
  let beatDuration = 60000 / bpm*beatsPerBar;
  if(container.querySelector("#MetronomeMode").value==1){
  	beatDuration = 60000 / bpm;
  }
  container.querySelector("#metronomeTime").value = Math.round(beatDuration);
}

function playMetronomeClick() {
  const osc = audioCTX2.createOscillator();
  const gain = audioCTX2.createGain();
  osc.frequency.value = 1000;
  gain.gain.value = 0.1;

  osc.connect(gain);
  gain.connect(audioCTX2.destination);

  osc.start();
  osc.stop(audioCTX2.currentTime + 0.05);
}

function startMetronome() {
  const time = parseInt(container.querySelector("#metronomeTime").value);
  if (isNaN(time) || time < 50) return;

  metronomeInterval = setInterval(() => {
    playMetronomeClick();
  }, time);
}

function stopMetronome() {
  if (metronomeInterval) {
    clearInterval(metronomeInterval);
    metronomeInterval = null;
  }
}

 

function blobToBase642(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => {
			const base64data = reader.result.split(',')[1];
			resolve(base64data);
		};
		reader.onerror = reject;
		reader.readAsDataURL(blob);
	});
}

let isPlaying=false;
let playingSources=[];
let activeTimeouts=[]
function setupKeyEvents() {
  const keys = container.querySelectorAll('.key');
  keys.forEach(key => {
    key.onmousedown = () => {
      key.classList.add('active');
      const id = key.id;
      const frequency = frequencies[id];
      if (frequency) {
        playSound(frequency);
        if (isRecording) {
          recordedNotes.push([frequency, performance.now() - startTime, parseFloat(container.querySelector('#durationL').value), 0.5, 1]);
        }
      }
    };
    key.onmouseup = key.onmouseleave = () => {
      key.classList.remove('active');
    };
  });
}
function generateKeyboard() { 
  const container2 = container.querySelector("#keyboardContainer");
  container2.innerHTML = '';
  const whiteNotes = ['c', 'd', 'e', 'f', 'g', 'a', 'h'];
  const blackNotes = ['c#', 'd#', null, 'f#', 'g#', 'a#', null];
  const baseFrequencies = {
    'c': 261.63,
    'c#': 277.18,
    'd': 293.66,
    'd#': 311.13,
    'e': 329.63,
    'f': 349.23,
    'f#': 369.99,
    'g': 392.00,
    'g#': 415.30,
    'a': 440.00,
    'a#': 466.16,
    'h': 493.88,
  };
  const octaves = parseInt(container.querySelector("#octaves").value);
  const startOctave = parseInt(container.querySelector("#startOctave").value);
  let keyIndex = 1;
  let posX = 0;
  for (let octave = startOctave; octave < startOctave + octaves; octave++) {
    for (let i = 0; i < whiteNotes.length; i++) {
      const note = whiteNotes[i];
      const freq = baseFrequencies[note] * Math.pow(2, octave - 4);
      const white = document.createElement("div");
      white.className = "key white-key";
       
      white.id = `key${keyIndex}`;
      white.innerText = note ;
      white.style.left = `${posX}px`;
      white.style.position = 'absolute';
      container2.appendChild(white);
      frequencies[`key${keyIndex}`] = freq;
      keyIndex++;
      posX += 50;
    }
  }
  keyIndex = 1;
  posX = 0;
  for (let octave = startOctave; octave < startOctave + octaves; octave++) {
    for (let i = 0; i < blackNotes.length; i++) {
      const black = blackNotes[i];
      if (!black) {
        posX += 50;
        continue;
      }
      const freq = baseFrequencies[black] * Math.pow(2, octave - 4);
      const blackKey = document.createElement("div");
      blackKey.className = "key black-key";
      blackKey.id = `key${keyIndex + 1000}`;
      blackKey.style.left = `${posX + 35}px`;
      blackKey.style.position = 'absolute';
      container2.appendChild(blackKey);
      frequencies[`key${keyIndex + 1000}`] = freq;
      keyIndex++;
      posX += 50;
    }
  }
  setupKeyEvents();
}
container.querySelector("#buildKeyboardButton").addEventListener("click", generateKeyboard);

  const audioCTX2 = new (window.AudioContext || window.webkitAudioContext)();
  const frequencies = {
 
  };
generateKeyboard()
  let startTime = 0;  
  let isRecording = false;
  let recordedNotes = [];
  function recordreset(){
    recordedNotes = [];
    audioCTX2.currentTime = 0;
  }
let audiobuff = [0,0, 0.5 ,0.5]; 
function handleWaveInput(event) {
  if (event.key === "Enter") {
  	event.preventDefault();
    const newInput = document.createElement("input");
    newInput.type = "number";
    newInput.className = "wave-input";
    newInput.onkeydown = handleWaveInput;
    container.querySelector("#waveInputsContainer").appendChild(newInput);
    newInput.focus();
    updateWaveArray();
  }else if ((event.key === "Delete" || event.key === "Backspace") && event.target.value === "") {
	const inputs = container.querySelectorAll(".wave-input");
	if (inputs.length > 1) {
		event.preventDefault();
		event.target.remove();
		updateWaveArray();
	}
}
 else {
    setTimeout(updateWaveArray, 0);
  }
}
function updateWaveArray() {
  audiobuff = Array.from(container.querySelectorAll(".wave-input"))
    .map(inp => parseFloat(inp.value) || 0);
}
function loadWaveInputsFromArray() {
  const container2 = container.querySelector("#waveInputsContainer");
  container2.innerHTML = ''; 
  audiobuff.forEach(value => {
    const input = document.createElement("input");
    input.type = "number";
    input.className = "wave-input";
    input.value = value;
    input.onkeydown = handleWaveInput;
    container2.appendChild(input);
  });
  updateWaveArray();
}
loadWaveInputsFromArray()
function frequencyToPitch(frequency) {
    return Math.round(12 * Math.log2(frequency / 440) + 57);
}


function playSound(frequency) {
 if (container.querySelector("#beepboxpiano").checked) {
  let duration = parseFloat(container.querySelector('#durationL').value);
  pressPianoKey(  frequencyToPitch(frequency), duration);
 }else{
  const sampleRate = audioCTX2.sampleRate;
  let duration = parseFloat(container.querySelector('#durationL').value);
  let volume = 0.5;
  let volumeEasing = 1;
  let frameCount = sampleRate * (duration / 1000);
  let buffer = audioCTX2.createBuffer(1, frameCount, sampleRate);
  let data = buffer.getChannelData(0);
  let waveformLength = audiobuff.length;
  for (let i = 0; i < frameCount; i++) {
    let time = i / sampleRate;
    let amplitude = volume;
    if (volumeEasing === 1) {
      amplitude *= Math.exp(-5 * time / (duration / 1000));
    } else if (volumeEasing > 1) {
      amplitude *= 1 - Math.exp(-5 * time / ((duration / 1000) * volumeEasing));
    }
    let wavePosition = (i * frequency * waveformLength / sampleRate) % waveformLength;
    let index = Math.floor(wavePosition);
    let nextIndex = (index + 1) % waveformLength;
    let frac = wavePosition - index;
    let sample = audiobuff[index] * (1 - frac) + audiobuff[nextIndex] * frac;
    data[i] = amplitude * sample;
  }
  let source = audioCTX2.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCTX2.destination);
  source.start();
 }
}
 
  container.querySelector('#startRecordingButton').addEventListener('click', () => {
    isRecording = true;
    startTime = performance.now();
    recordedNotes = [];
if (container.querySelector("#metronomeToggle").checked) {
	startMetronome();
} else {
	stopMetronome();
}
    container.querySelector('#startRecordingButton').disabled = true;
    container.querySelector('#stopRecordingButton').disabled = false;
  });
  container.querySelector('#stopRecordingButton').addEventListener('click', () => {
    isRecording = false;
    
    container.querySelector('#startRecordingButton').disabled = false;
    container.querySelector('#stopRecordingButton').disabled = true;
    music[1].notes = recordedNotes.map(note => {
      const [frequency, startTime, duration, volume, volumeEasing] = note;
      return [frequency, startTime, duration, volume, volumeEasing];
    });
    stopMetronome();
  });
  function saveAsBlob() {
    const blob = new Blob([JSON.stringify(music)], { type: 'application/octet-stream' });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'music.mm3';
    a.click();
    URL.revokeObjectURL(url);
    
if (location.href.startsWith("file:///")) {
	NativeJava.DownloadText( JSON.stringify(music) , "music.mm3");
}
    
  }
  function removefrombuttonstext() {
    const pianoKeys = document.querySelectorAll('.key');
    pianoKeys.forEach(key => {
      key.innerText = "";
    });
  }
  async function playTone(audioCTX2, frequency, duration, volume, customInstrument, volumeEasing) {
  return new Promise(resolve => {
    const sampleRate = audioCTX2.sampleRate;
    const frameCount = sampleRate * (duration / 1000);
    const buffer = audioCTX2.createBuffer(1, frameCount, sampleRate);
    const data = buffer.getChannelData(0);
    const waveformLength = audiobuff.length;
    for (let i = 0; i < frameCount; i++) {
      let time = i / sampleRate;
      let amplitude = volume;
      if (volumeEasing === 1) {
        amplitude *= Math.exp(-5 * time / (duration / 1000));
      } else if (volumeEasing > 1) {
        amplitude *= 1 - Math.exp(-5 * time / ((duration / 1000) * volumeEasing));
      }
      let wavePosition = (i * frequency * waveformLength / sampleRate) % waveformLength;
      let index = Math.floor(wavePosition);
      let nextIndex = (index + 1) % waveformLength;
      let frac = wavePosition - index;
      let sample = audiobuff[index] * (1 - frac) + audiobuff[nextIndex] * frac;
      data[i] = amplitude * sample;
    }
    const source = audioCTX2.createBufferSource();
    source.buffer = buffer;
    source.connect(audioCTX2.destination);
    playingSources.push(source);
    source.start();
    const keyId = Object.keys(frequencies).find(k => Math.abs(frequencies[k] - frequency) < 1);
if (keyId) document.getElementById(keyId)?.classList.add('active');

setTimeout(function(){
	if (keyId) document.getElementById(keyId)?.classList.remove('active');
},200)

source.onended = () => {
	resolve();
};
  });
}
  async function playSection(audioCTX2, sectionId) {
  const section = music[sectionId];
  const { notes, instrument, nextSection, runallnotes } = section;
  const tempo = section.tempo || music.tempo;

  if (runallnotes) {
    const promises = notes.map(([hz, timeout, length, volume, volumeEasing]) => {
      return new Promise(resolve => {
        const t = setTimeout(() => {
          if (!isPlaying) return resolve();
          playTone(audioCTX2, hz, length / tempo, volume, instrument, volumeEasing).then(resolve);
        }, timeout / tempo);
        activeTimeouts.push(t);
      });
    });
    await Promise.all(promises);
  } else {
    for (const note of notes) {
      if (!isPlaying) break;
      const [hz, timeout, length, volume, volumeEasing] = note;
      await playTone(audioCTX2, hz, length / tempo, volume, instrument, volumeEasing);
      if (!isPlaying) break;
      await new Promise(resolve => {
        const t = setTimeout(() => resolve(), timeout / tempo);
        activeTimeouts.push(t);
      });
    }
  }

  if (nextSection !== null && isPlaying) {
    await playSection(audioCTX2, nextSection);
  }
}

async function playMusic(name) {
  const playButton = document.querySelector('button[onclick^="playMusic"]');
  playingSources.forEach(src => src.stop());
  playingSources = [];
  activeTimeouts.forEach(timeout => clearTimeout(timeout));
  activeTimeouts = [];
  if (isPlaying) {
    isPlaying = false;
    playButton.textContent = 'play recorded music';
    return;
  }
  isPlaying = true;
  playButton.textContent = 'pause recorded music';

  const runSections = name.run;
  for (let sectionId of runSections) {
    if (!isPlaying) break;
    await playSection(audioCTX2, sectionId);
  }

  isPlaying = false;
  playButton.textContent = 'play recorded music';
}


  var music = {
    tempo: 1,  
    run: [1],  
    1: {
      notes: [],
      instrument: 'square',
      nextSection: null,
      runallnotes: 1
    }
  };
container.querySelector("#ImportMusic").addEventListener("change", function (event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const importedMusic = JSON.parse(e.target.result);
      if (importedMusic && typeof importedMusic === 'object') {
        music = importedMusic;
        alert("Loaded !");
      } else {
        alert("Error loading");
      }
    } catch (err) {
      alert("Error:  " + err.message);
    }
  };
  reader.readAsText(file);
});
  function blobToBase642(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => {
			const base64data = reader.result.split(',')[1];
			resolve(base64data);
		};
		reader.onerror = reject;
		reader.readAsDataURL(blob);
	});
}
  
  	container.querySelector("#convertBtn").addEventListener("click", () => {
  		const ConverterBox = container.querySelector("#ConverterBox");
  		if (!ConverterBox.files.length) return;
  		
  		const reader = new FileReader();
  		reader.onload = function(e) {
  			const mm3 = JSON.parse(e.target.result);
  			const fruitybox = convertToFruityBox(mm3);
  			let	jsonfull=JSON.stringify(fruitybox, null, 2)
  			const blob = new Blob([jsonfull], { type: "application/json" });
  			const url = URL.createObjectURL(blob);
  			const a = document.createElement("a");
  			a.href = url;
  			a.download = "fruitybox.json";
  			a.click();
  			URL.revokeObjectURL(url);
  			
if (location.href.startsWith("file:///")) {
	NativeJava.DownloadText( jsonfull , "fruitybox.json");
}
  			
  		};
  		reader.readAsText(ConverterBox.files[0]);
  	});
  	 
  	function convertToFruityBox(mm3) {
  		const notes = mm3["1"].notes;
  		notes.sort((a, b) => a[1] - b[1]);
  		const tempo = parseFloat(container.querySelector("#tempoData").value)||200 ;
  		const ticksPerBeat = 8;
  		const beatsPerBar = 8;
  		const ticksPerBar = ticksPerBeat * beatsPerBar;
  		const msPerTick = 60000 / tempo / ticksPerBeat;
  		const channels = [];
  		function createEmptyChannel(numPatterns) {
  const patterns = Array.from({ length: numPatterns }, () => ({ notes: [] }));
  const sequence = [...Array(numPatterns).keys()];
return {
	type: "pitch",
	name: "triangle",
	instruments: [{
		type: "chip",
		volume: 0,
		eqFilter: [],
		eqFilterType: false,
		eqSimpleCut: 10,
		eqSimplePeak: 0,
		eqSubFilters0: [],
		effects: [],
		fadeInSeconds: 0,
		fadeOutTicks: 48,
		wave: "triangle",
		envelopes: []
	}],
	patterns: patterns,
	sequence: sequence,
	octaveScrollBar: 0
};
}
function hasOverlap(existingNotes, startTick, endTick) {
  			return existingNotes.some(note => {
  				const nStart = note.points[0].tick;
  				const nEnd = note.points[1].tick;
  				return (startTick < nEnd && endTick > nStart);
});
}
let maxEndTick = 0;
for (const [freq, startMs, lenMs] of notes) {
	let msLEg = 500;
if (container.querySelector("#TypeSelect").value == "A")  {
	msLEg = parseInt(lenMs / 6)
}else if (container.querySelector("#TypeSelect").value == "B") {
	msLEg = parseInt(lenMs / 8)
}else if ( !isNaN(container.querySelector("#TypeSelect").value) ) {
	msLEg = parseInt(container.querySelector("#TypeSelect").value)
}
const clippedLenMs = Math.max(40, msLEg);
const absEndTick = Math.round((startMs + clippedLenMs) / msPerTick);
  if (absEndTick > maxEndTick) maxEndTick = absEndTick;
}
const numPatterns = Math.ceil(maxEndTick / ticksPerBar)+1;
  		for (const [freq, startMs, lenMs] of notes) {
  			const absStartTick = Math.round(startMs / msPerTick);
let msLEg=500;
if (container.querySelector("#TypeSelect").value == "A") {
	msLEg = parseInt(lenMs / 6)
} else if (container.querySelector("#TypeSelect").value == "B") {
	msLEg = parseInt(lenMs / 8)
} else if (!isNaN(container.querySelector("#TypeSelect").value)) {
	msLEg = parseInt(container.querySelector("#TypeSelect").value)
}
const clippedLenMs = Math.max(40, msLEg );
const absEndTick = Math.round((startMs + clippedLenMs) / msPerTick);
  			const patternIndex = Math.floor(absStartTick / ticksPerBar);
  			const startTick = absStartTick % ticksPerBar;
  			let endTick = absEndTick % ticksPerBar;
if (endTick <= startTick) {
	endTick = startTick + 1;
	if (endTick > ticksPerBar) endTick = ticksPerBar; 
}
const pitch = freqToPitchIndex(freq);
 if (pitch === null) continue;
  			let placed = false;
  			for (let c = 0; c <= channels.length; c++) {
  				if (channels[c] === undefined) channels[c] = createEmptyChannel(numPatterns);
  				const pattern = channels[c].patterns[patternIndex];
  				if (!hasOverlap(pattern.notes, startTick, endTick)) {
  					pattern.notes.push({
  						pitches: [pitch],
  						points: [
  							{ tick: startTick, pitchBend: 0, volume: 100, forMod: false },
  							{ tick: endTick, pitchBend: 0, volume: 100, forMod: false }
  						],
  						continuesLastPattern: false
  					});
  					placed = true;
  					break;
  				}
  			}
if (!placed) {
	const newChan = createEmptyChannel(numPatterns);
	channels.push(newChan);
	const pattern = newChan.patterns[patternIndex];
	pattern.notes.push({
		pitches: [pitch],
		points: [
			{ tick: startTick, pitchBend: 0, volume: 100, forMod: false },
			{ tick: endTick, pitchBend: 0, volume: 100, forMod: false }
		],
		continuesLastPattern: false
	});
}
}
  		return {
  			name: "StudioSong",
  			format: "StudioBox",
  			version: 5,
  			scale: "Free",
  			key: "C",
  			introBars: 0,
  			loopBars: 2,
  			beatsPerBar,
  			ticksPerBeat,
  			beatsPerMinute: tempo,
  			reverb: 0,
  			masterGain: 1,
  			compressionThreshold: 1,
  			limitThreshold: 1,
  			limitDecay: 4,
  			limitRise: 4000,
  			limitRatio: 1,
  			compressionRatio: 1,
  			layeredInstruments: false,
  			patternInstruments: false,
  			channels
  		};
  	}
  	
  	function freqToPitchIndex(freq) {
  		const midi = 69 + 12 * Math.log2(freq / 440);
  		const pitch = Math.round(midi - 12);
  		if (pitch < 0 || pitch > 95*2) return null;
  		return pitch;
  	}
	window.playMusic = (name) => playMusic(name);
	window.recordreset = () => recordreset();
	window.saveAsBlob = () => saveAsBlob();
	window.removefrombuttonstext = () => removefrombuttonstext();
	window.handleWaveInput = (e) => handleWaveInput(e);
}
destroy() {}
}
class CustomThemesPlugin {
static title = "Custom Themes";constructor() {this.paused = false;this.ticks = 0;this._raf = null;} 
render() {
  return `
    <h2 style="color: var(--primary-text); font-size: 1.4em; margin-bottom: 0.5em;">Custom Themes</h2>
    <div class="menu" style="
      display: flex; 
      flex-direction: column; 
      gap: 0.5em; 
      width: 100%; 
      max-width: 900px;">
      
      <label style="color: var(--secondary-text); font-weight: bold;">Theme Name:</label>
      <input id="varname2" type="text" placeholder="Enter theme name" style="
        padding: 0.4em 0.6em; 
        font-size: 1em; 
        border-radius: 0.3em; 
        border: 1px solid var(--input-box-outline); 
        background-color: var(--editor-background); 
        color: var(--primary-text);
        width: 100%;">

      <label style="color: var(--secondary-text); font-weight: bold;">Theme CSS:</label>
      <div style="display: flex; gap: 1em; flex-wrap: wrap; width: 100%;">
        <textarea id="cssInput" placeholder="Paste your CSS here..." style="
          flex: 1 1 60%; 
          outline:none;
          min-height: 250px; 
          resize: vertical; 
          padding: 0.6em; 
          font-family: monospace; 
          font-size: 0.9em; 
          border-radius: 0.4em; 
          border: 1px solid var(--input-box-outline); 
          background-color: var(--editor-background); 
          color: var(--primary-text); 
          overflow: auto;"></textarea>
        <div id="fileManager" style="
          flex: 1 1 35%; 
          max-height: 250px; 
          overflow-y: auto; 
          padding: 0.5em; 
          border-radius: 0.4em; 
          background-color: var(--ui-widget-background);
          border: 1px solid var(--input-box-outline);
          color: var(--primary-text);
          font-size: 0.85em;">
        </div>
      </div>
    </div>

    <div style="display: flex; flex-wrap: wrap; gap: 0.5em; margin-top: 1em;">
      <button id="generateButton222" disabled style="
        background-color: var(--loop-accent); 
        color: var(--primary-text); 
        border: none; 
        padding: 0.5em 1em; 
        border-radius: 0.3em; 
        cursor: pointer;">Create Theme</button>
      <button id="addImageBtn" style="
        background-color: var(--overwriting-mod-slider); 
        color: var(--primary-text); 
        border: none; 
        padding: 0.5em 1em; 
        border-radius: 0.3em; 
        cursor: pointer;">Add Image</button>
      <button id="loadRawBtn" style="
        background-color: var(--multiplicative-mod-slider); 
        color: var(--primary-text); 
        border: none; 
        padding: 0.5em 1em; 
        border-radius: 0.3em; 
        cursor: pointer;">Load CSS</button>
      <button id="exportCssBtn" style="
        background-color: var(--indicator-primary); 
        color: var(--primary-text); 
        border: none; 
        padding: 0.5em 1em; 
        border-radius: 0.3em; 
        cursor: pointer;">Export CSS</button>
      <select id="themeSelect" style="
        padding: 0.4em 0.6em; 
        border-radius: 0.3em; 
        border: 1px solid var(--input-box-outline); 
        background-color: var(--editor-background); 
        outline:none;
        color: var(--primary-text);
        font-size: 0.95em;">
      </select>
      <button id="getCssBtn" style="
        background-color: var(--indicator-secondary); 
        color: var(--primary-text); 
        border: none; 
        padding: 0.5em 1em; 
        border-radius: 0.3em; 
        cursor: pointer;">Get CSS</button>
    </div>

    <div id="themeList" style="
      margin-top: 1em; 
      display: flex; 
      flex-direction: column; 
      gap: 0.4em; 
      max-height: 300px; 
      overflow-y: auto;">
    </div>
  `;
}

script(container) {
	let imageVars = {};
let imageExample=`
:root{
	--image-example: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==");
}
.pattern-area.load,
#pattern-area.load {
  background-image: var(--image-example);
  image-rendering: pixelated;
  background-size: 350px 350px;
  background-position: center;
  background-repeat: no-repeat;
  position: relative;
}
.pattern-area.load::before,
#pattern-area.load::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.3);
  pointer-events: none;
}
body:not(:has(.beepboxEditorContainer)) {
  background-image: var(--image-example);
  image-rendering: pixelated;
  background-size: 350px 350px;
  background-position: center;
  background-repeat: no-repeat;
}
.pattern-area,
#pattern-area,
.track-editor,
#track-editor {
  background-color: transparent !important;
}
.editor-background {
  background: transparent !important;
}
`
function normalizeCss(css) {
  return css
    .split('\n')
    .map(line => line.trimStart())
    .join('\n')
    .trim();
}
function extractImagesFromCss(css) {
  const lines = css.split('\n');
  const cleanLines = [];
  imageVars = {};
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    if (line.startsWith('--image-') && line.includes('url(')) {
      const parts = line.split(':');
      if (parts.length < 2) continue;
      const varName = parts[0].trim();
      let val = parts.slice(1).join(':').trim();
      val = val.replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
      let mime = 'image/png';
      let data = val;
      if (val.startsWith('data:')) {
        const match = val.match(/^data:(.*?);base64,(.*)$/);
        if (match) {
          mime = match[1];
          data = match[2];
        }
      }
      imageVars[varName] = { mime, data };
      continue;
    }
    cleanLines.push(line);
  }
  renderImageManager();
for (let i = 0; i < cleanLines.length; i++) {
  if (
    cleanLines[i] === ':root' ||
    cleanLines[i] === ':root{' ||
    cleanLines[i] === ':root {'
  ) {
    let j = i;
    let hasContent = false;
    while (j < cleanLines.length) {
      if (cleanLines[j] === '}') break;
      if (
        cleanLines[j] !== ':root' &&
        cleanLines[j] !== ':root{' &&
        cleanLines[j] !== ':root {' &&
        cleanLines[j] !== '{'
      ) {
        hasContent = true;
      }
      j++;
    }
    if (!hasContent) {
      cleanLines.splice(i, j - i + 1);
      i--;
    }
  }
}
  return cleanLines.join('\n').trim()
}
function normalizeCssVar(name) {
  return name
    .toLowerCase()
    .replace(/\.[^/.]+$/, "")
    .replace(/[^a-z0-9-]/g, "-");
}
	container.querySelector('#getCssBtn').onclick = () => {
  const selected = container.querySelector('#themeSelect').value;
  let themeVars
  if(selected=="Example Theme With Image"){
  	themeVars = imageExample
  }else{
  themeVars = ColorConfig.themes[selected];
  }
  if (!themeVars) return;
  const cleanCss = extractImagesFromCss(themeVars);
  renderImageManager();
  container.querySelector('#cssInput').value = normalizeCss(cleanCss);
};
	function renderThemeSelect() {
  const select = container.querySelector('#themeSelect');
  select.innerHTML = '';
  Object.keys( ColorConfig.themes ).forEach(themeName => {
    const opt = document.createElement('option');
    opt.value = themeName;
    opt.textContent = themeName;
    select.appendChild(opt);
  });
  const opt2 = document.createElement('option');
  opt2.value = "Example Theme With Image";
  opt2.textContent = "Example Theme With Image";
  select.appendChild(opt2)
}
function getCss() {
  const textarea = container.querySelector('#cssInput');
  const lines = textarea.value.split('\n');
  const cleanCss = [];
  let insideRoot = false;

  for (let line of lines) {
    line = line.trim();
    if (line.startsWith(':root{')) {
      insideRoot = true;
      continue;
    }
    if (insideRoot && line.endsWith('}')) {
      insideRoot = false;
      continue;
    }
    if (!insideRoot && line) cleanCss.push(line);
  }

  let rootBlock = '';
  if (Object.keys(imageVars).length) {
    rootBlock = ':root{\n';
    for (let k in imageVars) {
      const img = imageVars[k];
      if (typeof img === "string") {
        rootBlock += `  ${k}: url("${img}");\n`;
      } else {
        rootBlock += `  ${k}: url("data:${img.mime};base64,${img.data}");\n`;
      }
    }
    rootBlock += '}\n\n';
  }
  return rootBlock + cleanCss.join('\n').trim();
}
container.querySelector('#exportCssBtn').onclick = () => {
  const css = getCss();
  if (!css) return;
  const blob = new Blob([css], { type: 'text/css' });
  const url = URL.createObjectURL(blob);
  save(blob, container.querySelector(`#varname2`).value + '.css',css)
  URL.revokeObjectURL(url);
};
function blobToBase64(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => {
			const base64data = reader.result.split(',')[1];
			resolve(base64data);
		};
		reader.onerror = reject;
		reader.readAsDataURL(blob);
	});
}
function renderImageManager() {
  container.querySelector('#fileManager').innerHTML = '';
  Object.keys(imageVars).forEach(cssVar => {
    const name = cssVar.replace('--image-','');
    const div = document.createElement('div');
    div.textContent = name;
    const copy = document.createElement('button');
    copy.style="margin-left:10px; background-color: var(--editor-background); padding:1px; border-radius:0px;"
    copy.textContent = 'cp';
    copy.onclick = () => {
      navigator.clipboard.writeText(`var(${cssVar})`);
    };
    const del = document.createElement('button');
    del.textContent = 'X';
    del.style="margin-left:10px; background-color: var(--editor-background); padding:1px; border-radius:0px;"
    del.onclick = () => {
      delete imageVars[cssVar];
      renderImageManager();
    };
    div.appendChild(copy);
    div.appendChild(del);
    container.querySelector('#fileManager').appendChild(div);
  });
}
container.querySelector('#loadRawBtn').onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.css';
  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const text = await file.text();
    const cleanCss = extractImagesFromCss(text);
    renderImageManager();
    container.querySelector('#cssInput').value = normalizeCss(cleanCss);
  };
  input.click();
};

container.querySelector('#addImageBtn').onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.multiple = true;
  input.accept = 'image/*';
  input.onchange = async () => {
    for (const file of input.files) {
      const base64 = await blobToBase64(file);
      const varName = "--image-" + normalizeCssVar(file.name);
      imageVars[varName] = {
        mime: file.type || 'image/png', 
        data: base64
      };
    }
    renderImageManager();
  };
  input.click();
};




function renderFileList2() {
	const list = container.querySelector('#themeList');
	list.innerHTML = '';
	Object.keys(CustomThemes).forEach(id => {
		const div = document.createElement('div');
		div.className = 'file-item';
		div.id = `file-${id}`;
		const span = document.createElement('span');
		span.textContent = id;
		const btn1 = document.createElement('button');
  btn1.textContent = 'copy';
		const btn = document.createElement('button');
		btn.textContent = 'X';
		btn.onclick = () => {
			delete CustomThemes[id];
			  THEMESDB.remove(id);
			container.querySelector(`#file-${id}`).remove();
		};
		btn1.onclick = () => {
  container.querySelector(`#cssInput`).value=extractImagesFromCss(CustomThemes[id]);
  container.querySelector(`#varname2`).value=id;
  };
		div.appendChild(span);
		div.appendChild(btn1);
		div.appendChild(btn);
		list.appendChild(div);
	});
}
container.querySelector('#cssInput').addEventListener('input', (event) => {
	if(document.getElementById('cssInput').value!=="" && container.querySelector('#varname2').value!=="" ){
	container.querySelector('#generateButton222').disabled = false;
	}else{
	container.querySelector('#generateButton222').disabled = true;
	}
});
container.querySelector('#varname2').addEventListener('input', (event) => {
	if (container.querySelector('#cssInput').value !== "" && container.querySelector('#varname2').value !== "") {
		container.querySelector('#generateButton222').disabled = false;
	} else {
		container.querySelector('#generateButton222').disabled = true;
	}
});

 
async function audioFileToBuffer(file) {
  const arrayBuffer = await file.arrayBuffer();
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  const channelData = audioBuffer.getChannelData(0);
  return Array.from(channelData);
}

function blobToBase6422(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64data = reader.result.split(',')[1];
      resolve(base64data);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}
container.querySelector('#generateButton222').addEventListener('click', async () => {
  const name = container.querySelector('#varname2').value;
  let css = getCss()
  CustomThemes[name] = css;
  await THEMESDB.save(name, css); 
  container.querySelector('#varname2').value = '';
  container.querySelector('#cssInput').value = '';
  container.querySelector('#generateButton222').disabled = true;
  renderFileList2();
  loadFiles2()
});
renderFileList2()
renderThemeSelect();

}
destroy() {}
}
function createStorage(dbName = "myDB", storeName = "store") {
	const dbPromise = new Promise((resolve, reject) => {
		const request = indexedDB.open(dbName, 1);
		request.onupgradeneeded = (event) => {
			const db = event.target.result;
			if (!db.objectStoreNames.contains(storeName)) {
				db.createObjectStore(storeName);
			}
		};
		request.onsuccess = () => {
			resolve(request.result);
		};
		request.onerror = () => {
			reject(request.error);
		};
	});
	async function save(slot, data) {
		const db = await dbPromise;
		return new Promise((resolve, reject) => {
			const tx = db.transaction([storeName], "readwrite");
			const store = tx.objectStore(storeName);
			const req = store.put(data, slot);
			req.onsuccess = () => resolve();
			req.onerror = () => reject(req.error);
		});
	}
	async function remove(slot) {
		const db = await dbPromise;
		return new Promise((resolve, reject) => {
			const tx = db.transaction([storeName], "readwrite");
			const store = tx.objectStore(storeName);
			const req = store.delete(slot);
			req.onsuccess = () => resolve();
			req.onerror = () => reject(req.error);
		});
	}
	
	function load(slot, callback) {
		dbPromise.then(db => {
			const tx = db.transaction([storeName], "readonly");
			const store = tx.objectStore(storeName);
			const req = store.get(slot);
			req.onsuccess = () => callback(req.result ?? null);
			req.onerror = () => callback(null);
		}).catch(() => callback(null));
	}
	return { save, load, remove, dbPromise };
}
let THEMESDB = createStorage("Themes", "themes")
async function loadFiles2() {
	CustomThemes = {};
	const db = await THEMESDB.dbPromise;
	const tx = db.transaction(["themes"], "readonly");
	const store = tx.objectStore("themes");
	const req = store.openCursor();
	req.onsuccess = (event) => {
		const cursor = event.target.result;
		if (cursor) {
			CustomThemes[cursor.key] = cursor.value;
			cursor.continue();
		} else {
			updateThemes()
			
		}
	};
}
loadFiles2() 
class OtherPlugin {
static title = "Other";constructor() {this.paused = false;this.ticks = 0;this._raf = null;}
render() {return `
 <button onclick='document.location.href="./midiplayer.html";
'>Open MIDI Player</button>
 <button onclick='document.location.href="./sample_extractor.html";
'>Open Sample Extractor</button>
 <button onclick='document.location.href="./sfmaker.html";
'>Open SF2 Tools</button>
 <button onclick='document.location.href="./record.html";
'>Open Recorder</button>
 <button onclick='document.location.href="./oscilloscope.html";
'>Open Oscilloscope player</button>
<button onclick="console_profiler123.style.display=console_profiler123.style.display=='block'?'none':'block' ">Debug Console</button>
</div>
        `;
    }
script(container) {
if(window.console_profiler123)return;
window.console_profiler123=document.createElement("div")
console_profiler123.id="console-panel"
console_profiler123.style.cssText="position:fixed;bottom:0;left:0;width:250px;height:200px;background:rgba(10,10,10,0.2);color:#0f0;font:12px monospace;z-index:9999;overflow:auto;display:none;white-space:pre-wrap;user-select:text !important; pointer-events:none;"
document.body.appendChild(console_profiler123)
 
const origLog=console.log
console.log=function(...args){
 origLog.apply(console,args)
 const msg=args.map(a=>(typeof a==="object"?JSON.stringify(a):a)).join(" ")
 const div=document.createElement("div")
 div.style.color="#0f0"
 div.textContent=msg
 console_profiler123.appendChild(div)
 console_profiler123.scrollTop=console_profiler123.scrollHeight
}


window.addEventListener("error", e => {
 const div = document.createElement("div")
 div.style.color = "red"
 div.textContent = `${e.message} @${e.filename}:${e.lineno}:${e.colno}`
 console_profiler123.appendChild(div)
 console_profiler123.scrollTop = console_profiler123.scrollHeight
})

window.addEventListener("unhandledrejection", e => {
 const div = document.createElement("div")
 div.style.color = "orange"
 div.textContent = `UnhandledPromiseRejection: ${e.reason}`
 console_profiler123.appendChild(div)
 console_profiler123.scrollTop = console_profiler123.scrollHeight
})


function toggleDebug(){
 ttgl34_ui5tyFrtVghyjk_67=ttgl34_ui5tyFrtVghyjk_67==0?1:0
}}
destroy() {}
}
class SelectPlugin {
  constructor(_doc) {
    this._doc = _doc;
    this.plugins = {
      samplesOffline: SamplesOfflinePlugin,
      sampleEditor: SampleEditorPlugin,
      fadeoutPlugin: FadeoutPlugin,
      reversePlugin: ReversePlugin,
      advEditor: AdvancedEditorPlugin,
      whistleToNotes: WhistleToNotesPlugin,
      melMaker: MelMakerPlugin,
      customThemes: CustomThemesPlugin,
      other: OtherPlugin
    };
    this._samplesOffline = button$6({}, SamplesOfflinePlugin.title);
    this._sampleEditor = button$6({}, SampleEditorPlugin.title);
    this._fadeoutPlugin = button$6({}, FadeoutPlugin.title);
    this._reversePlugin = button$6({}, ReversePlugin.title);
    this._advEditor = button$6({}, AdvancedEditorPlugin.title);
    this._whistleToNotes = button$6({}, WhistleToNotesPlugin.title);
    this._melMaker = button$6({}, MelMakerPlugin.title);
    this._customThemes = button$6({}, CustomThemesPlugin.title);
    this._other = button$6({}, OtherPlugin.title);
    
    this._cancelButton = button$6({ class: "cancelButton" });
    this.container = div$6(
      { class: "prompt noSelection", style: "width: 220px;" },
      h2$5("Open Plugins"),
      this._samplesOffline,
      this._sampleEditor,
      this._fadeoutPlugin,
      this._reversePlugin,
      this._advEditor,
      this._whistleToNotes,
      this._melMaker,
      this._customThemes,
      this._other,
      this._cancelButton,
    );
    this._cancelHandler = () => { editor._setPrompt(null);this._doc.undo();    }
    this._samplesOfflineHandler = () => this.openPlugin("samplesOffline");
    this._sampleEditorHandler = () => this.openPlugin("sampleEditor");
    this._fadeoutHandler = () => this.openPlugin("fadeoutPlugin");
    this._reverseHandler = () => this.openPlugin("reversePlugin");
    this._advEditorHandler = () => this.openPlugin("advEditor");
    this._whistleHandler = () => this.openPlugin("whistleToNotes");
    this._melMakerHandler = () => this.openPlugin("melMaker");
    this._customThemesHandler = () => this.openPlugin("customThemes");
    this._otherHandler = () => this.openPlugin("other");
    this._cancelButton.addEventListener("click", this._cancelHandler);
    this._samplesOffline.addEventListener("click", this._samplesOfflineHandler);
    this._sampleEditor.addEventListener("click", this._sampleEditorHandler);
    this._fadeoutPlugin.addEventListener("click", this._fadeoutHandler);
    this._reversePlugin.addEventListener("click", this._reverseHandler);
    this._advEditor.addEventListener("click", this._advEditorHandler);
    this._whistleToNotes.addEventListener("click", this._whistleHandler);
    this._melMaker.addEventListener("click", this._melMakerHandler);
    this._customThemes.addEventListener("click", this._customThemesHandler);
    this._other.addEventListener("click", this._otherHandler);
    editor.doc._pendingPlugin = null;
  }
  cleanUp() {
    this._cancelButton.removeEventListener("click", this._cancelHandler);
    this._samplesOffline.removeEventListener("click", this._samplesOfflineHandler);
    this._sampleEditor.removeEventListener("click", this._sampleEditorHandler);
    this._fadeoutPlugin.removeEventListener("click", this._fadeoutHandler);
    this._reversePlugin.removeEventListener("click", this._reverseHandler);
    this._advEditor.removeEventListener("click", this._advEditorHandler);
    this._whistleToNotes.removeEventListener("click", this._whistleHandler);
    this._melMaker.removeEventListener("click", this._melMakerHandler);
    this._customThemes.removeEventListener("click", this._customThemesHandler);
    this._other.removeEventListener("click", this._otherHandler);
  }
  openPlugin(id) {
    const PluginClass = this.plugins[id];
    const plugin = new PluginClass();
    this._cancelHandler()
    editor.doc.prompt = null;
    editor.doc._pendingPlugin = {
        id,
        plugin,
        title: PluginClass.title,
        html: plugin.render()
    };
    setTimeout(function(){
    editor._openPrompt(`plugin:${id}`);
    },100);
    }

}
   class SelectLanguage {
  	constructor(_doc) {
  		this._doc = _doc;
  		this._langSelect = select$4({ style: "width: 100%;" }, optgroup$1({ label: "Languages" }, option$4({ value: "en" }, "English"), option$4({ value: "pl" }, "Polski"),option$4({ value: "de" }, "Deutsch"),  ));
  		this._cancelButton = button$6({ class: "cancelButton" });
  		this._okayButton = button$6({ class: "okayButton", style: "width:45%;" }, "Okay");
  		this.container = div$6({ class: "prompt noSelection", style: "width: 220px;" }, h2$5("Set Language"), div$6({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$6({ class: "selectContainer", style: "width: 100%;" }, this._langSelect)), div$6({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
  		this.lastLang = window.localStorage.getItem("language");
  		this._close = () => {
  			if (this.lastLang != null) {
  				 this._doc.prefs.language = this.lastLang;
  			}
  			else {
  				 this._doc.prefs.language = "en";
  			}
  			this._doc.undo();
  		};
  		this.cleanUp = () => {
  			this._okayButton.removeEventListener("click", this._saveChanges);
  			this._cancelButton.removeEventListener("click", this._close);
  			this.container.removeEventListener("keydown", this._whenKeyPressed);
  		};
  		this._whenKeyPressed = (event) => {
  			if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
  				this._saveChanges();
  			}
  		};
  		this._saveChanges = async () => {
	const lang = this._langSelect.value
	window.localStorage.setItem("language", lang)
	this._doc.prompt = null
	this._doc.prefs.language = lang
	await autoTranslatePage(lang)
	this._doc.undo()
}
  		if (this.lastLang != null) {
  			this._langSelect.value = this.lastLang;
  		}
  		this._okayButton.addEventListener("click", this._saveChanges);
  		this._cancelButton.addEventListener("click", this._close);
  		this.container.addEventListener("keydown", this._whenKeyPressed);
  	}
  }
    
    class CustomThemePrompt {
        constructor(_doc, _pattern, _pattern2, _pattern3) {
            this._doc = _doc;
            this._pattern = _pattern;
            this._pattern2 = _pattern2;
            this._pattern3 = _pattern3;
            this._fileInput = input$4({ type: "file", accept: "image/*", text: "choose editor background image" });
            this._fileInput2 = input$4({ type: "file", accept: "image/*", text: "choose website background image" });
            this._colorInput = input$4({ type: "text", value: localStorage.getItem("customColors") || `:root {
	--page-margin: black;
	--editor-background: black;
	--hover-preview: white;
	--playhead: white;
	--primary-text: white;
	--secondary-text: #999;
	--inverted-text: black;
	--text-selection: rgba(119,68,255,0.99);
	--box-selection-fill: rgba(255,255,255,0.2);
	--loop-accent: #74f;
	--link-accent: #98f;
	--ui-widget-background: #444;
	--ui-widget-focus: #777;
	--pitch-background: #444;
	--tonic: #864;
	--fifth-note: #468;
	--white-piano-key: #bbb;
	--black-piano-key: #444;
	--white-piano-key-text: #131200;
	--black-piano-key-text: #fff;
	--use-color-formula: false;
	--track-editor-bg-pitch: #444;
	--track-editor-bg-pitch-dim: #333;
	--track-editor-bg-noise: #444;
	--track-editor-bg-noise-dim: #333;
	--track-editor-bg-mod: #234;
	--track-editor-bg-mod-dim: #123;
	--multiplicative-mod-slider: #456;
	--overwriting-mod-slider: #654;
	--indicator-primary: #74f;
	--indicator-secondary: #444;
	--select2-opt-group: #585858;
	--input-box-outline: #333;
	--mute-button-normal: #ffa033;
	--mute-button-mod: #9a6bff;
	--pitch1-secondary-channel: #0099A1;
	--pitch1-primary-channel:   #25F3FF;
	--pitch1-secondary-note:    #00BDC7;
	--pitch1-primary-note:      #92F9FF;
	--pitch2-secondary-channel: #A1A100;
	--pitch2-primary-channel:   #FFFF25;
	--pitch2-secondary-note:    #C7C700;
	--pitch2-primary-note:      #FFFF92;
	--pitch3-secondary-channel: #C75000;
	--pitch3-primary-channel:   #FF9752;
	--pitch3-secondary-note:    #FF771C;
	--pitch3-primary-note:      #FFCDAB;
	--pitch4-secondary-channel: #00A100;
	--pitch4-primary-channel:   #50FF50;
	--pitch4-secondary-note:    #00C700;
	--pitch4-primary-note:      #A0FFA0;
	--pitch5-secondary-channel: #D020D0;
	--pitch5-primary-channel:   #FF90FF;
	--pitch5-secondary-note:    #E040E0;
	--pitch5-primary-note:      #FFC0FF;
	--pitch6-secondary-channel: #7777B0;
	--pitch6-primary-channel:   #A0A0FF;
	--pitch6-secondary-note:    #8888D0;
	--pitch6-primary-note:      #D0D0FF;
	--pitch7-secondary-channel: #8AA100;
	--pitch7-primary-channel:   #DEFF25;
	--pitch7-secondary-note:    #AAC700;
	--pitch7-primary-note:      #E6FF92;
	--pitch8-secondary-channel: #DF0019;
	--pitch8-primary-channel:   #FF98A4;
	--pitch8-secondary-note:    #FF4E63;
	--pitch8-primary-note:      #FFB2BB;
	--pitch9-secondary-channel: #00A170;
	--pitch9-primary-channel:   #50FFC9;
	--pitch9-secondary-note:    #00C78A;
	--pitch9-primary-note:      #83FFD9;
	--pitch10-secondary-channel:#A11FFF;
	--pitch10-primary-channel:  #CE8BFF;
	--pitch10-secondary-note:   #B757FF;
	--pitch10-primary-note:     #DFACFF;
	--noise1-secondary-channel: #6F6F6F;
	--noise1-primary-channel:   #AAAAAA;
	--noise1-secondary-note:    #A7A7A7;
	--noise1-primary-note:      #E0E0E0;
	--noise2-secondary-channel: #996633;
	--noise2-primary-channel:   #DDAA77;
	--noise2-secondary-note:    #CC9966;
	--noise2-primary-note:      #F0D0BB;
	--noise3-secondary-channel: #4A6D8F;
	--noise3-primary-channel:   #77AADD;
	--noise3-secondary-note:    #6F9FCF;
	--noise3-primary-note:      #BBD7FF;
	--noise4-secondary-channel: #7A4F9A;
	--noise4-primary-channel:   #AF82D2;
	--noise4-secondary-note:    #9E71C1;
	--noise4-primary-note:      #D4C1EA;
	--noise5-secondary-channel: #607837;
	--noise5-primary-channel:   #A2BB77;
	--noise5-secondary-note:    #91AA66;
	--noise5-primary-note:      #C5E2B2;
	--mod1-secondary-channel:   #339955;
	--mod1-primary-channel:     #77fc55;
	--mod1-secondary-note:      #77ff8a;
	--mod1-primary-note:        #cdffee;
	--mod2-secondary-channel:   #993355;
	--mod2-primary-channel:     #f04960;
	--mod2-secondary-note:      #f057a0;
	--mod2-primary-note:        #ffb8de;
	--mod3-secondary-channel:   #553399;
	--mod3-primary-channel:     #8855fc;
	--mod3-secondary-note:      #aa64ff;
	--mod3-primary-note:	    #f8ddff;
	--mod4-secondary-channel:   #a86436;
	--mod4-primary-channel:     #c8a825;
	--mod4-secondary-note:      #e8ba46;
	--mod4-primary-note:        #fff6d3;
	--mod-label-primary:        #999;
	--mod-label-secondary-text: #333;
	--mod-label-primary-text:   black;
	--disabled-note-primary:    #999;
	--disabled-note-secondary:  #666; }` });
            this._cancelButton = button$7({ class: "cancelButton" });
            this._okayButton = button$7({ class: "okayButton", style: "width:45%;" }, "Okay");
            this._resetButton = button$7({ style: "height: auto; min-height: var(--button-size);" }, "Reset to defaults");
            this.container = div$7({ class: "prompt noSelection", style: "width: 300px;" }, h2$6("Import"), p$1({ style: "text-align: left; margin: 0.5em 0;" }, "You can upload images to create a custom theme. The first image will become the editor background, and the second image will be tiled across the webpage."), div$7({ style: "text-align: left; margin-top: 0.5em; margin-bottom: 0.5em;" }, "You can find a list of custom themes made by other users on the ", a$1({ target: "_blank", href: "https://docs.google.com/spreadsheets/d/1dGjEcLgJrPwzBExPmwA9pbE_KVQ3jNrnTBrd46d2IKo/edit" }, "custom theme sheet.")), div$7(), p$1({ style: "text-align: left; margin: 0;" }, "Editor Background Image:", this._fileInput), p$1({ style: "text-align: left; margin: 0.5em 0;" }, "Website Background Image:", this._fileInput2), div$7(), p$1({ style: "text-align: left; margin: 0;" }, "Replace the text below with your custom theme data to load it:"), this._colorInput, div$7({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._resetButton), div$7({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
                if (doReload) {
                    setTimeout(() => {cleanMemoryBeforeNavigation(); window.location.reload(); }, 50);
                }
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._close);
                this._cancelButton.removeEventListener("click", this._close);
                this._resetButton.removeEventListener("click", this._reset);
            };
            this._reset = () => {
                window.localStorage.removeItem("colorTheme");
                window.localStorage.removeItem("language");
                window.localStorage.removeItem("customTheme");
                window.localStorage.removeItem("customTheme2");
                window.localStorage.removeItem("customColors");
                this._pattern._svg.style.backgroundImage = "";
                document.body.style.backgroundImage = "";
                this._pattern2.style.backgroundImage = "";
                this._pattern3.style.backgroundImage = "";
                const secondImage = document.getElementById("secondImage");
                if (secondImage != null) {
                    secondImage.style.backgroundImage = "";
                }
                doReload = true;
                this._close();
            };
            this._whenColorsChanged = () => {
                localStorage.setItem("customColors", this._colorInput.value);
                window.localStorage.setItem("colorTheme", "custom");
                this._doc.colorTheme = "custom";
                doReload = true;
            };
            this._whenFileSelected = () => {
                const file = this._fileInput.files[0];
                if (!file)
                    return;
                const reader = new FileReader();
                reader.addEventListener("load", (event) => {
                    let base64 = reader.result;
                    window.localStorage.setItem("customTheme", base64);
                    const value = `url("${window.localStorage.getItem('customTheme')}")`;
                    console.log('setting', value);
                    this._pattern._svg.style.backgroundImage = value;
                    console.log('done');
                });
                reader.readAsDataURL(file);
            };
            this._whenFileSelected2 = () => {
                const file = this._fileInput2.files[0];
                if (!file)
                    return;
                const reader = new FileReader();
                reader.addEventListener("load", (event) => {
                    let base64 = reader.result;
                    window.localStorage.setItem("customTheme2", base64);
                    const value = `url("${window.localStorage.getItem('customTheme2')}")`;
                    document.body.style.backgroundImage = `url(${base64})`;
                    this._pattern2.style.backgroundImage = value;
                    this._pattern3.style.backgroundImage = value;
                    const secondImage = document.getElementById("secondImage");
                    if (secondImage != null) {
                        secondImage.style.backgroundImage = `url(${base64})`;
                    }
                });
                reader.readAsDataURL(file);
            };
            this._fileInput.addEventListener("change", this._whenFileSelected);
            this._fileInput2.addEventListener("change", this._whenFileSelected2);
            this._colorInput.addEventListener("change", this._whenColorsChanged);
            this._okayButton.addEventListener("click", this._close);
            this._cancelButton.addEventListener("click", this._close);
            this._resetButton.addEventListener("click", this._reset);
        }
    }

    const { button: button$6, div: div$6, h2: h2$5, select: select$4, option: option$4, optgroup: optgroup$1 } = HTML;
    class ThemePrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._themeSelect = select$4({ style: "width: 100%;" }, optgroup$1({ label: "Default Themes" }, option$4({ value: "slarmoosbox" }, "Slarmoo's Box"), option$4({ value: "forest" }, "Forest"), option$4({ value: "canyon" }, "Canyon"), option$4({ value: "midnight" }, "Midnight"), option$4({ value: "beachcombing" }, "Beachcombing"), option$4({ value: "violet verdant" }, "Violet Verdant"), option$4({ value: "sunset" }, "Sunset"), option$4({ value: "autumn" }, "Autumn"), option$4({ value: "fruit" }, "Shadowfruit"), option$4({ value: "toxic" }, "Toxic"), option$4({ value: "roe" }, "Roe"), option$4({ value: "moonlight" }, "Moonlight"), option$4({ value: "portal" }, "Portal"), option$4({ value: "fusion" }, "Fusion"), option$4({ value: "inverse" }, "Inverse"), option$4({ value: "nebula" }, "Nebula"), option$4({ value: "roe light" }, "Roe Light"), option$4({ value: "amoled dark" }, "High Contrast Dark"), option$4({ value: "energized" }, "Energized"), option$4({ value: "neapolitan" }, "Neapolitan"), option$4({ value: "poly" }, "Poly"), option$4({ value: "blutonium" }, "Blutonium"), option$4({ value: "greyscale" }, "Greyscale"), option$4({ value: "slushie" }, "Slushie")),  optgroup$1({ label: "Mod Themes" }, option$4({ value: "dark classic" }, "BeepBox Dark"), option$4({ value: "light classic" }, "BeepBox Light"), option$4({ value: "dark competition" }, "BeepBox Competition Dark"), option$4({ value: "jummbox classic" }, "JummBox Dark"), option$4({ value: "modbox classic" }, "Modbox"), option$4({ value: "sandbox classic" }, "Sandbox"), option$4({ value: "harrybox" }, "Haileybox"), option$4({ value: "brucebox" }, "Brucebox"), option$4({ value: "shitbox 3.0" }, "Shitbox 1.0/3.0"), option$4({ value: "shitbox 2.0" }, "Shitbox 2.0"), option$4({ value: "nerdbox" }, "NerdBox"), option$4({ value: "zefbox" }, "Zefbox"), option$4({ value: "cardboardbox classic" }, "Cardboardbox"), option$4({ value: "blubox classic" }, "Blubox"), option$4({ value: "dogebox classic" }, "Dogebox"), option$4({ value: "wackybox" }, "Wackybox"), option$4({ value: "todbox dark mode" }, "Todbox Dark Mode"), option$4({ value: "mainbox 1.0" }, "Mainbox"), option$4({ value: "microbox" }, "MicroBox"), option$4({ value: "paandorasbox" }, "PaandorasBox"), option$4({ value: "foxbox" }, "FoxBox"), option$4({ value: "midbox" }, "Midbox"), option$4({ value: "dogebox2" }, "Dogebox2"), option$4({ value: "abyssbox classic" }, "AbyssBox Classic"), option$4({ value: "abyssbox light" }, "AbyssBox Light"), option$4({ value: "nepbox" }, "Nepbox"), option$4({ value: "ultrabox dark" }, "UltraBox"), option$5({value:"jummbox light"},"Jumm Box Light"), option$5({value:"dogebox dark"},"Dogebox Dark"), option$5({value:"fogbox"},"FogBox"),  option$4({ value: "voxonium" }, "Voxonium"), option$4({ value: "axobox" }, "AxoBox"), option$4({ value: "lemmbox dark" }, "LemmBox")), optgroup$1({ label: "Misc" }, option$4({ value: "azur lane" }, "Azur Lane"), option$4({ value: "custom" }, "Custom")) ,
            optgroup$1({label:"AbyssBox Themes"},
            	option$5({value:"2012 Video Tutorial"},"2012 Video Tutorial"),
            	option$5({value:"Scratch"},"Scratch"),
            	option$5({value:"Deuteranopia"},"Deuteranopia"),
            	option$5({value:"Tritanopia"},"Tritanopia"),
            	option$5({value:"Protanopia"},"Protanopia"),
            	option$5({value:"Windows Xp"},"Windows XP"),
            	option$5({value:"Terminal 2.0 (AB)"},"Terminal 2.0 (AB)"),
            	option$5({value:"corporate light"},"Corporate Light"),
            	option$5({value:"corporate dark"},"Corporate Dark"),
            	option$5({value:"Skeuomorphic"},"Skeuomorphic"),
            	option$5({value:"woodland"},"Woodland"),
            	option$5({value:"Frutiger Aero"},"Frutiger Aero"),
            	option$5({value:"Frutiger Aero Night"},"Frutiger Aero Night"),
            	option$5({value:"Half-Life"},"Half Life"),
            	option$5({value:"Undertale"},"Undertale"),
            	option$5({value:"Doom 1993"},"Doom"),
            	
            ),
            optgroup$1({label:"Studio Themes"}, 
option$5({ value: "canyon" }, "Canyon"), option$5({ value: "midnight" }, "Midnight"), option({ value: "beachcombing" }, "Beachcombing"),
 	option$5({ value: "funky" }, "Funky"),
 	option$5({ value: "funkylight" }, "Funky Light"),
 	option$5({ value: "githubdark" }, "Github Dark"),
 	option$5({ value: "mirage" }, "Mirage"),
 	option$5({ value: "Mirage" }, "Mirage2"),
 	option$5({ value: "Citrus" }, "Citrus"),
 	option$5({ value: "dark-monoKai" }, "MonoKai"),
 	option$5({ value: "dark-dracula" }, "Dracula"), 
 	option$5({ value: "neon" }, "Neon"),
 	option$5({ value: "greenish" }, "Greenish Dark"),
 	option$5({ value: "yellowed" }, "Yellow Light"),
 	option$5({ value: "coolblue" }, "Cool Blue"),
 	option$5({ value: "WinterIsComing" }, "WinterIsComing"),
 	option$5({ value: "grayscale" }, "GrayScale"),
 	option$5({ value: "VintageSepia" }, "Sepia"),
 	option$5({ value: "TimeForVacation" }, "TimeForVacation Light"),
 	option$5({ value: "coollime" }, "Cool Lime"),
 	option$5({ value: "coolred" }, "Cool Red"),
 	option$5({ value: "matrix" }, "Matrix"),
 	option$5({ value: "typebox" }, "Typebox"),
 	option$5({ value: "Synthwave" }, "Synthwave"),
 	option({ value: "ToxicGlow" }, "Toxic Glow"),
 	option$5({ value: "Inferno" }, "Inferno"),
 	option$5({ value: "Halloween" }, "Halloween"),
 	option$5({ value: "Paper" }, "Paper"),
 	option$5({ value: "Void" }, "Void"),
 	option$5({ value: "DreamyPink" }, "DreamyPink"),
 	option$5({ value: "Rock" }, "Rock"),
 	option({ value: "CyberPunk" }, "CyberPunk"),
 	option$5({ value: "FioletPower" }, "Fiolet"),
 	option({ value: "copperblue" }, "CopperBlue"),
 	option({ value: "copper" }, "CopperColor"),
 	option({ value: "slushie" }, "Slushie"),
 	option({ value: "TheOrange" }, "The Orange"),
 	option({ value: "Dirty" }, "Dirty"),
 	option({ value: "Moai" }, "Moai"),
 	option({ value: "Edit" }, "Edit"),
 	option({ value: "Steel" }, "Steel"),
 	option({ value: "Texture" }, "Texture"),
	option$5({ value: "FruityBox Nano" }, "Nano"),
	option$5({ value: "FruityBox Contrast" }, "Contrast"),
	option$5({ value: "FruityBox Standard" }, "Standard"),
	option$5({ value: "FruityBox Standard Blue" }, "Standard Blue"),
	option$5({ value: "FruityBox" }, "Classic"),
	option$5({ value: "FruityBox Dark" }, "Contrast Classic"),
	option$5({ value: "FruityBoxLight" }, "Classic Light"),
),optgroup$1({ label: "Rest" }, ) ); 
const existingThemeValues = new Set(
		Array.from(this._themeSelect.options).map(opt => opt.value)
	); 
	const newOptions = Object.keys(ColorConfig.themes)
		.filter(key => !existingThemeValues.has(key) && key!=='')
		.map(key => option$5({ value: key }, ColorConfig.themes[key].name || key));
	this._themeSelect.append(...newOptions);

            
            this._cancelButton = button$6({ class: "cancelButton" });
            this._okayButton = button$6({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$6({ class: "prompt noSelection", style: "width: 220px;" }, h2$5("Set Theme"), div$6({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$6({ class: "selectContainer", style: "width: 100%;" }, this._themeSelect)), div$6({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this.lastTheme = window.localStorage.getItem("colorTheme");
            this._themeSelect.value = this.lastTheme||ColorConfig.defaultTheme;

            this._close = () => {
                if (this.lastTheme != null) {
                    ColorConfig.setTheme(this.lastTheme);
                }
                else {
                    ColorConfig.setTheme(ColorConfig.defaultTheme);
                }
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("colorTheme", this._themeSelect.value);
                this._doc.prompt = null;
                this._doc.prefs.colorTheme = this._themeSelect.value;
                this._doc.undo();
            };
            this._previewTheme = () => {
                ColorConfig.setTheme(this._themeSelect.value);
                this._doc.notifier.changed();
            };
            if (this.lastTheme != null) {
                this._themeSelect.value = this.lastTheme;
            }
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._themeSelect.addEventListener("change", this._previewTheme);
        }
    }

    const { button: button$5, div: div$5, p, h2: h2$4, h3 } = HTML;
    class TipPrompt {
        constructor(_doc, type) {
            this._doc = _doc;
            this._closeButton = button$5({ class: "cancelButton" });
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._closeButton.removeEventListener("click", this._close);
            };
            let message;
            switch (type) {
                case "scale":
                    {
                        message = div$5(h2$4("Scale"), p("This setting limits the available pitches for adding notes. You may think that there's no point in limiting your choices, but the set of pitches you use has a strong influence on the mood and feel of your song, and these scales serve as guides to help you choose appropriate pitches. Don't worry, you can change the scale at any time, so you're not locked into it. Try making little melodies using all the available pitches of a scale to get a sense for how it sounds."), p("The most common scales are major and minor. Assuming your song uses all pitches in the scale and especially \"tonic\" pitches (the purple rows in the pattern editor) then major scales tend to sound more playful or optimistic, whereas minor scales sound more serious or sad."));
                    }
                    break;
                case "key":
                    {
                        message = div$5(h2$4("Song Key"), p("This setting can shift the frequency of every note in your entire song up or down, keeping the \"tonic\" pitches (the brown rows in the pattern editor) aligned with the selected \"key\" pitch."), p("If you've already placed some notes but they don't emphasize \"tonic\" pitches then the selected key isn't very meaningful. You can select the \"Detect Key\" option in the key menu to automatically align the most emphasized notes with \"tonic\" pitches."));
                    }
                    break;
                case "key_octave":
                    {
                        message = div$5(h2$4("Octave"), p("This setting can shift the \"key\" by an octave, allowing you to use a B- or C+ key."), p(`This goes from ${Config.octaveMin} to ${Config.octaveMax}.`));
                    }
                    break;
                case "tempo":
                    {
                        message = div$5(h2$4("Song Tempo"), p("This setting controls the speed of your song, measured in beats-per-minute. A \"beat\" is the duration of the little gray rectangles in the pattern editor. (In conventional music notation, a \"quarter note\" is usually equivalent to \"beat\".)"));
                    }
                    break;
                case "reverb":
                    {
                        message = div$5(h2$4("Reverb"), p("Reverb is like a continuous echo effect. A little bit helps instruments sound more natural. Adding a lot of reverb can add sense of depth or mystery, but too much reverb can kinda \"smear\" sounds so that it's harder to distinguish notes or instruments, especially for lower \"bass\" notes."));
                    }
                    break;
                case "rhythm":
                    {
                        message = div$5(h2$4("Rhythm"), p("This setting determines how beats are divided. The pattern editor helps you align notes to fractions of a beat based on this setting."), p("If you've already placed some notes but they don't align with the selected rhythm, you can select the \"Snap Notes To Rhythm\" option in the rhythm menu to force the notes in the currently selected pattern(s) to align with the selected rhythm."));
                    }
                    break;
                case "instrumentIndex":
                    {
                        message = div$5(h2$4("Instrument Number"), p("In the \"Channel Settings\" option from Slarmoo's Box's \"Edit\" menu, there are a few ways to enable multiple instruments per channel."), p("First, you could enable multiple simultaneous instruments per channel. All of the channel's instruments will play all of the notes in the channel at the same time, and you can click an instrument number to view and edit its settings."), p("Second, you could enable different instruments per pattern. Only one of the instruments will play at any given time, but you can click the instrument number to change which instrument is used for the currently selected pattern(s)."), p("Finally, you can enable them both, in which case you can click an instrument number once to view it, and again to toggle whether the instrument is used for the currently selected pattern(s)."), p("Either way, you can click the + button to add more instruments to a channel, and you can press shift and a number key on your keyboard to select an instrument as if you had clicked the corresponding button here."));
                    }
                    break;
                case "instrumentVolume":
                    {
                        message = div$5(h2$4("Instrument Volume"), p("This setting controls the volume of the selected instrument without affecting the volume of the other instruments. This allows you to balance the loudness of each instrument relative to each other."), p("Please be careful when using volume settings above 0. This indicates amplification and too much of that can trip the audio limiter built into this tool. This can lead to your song sounding muffled if overused. But when used carefully, amplification can be a powerful tool!"));
                    }
                    break;
                case "pan":
                    {
                        message = div$5(h2$4("Instrument Panning"), p("If you're listening through headphones or some other stereo sound system, this controls the position of the instrument and where the sound is coming from, ranging from left to right."), p("As a suggestion, composers often put lead melodies, drums, and basses in the center, and spread other instruments toward either side. If too many instruments seem like they're coming from the same place, it can feel crowded and harder to distinguish individual sounds, especially if they cover a similar pitch range."));
                    }
                    break;
                case "panDelay":
                    {
                        message = div$5(h2$4("Stereo Delay"), p("When panning, a slight delay is often added between the left and right ear to help make a sound feel more 'directional'. For example, in the real world your left ear will hear a sound coming from the left just slightly before the right ear."), p("This setting controls how much delay is added. When this is set to minimum, panning only affects the volume of the left/right ear without changing the delay. This can help to get a more 'uniform' feeling sound, which can be desirable for making 8-bit music."));
                    }
                    break;
                case "arpeggioSpeed":
                    {
                        message = div$5(h2$4("Arpeggio Speed"), p("This setting affects how fast your chord will 'arpeggiate', or cycle between notes. With a fast arpeggio speed it will sound rapid-fire, with a slow speed you can hear each note one after another."));
                    }
                    break;
                case "twoNoteArpeggio":
                    {
                        message = div$5(h2$4("Faster Two-Note Arpeggio"), p("This setting makes arpeggios with only two notes in them happen twice as fast. Arpeggios with more notes in them are unaffected."));
                    }
                    break;
                case "monophonic":
                    {
                        message = div$5(h2$4("Monophonic Note"), p(`This setting controls which note of the chord your instrument will play. `));
                    }
                    break;
                case "detune":
                    {
                        message = div$5(h2$4("Detune"), p("This setting can be used to finely control the pitch of your instrument. It is in units of 'cents', 100 of which equal a pitch shift of one semitone."), p("Careful - you can quickly get very dissonant sounding songs by using this setting."));
                    }
                    break;
                case "instrumentType":
                    {
                        message = div$5(h2$4("Instrument Type"), p("Slarmoo's Box comes with many instrument presets, try them out! You can also create your own custom instruments!"), p("There are also options for generating random instruments towards the top of the instrument type menu and for copying and pasting instrument settings in preferences."));
                    }
                    break;
                case "eqFilter":
                    {
                        message = div$5(h2$4("EQ Filter"), p("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), p("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), p("Insert a new point on the left side of the filter editor to add a \"high-pass\" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a \"low-pass\" filter point which reduces the volume of higher frequencies."), p("You can also enable a \"Note Filter\" as an effect. EQ and note filters are mostly the same, but have different purposes. EQ filters are for overall adjustments, whereas note filters are for dynamic control and can be moved with envelopes. Note filters also change how the distortion effect sounds."));
                    }
                    break;
                case "noteFilter":
                    {
                        message = div$5(h2$4("Note Filter"), p("Note filters are mostly the same as EQ filters, but have a different purpose. EQ filters are for overall adjustments, whereas note filters are for dynamic control and can be moved with envelopes. Note filters also change how the distortion effect sounds."), p("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), p("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), p("Insert a new point on the left side of the filter editor to add a \"high-pass\" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a \"low-pass\" filter point which reduces the volume of higher frequencies."));
                    }
                    break;
                case "fadeInOut":
                    {
                        message = div$5(h2$4("Fade In/Out"), p("This setting controls how long it takes for notes to reach full volume at the beginning or decay to silence at the end."), p("An instant fade-in sounds like instruments that are played by hitting or plucking, whereas slower fade-ins sound like instruments that are played by blowing air."), p("You can also make the fade-out start before the note ends to leave a gap before the next note starts, or after the note ends to allow the sound of the end of the note to overlap with the start of the next note."));
                    }
                    break;
                case "transition":
                    {
                        message = div$5(h2$4("Transition"), p("Usually, when one note ends at the same time another begins, the old note will fade out and the new note will fade in based on the fade in/out settings, but this setting can override that, connecting the end of one note to the beginning of the next."), p("The \"interrupt\" transition makes the wave suddenly change from the old note's frequency to the new note's frequency without any fading, but still restarts envelopes at the beginning of the new note. The \"continue\" transition is similar but it doesn't even restart envelopes, and can be used to make each of the notes in a chord start or stop at different times!"), p("The \"slide\" transition makes the pitch shift quickly but not instantaneously from the old note's frequency to the new note's frequency, and softly restarts envelopes. The \"slide in pattern\" transition is the same except it doesn't connect the last note in a pattern to the first note in the next pattern."));
                    }
                    break;
                case "chipWave":
                    {
                        message = div$5(h2$4("Chip Wave"), p("Slarmoo's Box comes with some sound waves based on classic electronic sound chips, as well as several unique waves. This is the basic source of the sound of the instrument, which is modified by the other instrument settings."));
                    }
                    break;
                case "chipNoise":
                    {
                        message = div$5(h2$4("Noise"), p("Slarmoo's Box comes with several basic noise sounds. These do not have any distinct musical pitch, and can be used like drums to create beats and emphasize your song's rhythm."));
                    }
                    break;
                case "supersawDynamism":
                    {
                        message = div$5(h2$4("Supersaw Dynamism"), p("A supersaw is a combination of many sawtooth waves, and this setting controls the contribution of extra sawtooth waves."), p("At the low end of the slider, only the first wave is contributing to the sound, which sounds like an ordinary static sawtooth wave. At the maximum setting, all of the waves are contributing equally and the resulting tone can randomly shift depending on how the waves line up with each other, similar to the \"unison\" and \"chorus\" settings."));
                    }
                    break;
                case "supersawSpread":
                    {
                        message = div$5(h2$4("Supersaw Spread"), p("A supersaw is a combination of many sawtooth waves, and this setting controls the distance between their frequencies. The dynamism setting must be used for the extra waves to have any effect."), p("At the low end of the spread slider, all of the voices have the same frequency but random phase, resulting in a different sound every time a note starts. In the middle, the waves all have slightly different frequencies that shift in and out of phase over time similar to the \"unison\" and \"chorus\" settings, creating a classic supersaw sound. At the extreme end, the frequencies are so far apart they sound dissonant."));
                    }
                    break;
                case "supersawShape":
                    {
                        message = div$5(h2$4("Supersaw Shape"), p("This supersaw instrument includes an option to change the shape of the waves from sawtooth waves to pulse waves. Use this setting to morph between the two shapes."), p("When a pulse wave shape is used, you can also control the pulse width with a separate setting."));
                    }
                    break;
                case "pulseWidth":
                    {
                        message = div$5(h2$4("Pulse Wave Width"), p("This setting controls the shape and sound of a pulse wave. At the minimum width, it sounds light and buzzy. At the maximum width, it is shaped like a classic square wave."));
                    }
                    break;
                case "unison":
                    {
                        message = div$5(h2$4("Unison"), p("This instrument can play multiple identical waves at different frequencies. When two waves play at slightly different frequencies, they move in and out of phase with each other over time as different parts of the waves line up. This creates a dynamic, shifting sound. Pianos are a common example of this kind of sound, because each piano key strikes multiple strings that are tuned to slightly different frequencies."), p("The distance between two frequencies is called an \"interval\", and this setting controls how large it is. If the interval is too wide, then the waves may sound out-of-tune and \"dissonant\". However, if the interval is even larger, then the two frequencies can even be distinct pitches."), p("Adding more than two waves amplifies these effects. "));
                    }
                    break;
                case "chords":
                    {
                        message = div$5(h2$4("Chords"), p("When multiple different notes occur at the same time, this is called a chord. Chords can be created in Slarmoo's Box's pattern editor by adding notes above or below another note."), p("This setting determines how chords are played. The standard option is \"simultaneous\" which starts playing all of the pitches in a chord at the same instant. The \"strum\" option is similar, but plays the notes starting at slightly different times. The \"arpeggio\" option is used in \"chiptune\" style music and plays a single tone that rapidly alternates between all of the pitches in the chord. The \"monophonic\" option allows you to have only one tone in a chord play at a time. "), p("Some Slarmoo's Box instruments have an option called \"custom interval\" which uses the chord notes to control the interval between the waves of a single tone. This can create strange sound effects when combined with FM modulators."));
                    }
                    break;
                case "vibrato":
                    {
                        message = div$5(h2$4("Vibrato"), p("This setting causes the frequency of a note to wobble slightly. Singers and violinists often use vibrato."));
                    }
                    break;
                case "vibratoDepth":
                    {
                        message = div$5(h2$4("Vibrato Depth"), p("This setting affects the depth of your instrument's vibrato, making the wobbling effect sound stronger or weaker."));
                    }
                    break;
                case "vibratoDelay":
                    {
                        message = div$5(h2$4("Vibrato Delay"), p("This setting changes when vibrato starts to kick in after a note is played. Vibrato is most common for long held notes and less common in short notes, so this can help you achieve that effect."));
                    }
                    break;
                case "vibratoSpeed":
                    {
                        message = div$5(h2$4("Vibrato Speed"), p("This setting determines how fast the vibrato's up-and-down wobble effect will happen for your instrument."));
                    }
                    break;
                case "vibratoType":
                    {
                        message = div$5(h2$4("Vibrato Type"), p("This determines the way vibrato causes your instrument's pitch to wobble. The normal type is smooth up and down, the shaky type is chaotic."));
                    }
                    break;
                case "algorithm":
                    {
                        message = div$5(h2$4("FM Algorithm"), p('FM Synthesis is a mysterious but powerful technique for crafting sounds, popularized by Yamaha keyboards and the Sega Genesis/Mega Drive. It may seem confusing, but try playing around with the options until you get a feel for it, or check out some of the preset examples!'), p('This FM synthesizer uses up to four waves, numbered 1, 2, 3, and 4. Each wave may have its own frequency and volume.'), p('There are two kinds of waves: "carrier" waves play a tone out loud, but "modulator" waves distort other waves instead. Wave 1 is always a carrier and plays a tone, but other waves may distort it. The "Algorithm" setting determines which waves are modulators, and which other waves those modulators distort. For example, "12" means that wave 2 modulates wave 1, and wave 1 plays out loud.'));
                    }
                    break;
                case "feedbackType":
                    {
                        message = div$5(h2$4("Feedback Type"), p('Modulators distort in one direction (like 12), but you can also use the feedback setting to make any wave distort in the opposite direction (12), or even itself (1).'));
                    }
                    break;
                case "feedbackVolume":
                    {
                        message = div$5(h2$4("Feedback Distortion"), p("This setting controls the amount of feedback distortion based on the feedback type setting."));
                    }
                    break;
                case "operatorFrequency":
                    {
                        message = div$5(h2$4("Operator Frequency"), p('This setting controls the frequency of an individual FM wave, relative to the fundamental frequency of the note. The multiplier 1 is the same as the fundamental frequency, whereas 2x would be an octave (12 semitones) above it. The frequencies with a "~" are slightly detuned and shift in and out of phase over time compared to the other frequencies.'), p('Try different combinations of a "carrier" wave and a "modulator" wave with different frequencies to get a feel for how they sound together.'));
                    }
                    break;
                case "operatorVolume":
                    {
                        message = div$5(h2$4("Operator Volume"), p("This setting controls the volume of \"carrier\" waves, or the amount of distortion that \"modulator\" waves apply to other waves."));
                    }
                    break;
                case "spectrum":
                    {
                        message = div$5(h2$4("Spectrum"), p("This setting allows you to draw your own noise spectrum! This is good for making drum sounds."), p("If you only use certain frequencies and a soft fade in/out, it's also possible to make howling wind sounds or even musical wind instruments."), p("The left side of the spectrum editor controls the noise energy at lower frequencies, and the right side controls higher frequencies."));
                    }
                    break;
                case "harmonics":
                    {
                        message = div$5(h2$4("Harmonics"), p("This setting allows you to design your own sound wave! Most musical waves are actually a combination of sine waves at certain frequencies, and this lets you control the volume of each sine wave individually."), p("The left side of the harmonics editor controls the sine wave volumes at lower frequencies, and the right side controls higher frequencies."));
                    }
                    break;
                case "effects":
                    {
                        message = div$5(h2$4("Effects"), p("Slarmoo's Box has many different kinds of special effects you can add to instruments. You can turn on multiple effects at once, and they can be configured individually. Try them all out!"));
                    }
                    break;
                case "drumsetEnvelope":
                    {
                        message = div$5(h2$4("Drumset Envelope"), p("This drumset comes with a low-pass filter, and this setting can dynamically change the low-pass filter frequency over time. Each row in the pattern editor can have a different envelope shape."));
                    }
                    break;
                case "drumsetSpectrum":
                    {
                        message = div$5(h2$4("Drumset Spectrum"), p("This setting allows you to draw your own noise spectrum! This is good for making drumsets. Each row in the pattern editor gets its own spectrum."), p("The left side of the spectrum editor controls the noise energy at lower frequencies, and the right side controls higher frequencies."));
                    }
                    break;
                case "chorus":
                    {
                        message = div$5(h2$4("Chorus"), p("The chorus effect combines multiple copies of the instrument's sound and adds a bit of vibrato to simulate an ensemble of instruments or voices. Drag the slider to control how much chorus is added."));
                    }
                    break;
                case "echoSustain":
                    {
                        message = div$5(h2$4("Echo Volume"), p("The echo effect repeats the instrument's sound after a delay. Each echo is a little bit quieter than the last, and this setting controls how much quieter."));
                    }
                    break;
                case "echoDelay":
                    {
                        message = div$5(h2$4("Echo Delay"), p("The echo effect repeats the instrument's sound after a delay, and this setting controls how long the delay is."));
                    }
                    break;
                case "pitchShift":
                    {
                        message = div$5(h2$4("Pitch Shift"), p("This setting makes instruments play higher or lower pitches than the ones displayed in the pattern editor. Be careful that you don't confuse yourself!"), p("You can combine this with envelopes to bend pitch over time, or play multiple simultaneous instruments with different pitch shifts for interesting layered sounds."), p("The intervals created by this setting are in \"just intonation\" which means they stay in phase with the original pitch instead of shifting in and out of phase over time. If you want the shifting, add the detune effect!"));
                    }
                    break;
                    case "octaveShift":
                    {
                        message = div$5(h2$4("Octave Shift"), p("This setting makes instruments play higher or lower pitches than the ones displayed in the pattern editor. Be careful that you don't confuse yourself!"), p("You can combine this with envelopes to bend pitch over time, or play multiple simultaneous instruments with different pitch shifts for interesting layered sounds."), p("The intervals created by this setting are in \"just intonation\" which means they stay in phase with the original pitch instead of shifting in and out of phase over time. If you want the shifting, add the detune effect!"));
                    }
                    break;
                    case "functionHD":
                    {
                        message = div$5(h2$4("Head Of The Function"), p("This setting creates inputs and adjustable in mod sliders"), p("Paste your sliders etc example 'I1'(min,max,step),'I2'([1,2,'A') etc etc "), p("ITS USELESS WITHOUT FN ALGORITHM"));
                    }
                    break;
                    case "functionFN":
                    {
                        message = div$5(h2$4("Function Algorithm"), p("This setting makes instruments wave different by the algorithm you use"), p("In FN tag paste your algorithm. For example this is the example formula 'p.v * safe(b[p.i+2]) / 1' p.v is value p.i is index safe is safe function so you don't get undefined and error "), p("ITS MORE AUTOMATED IF YOU USE HEAD"));
                    }
                    break;
                case "distortion":
                    {
                        message = div$5(h2$4("Distortion"), p("This is the famous electric guitar effect! However, there are some things to be aware of."), p("First, most chords don't sound right when combined with heavy distortion. The only chords commonly used with distorted electric guitars are \"power chords\" which consist of a root note, a \"fifth\" note above that, and/or any octaves of those two notes."), p("Second, the distortion sound depends a lot on filtering. In particular, I recommend enabling the note filter effect, and adding both high-pass and low-pass points to the note filter. (Note filters are applied first, then distortion which transforms the sound based on that filtering, then the EQ filter is applied last.)"), p("Finally, I recommend adjusting the fade-out setting to allow the end of each note to overlap a little bit with the beginning of the next, but not too much!"));
                    }
                    break;
                case "bitcrusherQuantization":
                    {
                        message = div$5(h2$4("Bitcrusher Quantization"), p("This effect makes stuff sounds harsher, artificial, and \"low quality\", which is great if that's what you're going for!"));
                    }
                    break;
                case "bitcrusherFreq":
                    {
                        message = div$5(h2$4("Frequency Quantization"), p("The bitcrusher effect comes with an additional frequency quantization effect! This is a fun one to play with, especially when combined with the note filter effect."), p("Every other notch on this slider is aligned with the currently selected key of the song, and the in-between notches are aligned with the tritones of the key."));
                    }
                    break;
                case "envelopes":
                    {
                        message = div$5(h2$4("Envelopes"), p("Envelopes are a way to dynamically adjust various other settings over time, usually based on how long the note lasts. Press the + button to add an envelope, then use the menus below to select which setting to control and the curve of the envelope. Try different combinations to see how they sound!"), p("Most envelope curves restart from the beginning every time a new note plays. The \"note size\" option is based on the note width as drawn in the pattern editor while the \"pitch\" option is based on the pitch of the note played. The \"random\" envelope type deterministically produces a random result based on either the time or pitch of a note."), p("Envelope curves move in the range from 0 to 1 (or vice versa), where 0 means as quiet as possible and 1 is the same as the corresponding position selected in the instrument settings above. If multiple envelopes are targetting the same setting, they are multiplied before applying to the setting."));
                    }
                    break;
                case "discreteEnvelope":
                    {
                        message = div$5(h2$4("Use Discrete Envelopes?"), p("Envelopes are usually interpolated, meaning they change continuously and smoothly. This setting, when ticked, makes envelopes not interpolate. It's a small difference, but can be helpful for some chip noises, and it's most noticeable with the 'blip' transitions."));
                    }
                    break;
                case "envelopeSpeed":
                    {
                        message = div$5(h2$4("Envelope Speed"), p("This setting controls the speed of ALL envelopes for the instrument. Each envelope 'plays' at a certain speed, and this slider can scale it to play faster or slower. You can use this to fine-tune your tremolo or how fast something decays to get just the right effect."), p("Note that, while this setting is limited in the sense that it controls all envelopes at once, you can still achieve a variety of outcomes by trying combinations of modes of each envelope type, which typically differ only in speed."));
                    }
                    break;
                case "perEnvelopeSpeed":
                    {
                        message = div$5(h2$4("Individual Envelope Speed"), p("This setting is applied per envelope rather than all of them simultaneously, unlike the envelope speed in the top dropdown."), p("This controls the speed of this envelope as a multiplier of the global envelope speed and the envelope curve"), p("The speed of an envelope changes how fast its runs. In BeepBox, this is equivalent to the numbers beside each envelope type's name."), p("You can see an equivalence chart on the ", HTML.a({ href: "./faq.html", target: "_blank" }, "FAQ"), " page"), p("This setting will not appear for note size, pitch, punch, or none envelopes"));
                    }
                    break;
                case "usedInstrument":
                    {
                        message = div$5(h3("'Is this instrument used somewhere else?'"), p("This indicator will light up when the instrument you're currently looking at is used in another place in your song (outside the selection)."), p("This can be useful when you're not sure if you've used the instrument before and making edits carelessly could change other parts of the song."));
                    }
                    break;
                case "usedPattern":
                    {
                        message = div$5(h3("'Is this pattern used somewhere else?'"), p("This indicator will light up when the pattern you're currently looking at is used in another place in your song (outside the selection)."), p("This can be useful when you're not sure if you've used the pattern before and making edits carelessly could change other parts of the song."));
                    }
                    break;
                case "modChannel":
                    {
                        message = div$5(h2$4("Modulator Channel"), p("Modulators can be used to change settings in your song automatically over time. This technique is also known as automation."), p("This setting controls which channel the modulators will take effect for. If you choose 'Song', you can change song-wide settings too!"));
                    }
                    break;
                case "modInstrument":
                    {
                        message = div$5(h2$4("Modulator Instrument"), p("Modulators can be used to change settings in your song automatically over time. This technique is also known as automation."), p("This setting controls which instrument your modulator will apply to within the given channel you've chosen."), p("If you choose 'all', every instrument in the channel will be affected. If you choose 'active', just the current ones used in this pattern will be instead."), p("Note that with 'all' or 'active', effects will only be applied to instruments that the effect is applicable on. For example if an instrument does not have panning effects, modulating panning will not affect it."));
                    }
                    break;
                case "modSet":
                    {
                        message = div$5(h2$4("Modulator Setting"), p("This is the parameter that you want to change with this modulator. For example, if you set this to 'Tempo', you can speed up or slow down your song by laying notes in the pattern editor."), p("Note that you'll see different options if your channel is set to 'Song' versus a channel number. With 'Song', you'll see song-wide settings such as tempo. With a channel, you'll see specific instrument settings. Adding more effects to the instrument causes modulators for them to be available, so be sure to experiment!"), p("Most modulators behave as you'd expect and work just as if you were moving their associated slider. Click the '?' when you have a setting selected to get more info about it!"));
                    }
                    break;
                case "modFilter":
                    {
                        message = div$5(h2$4("Filter Target"), p("This setting specifies which parameter of your targeted filter you would like to change."), p("With the 'morph' setting, the note value for your modulator represents the number of a subfilter to 'morph' into over time. For example, dragging a note from 0 to 7 will morph from your main filter to the 7th subfilter. To change how your subfilters are set up, click the '+' button on the target filter."), p("With a Dot setting, you can fine-tune the exact location of every dot on your filter graph. Note that this is extremely intensive if you want to modulate all dots - a morph is better in that case - but this can come in handy for small adjustments."));
                    }
                    break;
                case "transitionBar":
                    {
                        message = div$5(h2$4("Tie Notes Over Bars"), p("With this option ticked, notes won't transition across bars if you put notes with the same pitches at the start of the next bar. Instead they will 'tie over' and sound like one long note."));
                    }
                    break;
                case "clicklessTransition":
                    {
                        message = div$5(h2$4("Clickless Transition"), p("Sometimes, seamless and other transition types can make audible 'clicks' when changing between notes. Ticking this option will cause those clicks to be silenced as much as possible."));
                    }
                    break;
                case "aliases":
                    {
                        message = div$5(h2$4("Aliasing"), p("Slarmoo's Box applies a technique called 'anti-aliasing' to instruments normally to help them sound cleaner even at high frequencies and low sample rates."), p("When this setting is ticked that technique is disabled, so you may hear strange audio artifacts especially at high pitches and when bending notes. However, this can lend a grungy sound to an instrument that could be desirable."));
                    }
                    break;
                case "operatorWaveform":
                    {
                        message = div$5(h2$4("Operator Waveform"), p('This setting controls the what kind of sound wave an individual FM wave uses.'), p('By defualt the FM synth uses sinewaves.'));
                    }
                    break;
                case "filterType":
                    {
                        message = div$5(h2$4("Filter Type"), p('Toggling these buttons lets you choose between a simple filter interface with two sliders, or the more advanced filter graph.'), p('The two-slider version controls a single low-pass filter and was used in legacy versions. It is not as powerful, but if you feel overwhelmed you can start with this.'), p('Note that switching from the simple interface to the advanced interface will convert your current settings, so you can also use it as a basis for later tweaking.'));
                    }
                    break;
                case "filterCutoff":
                    {
                        message = div$5(h2$4("Low-Pass Filter Cutoff Frequency"), p("The lowest setting feels \"muffled\" or \"dark\", and the highest setting feels \"harsh\" or \"bright\"."), p("Most sounds include a range of frequencies from low to high. Slarmoo's Box instruments have a filter that allows the lowest frequencies to pass through at full volume, but can reduce the volume of the higher frequencies that are above a cutoff frequency. This setting controls the cutoff frequency and thus the range of higher frequencies that are reduced."), p("This cutoff setting also determines which frequency resonates when the resonance peak setting is used."));
                    }
                    break;
                case "filterResonance":
                    {
                        message = div$5(h2$4("Low-Pass Filter Resonance Peak"), p("Increasing this setting emphasizes a narrow range of frequencies, based on the position of the filter cutoff setting. This can be used to imitate the resonant bodies of acoustic instruments and other interesting effects."), p("The filter preserves the volume of frequencies that are below the cutoff frequency, and reduces the volume of frequencies that are above the cutoff. If this setting is used, the filter also increases the volume of frequencies that are near the cutoff."));
                    }
                    break;
                case "loopControls":
                    {
                        message = div$5(h2$4("Loop Controls"), p("This enables the use of parameters that control how a chip wave should repeat."));
                    }
                    break;
                case "loopMode":
                    {
                        message = div$5(h2$4("Loop Mode"), p("This sets the way the chip wave loops when its ends are reached."), p("The \"Loop\" mode is the default: when the end of the loop is reached, it will jump back to the starting point of the loop."), p("The \"Ping-Pong\" mode starts playing the chip wave backwards when the end of the loop is reached. Once it reaches the start of the loop, it will start playing forwards again, endlessly going back and forth."), p("The \"Play Once\" mode stops the chip wave once the end is reached (or the start of the loop, if it's playing backwards)."), p("The \"Play Loop Once\" mode stops the chip wave once the end of the loop is reached (or the start of the loop, if it's playing backwards)."));
                    }
                    break;
                case "loopStart":
                    {
                        message = div$5(h2$4("Loop Start Point"), p("This specifies where the loop region of the chip wave starts. It's measured in \"samples\", or rather, it refers to a point on a waveform."), p("Be careful with tiny loop sizes (especially combined with high pitches), they may re-introduce aliasing even if the \"Aliasing\" checkbox is unchecked."));
                    }
                    break;
                case "loopEnd":
                    {
                        message = div$5(h2$4("Loop End Point"), p("This specifies where the loop region of the chip wave ends. It's measured in \"samples\", or rather, it refers to a point on a waveform."), p("The button next to the input box sets this to end of the chip wave."), p("Be careful with tiny loop sizes (especially combined with high pitches), they may re-introduce aliasing even if the \"Aliasing\" checkbox is unchecked."));
                    }
                    break;
                case "offset":
                    {
                        message = div$5(h2$4("Offset"), p("This specifies where the chip wave should start playing from. You can use this to chop up a large sample, to say, turn a drum loop into a drum kit! It's measured in \"samples\", or rather, it refers to a point on a waveform."));
                    }
                    break;
                case "backwards":
                    {
                        message = div$5(h2$4("Backwards"), p("When set, the chip wave will start playing backwards. After checking this, you may want to adjust the offset to start from a different point that makes sense for this mode."));
                    }
                    break;
                case "decimalOffset":
                    {
                        message = div$5(h2$4("Decimal Offset"), p("The decimal offset is subtracted from the pulse width value, enabling the use of numbers such as 12.5 or 6.25. This could be useful if you're trying to recreate the sound of old soundchips."));
                    }
                    break;
                case "unisonVoices":
                    {
                        message = div$5(h2$4("Unison Voices"), p("This setting controls how many voices there are in a unison. Unisons such as \"none\" or \"detune\" use 1 voice, many other unisons use 2 voices, and some use up to " + Config.unisonVoicesMax + " voices"));
                    }
                    break;
                case "unisonSpread":
                    {
                        message = div$5(h2$4("Unison Spread"), p("This setting controls the distance between the voices, in semitones. A small amount of spread causes the voice's waves to shift in and out from each other, causing a shimmering effect. Larger spread will cause the voices to act like separate notes."));
                    }
                    break;
                case "unisonOffset":
                    {
                        message = div$5(h2$4("Unison Offset"), p("This setting controls the detune applied to ALL voices, in semitones."));
                    }
                    break;
                case "unisonExpression":
                    {
                        message = div$5(h2$4("Unison Volume"), p("This setting controls the unison volume. Use this if the unison makes your instrument too loud in comparison to other instruments."), p("If this is set to a negative value, it will invert the wave!"));
                    }
                    break;
                case "unisonSign":
                    {
                        message = div$5(h2$4("Unison Sign"), p("This setting is a volume multiplier applied to every voice EXCEPT the first. This setting will only work correctly with more than one voices."));
                    }
                    break;
                case "pitchRange":
                    {
                        message = div$5(h2$4("Pitch Envelope Start and End"), p("These two settings will adjust where the start and end of the pitch envelope affects. Everything below start envelope will be the value of the lower bound, everything above end envelope will be upper bound, and everything inbetween will scale linearly based on pitch (the opposite is true if inverted)."), p("This will NOT work properly if pitch start is greater than pitch end."), p("These values are different than the MIDI numbers. These correspond to how many paino keys from the bottom of the song player a specific pitch is"));
                    }
                    break;
                case "noteSizeRange":
                    {
                        message = div$5(h2$4("Note Size Envelope Start and End"), p("These two settings work vert similarly to the pitch range bounds, except for note size envelopes instead. Everything below start envelope will be the value of the lower bound, everything above end envelope will be upper bound, and everything inbetween will scale linearly based on note size (the opposite is true if inverted)."), p("This will NOT work properly if note size start is greater than note size end."));
                    }
                    break;
                case "envelopeInvert":
                    {
                        message = div$5(h2$4("Envelope Inversion"), p("This setting will invert the envelope curve. So instead of, for example, lower pitches leading to a smaller output, lower pitches can lead to a greater output."));
                    }
                    break;
                case "envelopeRange":
                    {
                        message = div$5(h2$4("Envelope Bounds"), p("These two settings stretch or shrink the envelope vertically, allowing for different ranges of affect."), p("This will NOT work properly if lower bound is greater than upper bound."));
                    }
                    break;
                case "modEnvelope":
                    {
                        message = div$5(h2$4("Envelope Target"), p("This setting specifies which envelope of the specified instrument you would like to change."));
                    }
                    break;
                case "randomSteps":
                    {
                        message = div$5(h2$4("Random Envelope Steps"), p("This setting changes how many \"steps\", or different possible values can be outputted. For example, a step size of 2 will output either 0 or 1, and a step size of 3 either 0, 0.5, or 1. Every step is equidistant from each other"));
                    }
                    break;
                case "randomSeed":
                    {
                        message = div$5(h2$4("Random Envelope Seed"), p("There are 64 seeds, or pseudorandom patterns that you can choose from when enveloping a setting."), p("The same seed will output the same value per tick or pitch if the other envelope settings are also the same, meaning that if two different songs use the same seed for their envelope they will have the same \"randomization\"."));
                    }
                    break;
                case "songeq":
                    {
                        message = div$5(h2$4("Song Eq Filter"), p("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), p("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), p("Insert a new point on the left side of the filter editor to add a \"high-pass\" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a \"low-pass\" filter point which reduces the volume of higher frequencies."), p("The Song Eq Filter applies to all instruments. This can be handy for getting the sound of a certain genre or fading in and out in combination with modulation"));
                    }
                    break;
                case "lfoEnvelopeWaveform":
                    {
                        message = div$5(h2$4("LFO Envelope Waveform"), p("LFO envelopes can output a variety of different waveforms, from old tremolo's sine to more complex ones."), p("These waves are: sines, squares, triangles, sawtooths, trapezoids, and stepped variants of triangles and sawtooths."));
                    }
                    break;
                case "randomEnvelopeType":
                    {
                        message = div$5(h2$4("Random Envelope Type"), p("Random Envelopes can switch between being determined by the time in the song, the pitch of the note, or per note trigger."));
                    }
                    break;
                case "ringMod":
                    {
                        message = div$5(h2$4("Ring Modulation"), p(`This setting multiplies a selected wave's frequency with an instrument frequency, this is useful for "bell-like" instruments.`));
                    }
                    break;
                case "RingModHz":
                    {
                        message = div$5(h2$4("Ring Modulation (Hertz)"), p(`This setting changes the Hertz of the multiplied frequency.`));
                    }
                    break;
                case "phaserMix":
                    {
                        message = div$9(h2$7("Phaser Mix"), p$1(`This setting adds holes (aka notches) or peaks in the frequency spectrum to the waveform its given. The placement of these peaks and notches in the waveform can be changed by using envelopes and/or modulators.`));
                    }
                    break;
                case "phaserFreq":
                    {
                        message = div$9(h2$7("Phaser Frequency"), p$1(`This setting controls the frequency of the the peaks and notches of the phaser.`));
                    }
                    break;
                case "phaserFeedback":
                    {
                        message = div$9(h2$7("Phaser Feedback"), p$1(`This setting effects how pronounced the Feedback of the Phaser is, this is done by adding the Feedback of the Phaser back into itself.`));
                    }
                    break;
                case "phaserStages":
                    {
                        message = div$9(h2$7("Phaser Stages"), p$1(`This slider changes how many all-passes there are in the phaser. An all-pass is created by splitting an audio signal into paths, every path after the first one that is created is called an all-pass.`), p$1(`The minimum value of this slider is 1, the reason being that 1 all-pass is the exact same as having no phaser at all, if there were 0 all-passes then the audio would cease to exist.`));
                    }
                    break;
                case "ringModChipWave":
                    {
                        message = div$5(h2$4("Ring Mod Chip Wave"), p("This is the shape of the wave modulating your instrument's sound"),p("No matter how long sample you will put here it will be squeezed "));
                    }
                    break;
                case "granular":
                    {
                        message = div$5(h2$4("Granular Synthesis"), p(`This effect is based on granular synthesis! It takes random points from a wave and rearranges them to form "sonic clouds".`), p(`This particular slider controls the wet/dry mix of the granulation.`));
                    }
                    break;
                case "grainSize":
                    {
                        message = div$5(h2$4("Grain Size"), p(`This setting controls the size of the grain.`));
                    }
                    break;
                case "grainAmount":
                    {
                        message = div$5(h2$4("Grain Freq"), p(`This setting controls about how often a grain (a group of audio samples) is added to the output, from rarely to multiple at once.`));
                    }
                    break;
                case "grainRange":
                    {
                        message = div$5(h2$4("Grain Range"), p(`This setting controls the range of randomization for grain sizes. `));
                    }
                    break;
                default:
                    if (type.indexOf("modSetInfo") >= 0) {
                        let modNum = +type[type.length - 1];
                        let modulator = _doc.song.channels[_doc.channel].instruments[_doc.getCurrentInstrument()].modulators[modNum];
                        let pList = [];
                        for (let s = 0; s < Config.modulators[modulator].promptDesc.length; s++) {
                            pList.push(p(Config.modulators[modulator].promptDesc[s]
                                .replace("$LO", "" + Config.modulators[modulator].convertRealFactor)
                                .replace("$MID", "" + (Config.modulators[modulator].convertRealFactor + Config.modulators[modulator].maxRawVol / 2))
                                .replace("$HI", "" + (Config.modulators[modulator].convertRealFactor + Config.modulators[modulator].maxRawVol))));
                        }
                        pList[pList.length - 1].style.setProperty("color", "var(--secondary-text)");
                        message = div$5(h2$4(Config.modulators[modulator].promptName), pList);
                        break;
                    }
                    else {
                        throw new Error("Unhandled TipPrompt type: " + type);
                    }
            }
            this.container = div$5({ class: "prompt", style: "width: 300px;" }, message, this._closeButton);
            setTimeout(() => this._closeButton.focus());
            this._closeButton.addEventListener("click", this._close);
        }
    }

    class TrackEditor {
        constructor(_doc, _songEditor) {
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._barDropDown = HTML.select({ style: "width: 32px; height: " + Config.barEditorHeight + "px; top: 0px; position: absolute; opacity: 0" }, HTML.option({ value: "barBefore" }, "Insert Bar Before"), HTML.option({ value: "barAfter" }, "Insert Bar After"), HTML.option({ value: "deleteBar" }, "Delete This Bar"));
            this._channelRowContainer = HTML.div({ style: `display: flex; flex-direction: column; padding-top: ${Config.barEditorHeight}px` });
            this._barNumberContainer = SVG.g();
            this._playhead = SVG.rect({ fill: ColorConfig.playhead, x: 0, y: 0, width: 3, height: 128 });
            this._boxHighlight = SVG.rect({ fill: "none", stroke: ColorConfig.hoverPreview, "stroke-width": 2, "pointer-events": "none", x: 1, y: 1, width: 30, height: 30 });
            this._upHighlight = SVG.path({ fill: ColorConfig.invertedText, stroke: ColorConfig.invertedText, "stroke-width": 1, "pointer-events": "none" });
            this._downHighlight = SVG.path({ fill: ColorConfig.invertedText, stroke: ColorConfig.invertedText, "stroke-width": 1, "pointer-events": "none" });
            this._barEditorPath = SVG.path({ fill: ColorConfig.uiWidgetBackground, stroke: ColorConfig.uiWidgetBackground, "stroke-width": 1, "pointer-events": "none" });
            this._selectionRect = SVG.rect({ class: "dashed-line dash-move", fill: ColorConfig.boxSelectionFill, stroke: ColorConfig.hoverPreview, "stroke-width": 2, "stroke-dasharray": "5, 3", "fill-opacity": "0.4", "pointer-events": "none", visibility: "hidden", x: 1, y: 1, width: 62, height: 62 });
            this._svg = SVG.svg({ style: `position: absolute; top: 0;` }, this._barEditorPath, this._selectionRect, this._barNumberContainer, this._boxHighlight, this._upHighlight, this._downHighlight, this._playhead);
            this._select = HTML.select({ class: "trackSelectBox", style: "background: none; border: none; appearance: none; border-radius: initial; box-shadow: none; color: transparent; position: absolute; touch-action: none;" });
            this.container = HTML.div({ class: "noSelection", style: `background-color: ${ColorConfig.editorBackground}; position: relative; overflow: hidden;` }, this._channelRowContainer, this._svg, this._select, this._barDropDown);
            this._channels = [];
            this._barNumbers = [];
            this._mouseX = 0;
            this._mouseY = 0;
            this._mouseStartBar = 0;
            this._mouseStartChannel = 0;
            this._mouseBar = 0;
            this._mouseChannel = 0;
            this._mouseOver = false;
            this._mousePressed = false;
            this._mouseDragging = false;
            this._barWidth = 32;
            this._renderedBarCount = -1;
            this._renderedEditorWidth = -1;
            this._renderedEditorHeight = -1;
            this._renderedPatternCount = 0;
            this._renderedPlayhead = -1;
            this._touchMode = isMobile;
            this._barDropDownBar = 0;
            this._lastScrollTime = 0;
            this._barDropDownGetOpenedPosition = (event) => {
                this._barDropDownBar = Math.floor(Math.min(this._doc.song.barCount - 1, Math.max(0, this._mouseX / this._barWidth)));
            };
            this._barDropDownHandler = (event) => {
                var moveBarOffset = (this._barDropDown.value == "barBefore") ? 0 : 1;
                if (this._barDropDown.value == "barBefore" || this._barDropDown.value == "barAfter") {
                    this._doc.bar = this._barDropDownBar - 1 + moveBarOffset;
                    this._doc.selection.resetBoxSelection();
                    this._doc.selection.insertBars();
                    if (this._doc.synth.playhead >= this._barDropDownBar + moveBarOffset) {
                        this._doc.synth.playhead++;
                        this._songEditor._barScrollBar.animatePlayhead();
                    }
                }
                else if (this._barDropDown.value == "deleteBar") {
                    this._doc.bar = this._barDropDownBar;
                    this._doc.selection.resetBoxSelection();
                    this._doc.selection.deleteBars();
                    if (this._doc.synth.playhead > this._barDropDownBar) {
                        this._doc.synth.playhead--;
                        this._songEditor._barScrollBar.animatePlayhead();
                    }
                }
                this._barDropDown.selectedIndex = -1;
            };
this._whenSelectOpen = () => {
	const addOption = this._select.querySelector('option[value="add"]');
	if(addOption) this._select.removeChild(addOption);

	const newAddOption = document.createElement("option");
	newAddOption.value = "add";
	newAddOption.textContent = "+ Add Pattern";
	this._select.appendChild(newAddOption);
};

this._whenSelectChanged = () => {
	const doc = editor.doc;
	const song = doc.song;
	const channel = doc.channel;

	if(this._select.value === "add"){
		const currentPatternCount = song.patternsPerChannel;
		doc.record(new ChangePatternsPerChannel(doc, currentPatternCount + 1));
		doc.selection.setPattern(currentPatternCount+1);
	}else{
		doc.selection.setPattern(this._select.selectedIndex);
	}
};

            this._animatePlayhead = (timestamp) => {
                const playhead = (this._barWidth * this._doc.synth.playhead - 2);
                if (this._renderedPlayhead != playhead) {
                    this._renderedPlayhead = playhead;
                    this._playhead.setAttribute("x", "" + playhead);
                }
                window.requestAnimationFrame(this._animatePlayhead);
            };
            this._whenSelectPressed = (event) => {
                this._mousePressed = true;
                this._mouseDragging = true;
                this._updateSelectPos(event);
                this._mouseStartBar = this._mouseBar;
                this._mouseStartChannel = this._mouseChannel;
            };
            this._whenSelectMoved = (event) => {
                this._updateSelectPos(event);
                if (this._mouseStartBar != this._mouseBar || this._mouseStartChannel != this._mouseChannel) {
                    event.preventDefault();
                }
                if (this._mousePressed)
                    this._dragBoxSelection();
                this._updatePreview();
            };
            this._whenSelectReleased = (event) => {
                this._mousePressed = false;
                this._mouseDragging = false;
                this._updatePreview();
            };
            this._whenMouseOver = (event) => {
                if (this._mouseOver)
                    return;
                this._mouseOver = true;
            };
            this._whenMouseOut = (event) => {
                if (!this._mouseOver)
                    return;
                this._mouseOver = false;
            };
            this._whenMousePressed = (event) => {
                event.preventDefault();
                this._mousePressed = true;
                this._updateMousePos(event);
                this._mouseStartBar = this._mouseBar;
                this._mouseStartChannel = this._mouseChannel;
                if (this._mouseY >= Config.barEditorHeight) {
                    if (event.shiftKey) {
                        this._mouseDragging = true;
                        this._doc.selection.setTrackSelection(this._doc.selection.boxSelectionX0, this._mouseBar, this._doc.selection.boxSelectionY0, this._mouseChannel);
                        this._doc.selection.selectionUpdated();
                    }
                    else {
                        this._mouseDragging = false;
                        if (this._doc.channel != this._mouseChannel || this._doc.bar != this._mouseBar) {
                            this._doc.selection.setChannelBar(this._mouseChannel, this._mouseBar);
                            this._mouseDragging = true;
                        }
                        this._doc.selection.resetBoxSelection();
                    }
                }
            };
            this._whenMouseMoved = (event) => {
                this._updateMousePos(event);
                if (this._mousePressed) {
                    if (this._mouseStartBar != this._mouseBar || this._mouseStartChannel != this._mouseChannel) {
                        this._mouseDragging = true;
                    }
                    this._dragBoxSelection();
                }
                this._updatePreview();
            };
            this._whenMouseReleased = (event) => {
                if (this._mousePressed && !this._mouseDragging) {
                    if (this._doc.channel == this._mouseChannel && this._doc.bar == this._mouseBar) {
                        const up = ((this._mouseY - Config.barEditorHeight) % ChannelRow.patternHeight) < ChannelRow.patternHeight / 2;
                        const patternCount = this._doc.song.patternsPerChannel;
                        this._doc.selection.setPattern((this._doc.song.channels[this._mouseChannel].bars[this._mouseBar] + (up ? 1 : patternCount)) % (patternCount + 1));
                    }
                }
                this._mousePressed = false;
                this._mouseDragging = false;
                this._updatePreview();
            };
            window.requestAnimationFrame(this._animatePlayhead);
            this._svg.addEventListener("mousedown", this._whenMousePressed);
            document.addEventListener("mousemove", this._whenMouseMoved);
            document.addEventListener("mouseup", this._whenMouseReleased);
            this._svg.addEventListener("mouseover", this._whenMouseOver);
            this._svg.addEventListener("mouseout", this._whenMouseOut);
            this._select.addEventListener("change", this._whenSelectChanged); 
            this._select.addEventListener("pointerdown", this._whenSelectOpen);
            this._select.addEventListener("touchstart", this._whenSelectPressed);
            this._select.addEventListener("touchmove", this._whenSelectMoved);
            this._select.addEventListener("touchend", this._whenSelectReleased);
            this._select.addEventListener("touchcancel", this._whenSelectReleased);
            let determinedCursorType = false;
            document.addEventListener("mousedown", () => {
                if (!determinedCursorType) {
                    this._touchMode = false;
                    this._updatePreview();
                }
                determinedCursorType = true;
            }, true);
            document.addEventListener("touchstart", () => {
                if (!determinedCursorType) {
                    this._touchMode = true;
                    this._updatePreview();
                }
                determinedCursorType = true;
            }, true);
            this._barDropDown.selectedIndex = -1;
            this._barDropDown.addEventListener("change", this._barDropDownHandler);
            this._barDropDown.addEventListener("mousedown", this._barDropDownGetOpenedPosition);
        }
        movePlayheadToMouse() {
            if (this._mouseOver) {
                this._doc.synth.playhead = this._mouseBar + (this._mouseX % this._barWidth) / this._barWidth;
                return true;
            }
            return false;
        }
        _dragBoxSelection() {
            this._doc.selection.setTrackSelection(this._doc.selection.boxSelectionX0, this._mouseBar, this._doc.selection.boxSelectionY0, this._mouseChannel);
            this._doc.selection.selectionUpdated();
        }
        _updateSelectPos(event) {
            const boundingRect = this._svg.getBoundingClientRect();
            this._mouseX = event.touches[0].clientX - boundingRect.left;
            this._mouseY = event.touches[0].clientY - boundingRect.top;
            if (isNaN(this._mouseX))
                this._mouseX = 0;
            if (isNaN(this._mouseY))
                this._mouseY = 0;
            this._mouseBar = Math.floor(Math.min(this._doc.song.barCount - 1, Math.max(0, this._mouseX / this._barWidth)));
            this._mouseChannel = Math.floor(Math.min(this._doc.song.getChannelCount() - 1, Math.max(0, (this._mouseY - Config.barEditorHeight) / ChannelRow.patternHeight)));
        }
        _updateMousePos(event) {
            const boundingRect = this._svg.getBoundingClientRect();
            this._mouseX = (event.clientX || event.pageX) - boundingRect.left;
            this._mouseY = (event.clientY || event.pageY) - boundingRect.top;
            this._mouseBar = Math.floor(Math.min(this._doc.song.barCount - 1, Math.max(0, this._mouseX / this._barWidth)));
            this._mouseChannel = Math.floor(Math.min(this._doc.song.getChannelCount() - 1, Math.max(0, (this._mouseY - Config.barEditorHeight) / ChannelRow.patternHeight)));
        }
        _updatePreview() {
            let channel = this._mouseChannel;
            let bar = this._mouseBar;
            const selected = (bar == this._doc.bar && channel == this._doc.channel);
            const overTrackEditor = (this._mouseY >= Config.barEditorHeight);
            if (this._mouseDragging && this._mouseStartBar != this._mouseBar) {
                var timestamp = Date.now();
                if (timestamp - this._lastScrollTime >= 50) {
                    if (bar > this._doc.barScrollPos + this._doc.trackVisibleBars - 1 && this._doc.barScrollPos < this._doc.song.barCount - this._doc.trackVisibleBars) {
                        this._songEditor.changeBarScrollPos(1);
                    }
                    if (bar < this._doc.barScrollPos && this._doc.barScrollPos > 0) {
                        this._songEditor.changeBarScrollPos(-1);
                    } // fuck this i added Scroll Y in Track Editor because i hate "select more"
                    const trackRect = this._svg.getBoundingClientRect();const scrollSpeed = 20; const scrollMargin = 50;
                    if (this._mouseY + trackRect.top > window.innerHeight - scrollMargin){
                      window.scrollBy({ top: scrollSpeed });
                    } else if (this._mouseY + trackRect.top < scrollMargin) {
                      window.scrollBy({ top: -scrollSpeed });
                    }
                    this._lastScrollTime = timestamp;
                }
            }
            if (this._mouseOver && !this._mousePressed && !selected && overTrackEditor) {
                this._boxHighlight.setAttribute("x", "" + (1 + this._barWidth * bar));
                this._boxHighlight.setAttribute("y", "" + (1 + Config.barEditorHeight + ChannelRow.patternHeight * channel));
                this._boxHighlight.setAttribute("height", "" + (ChannelRow.patternHeight - 2));
                this._boxHighlight.setAttribute("width", "" + (this._barWidth - 2));
                this._boxHighlight.style.visibility = "visible";
            }
            else if ((this._mouseOver || ((this._mouseX >= bar * this._barWidth) && (this._mouseX < bar * this._barWidth + this._barWidth) && (this._mouseY > 0))) && (!overTrackEditor)) {
                this._boxHighlight.setAttribute("x", "" + (1 + this._barWidth * bar));
                this._boxHighlight.setAttribute("y", "1");
                this._boxHighlight.setAttribute("height", "" + (Config.barEditorHeight - 3));
                this._boxHighlight.style.visibility = "visible";
            }
            else {
                this._boxHighlight.style.visibility = "hidden";
            }
            if ((this._mouseOver || this._touchMode) && selected && overTrackEditor) {
                const up = ((this._mouseY - Config.barEditorHeight) % ChannelRow.patternHeight) < ChannelRow.patternHeight / 2;
                const center = this._barWidth * (bar + 0.8);
                const middle = Config.barEditorHeight + ChannelRow.patternHeight * (channel + 0.5);
                const base = ChannelRow.patternHeight * 0.1;
                const tip = ChannelRow.patternHeight * 0.4;
                const width = ChannelRow.patternHeight * 0.175;
                this._upHighlight.setAttribute("fill", up && !this._touchMode ? ColorConfig.hoverPreview : ColorConfig.invertedText);
                this._downHighlight.setAttribute("fill", !up && !this._touchMode ? ColorConfig.hoverPreview : ColorConfig.invertedText);
                this._upHighlight.setAttribute("d", `M ${center} ${middle - tip} L ${center + width} ${middle - base} L ${center - width} ${middle - base} z`);
                this._downHighlight.setAttribute("d", `M ${center} ${middle + tip} L ${center + width} ${middle + base} L ${center - width} ${middle + base} z`);
                this._upHighlight.style.visibility = "visible";
                this._downHighlight.style.visibility = "visible";
            }
            else {
                this._upHighlight.style.visibility = "hidden";
                this._downHighlight.style.visibility = "hidden";
            }
            this._selectionRect.style.left = (this._barWidth * this._doc.bar) + "px";
            this._selectionRect.style.top = (Config.barEditorHeight + (ChannelRow.patternHeight * this._doc.channel)) + "px";
            this._select.style.left = (this._barWidth * this._doc.bar) + "px";
            this._select.style.width = this._barWidth + "px";
            this._select.style.top = (Config.barEditorHeight + ChannelRow.patternHeight * this._doc.channel) + "px";
            this._select.style.height = ChannelRow.patternHeight + "px";
            this._barDropDown.style.left = (this._barWidth * bar) + "px";
            const patternCount = this._doc.song.patternsPerChannel + 1;
            for (let i = this._renderedPatternCount; i < patternCount; i++) {
                this._select.appendChild(HTML.option({ value: i }, i));
            }
            for (let i = patternCount; i < this._renderedPatternCount; i++) {
                this._select.removeChild(this._select.lastChild);
            }
            this._renderedPatternCount = patternCount;
            const selectedPattern = this._doc.song.channels[this._doc.channel].bars[this._doc.bar];
            if (this._select.selectedIndex != selectedPattern)
                this._select.selectedIndex = selectedPattern;
        }
        render() {
            this._barWidth = this._doc.getBarWidth();
            if (this._channels.length != this._doc.song.getChannelCount()) {
                for (let y = this._channels.length; y < this._doc.song.getChannelCount(); y++) {
                    const channelRow = new ChannelRow(this._doc, y);
                    this._channels[y] = channelRow;
                    this._channelRowContainer.appendChild(channelRow.container);
                }
                for (let y = this._doc.song.getChannelCount(); y < this._channels.length; y++) {
                    this._channelRowContainer.removeChild(this._channels[y].container);
                }
                this._channels.length = this._doc.song.getChannelCount();
                this._mousePressed = false;
            }
            for (let j = 0; j < this._doc.song.getChannelCount(); j++) {
                this._channels[j].render();
            }
            const editorWidth = this._barWidth * this._doc.song.barCount;
            if (this._renderedEditorWidth != editorWidth) {
                this._renderedEditorWidth = editorWidth;
                this._channelRowContainer.style.width = editorWidth + "px";
                this.container.style.width = editorWidth + "px";
                this._svg.setAttribute("width", editorWidth + "");
                this._mousePressed = false;
                var pathString = "";
                for (let x = 0; x < this._doc.song.barCount; x++) {
                    var pathLeft = x * this._barWidth + 2;
                    var pathTop = 1;
                    var pathRight = x * this._barWidth + this._barWidth - 2;
                    var pathBottom = Config.barEditorHeight - 3;
                    pathString += `M ${pathLeft} ${pathTop} H ${pathRight} V ${pathBottom} H ${pathLeft} V ${pathTop} Z `;
                }
                this._barEditorPath.setAttribute("d", pathString);
                if (this._renderedBarCount < this._doc.song.barCount) {
                    this._barNumbers.length = this._doc.song.barCount;
                    for (var pos = this._renderedBarCount; pos < this._barNumbers.length; pos++) {
                        this._barNumbers[pos] = SVG.text({ "font-family": "sans-serif", "font-size": "8px", "text-anchor": "middle", "font-weight": "bold", "x": (pos * this._barWidth + this._barWidth / 2) + "px", "y": "7px", fill: ColorConfig.secondaryText }, "" + (pos + 1));
                        if (pos % 4 == 0) {
                            this._barNumbers[pos].setAttribute("fill", ColorConfig.primaryText);
                        }
                        this._barNumberContainer.appendChild(this._barNumbers[pos]);
                    }
                    this._renderedBarCount = this._doc.song.barCount;
                }
                else if (this._renderedBarCount > this._doc.song.barCount) {
                    for (var pos = this._renderedBarCount - 1; pos >= this._doc.song.barCount; pos--) {
                        this._barNumberContainer.removeChild(this._barNumbers[pos]);
                    }
                    this._barNumbers.length = this._doc.song.barCount;
                    this._renderedBarCount = this._doc.song.barCount;
                }
                for (var pos = 0; pos < this._barNumbers.length; pos++) {
                    this._barNumbers[pos].setAttribute("x", (pos * this._barWidth + this._barWidth / 2) + "px");
                }
                this._renderedEditorWidth = editorWidth;
                this._channelRowContainer.style.width = editorWidth + "px";
                this.container.style.width = editorWidth + "px";
                this._svg.setAttribute("width", editorWidth + "");
                this._mousePressed = false;
            }
            const editorHeight = this._doc.song.getChannelCount() * ChannelRow.patternHeight;
            if (this._renderedEditorHeight != editorHeight) {
                this._renderedEditorHeight = editorHeight;
                this._svg.setAttribute("height", "" + (editorHeight + Config.barEditorHeight));
                this._playhead.setAttribute("height", "" + (editorHeight + Config.barEditorHeight));
                this.container.style.height = (editorHeight + Config.barEditorHeight) + "px";
            }
            this._select.style.display = this._touchMode ? "" : "none";
            if (this._doc.selection.boxSelectionActive) {
                this._selectionRect.setAttribute("x", String(this._barWidth * this._doc.selection.boxSelectionBar + 1));
                this._selectionRect.setAttribute("y", String(Config.barEditorHeight + ChannelRow.patternHeight * this._doc.selection.boxSelectionChannel + 1));
                this._selectionRect.setAttribute("width", String(this._barWidth * this._doc.selection.boxSelectionWidth - 2));
                this._selectionRect.setAttribute("height", String(ChannelRow.patternHeight * this._doc.selection.boxSelectionHeight - 2));
                this._selectionRect.setAttribute("visibility", "visible");
            }
            else {
                this._selectionRect.setAttribute("visibility", "hidden");
            }
            this._updatePreview();
        }
    }

    class oscilloscopeCanvas {
        constructor(canvas, scale = 1) {
            this.canvas = canvas;
            this.scale = scale;
            this._EventUpdateCanvas = function (directlinkL, directlinkR) {
                if (directlinkR) {
                    var ctx = canvas.getContext("2d");
                    ctx.fillStyle = ColorConfig.getComputed("--editor-background");
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = ColorConfig.getComputed("--oscilloscope-line-L");
                    for (let i = directlinkL.length - 1; i >= directlinkL.length - 1 - (canvas.width / scale); i--) {
                        let x = i - (directlinkL.length - 1) + (canvas.width / scale);
                        let yl = (directlinkL[i] * (canvas.height / scale / 2) + (canvas.height / scale / 2));
                        ctx.fillRect((x - 1) * scale, (yl - 1) * scale, 1 * scale, 1.5 * scale);
                        if (x == 0)
                            break;
                    }
                    ctx.fillStyle = ColorConfig.getComputed("--oscilloscope-line-R");
                    for (let i = directlinkR.length - 1; i >= directlinkR.length - 1 - (canvas.width / scale); i--) {
                        let x = i - (directlinkR.length - 1) + (canvas.width / scale);
                        let yr = (directlinkR[i] * (canvas.height / scale / 2) + (canvas.height / scale / 2));
                        ctx.fillRect((x - 1) * scale, (yr - 1) * scale, 1 * scale, 1.5 * scale);
                        if (x == 0)
                            break;
                    }
                }
            };
            events.listen("oscilloscopeUpdate", this._EventUpdateCanvas);
        }
    }

    const { div: div$4, input: input$3, button: button$4, h2: h2$3, select: select$3, option: option$3, canvas: canvas$1 } = HTML;
    const defaultShapeFunction = (cnv, ctx, x, y, w, h) => {
        ctx.fillRect(x, y, w, h);
    };
    class VisualLoopControlsHandle {
        constructor(value, canvasWidth, canvasHeight, viewportX0, viewportX1, validator, whenValueChanges, whenMouseUpHappens, shapeFunction) {
            this._handleWidth = 40;
            this._mouseDown = false;
            this._handleDragOffset = null;
            this.canvas = null;
            this._context = null;
            this.update = (newValue) => {
                this._value = this._validator(newValue);
            };
            this.render = () => {
                const cnv = this.canvas;
                const ctx = this._context;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const v = this._value;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                const bw = this._handleWidth;
                const bh = h;
                const bx = Math.floor((v - vx0) * w / (vx1 - vx0)) - bw / 2;
                const by = 0;
                this._shapeFunction(cnv, ctx, bx, by, bw, bh);
            };
            this.updateViewport = (x0, x1) => {
                this._viewportX0 = x0;
                this._viewportX1 = x1;
            };
            this._whenMouseMoves = (event) => {
                if (!this._mouseDown)
                    return;
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenMouseIsDown = (event) => {
                this._mouseDown = true;
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                const bw = this._handleWidth;
                const bx0 = ((this._value - vx0) * w / (vx1 - vx0)) - bw / 2;
                const bx1 = bx0 + bw;
                if (mx >= bx0 && mx <= bx1) {
                    this._handleDragOffset = (mx - (bx0 + bw / 2)) * (vx1 - vx0) / w;
                }
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenMouseIsUp = (event) => {
                if (!this._mouseDown)
                    return;
                this._mouseDown = false;
                this._handleDragOffset = null;
                this._whenMouseUpHappens();
            };
            this._whenTouchMoves = (event) => {
                if (!this._mouseDown)
                    return;
                event.preventDefault();
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenTouchIsDown = (event) => {
                event.preventDefault();
                this._mouseDown = true;
                const w = this._canvasWidth;
                const vx0 = this._viewportX0;
                const vx1 = this._viewportX1;
                const bounds = this.canvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                const bw = this._handleWidth;
                const bx0 = ((this._value - vx0) * w / (vx1 - vx0)) - bw / 2;
                const bx1 = bx0 + bw;
                if (mx >= bx0 && mx <= bx1) {
                    this._handleDragOffset = (mx - (bx0 + bw / 2)) * (vx1 - vx0) / w;
                }
                const wmx = vx0 + mx * (vx1 - vx0) / w;
                this._value = this._validator(wmx - (this._handleDragOffset != null ? this._handleDragOffset : 0));
                this.render();
                if (this._whenValueChanges)
                    this._whenValueChanges(this._value);
            };
            this._whenTouchIsUp = (event) => {
                event.preventDefault();
                this._mouseDown = false;
                this._handleDragOffset = null;
                this._whenMouseUpHappens();
            };
            this.cleanUp = () => {
                window.removeEventListener("mousemove", this._whenMouseMoves);
                this.canvas.removeEventListener("mousedown", this._whenMouseIsDown);
                window.removeEventListener("mouseup", this._whenMouseIsUp);
                this.canvas.removeEventListener("touchstart", this._whenTouchIsDown);
                this.canvas.removeEventListener("touchmove", this._whenTouchMoves);
                this.canvas.removeEventListener("touchend", this._whenTouchIsUp);
                this.canvas.removeEventListener("touchcancel", this._whenTouchIsUp);
            };
            this._value = value;
            this._validator = validator;
            this._whenValueChanges = whenValueChanges;
            this._whenMouseUpHappens = whenMouseUpHappens;
            this._shapeFunction = shapeFunction == null ? defaultShapeFunction : shapeFunction;
            this._viewportX0 = viewportX0;
            this._viewportX1 = viewportX1;
            this._canvasWidth = canvasWidth;
            this._canvasHeight = canvasHeight;
            this.canvas = canvas$1({ width: this._canvasWidth, height: this._canvasHeight, style: "cursor: default; position: static; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; outline: 1px solid var(--ui-widget-background); box-sizing: border-box; width: 100%;" });
            this._context = this.canvas.getContext("2d");
            window.addEventListener("mousemove", this._whenMouseMoves);
            this.canvas.addEventListener("mousedown", this._whenMouseIsDown);
            window.addEventListener("mouseup", this._whenMouseIsUp);
            this.canvas.addEventListener("touchstart", this._whenTouchIsDown);
            this.canvas.addEventListener("touchmove", this._whenTouchMoves);
            this.canvas.addEventListener("touchend", this._whenTouchIsUp);
            this.canvas.addEventListener("touchcancel", this._whenTouchIsUp);
        }
    }

class PointLabeling{
 constructor(container, e){
  this.e = e
  this.container=container
  this.data=JSON.parse(localStorage.getItem("pointLabelings")||"[]")
  this.openLabelings=new Set()
  this.currentLabeling=null
  this._render()
 }
 _save(){localStorage.setItem("pointLabelings",JSON.stringify(this.data))}
 returnLabels(){
  if(this.currentLabeling===null)return false
  const lab=this.data[this.currentLabeling]
  return lab?lab.labels:false
 }
 _ldE(e){
  this.e=e
 }
 _open(){
  const currentState=history.state||{}
  this.lockScroll()
  window.addEventListener("popstate",()=>{this.container.style.display="none"; this.e._render() ; this.unlockScroll(); const savedScrollY = parseInt(localStorage.getItem('customSelectScrollY') || '0', 10)
  window.scrollTo(0, savedScrollY)},{once:true} )
 }
 lockScroll(){
 savedScrollY=window.scrollY
 localStorage.setItem("customSelectScrollY",savedScrollY)
 document.body.style.position='fixed'
 document.body.style.top=`-${savedScrollY}px`
 document.body.style.left='0'
 document.body.style.right='0'
 document.body.style.overflow='hidden'
 document.documentElement.style.overflow='hidden'
}
 unlockScroll(){
 document.body.style.position=''
 document.body.style.top=''
 document.body.style.left=''
 document.body.style.right=''
 document.body.style.overflow=''
 document.documentElement.style.overflow=''
}
 _render(){
  const previouslyOpen=new Set(this.openLabelings)
  this.openLabelings.clear()
  this.container.innerHTML=""
  const wrap=document.createElement("div")
  wrap.style.cssText=`
   width:90%;height:90%;color:#eee;font-size:13px;overflow:hidden; overflow-y: scroll; z-index:10000;`
 wrap.classList="prompt noSelection"
  const input=document.createElement("input")
  input.placeholder="Labeling name"
 input.style.cssText="width:calc(100% - 30px);margin-bottom:0px;background:#333;color:#fff;border:1px solid #555;padding:2px 4px; float:left;"
 
  const del1=document.createElement("div")
  del1.textContent=""
  del1.style.cssText=`position:absolute; top:6px; right:6px; float:left !important; width:20px; 	height: var(--button-size);	border: none;	border-radius: 0px;	background-color: ${ColorConfig.uiWidgetBackground} !important;	font-size: inherit;	font-family: inherit;	font-weight: inherit; background-image: var(--internal-close-symbol); width:25px; background-repeat: no-repeat; background-position: center; `
  del1.classList="cancelButton"
  del1.onclick=()=>{this.container.style.display="none"; this.unlockScroll(); this.e._render() }
  const addBtn=document.createElement("button")
  addBtn.textContent="Add Labeling"
  addBtn.style.cssText="width:100%;background:#444;border:none;padding:4px;color:#fff;border-radius:4px;"
  addBtn.onclick=()=>{
   const name=input.value.trim()
   if(!name||this.data.some(l=>l.labname===name))return
   this.data.push({labname:name,labels:[]})
   input.value=""
   this._save()
   this._render()
  }
const impexpcont=document.createElement("div")
impexpcont.style.cssText=" display:flex; flex-direction:row; margin-top:4px; "
  const expBtn=document.createElement("button")
expBtn.textContent="Export JSON"
expBtn.style.cssText="width:calc(50% - 2px);background:#555;border:none;padding:4px;color:#fff;border-radius:4px; margin-left:6px; display:flex; float:left; "
expBtn.onclick = () => {
 const text = JSON.stringify(this.data)
 const blob = new Blob([text], { type: "application/json" })
 save(blob, "labelings.json", text, true)
}

const impInput=document.createElement("input")
impInput.type="file"
impInput.accept=".json"
impInput.style.display="none"
impInput.onchange=(e)=>{
 const file=e.target.files[0]
 if(!file)return
 const reader=new FileReader()
 reader.onload=ev=>{
  try{
   const imported=JSON.parse(ev.target.result)
   if(Array.isArray(imported)){
    this.data.push(...imported)
    this._save()
    this._render()
   }
  }catch(err){alert("Invalid JSON")}
 }
 reader.readAsText(file)
}
const impBtn=document.createElement("button")
impBtn.textContent="Import JSON"
impBtn.style.cssText="width:calc(50% - 2px);background:#555;border:none;padding:4px;color:#fff;border-radius:4px; margin-left:0px; display:flex; float:left; "
impBtn.onclick=()=>impInput.click()
impexpcont.append(impBtn,expBtn)
  wrap.append(input,del1,addBtn)

  this.data.forEach((lab,i)=>{
   const row=document.createElement("div")
   row.style.cssText="margin-top:6px;padding:4px;border:1px solid #555;border-radius:4px;background:#2b2b2b;"
   row.dataset.index=i
   const head=document.createElement("div")
   head.style.cssText="display:flex;justify-content:space-between;align-items:center;"
   const title=document.createElement("span")
   title.textContent=lab.labname
   const btns=document.createElement("div")
   const open=document.createElement("button")
open.textContent = this.currentLabeling === i ? "Close" : "Open"
open.style.cssText = this.currentLabeling === i ?
 "background:#a33;border:none;color:#fff;padding:2px 6px;border-radius:4px;margin-right:4px;" :
 "background:#3a3;border:none;color:#fff;padding:2px 6px;border-radius:4px;margin-right:4px;"
open.onclick = () => {
 if (this.currentLabeling === i) {
  this.currentLabeling = null
 } else {
  this.currentLabeling = i
  this._highlightCurrent(wrap)
 }
 this._render()
}
   const edit=document.createElement("button")
   edit.textContent="Edit"
   edit.style.cssText="background:#444;border:none;color:#fff;padding:2px 6px;border-radius:4px;"
   const del=document.createElement("button")
   del.textContent="X"
   del.style.cssText="background:none;border:none;color:#f55;"
   del.onclick=()=>{
    this.data.splice(i,1)
    if(this.currentLabeling===i)this.currentLabeling=null
    else if(this.currentLabeling>i)this.currentLabeling--
    this._save()
    this._render()
   }
   btns.append(open,edit,del)
   head.append(title,btns)
   row.append(head)
   const editBox=document.createElement("div")
   editBox.style.cssText="margin-top:4px;display:none;flex-direction:column;gap:4px;"
   edit.onclick=()=>{
    const isOpen=editBox.style.display==="none"
    editBox.style.display=isOpen?"flex":"none"
    if(isOpen)this.openLabelings.add(lab.labname)
    else this.openLabelings.delete(lab.labname)
   }
   if(previouslyOpen.has(lab.labname)){
    editBox.style.display="flex"
    this.openLabelings.add(lab.labname)
   }
   lab.labels.forEach((lbl,li)=>{
    const lrow=document.createElement("div")
    lrow.style.cssText="display:flex;gap:4px;"
    const name=document.createElement("input")
    name.value=lbl.name
    name.placeholder="name"
    name.style.cssText="flex:1;background:#333;border:1px solid #555;color:#fff;padding:2px 4px;"
    const pos=document.createElement("input")
    pos.value=lbl.pos
    pos.placeholder="position"
    pos.style.cssText="flex:1;background:#333;border:1px solid #555;color:#fff;padding:2px 4px;width:25%;"
    const delLbl=document.createElement("button")
    delLbl.textContent=""
    delLbl.style.cssText="background:none;border:none;color:#f55;cursor:pointer;"
    delLbl.onclick=()=>{
     lab.labels.splice(li,1)
     this._save()
     this._render()
    }
    name.oninput=()=>{lab.labels[li].name=name.value;this._save()}
    pos.oninput=()=>{lab.labels[li].pos=pos.value;this._save()}
    lrow.append(name,pos,delLbl)
    editBox.append(lrow)
   })
   const addLabel=document.createElement("button")
   addLabel.textContent="Add Label"
   addLabel.style.cssText="width:100%;background:#444;border:none;padding:3px;color:#fff;border-radius:4px;cursor:pointer;"
   addLabel.onclick=()=>{
    lab.labels.push({name:"",pos:""})
    this._save()
    this._render()
   }
   editBox.append(addLabel)
   row.append(editBox)
   wrap.append(row)
   wrap.append(impexpcont)
  })
  this._highlightCurrent(wrap)
  this.container.append(wrap)
  this._highlightCurrent(wrap)
 }
 _highlightCurrent(wrap){
 const rows=[...wrap.querySelectorAll("[data-index]")]
 rows.forEach(el=>{
  const idx=parseInt(el.dataset.index)
  if(this.currentLabeling!==null && this.data[this.currentLabeling]){
   el.style.outline=idx===this.currentLabeling?"1px solid #0f0":"none"
  }else el.style.outline="none"
 })
}


}

  class VisualLoopControlsPromptOLD {
        constructor(_doc, _songEditor) {
            this._waveformCanvasWidth = 500;
            this._waveformCanvasHeight = 200;
            this._handleCanvasHeight = 20;
            this._instrument = null;
            this._waveformData = null;
            this._waveformDataLength = null;
            this._initialChipWaveLoopMode = null;
            this._initialChipWaveStartOffset = null;
            this._initialChipWaveLoopStart = null;
            this._initialChipWaveLoopEnd = null;
            this._initialChipWavePlayBackwards = null;
            this._chipWaveLoopMode = 0;
            this._chipWaveStartOffset = 0;
            this._chipWaveLoopStart = 0;
            this._chipWaveLoopEnd = 0;
            this._chipWavePlayBackwards = false;
            this._waveformViewportX0 = 0;
            this._waveformViewportX1 = 1;
            this._waveformViewportY0 = -1.01;
            this._waveformViewportY1 = 1.01;
            this._waveformViewportWidth = 1;
            this._waveformViewportOffset = 0;
            this._waveformViewportMaxOffset = 0;
            this._overlayIsMouseDown = false;
            this._overlaySelectionX0 = null;
            this._overlaySelectionX1 = null;
            this._startOffsetValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.floor(v)));
            };
            this._loopStartValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.min(this._chipWaveLoopEnd - 2, Math.floor(v))));
            };
            this._loopEndValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.max(this._chipWaveLoopStart + 2, Math.floor(v))));
            };
            this._startOffsetHandle = new VisualLoopControlsHandle(this._chipWaveStartOffset, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._startOffsetValidator, (v) => {
                this._chipWaveStartOffset = v;
                this._instrument.chipWaveStartOffset = this._chipWaveStartOffset;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const th = h / 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y);
                ctx.lineTo(x + w, y + h - th);
                ctx.lineTo(x + w / 2, y + h);
                ctx.lineTo(x, y + h - th);
                ctx.fill();
            });
            this._loopStartHandle = new VisualLoopControlsHandle(this._chipWaveLoopStart, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._loopStartValidator, (v) => {
                this._chipWaveLoopStart = v;
                this._instrument.chipWaveLoopStart = this._chipWaveLoopStart;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const tw = w / 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w - tw, y);
                ctx.lineTo(x + w, y + h / 2);
                ctx.lineTo(x + w - tw, y + h);
                ctx.lineTo(x, y + h);
                ctx.fill();
            });
            this._loopEndHandle = new VisualLoopControlsHandle(this._chipWaveLoopEnd, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._loopEndValidator, (v) => {
                this._chipWaveLoopEnd = v;
                this._instrument.chipWaveLoopEnd = this._chipWaveLoopEnd;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const tw = w / 4;
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(x + w, y + h);
                ctx.lineTo(x + tw, y + h);
                ctx.lineTo(x, y + h / 2);
                ctx.lineTo(x + tw, y);
                ctx.fill();
            });
            this._chipWaveIsUnavailable = true;
            this._waveformCanvas = canvas$1({ width: this._waveformCanvasWidth, height: this._waveformCanvasHeight, style: "cursor: default; position: static; width: 100%;" });
            this._waveformContext = null;
            this._overlayCanvas = canvas$1({ width: this._waveformCanvasWidth, height: this._waveformCanvasHeight, style: "cursor: default; position: absolute; top: 0; left: 0; width: 100%;" });
            this._overlayContext = null;
            this._waveformContainer = div$8({ style: `position: relative; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; width: 100%; outline: 1px solid ${ColorConfig.uiWidgetBackground};` }, this._waveformCanvas, this._overlayCanvas);
            this._viewportOffsetSlider = input$5({ style: "width: 100%; flex-grow: 1; margin: 0;", type: "range", min: "0", max: "1", value: "0", step: "0.00001" });
            this._zoomInButton = button$8({ type: "button", title: "Zoom In", style: "height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "20", height: "20", viewBox: "-10 -10 20 20", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.circle({ cx: -1, cy: -1, r: 6, "stroke-width": 2, stroke: ColorConfig.primaryText, fill: "none" }), SVG.path({ stroke: ColorConfig.primaryText, "stroke-width": 2, d: "M 3 3 L 7 7 M -1 -4 L -1 2 M -4 -1 L 2 -1", fill: "none" })));
            this._zoomOutButton = button$8({ type: "button", title: "Zoom Out", style: "height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "20", height: "20", viewBox: "-10 -10 20 20", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.circle({ cx: -1, cy: -1, r: 6, "stroke-width": 2, stroke: ColorConfig.primaryText, fill: "none" }), SVG.path({ stroke: ColorConfig.primaryText, "stroke-width": 2, d: "M 3 3 L 7 7 M -4 -1 L 2 -1", fill: "none" })));
            this._zoom100Button = button$8({ type: "button", title: "Zoom 100%", style: "height: var(--button-size); margin-left: 0.5em;" }, "100%");
            this._loopModeSelect = select$4({ style: "width: 100%; flex-grow: 1; margin-left: 0.5em;" }, option$4({ value: 0 }, "Loop"), option$4({ value: 1 }, "Ping-Pong"), option$4({ value: 2 }, "Play Once"), option$4({ value: 3 }, "Play Loop Once"));
            this._startOffsetStepper = input$5({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveStartOffset, min: "0", step: "1" });
            this._loopStartStepper = input$5({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveLoopStart, min: "0", step: "1" });
            this._loopEndStepper = input$5({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveLoopEnd, min: "0", step: "1" });
            this._playBackwardsBox = input$5({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: auto; margin-right: auto;" });
            this._playSongButton = button$8({ style: "width: 55%;", type: "button" });
            this._cancelButton = button$8({ class: "cancelButton" });
            this._okayButton = button$8({ class: "okayButton", style: "width: 25%;" }, "Okay");
            this._sampleIsLoadingMessage = div$8({ style: "margin-bottom: 0.5em; display: none;" }, "Sample is loading");
            this._labelingContainer=document.createElement("div")
this._labelingContainer.style.cssText="position:fixed;top:0;left:0;z-index:9999;display:none; width:100%; height:100vh; overflow:hidden; background:rgba(0,0,0,0.15)"
document.body.append(this._labelingContainer)
this._pointLabeling=new PointLabeling(this._labelingContainer )
this._addLabelButton=button$4({type:"button",title:"Add Label"},"Labeling")
this._addLabelButton.addEventListener("click", () => {
 const visible = this._labelingContainer.style.display === "block"
 this._labelingContainer.style.display = visible ? "none" : "block"
 this._pointLabeling._open()
})
            this._loopControlsContainer = div$8(div$8({ style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$8({ style: `width: 100%; margin-bottom: 0.5em; text-align: center; color: ${ColorConfig.secondaryText};` }, "You can also zoom by dragging horizontally on the waveform.")), this._startOffsetHandle.canvas, this._waveformContainer, this._loopStartHandle.canvas, this._loopEndHandle.canvas, div$8({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, this._viewportOffsetSlider, this._zoomInButton, this._zoomOutButton, this._zoom100Button), div$8({ style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$8({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$8({ style: `flex-shrink: 0; text-align: right: color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop Mode"), this._loopModeSelect), div$8({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$8({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Offset"), this._startOffsetStepper), div$8({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$8({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop Start"), this._loopStartStepper), div$8({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$8({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop End"), this._loopEndStepper), div$8({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$8({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Backwards"), this._playBackwardsBox), div$8({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em; justify-content: center;" }, this._playSongButton , div$4({style:"display:flex;gap:0.5em;margin-left:2px;"},this._addLabelButton))));
            this.container = div$8({ class: "prompt noSelection", style: "width: 500px;" }, div$8(div$8({ class: "promptTitle" }, h2$6({ class: "loop-controlsExt", style: "text-align: inherit;" }, ""), h2$6({ class: "loop-controlsTitle" }, "Loop Controls")), this._sampleIsLoadingMessage, this._loopControlsContainer, div$8({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton)), this._cancelButton);
            this.gotMouseUp = false;
            this._waveformSampleLookup = (x) => {
                const n = this._waveformDataLength;
                if (x >= 0 && x < n) {
                    return this._waveformData[Math.floor(x)];
                }
                else {
                    return 0;
                }
            };
            this._waveformSamplesLookup = (x0, x1) => {
                const n = this._waveformDataLength;
                const a = Math.max(0, Math.min(n, Math.ceil(x0)));
                const b = Math.max(0, Math.min(n, Math.ceil(x1)));
                if (a >= b)
                    return [0, 0];
                let y0 = this._waveformData[a];
                let y1 = y0;
                for (let i = a + 1; i < b; i++) {
                    const v = this._waveformData[i];
                    y0 = Math.min(y0, v);
                    y1 = Math.max(y1, v);
                }
                return [y0, y1];
            };
            this.cleanUp = () => {
                this._startOffsetHandle.cleanUp();
                this._loopStartHandle.cleanUp();
                this._loopEndHandle.cleanUp();
                this.container.removeEventListener("keydown", this._whenKeyPressed);
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._viewportOffsetSlider.removeEventListener("input", this._whenViewportOffsetSliderChanges);
                this._zoomInButton.removeEventListener("click", this._whenZoomInClicked);
                this._zoomOutButton.removeEventListener("click", this._whenZoomOutClicked);
                this._zoom100Button.removeEventListener("click", this._whenZoom100Clicked);
                this._loopModeSelect.removeEventListener("change", this._whenLoopModeSelectChanges);
                this._startOffsetStepper.removeEventListener("change", this._whenStartOffsetStepperChanges);
                this._loopStartStepper.removeEventListener("change", this._whenLoopStartStepperChanges);
                this._loopEndStepper.removeEventListener("change", this._whenLoopEndStepperChanges);
                this._playBackwardsBox.removeEventListener("input", this._whenPlayBackwardsBoxChanges);
                this._playSongButton.removeEventListener("click", this._togglePlaySong);
                this._overlayCanvas.removeEventListener("mousemove", this._whenOverlayMouseMoves);
                this._overlayCanvas.removeEventListener("mousedown", this._whenOverlayMouseIsDown);
                this._overlayCanvas.removeEventListener("mouseup", this._whenOverlayMouseIsUp);
                this._overlayCanvas.removeEventListener("touchstart", this._whenOverlayTouchIsDown);
                this._overlayCanvas.removeEventListener("touchmove", this._whenOverlayTouchMoves);
                this._overlayCanvas.removeEventListener("touchend", this._whenOverlayTouchIsUp);
                this._overlayCanvas.removeEventListener("touchcancel", this._whenOverlayTouchIsUp);
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this._saveChanges = () => {
                if (!this._chipWaveIsUnavailable) {
                    this._doc.prompt = null;
                    this._instrument.chipWaveLoopMode = this._initialChipWaveLoopMode;
                    this._instrument.chipWaveStartOffset = this._initialChipWaveStartOffset;
                    this._instrument.chipWaveLoopStart = this._initialChipWaveLoopStart;
                    this._instrument.chipWaveLoopEnd = this._initialChipWaveLoopEnd;
                    this._instrument.chipWavePlayBackwards = this._initialChipWavePlayBackwards;
                    const group = new ChangeGroup();
                    group.append(new ChangeChipWaveLoopMode(this._doc, this._chipWaveLoopMode));
                    group.append(new ChangeChipWaveStartOffset(this._doc, this._chipWaveStartOffset));
                    group.append(new ChangeChipWaveLoopStart(this._doc, this._chipWaveLoopStart));
                    group.append(new ChangeChipWaveLoopEnd(this._doc, this._chipWaveLoopEnd));
                    group.append(new ChangeChipWavePlayBackwards(this._doc, this._chipWavePlayBackwards));
                    this._doc.record(group, true);
                }
                else {
                    this._doc.prompt = null;
                    this._doc.undo();
                }
            };
            this._togglePlaySong = () => {
                this._songEditor.togglePlay();
                this._updatePlaySongButton();
            };
            this._renderWaveform = () => {
                if (this._chipWaveIsUnavailable)
                    return;
                const cnv = this._waveformCanvas;
                const ctx = this._waveformContext;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const vy0 = this._waveformViewportY0;
                const vy1 = this._waveformViewportY1;
                const sampleWidth = (vx1 - vx0) / w;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                ctx.fillRect(0, h / 2, w, 1);
                const waveformColor = ColorConfig.getComputed("--primary-text");
                if (sampleWidth < 1) {
                    ctx.strokeStyle = waveformColor;
                    ctx.lineWidth = 1;
                    let firstMove = true;
                    ctx.beginPath();
                    for (let cx = 0; cx < w; cx++) {
                        const wx = vx0 + cx * sampleWidth;
                        const wy = this._waveformSampleLookup(wx);
                        const cy = h - (wy - vy0) * h / (vy1 - vy0);
                        if (firstMove) {
                            ctx.moveTo(cx, cy);
                            firstMove = false;
                        }
                        else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    ctx.stroke();
                }
                else {
                    ctx.fillStyle = waveformColor;
                    let pcy0 = null;
                    let pcy1 = null;
                    for (let cx = 0; cx < w; cx++) {
                        const wx = vx0 + cx * sampleWidth;
                        const [wy0, wy1] = this._waveformSamplesLookup(wx - sampleWidth / 2, wx + sampleWidth / 2);
                        const cy0 = Math.max(-1, Math.min(h, h - (wy1 - vy0) * h / (vy1 - vy0)));
                        const cy1 = Math.max(-1, Math.min(h, h - (wy0 - vy0) * h / (vy1 - vy0)));
                        const cy0i = Math.floor(cy0);
                        const cy1i = Math.max(Math.ceil(cy1), cy0i + 1);
                        const ocy0 = pcy1 == null ? cy0i : Math.min(cy0i, pcy1);
                        const ocy1 = pcy0 == null ? cy1i : Math.max(cy1i, pcy0);
                        const bh = Math.max(1, ocy1 - ocy0);
                        ctx.fillRect(cx, ocy0, 1, bh);
                        pcy0 = ocy0;
                        pcy1 = ocy1;
                    }
                }
            };
            this._renderOverlay = () => {
                const cnv = this._overlayCanvas;
                const ctx = this._overlayContext;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const so = this._chipWaveStartOffset;
                const ls = this._chipWaveLoopStart;
                const le = this._chipWaveLoopEnd;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                const obx = Math.floor((so - vx0) * w / (vx1 - vx0));
                const oby = 0;
                const obw = 1;
                const obh = h;
                ctx.fillRect(obx, oby, obw, obh);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                ctx.globalAlpha = 0.5;
                const lbx0 = Math.floor((ls - vx0) * w / (vx1 - vx0));
                const lbx1 = Math.floor((le - vx0) * w / (vx1 - vx0));
                const lbx = lbx0;
                const lby = 0;
                const lbw = lbx1 - lbx0;
                const lbh = h;
                ctx.fillRect(lbx, lby, lbw, lbh);
                ctx.globalAlpha = 1;
                if (this._overlaySelectionX0 != null && this._overlaySelectionX1 != null) {
                    ctx.fillStyle = ColorConfig.getComputed("--box-selection-fill");
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(this._overlaySelectionX0, 0, this._overlaySelectionX1 - this._overlaySelectionX0, h);
                    ctx.globalAlpha = 1;
                }
                this._drawLabelingMarkers(ctx,w,h,vx0,vx1)
            };
            this._reconfigureLoopControls = () => {
                this._loopModeSelect.value = "" + this._chipWaveLoopMode;
                this._startOffsetStepper.value = "" + this._chipWaveStartOffset;
                this._loopStartStepper.value = "" + this._chipWaveLoopStart;
                this._loopEndStepper.value = "" + this._chipWaveLoopEnd;
                this._playBackwardsBox.checked = this._chipWavePlayBackwards;
            };
            this._whenViewportOffsetSliderChanges = (event) => {
                const rawOffset = Math.max(0, Math.min(1, +event.target.value));
                const newViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, rawOffset * this._waveformViewportMaxOffset));
                this._waveformViewportOffset = Math.min(this._waveformViewportMaxOffset, newViewportOffset);
                this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoomInClicked = (event) => {
                const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, this._waveformViewportWidth / 2));
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                const centerX = this._waveformViewportX0 + (this._waveformCanvasWidth / 2) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX - (this._waveformCanvasWidth / 2) * this._waveformViewportWidth / this._waveformCanvasWidth));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoomOutClicked = (event) => {
                const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, this._waveformViewportWidth * 2));
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                const centerX = this._waveformViewportX0 + (this._waveformCanvasWidth / 2) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX - (this._waveformCanvas.width / 2) * this._waveformViewportWidth / this._waveformCanvasWidth));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                if (this._waveformViewportWidth === this._waveformDataLength) {
                    this._viewportOffsetSlider.value = "0";
                }
                else {
                    this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                }
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoom100Clicked = (event) => {
                const newViewportWidth = this._waveformDataLength;
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, 0));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                if (this._waveformViewportWidth === this._waveformDataLength) {
                    this._viewportOffsetSlider.value = "0";
                }
                else {
                    this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                }
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenLoopModeSelectChanges = (event) => {
                const element = event.target;
                const newValue = +element.value;
                this._chipWaveLoopMode = newValue;
                this._instrument.chipWaveLoopMode = this._chipWaveLoopMode;
            };
            this._whenStartOffsetStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._startOffsetValidator(+element.value);
                this._chipWaveStartOffset = newValue;
                this._instrument.chipWaveStartOffset = this._chipWaveStartOffset;
                element.value = "" + newValue;
                this._startOffsetHandle.update(newValue);
                this._startOffsetHandle.render();
                this._renderOverlay();
            };
            this._whenLoopStartStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._loopStartValidator(+element.value);
                this._chipWaveLoopStart = newValue;
                this._instrument.chipWaveLoopStart = this._chipWaveLoopStart;
                element.value = "" + newValue;
                this._loopStartHandle.update(newValue);
                this._loopStartHandle.render();
                this._renderOverlay();
            };
            this._whenLoopEndStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._loopEndValidator(+element.value);
                this._chipWaveLoopEnd = newValue;
                this._instrument.chipWaveLoopEnd = this._chipWaveLoopEnd;
                element.value = "" + newValue;
                this._loopEndHandle.update(newValue);
                this._loopEndHandle.render();
                this._renderOverlay();
            };
            this._whenPlayBackwardsBoxChanges = (event) => {
                const element = event.target;
                const newValue = element.checked;
                this._chipWavePlayBackwards = newValue;
                this._instrument.chipWavePlayBackwards = this._chipWavePlayBackwards;
            };
            this._whenOverlayMouseMoves = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayMouseIsDown = (event) => {
                this._overlayIsMouseDown = true;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX0 = mx;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayMouseIsUp = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
                this._overlayIsMouseDown = false;
                const w = this._overlayCanvas.width;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._overlaySelectionX0 = Math.max(0, Math.min(w, this._overlaySelectionX0));
                this._overlaySelectionX1 = Math.max(0, Math.min(w, this._overlaySelectionX1));
                if (this._overlaySelectionX0 > this._overlaySelectionX1) {
                    const t = this._overlaySelectionX0;
                    this._overlaySelectionX0 = this._overlaySelectionX1;
                    this._overlaySelectionX1 = t;
                }
                let zoomAreaIsTooSmall = false;
                if (this._overlaySelectionX1 - this._overlaySelectionX0 > 2) {
                    const wosx0 = vx0 + this._overlaySelectionX0 * (vx1 - vx0) / w;
                    const wosx1 = vx0 + this._overlaySelectionX1 * (vx1 - vx0) / w;
                    const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, wosx1 - wosx0));
                    this._waveformViewportWidth = newViewportWidth;
                    this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                    const centerX = vx0 + (this._overlaySelectionX0) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                    this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX));
                    this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                    this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                    if (this._waveformViewportWidth === this._waveformDataLength) {
                        this._viewportOffsetSlider.value = "0";
                    }
                    else {
                        this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                    }
                }
                else {
                    zoomAreaIsTooSmall = true;
                }
                this._overlaySelectionX0 = null;
                this._overlaySelectionX1 = null;
                if (!zoomAreaIsTooSmall) {
                    this._propagateViewportUpdate();
                    this._render();
                }
                this._renderOverlay();
            };
            this._whenOverlayTouchIsDown = (event) => {
                event.preventDefault();
                this._overlayIsMouseDown = true;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                this._overlaySelectionX0 = mx;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayTouchMoves = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                event.preventDefault();
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayTouchIsUp = (event) => {
                event.preventDefault();
                if (!this._overlayIsMouseDown)
                    return;
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
                this._overlayIsMouseDown = false;
                const w = this._overlayCanvas.width;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                this._overlaySelectionX0 = Math.max(0, Math.min(w, this._overlaySelectionX0));
                this._overlaySelectionX1 = Math.max(0, Math.min(w, this._overlaySelectionX1));
                if (this._overlaySelectionX0 > this._overlaySelectionX1) {
                    const t = this._overlaySelectionX0;
                    this._overlaySelectionX0 = this._overlaySelectionX1;
                    this._overlaySelectionX1 = t;
                }
                let zoomAreaIsTooSmall = false;
                if (this._overlaySelectionX1 - this._overlaySelectionX0 > 2) {
                    const wosx0 = vx0 + this._overlaySelectionX0 * (vx1 - vx0) / w;
                    const wosx1 = vx0 + this._overlaySelectionX1 * (vx1 - vx0) / w;
                    const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, wosx1 - wosx0));
                    this._waveformViewportWidth = newViewportWidth;
                    this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                    const centerX = vx0 + (this._overlaySelectionX0) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                    this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX));
                    this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                    this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                    if (this._waveformViewportWidth === this._waveformDataLength) {
                        this._viewportOffsetSlider.value = "0";
                    }
                    else {
                        this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                    }
                }
                else {
                    zoomAreaIsTooSmall = true;
                }
                this._overlaySelectionX0 = null;
                this._overlaySelectionX1 = null;
                if (!zoomAreaIsTooSmall) {
                    this._propagateViewportUpdate();
                    this._render();
                }
                this._renderOverlay();
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlaySong();
                    event.preventDefault();
                }
            };
            this._updatePlaySongButton = () => {
                if (this._doc.synth.playing) {
                    this._playSongButton.classList.remove("playButton");
                    this._playSongButton.classList.add("pauseButton");
                    this._playSongButton.title = "Pause (Space)";
                    this._playSongButton.innerText = "Pause";
                }
                else {
                    this._playSongButton.classList.remove("pauseButton");
                    this._playSongButton.classList.add("playButton");
                    this._playSongButton.title = "Play (Space)";
                    this._playSongButton.innerText = "Play";
                }
            };
            this._propagateViewportUpdate = () => {
                this._startOffsetHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
                this._loopStartHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
                this._loopEndHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
            };
            this._render = () => {
                if (this._chipWaveIsUnavailable)
                    return;
                this._renderWaveform();
                this._startOffsetHandle.render();
                this._loopStartHandle.render();
                this._loopEndHandle.render();
                this._renderOverlay();
            };
            this._doc = _doc;
            this._songEditor = _songEditor;
            this._waveformContext = this._waveformCanvas.getContext("2d");
            this._overlayContext = this._overlayCanvas.getContext("2d");
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const rawChipWave = Config.rawRawChipWaves[this._instrument.chipWave]; 
            //console.log([(Config.chipWaves[this._instrument.chipWave].isCustomSampled === true),sampleLoadingState.statusTable[this._instrument.chipWave] , Config.chipWaves[this._instrument.chipWave].isCustomLoaded]) 
            const customSampleIsLoading = (rawChipWave.isCustomSampled === true ) && sampleLoadingState.statusTable[this._instrument.chipWave] !== 1 && !rawChipWave.isCustomLoaded;
            if (customSampleIsLoading) {
                this._sampleIsLoadingMessage.style.display = "";
                this._loopControlsContainer.style.display = "none";
                this._chipWaveIsUnavailable = true;
            }
            else {
                this._sampleIsLoadingMessage.style.display = "none";
                this._loopControlsContainer.style.display = "";
                this._chipWaveIsUnavailable = false;
                this._waveformData = rawChipWave.samples;
                this._waveformDataLength = this._waveformData.length - 1;
                this._initialChipWaveLoopMode = this._instrument.chipWaveLoopMode;
                this._initialChipWaveStartOffset = this._instrument.chipWaveStartOffset;
                this._initialChipWaveLoopStart = this._instrument.chipWaveLoopStart;
                this._initialChipWaveLoopEnd = this._instrument.chipWaveLoopEnd;
                this._initialChipWavePlayBackwards = this._instrument.chipWavePlayBackwards;
                this._chipWaveLoopMode = this._initialChipWaveLoopMode;
                this._chipWaveStartOffset = this._initialChipWaveStartOffset;
                this._chipWaveLoopStart = this._initialChipWaveLoopStart;
                this._chipWaveLoopEnd = this._initialChipWaveLoopEnd;
                this._chipWavePlayBackwards = this._initialChipWavePlayBackwards;
                const verticalBounds = this._waveformSamplesLookup(0, this._waveformDataLength);
                const maxVerticalBound = Math.max(Math.abs(verticalBounds[0]), Math.abs(verticalBounds[1])) + 0.01;
                verticalBounds[0] = -maxVerticalBound;
                verticalBounds[1] = maxVerticalBound;
                this._waveformViewportX0 = 0;
                this._waveformViewportX1 = this._waveformDataLength;
                this._waveformViewportY0 = verticalBounds[0];
                this._waveformViewportY1 = verticalBounds[1];
                this._waveformViewportWidth = this._waveformViewportX1 - this._waveformViewportX0;
                this._waveformViewportOffset = 0;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                this._startOffsetHandle.update(this._chipWaveStartOffset);
                this._loopStartHandle.update(this._chipWaveLoopStart);
                this._loopEndHandle.update(this._chipWaveLoopEnd);
                this._propagateViewportUpdate();
            }
            this._updatePlaySongButton();
            this._render();
            this._reconfigureLoopControls();
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._viewportOffsetSlider.addEventListener("input", this._whenViewportOffsetSliderChanges);
            this._zoomInButton.addEventListener("click", this._whenZoomInClicked);
            this._zoomOutButton.addEventListener("click", this._whenZoomOutClicked);
            this._zoom100Button.addEventListener("click", this._whenZoom100Clicked);
            this._loopModeSelect.addEventListener("change", this._whenLoopModeSelectChanges);
            this._startOffsetStepper.addEventListener("change", this._whenStartOffsetStepperChanges);
            this._loopStartStepper.addEventListener("change", this._whenLoopStartStepperChanges);
            this._loopEndStepper.addEventListener("change", this._whenLoopEndStepperChanges);
            this._playBackwardsBox.addEventListener("input", this._whenPlayBackwardsBoxChanges);
            this._playSongButton.addEventListener("click", this._togglePlaySong);
            window.addEventListener("mousemove", this._whenOverlayMouseMoves);
            this._overlayCanvas.addEventListener("mousedown", this._whenOverlayMouseIsDown);
            window.addEventListener("mouseup", this._whenOverlayMouseIsUp);
            this._overlayCanvas.addEventListener("touchstart", this._whenOverlayTouchIsDown);
            this._overlayCanvas.addEventListener("touchmove", this._whenOverlayTouchMoves);
            this._overlayCanvas.addEventListener("touchend", this._whenOverlayTouchIsUp);
            this._overlayCanvas.addEventListener("touchcancel", this._whenOverlayTouchIsUp);
        this._pointLabeling._ldE(this)
        }
_drawLabelingMarkers(ctx, w, h, vx0, vx1) {
	const labels = this._pointLabeling.returnLabels()
	if (!labels) return
	ctx.save()
	ctx.strokeStyle = "#fff"
	ctx.fillStyle = "#fff"
	ctx.font = "12px sans-serif"
	for (const l of labels) {
		const pos = parseFloat(l.pos)
		if (isNaN(pos)) continue
		const x = (pos - vx0) * w / (vx1 - vx0)
		if (x < 0 || x > w) continue
		ctx.beginPath()
		ctx.moveTo(x, 0)
		ctx.lineTo(x, h)
		ctx.stroke()
		ctx.fillText(l.name || "", x + 4, 12)
	}
	ctx.restore()
}
    }


    class VisualLoopControlsPrompt { 
        constructor(_doc, _songEditor) {
            this._waveformCanvasWidth = 500;
            this._waveformCanvasHeight = 200;
            this._handleCanvasHeight = 20;
            this._instrument = null;
            this._waveformData = null;
            this._zoomYanabled=false;
            this._zoomedYAxis=false
            this._waveformDataLength = null;
            this._initialChipWaveLoopMode = null;
            this._initialChipWaveStartOffset = null;
            this._initialChipWaveLoopStart = null;
            this._initialChipWaveLoopEnd = null;
            this._initialChipWavePlayBackwards = null;
            this._chipWaveLoopMode = 0;
            this._chipWaveStartOffset = 0;
            this._chipWaveLoopStart = 0;
            this._chipWaveLoopEnd = 0;
            this._chipWavePlayBackwards = false;
            this._waveformViewportX0 = 0;
            this._waveformViewportX1 = 1;
            this._waveformViewportY0 = -1.01;
            this._waveformViewportY1 = 1.01;
            this._waveformViewportWidth = 1;
            this._waveformViewportOffset = 0;
            this._waveformViewportMaxOffset = 0;
            this._overlayIsMouseDown = false;
            this._overlaySelectionX0 = null;
            this._overlaySelectionX1 = null;
            
 this._waveformViewportYOffset = 0
this._waveformViewportYRange = this._waveformViewportY1 - this._waveformViewportY0
this._waveformViewportYMaxOffset = 0

            this._startOffsetValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.floor(v)));
            };
            this._loopStartValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.min(this._chipWaveLoopEnd - 2, Math.floor(v))));
            };
            this._loopEndValidator = (v) => {
                return Math.max(0, Math.min(this._waveformDataLength, Math.max(this._chipWaveLoopStart + 2, Math.floor(v))));
            };
            this._startOffsetHandle = new VisualLoopControlsHandle(this._chipWaveStartOffset, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._startOffsetValidator, (v) => {
                this._chipWaveStartOffset = v;
                this._instrument.chipWaveStartOffset = this._chipWaveStartOffset;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const th = h / 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y);
                ctx.lineTo(x + w, y + h - th);
                ctx.lineTo(x + w / 2, y + h);
                ctx.lineTo(x, y + h - th);
                ctx.fill();
            });
            this._loopStartHandle = new VisualLoopControlsHandle(this._chipWaveLoopStart, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._loopStartValidator, (v) => {
                this._chipWaveLoopStart = v;
                this._instrument.chipWaveLoopStart = this._chipWaveLoopStart;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const tw = w / 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w - tw, y);
                ctx.lineTo(x + w, y + h / 2);
                ctx.lineTo(x + w - tw, y + h);
                ctx.lineTo(x, y + h);
                ctx.fill();
            });
            this._loopEndHandle = new VisualLoopControlsHandle(this._chipWaveLoopEnd, this._waveformCanvasWidth, this._handleCanvasHeight, this._waveformViewportX0, this._waveformViewportX1, this._loopEndValidator, (v) => {
                this._chipWaveLoopEnd = v;
                this._instrument.chipWaveLoopEnd = this._chipWaveLoopEnd;
                this._renderOverlay();
                this._reconfigureLoopControls();
            }, () => {
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
            }, (cnv, ctx, x, y, w, h) => {
                const tw = w / 4;
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(x + w, y + h);
                ctx.lineTo(x + tw, y + h);
                ctx.lineTo(x, y + h / 2);
                ctx.lineTo(x + tw, y);
                ctx.fill();
            });
            this._chipWaveIsUnavailable = true;
this._zoomInYButton = button$4({ type: "button", title: "Zoom In Y", style: "height: var(--button-size); margin-left: 0.5em;" }, "YZoom")
 this._zoomInYButton.addEventListener("click",()=>{
 if(!this._waveformData)return
 this._zoomYanabled=!this._zoomYanabled;
 this._zoomYanabled?this._zoomInYButton.style.border="2px solid white":this._zoomInYButton.style.border=""
 localStorage.setItem("zoomY", this._zoomYanabled);
 this._render()
})
const savedZoomY = localStorage.getItem("zoomY");
this._zoomYanabled = savedZoomY === "true";
this._zoomYanabled?this._zoomInYButton.style.border="2px solid white":this._zoomInYButton.style.border=""

            this._waveformCanvas = canvas$1({ width: this._waveformCanvasWidth, height: this._waveformCanvasHeight, style: "cursor: default; position: static; width: 100%;" });
            this._waveformContext = null;
            this._overlayCanvas = canvas$1({ width: this._waveformCanvasWidth, height: this._waveformCanvasHeight, style: "cursor: default; position: absolute; top: 0; left: 0; width: 100%;" });
this._labelingContainer=document.createElement("div") 
this._labelingContainer.style.cssText="position:fixed;top:0;left:0;z-index:9999;display:none; width:100%; height:100vh; overflow:hidden; background:rgba(0,0,0,0.15)"
document.body.append(this._labelingContainer)
this._pointLabeling=new PointLabeling(this._labelingContainer )
            this._overlayContext = null;
            this._waveformContainer = div$4({ style: `position: relative; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; width: 100%; outline: 1px solid ${ColorConfig.uiWidgetBackground};` }, this._waveformCanvas, this._overlayCanvas);
            this._viewportOffsetSlider = input$3({ style: "width: 100%; flex-grow: 1; margin: 0;", type: "range", min: "0", max: "1", value: "0", step: "0.00001" });
            this._zoomInButton = button$4({ type: "button", title: "Zoom In", style: "height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "20", height: "20", viewBox: "-10 -10 20 20", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.circle({ cx: -1, cy: -1, r: 6, "stroke-width": 2, stroke: ColorConfig.primaryText, fill: "none" }), SVG.path({ stroke: ColorConfig.primaryText, "stroke-width": 2, d: "M 3 3 L 7 7 M -1 -4 L -1 2 M -4 -1 L 2 -1", fill: "none" })));
            this._zoomOutButton = button$4({ type: "button", title: "Zoom Out", style: "height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "20", height: "20", viewBox: "-10 -10 20 20", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.circle({ cx: -1, cy: -1, r: 6, "stroke-width": 2, stroke: ColorConfig.primaryText, fill: "none" }), SVG.path({ stroke: ColorConfig.primaryText, "stroke-width": 2, d: "M 3 3 L 7 7 M -4 -1 L 2 -1", fill: "none" })));
            this._zoom100Button = button$4({ type: "button", title: "Zoom 100%", style: "height: var(--button-size); margin-left: 0.5em;" }, "100%");
            this._addLabelButton=button$4({type:"button",title:"Add Label"},"Labeling")
this._addLabelButton.addEventListener("click", () => {
 const visible = this._labelingContainer.style.display === "block"
 this._labelingContainer.style.display = visible ? "none" : "block"
 this._pointLabeling._open()
})
            this._loopModeSelect = select$3({ style: "width: 100%; flex-grow: 1; margin-left: 0.5em;" }, option$3({ value: 0 }, "Loop"), option$3({ value: 1 }, "Ping-Pong"), option$3({ value: 2 }, "Play Once"), option$3({ value: 3 }, "Play Loop Once"));
            this._startOffsetStepper = input$3({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveStartOffset, min: "0", step: "1" });
            this._loopStartStepper = input$3({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveLoopStart, min: "0", step: "1" });
            this._loopEndStepper = input$3({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: this._chipWaveLoopEnd, min: "0", step: "1" });
            this._playBackwardsBox = input$3({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: auto; margin-right: auto;" });
            this._playSongButton = button$4({ style: "width: 55%;", type: "button" });
            this._cancelButton = button$4({ class: "cancelButton" });
            this._okayButton = button$4({ class: "okayButton", style: "width: 25%;" }, "Okay");
            this._sampleIsLoadingMessage = div$4({ style: "margin-bottom: 0.5em; display: none;" }, "Sample is loading");
            
            this._loopControlsContainer = div$4(div$4({ style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$4({ style: `width: 100%; margin-bottom: 0.5em; text-align: center; color: ${ColorConfig.secondaryText};` }, "You can also zoom by dragging horizontally on the waveform.")), this._startOffsetHandle.canvas, this._waveformContainer, this._loopStartHandle.canvas, this._loopEndHandle.canvas, div$4({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, this._viewportOffsetSlider, this._zoomInButton, this._zoomOutButton, this._zoom100Button,this._zoomInYButton), 
            div$4({ style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right: color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop Mode"), this._loopModeSelect), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Offset"), this._startOffsetStepper), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop Start"), this._loopStartStepper), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Loop End"), this._loopEndStepper),div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;" }, div$4({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText}; align-self: center;` }, "Backwards"), this._playBackwardsBox), div$4({ style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em; justify-content: center;" },
            this._playSongButton , div$4({style:"display:flex;gap:0.5em;margin-left:2px;"},this._addLabelButton)
            )));
            this.container = div$4({ class: "prompt noSelection", style: "width: 500px;" }, div$4(h2$3({ style: "margin-bottom: 0.5em;" }, "Loop Controls"), this._sampleIsLoadingMessage, this._loopControlsContainer, div$4({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton)), this._cancelButton);
            this.gotMouseUp = false;
            this._waveformSampleLookup = (x) => {
                const n = this._waveformDataLength;
                if (x >= 0 && x < n) {
                    return this._waveformData[Math.floor(x)];
                }
                else {
                    return 0;
                }
            };
            this._waveformSamplesLookup = (x0, x1) => {
                const n = this._waveformDataLength;
                const a = Math.max(0, Math.min(n, Math.ceil(x0)));
                const b = Math.max(0, Math.min(n, Math.ceil(x1)));
                if (a >= b)
                    return [0, 0];
                let y0 = this._waveformData[a];
                let y1 = y0;
                for (let i = a + 1; i < b; i++) {
                    const v = this._waveformData[i];
                    y0 = Math.min(y0, v);
                    y1 = Math.max(y1, v);
                }
                return [y0, y1];
            };
            this.cleanUp = () => {
                this._startOffsetHandle.cleanUp();
                this._loopStartHandle.cleanUp();
                this._loopEndHandle.cleanUp();
                this.container.removeEventListener("keydown", this._whenKeyPressed);
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._viewportOffsetSlider.removeEventListener("input", this._whenViewportOffsetSliderChanges);
                this._zoomInButton.removeEventListener("click", this._whenZoomInClicked);
                this._zoomOutButton.removeEventListener("click", this._whenZoomOutClicked);
                this._zoom100Button.removeEventListener("click", this._whenZoom100Clicked);
                this._loopModeSelect.removeEventListener("change", this._whenLoopModeSelectChanges);
                this._startOffsetStepper.removeEventListener("change", this._whenStartOffsetStepperChanges);
                this._loopStartStepper.removeEventListener("change", this._whenLoopStartStepperChanges);
                this._loopEndStepper.removeEventListener("change", this._whenLoopEndStepperChanges);
                this._playBackwardsBox.removeEventListener("input", this._whenPlayBackwardsBoxChanges);
                this._playSongButton.removeEventListener("click", this._togglePlaySong);
                this._overlayCanvas.removeEventListener("mousemove", this._whenOverlayMouseMoves);
                this._overlayCanvas.removeEventListener("mousedown", this._whenOverlayMouseIsDown);
                this._overlayCanvas.removeEventListener("mouseup", this._whenOverlayMouseIsUp);
                this._overlayCanvas.removeEventListener("touchstart", this._whenOverlayTouchIsDown);
                this._overlayCanvas.removeEventListener("touchmove", this._whenOverlayTouchMoves);
                this._overlayCanvas.removeEventListener("touchend", this._whenOverlayTouchIsUp);
                this._overlayCanvas.removeEventListener("touchcancel", this._whenOverlayTouchIsUp);
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this._saveChanges = () => {
                if (!this._chipWaveIsUnavailable) {
                    this._doc.prompt = null;
                    this._instrument.chipWaveLoopMode = this._initialChipWaveLoopMode;
                    this._instrument.chipWaveStartOffset = this._initialChipWaveStartOffset;
                    this._instrument.chipWaveLoopStart = this._initialChipWaveLoopStart;
                    this._instrument.chipWaveLoopEnd = this._initialChipWaveLoopEnd;
                    this._instrument.chipWavePlayBackwards = this._initialChipWavePlayBackwards;
                    const group = new ChangeGroup();
                    group.append(new ChangeChipWaveLoopMode(this._doc, this._chipWaveLoopMode));
                    group.append(new ChangeChipWaveStartOffset(this._doc, this._chipWaveStartOffset));
                    group.append(new ChangeChipWaveLoopStart(this._doc, this._chipWaveLoopStart));
                    group.append(new ChangeChipWaveLoopEnd(this._doc, this._chipWaveLoopEnd));
                    group.append(new ChangeChipWavePlayBackwards(this._doc, this._chipWavePlayBackwards));
                    this._doc.record(group, true);
                }
                else {
                    this._doc.prompt = null;
                    this._doc.undo();
                }
            };
            this._togglePlaySong = () => {
                this._songEditor.togglePlay();
                this._updatePlaySongButton();
            };
            this._renderWaveform = () => { 
                if (this._chipWaveIsUnavailable)
                    return;
                const cnv = this._waveformCanvas;
                const ctx = this._waveformContext;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const vy0 = this._waveformViewportY0;
                const vy1 = this._waveformViewportY1;
                const sampleWidth = (vx1 - vx0) / w;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                ctx.fillRect(0, h / 2, w, 1);
                const waveformColor = ColorConfig.getComputed("--primary-text");
                if (sampleWidth < 1) {
                    ctx.strokeStyle = waveformColor;
                    ctx.lineWidth = 1;
                    let firstMove = true;
                    ctx.beginPath();
                    for (let cx = 0; cx < w; cx++) {
                        const wx = vx0 + cx * sampleWidth;
                        const wy = this._waveformSampleLookup(wx);
                        const cy = h - (wy - vy0) * h / (vy1 - vy0);
                        if (firstMove) {
                            ctx.moveTo(cx, cy);
                            firstMove = false;
                        }
                        else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    ctx.stroke();
                }
                else {
                    ctx.fillStyle = waveformColor;
                    let pcy0 = null;
                    let pcy1 = null;
                    for (let cx = 0; cx < w; cx++) {
                        const wx = vx0 + cx * sampleWidth;
                        const [wy0, wy1] = this._waveformSamplesLookup(wx - sampleWidth / 2, wx + sampleWidth / 2);
                        const cy0 = Math.max(-1, Math.min(h, h - (wy1 - vy0) * h / (vy1 - vy0)));
                        const cy1 = Math.max(-1, Math.min(h, h - (wy0 - vy0) * h / (vy1 - vy0)));
                        const cy0i = Math.floor(cy0);
                        const cy1i = Math.max(Math.ceil(cy1), cy0i + 1);
                        const ocy0 = pcy1 == null ? cy0i : Math.min(cy0i, pcy1);
                        const ocy1 = pcy0 == null ? cy1i : Math.max(cy1i, pcy0);
                        const bh = Math.max(1, ocy1 - ocy0);
                        ctx.fillRect(cx, ocy0, 1, bh);
                        pcy0 = ocy0;
                        pcy1 = ocy1;
                    }
                }
            };
            this._renderOverlay = () => {
                const cnv = this._overlayCanvas;
                const ctx = this._overlayContext;
                const w = cnv.width;
                const h = cnv.height;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const so = this._chipWaveStartOffset;
                const ls = this._chipWaveLoopStart;
                const le = this._chipWaveLoopEnd;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                const obx = Math.floor((so - vx0) * w / (vx1 - vx0));
                const oby = 0;
                const obw = 1;
                const obh = h;
                ctx.fillRect(obx, oby, obw, obh);
                ctx.fillStyle = ColorConfig.getComputed("--loop-accent");
                ctx.globalAlpha = 0.5;
                const lbx0 = Math.floor((ls - vx0) * w / (vx1 - vx0));
                const lbx1 = Math.floor((le - vx0) * w / (vx1 - vx0));
                const lbx = lbx0;
                const lby = 0;
                const lbw = lbx1 - lbx0;
                const lbh = h;
                ctx.fillRect(lbx, lby, lbw, lbh);
                ctx.globalAlpha = 1;
                if (this._overlaySelectionX0 != null && this._overlaySelectionX1 != null) {
                    ctx.fillStyle = ColorConfig.getComputed("--box-selection-fill");
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(this._overlaySelectionX0, 0, this._overlaySelectionX1 - this._overlaySelectionX0, h);
                    ctx.globalAlpha = 1;
                }
                this._drawLabelingMarkers(ctx,w,h,vx0,vx1)
            };
            this._reconfigureLoopControls = () => {
                this._loopModeSelect.value = "" + this._chipWaveLoopMode;
                this._startOffsetStepper.value = "" + this._chipWaveStartOffset;
                this._loopStartStepper.value = "" + this._chipWaveLoopStart;
                this._loopEndStepper.value = "" + this._chipWaveLoopEnd;
                this._playBackwardsBox.checked = this._chipWavePlayBackwards;
            };
            this._whenViewportOffsetSliderChanges = (event) => {
                const rawOffset = Math.max(0, Math.min(1, +event.target.value));
                const newViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, rawOffset * this._waveformViewportMaxOffset));
                this._waveformViewportOffset = Math.min(this._waveformViewportMaxOffset, newViewportOffset);
                this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoomInClicked = (event) => {
                const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, this._waveformViewportWidth / 2));
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                const centerX = this._waveformViewportX0 + (this._waveformCanvasWidth / 2) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX - (this._waveformCanvasWidth / 2) * this._waveformViewportWidth / this._waveformCanvasWidth));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoomOutClicked = (event) => {
                const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, this._waveformViewportWidth * 2));
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                const centerX = this._waveformViewportX0 + (this._waveformCanvasWidth / 2) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX - (this._waveformCanvas.width / 2) * this._waveformViewportWidth / this._waveformCanvasWidth));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                if (this._waveformViewportWidth === this._waveformDataLength) {
                    this._viewportOffsetSlider.value = "0";
                }
                else {
                    this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                }
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenZoom100Clicked = (event) => {
                const newViewportWidth = this._waveformDataLength;
                this._waveformViewportWidth = newViewportWidth;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, 0));
                this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                if (this._waveformViewportWidth === this._waveformDataLength) {
                    this._viewportOffsetSlider.value = "0";
                }
                else {
                    this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                }
                this._propagateViewportUpdate();
                this._render();
            };
            this._whenLoopModeSelectChanges = (event) => {
                const element = event.target;
                const newValue = +element.value;
                this._chipWaveLoopMode = newValue;
                this._instrument.chipWaveLoopMode = this._chipWaveLoopMode;
            };
            this._whenStartOffsetStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._startOffsetValidator(+element.value);
                this._chipWaveStartOffset = newValue;
                this._instrument.chipWaveStartOffset = this._chipWaveStartOffset;
                element.value = "" + newValue;
                this._startOffsetHandle.update(newValue);
                this._startOffsetHandle.render();
                this._renderOverlay();
            };
            this._whenLoopStartStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._loopStartValidator(+element.value);
                this._chipWaveLoopStart = newValue;
                this._instrument.chipWaveLoopStart = this._chipWaveLoopStart;
                element.value = "" + newValue;
                this._loopStartHandle.update(newValue);
                this._loopStartHandle.render();
                this._renderOverlay();
            };
            this._whenLoopEndStepperChanges = (event) => {
                const element = event.target;
                const newValue = this._loopEndValidator(+element.value);
                this._chipWaveLoopEnd = newValue;
                this._instrument.chipWaveLoopEnd = this._chipWaveLoopEnd;
                element.value = "" + newValue;
                this._loopEndHandle.update(newValue);
                this._loopEndHandle.render();
                this._renderOverlay();
            };
            this._whenPlayBackwardsBoxChanges = (event) => {
                const element = event.target;
                const newValue = element.checked;
                this._chipWavePlayBackwards = newValue;
                this._instrument.chipWavePlayBackwards = this._chipWavePlayBackwards;
            };
            this._whenOverlayMouseMoves = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayMouseIsDown = (event) => {
                this._overlayIsMouseDown = true;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX0 = mx;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayMouseIsUp = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
                this._overlayIsMouseDown = false;
                const w = this._overlayCanvas.width;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = ((event.clientX || event.pageX) - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._overlaySelectionX0 = Math.max(0, Math.min(w, this._overlaySelectionX0));
                this._overlaySelectionX1 = Math.max(0, Math.min(w, this._overlaySelectionX1));
                if (this._overlaySelectionX0 > this._overlaySelectionX1) {
                    const t = this._overlaySelectionX0;
                    this._overlaySelectionX0 = this._overlaySelectionX1;
                    this._overlaySelectionX1 = t;
                }
                let zoomAreaIsTooSmall = false;
                if (this._overlaySelectionX1 - this._overlaySelectionX0 > 2) {
                    const wosx0 = vx0 + this._overlaySelectionX0 * (vx1 - vx0) / w;
                    const wosx1 = vx0 + this._overlaySelectionX1 * (vx1 - vx0) / w;
                    const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, wosx1 - wosx0));
                    this._waveformViewportWidth = newViewportWidth;
                    this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                    const centerX = vx0 + (this._overlaySelectionX0) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                    this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX));
                    this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                    this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                    if (this._waveformViewportWidth === this._waveformDataLength) {
                        this._viewportOffsetSlider.value = "0";
                    }
                    else {
                        this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                    }
                }
                else {
                    zoomAreaIsTooSmall = true;
                }
                this._overlaySelectionX0 = null;
                this._overlaySelectionX1 = null;
                if (!zoomAreaIsTooSmall) {
                    this._propagateViewportUpdate();
                    this._render();
                }
                this._renderOverlay();
            };
            this._whenOverlayTouchIsDown = (event) => {
                event.preventDefault();
                this._overlayIsMouseDown = true;
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                this._overlaySelectionX0 = mx;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayTouchMoves = (event) => {
                if (!this._overlayIsMouseDown)
                    return;
                event.preventDefault();
                const w = this._overlayCanvas.width;
                const bounds = this._overlayCanvas.getBoundingClientRect();
                const canvasXScale = w / bounds.width;
                const mx = (event.touches[0].clientX - bounds.left) * canvasXScale;
                this._overlaySelectionX1 = mx;
                this._renderOverlay();
            };
            this._whenOverlayTouchIsUp = (event) => {
                event.preventDefault();
                if (!this._overlayIsMouseDown)
                    return;
                this.gotMouseUp = true;
                setTimeout(() => { this.gotMouseUp = false; }, 10);
                this._overlayIsMouseDown = false;
                const w = this._overlayCanvas.width;
                const vx0 = this._waveformViewportX0;
                const vx1 = this._waveformViewportX1;
                this._overlaySelectionX0 = Math.max(0, Math.min(w, this._overlaySelectionX0));
                this._overlaySelectionX1 = Math.max(0, Math.min(w, this._overlaySelectionX1));
                if (this._overlaySelectionX0 > this._overlaySelectionX1) {
                    const t = this._overlaySelectionX0;
                    this._overlaySelectionX0 = this._overlaySelectionX1;
                    this._overlaySelectionX1 = t;
                }
                let zoomAreaIsTooSmall = false;
                if (this._overlaySelectionX1 - this._overlaySelectionX0 > 2) {
                    const wosx0 = vx0 + this._overlaySelectionX0 * (vx1 - vx0) / w;
                    const wosx1 = vx0 + this._overlaySelectionX1 * (vx1 - vx0) / w;
                    const newViewportWidth = Math.max(1, Math.min(this._waveformDataLength, wosx1 - wosx0));
                    this._waveformViewportWidth = newViewportWidth;
                    this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                    const centerX = vx0 + (this._overlaySelectionX0) * (this._waveformViewportX1 - this._waveformViewportX0) / this._waveformCanvasWidth;
                    this._waveformViewportOffset = Math.max(0, Math.min(this._waveformViewportMaxOffset, centerX));
                    this._waveformViewportX0 = 0 + this._waveformViewportOffset;
                    this._waveformViewportX1 = this._waveformViewportWidth + this._waveformViewportOffset;
                    if (this._waveformViewportWidth === this._waveformDataLength) {
                        this._viewportOffsetSlider.value = "0";
                    }
                    else {
                        this._viewportOffsetSlider.value = "" + (this._waveformViewportOffset / this._waveformViewportMaxOffset);
                    }
                }
                else {
                    zoomAreaIsTooSmall = true;
                }
                this._overlaySelectionX0 = null;
                this._overlaySelectionX1 = null;
                if (!zoomAreaIsTooSmall) {
                    this._propagateViewportUpdate();
                    this._render();
                }
                this._renderOverlay();
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
                if (event.keyCode == 32) {
                    this._togglePlaySong();
                    event.preventDefault();
                }
            };
            this._updatePlaySongButton = () => {
                if (this._doc.synth.playing) {
                    this._playSongButton.classList.remove("playButton");
                    this._playSongButton.classList.add("pauseButton");
                    this._playSongButton.title = "Pause (Space)";
                    this._playSongButton.innerText = "Pause";
                }
                else {
                    this._playSongButton.classList.remove("pauseButton");
                    this._playSongButton.classList.add("playButton");
                    this._playSongButton.title = "Play (Space)";
                    this._playSongButton.innerText = "Play";
                }
            };
            this._propagateViewportUpdate = () => {
                this._startOffsetHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
                this._loopStartHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
                this._loopEndHandle.updateViewport(this._waveformViewportX0, this._waveformViewportX1);
            };
            this._render = () => {
                if (this._chipWaveIsUnavailable)
                    return;
                this._renderWaveform();
                this._startOffsetHandle.render();
                this._loopStartHandle.render();
                this._loopEndHandle.render();
                this._renderOverlay();
                 
this._zoomedYAxis=true
 if(this._zoomedYAxis && this._zoomYanabled){
  let min=Infinity,max=-Infinity
  
  
  const vx0=Math.floor(this._waveformViewportX0)
  const vx1=Math.ceil(this._waveformViewportX1)
  for(let i=vx0;i<vx1&&i<this._waveformDataLength;i++){
   const v=this._waveformData[i]
   if(v<min)min=v
   if(v>max)max=v
  }
  if(min==Infinity||max==-Infinity){min=-1;max=1}
  const pad=(max-min)*0.05
  this._waveformViewportY0=min-pad
  this._waveformViewportY1=max+pad
 }else{
 	const verticalBounds = this._waveformSamplesLookup(0, this._waveformDataLength);
const maxVerticalBound = Math.max(Math.abs(verticalBounds[0]), Math.abs(verticalBounds[1])) + 0.01;
verticalBounds[0] = -maxVerticalBound;
verticalBounds[1] = maxVerticalBound;
this._waveformViewportY0 = verticalBounds[0];
this._waveformViewportY1 = verticalBounds[1];
 }
 this._waveformViewportYRange=this._waveformViewportY1-this._waveformViewportY0
 this._renderWaveform()
 this._renderOverlay()
            };

            this._doc = _doc;
            this._songEditor = _songEditor;
            this._waveformContext = this._waveformCanvas.getContext("2d");
            this._overlayContext = this._overlayCanvas.getContext("2d");
            this._instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
            const rawChipWave = Config.chipWaves[this._instrument.chipWave];
            const customSampleIsLoading = (rawChipWave.isCustomSampled === true ) && sampleLoadingState.statusTable[this._instrument.chipWave] !== 1 && !rawChipWave.isCustomLoaded;
            if (customSampleIsLoading) {
                this._sampleIsLoadingMessage.style.display = "";
                this._loopControlsContainer.style.display = "none";
                this._chipWaveIsUnavailable = true;
            }
            else {
                this._sampleIsLoadingMessage.style.display = "none";
                this._loopControlsContainer.style.display = "";
                this._chipWaveIsUnavailable = false;
                this._waveformData = rawChipWave.samples;
                this._waveformDataLength = this._waveformData.length - 1;
                this._initialChipWaveLoopMode = this._instrument.chipWaveLoopMode;
                this._initialChipWaveStartOffset = this._instrument.chipWaveStartOffset;
                this._initialChipWaveLoopStart = this._instrument.chipWaveLoopStart;
                this._initialChipWaveLoopEnd = this._instrument.chipWaveLoopEnd;
                this._initialChipWavePlayBackwards = this._instrument.chipWavePlayBackwards;
                this._chipWaveLoopMode = this._initialChipWaveLoopMode;
                this._chipWaveStartOffset = this._initialChipWaveStartOffset;
                this._chipWaveLoopStart = this._initialChipWaveLoopStart;
                this._chipWaveLoopEnd = this._initialChipWaveLoopEnd;
                this._chipWavePlayBackwards = this._initialChipWavePlayBackwards;
                const verticalBounds = this._waveformSamplesLookup(0, this._waveformDataLength);
                const maxVerticalBound = Math.max(Math.abs(verticalBounds[0]), Math.abs(verticalBounds[1])) + 0.01;
                verticalBounds[0] = -maxVerticalBound;
                verticalBounds[1] = maxVerticalBound;
                this._waveformViewportX0 = 0;
                this._waveformViewportX1 = this._waveformDataLength;
                this._waveformViewportY0 = verticalBounds[0];
                this._waveformViewportY1 = verticalBounds[1];
                this._waveformViewportWidth = this._waveformViewportX1 - this._waveformViewportX0;
                this._waveformViewportOffset = 0;
                this._waveformViewportMaxOffset = this._waveformDataLength - this._waveformViewportWidth;
                this._startOffsetHandle.update(this._chipWaveStartOffset);
                this._loopStartHandle.update(this._chipWaveLoopStart);
                this._loopEndHandle.update(this._chipWaveLoopEnd);
                this._propagateViewportUpdate();
            }
            this._updatePlaySongButton();
            this._render();
            this._reconfigureLoopControls();
            this.container.addEventListener("keydown", this._whenKeyPressed);
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._viewportOffsetSlider.addEventListener("input", this._whenViewportOffsetSliderChanges);
            this._zoomInButton.addEventListener("click", this._whenZoomInClicked);
            this._zoomOutButton.addEventListener("click", this._whenZoomOutClicked);
            this._zoom100Button.addEventListener("click", this._whenZoom100Clicked);
            this._loopModeSelect.addEventListener("change", this._whenLoopModeSelectChanges);
            this._startOffsetStepper.addEventListener("change", this._whenStartOffsetStepperChanges);
            this._loopStartStepper.addEventListener("change", this._whenLoopStartStepperChanges);
            this._loopEndStepper.addEventListener("change", this._whenLoopEndStepperChanges);
            this._playBackwardsBox.addEventListener("input", this._whenPlayBackwardsBoxChanges);
            this._playSongButton.addEventListener("click", this._togglePlaySong);
            window.addEventListener("mousemove", this._whenOverlayMouseMoves);
            this._overlayCanvas.addEventListener("mousedown", this._whenOverlayMouseIsDown);
            window.addEventListener("mouseup", this._whenOverlayMouseIsUp);
            this._overlayCanvas.addEventListener("touchstart", this._whenOverlayTouchIsDown);
            this._overlayCanvas.addEventListener("touchmove", this._whenOverlayTouchMoves);
            this._overlayCanvas.addEventListener("touchend", this._whenOverlayTouchIsUp);
            this._overlayCanvas.addEventListener("touchcancel", this._whenOverlayTouchIsUp);
            this._pointLabeling._ldE(this)
        }
_drawLabelingMarkers(ctx, w, h, vx0, vx1) {
 const labels = this._pointLabeling.returnLabels()
 if (!labels) return
 ctx.save()
 ctx.strokeStyle = "#fff"
 ctx.fillStyle = "#fff"
 ctx.font = "12px sans-serif"
 for (const l of labels) {
  const pos = parseFloat(l.pos)
  if (isNaN(pos)) continue
  const x = (pos - vx0) * w / (vx1 - vx0)
  if (x < 0 || x > w) continue
  ctx.beginPath()
  ctx.moveTo(x, 0)
  ctx.lineTo(x, h)
  ctx.stroke()
  ctx.fillText(l.name || "", x + 4, 12)
 }
 ctx.restore()
}
    }

    const { div: div$3, h2: h2$2, span: span$2, input: input$2, button: button$3 } = HTML;
    class SampleLoadingStatusPrompt {
        constructor(_doc) {
            this._intervalDuration = 2000;
            this._interval = null;
            this._renderedWhenAllHaveStoppedChanging = false;
            this._cancelButton = button$3({ class: "cancelButton" });
            this._statusesContainer = div$3();
            this._noSamplesMessage = div$3({ style: "margin-top: 0.5em; display: none;" }, "There's no custom samples in this song.");
            this.container = div$3({ class: "prompt noSelection", style: "width: 350px;" }, div$3(h2$2("Sample Loading Status"), div$3({ style: "display: flex; flex-direction: column; align-items: center; margin-bottom: 0.5em;" }, this._noSamplesMessage, div$3({ style: "width: 100%; max-height: 350px; overflow-y: scroll;" }, this._statusesContainer))), this._cancelButton);
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
            };
            this.cleanUp = () => {
                while (this._statusesContainer.firstChild !== null) {
                    this._statusesContainer.removeChild(this._statusesContainer.firstChild);
                }
                this._cancelButton.removeEventListener("click", this._close);
                clearInterval(this._interval);
            };
            this._render = () => {
                const hasNoCustomSamples = EditorConfig.customSamples == null;
                if (hasNoCustomSamples) {
                    this._noSamplesMessage.style.display = "";
                }
                if (hasNoCustomSamples || this._renderedWhenAllHaveStoppedChanging) {
                    clearInterval(this._interval);
                    return;
                }
                let allHaveStoppedChanging = true;
                for (let chipWaveIndex = 0; chipWaveIndex < Config.chipWaves.length; chipWaveIndex++) {
                    const chipWave = Config.chipWaves[chipWaveIndex];
                    if (chipWave.isCustomSampled !== true && chipWave.isSampled !== true)
                        continue;
                    const loadingStatus = sampleLoadingState.statusTable[chipWaveIndex];
                    if (loadingStatus === 0) {
                        allHaveStoppedChanging = false;
                        break;
                    }
                }
                while (this._statusesContainer.firstChild !== null) {
                    this._statusesContainer.removeChild(this._statusesContainer.firstChild);
                }
                for (let chipWaveIndex = 0; chipWaveIndex < Config.chipWaves.length; chipWaveIndex++) {
                    const chipWave = Config.chipWaves[chipWaveIndex];
                    if (chipWave.isCustomSampled !== true && chipWave.isSampled !== true)
                        continue;
                    const sampleName = chipWave.name;
                    const url = sampleLoadingState.urlTable[chipWaveIndex];
                    const loadingStatus = getSampleLoadingStatusName(sampleLoadingState.statusTable[chipWaveIndex]);
                    const urlDisplay = input$2({ style: `margin-left: 0.5em; color: ${ColorConfig.primaryText}; background-color: ${ColorConfig.editorBackground}; width: 100%; border: 1px solid ${ColorConfig.uiWidgetBackground}; -webkit-user-select: none; -webkit-touch-callout: none; -moz-user-select: none; -ms-user-select: none; user-select: none;`, value: url, title: url, disabled: true });
                    const loadingStatusColor = loadingStatus === "loaded" ? ColorConfig.indicatorPrimary : ColorConfig.secondaryText;
                    const loadingStatusDisplay = span$2({ style: `margin-left: 0.5em; color: ${loadingStatusColor}` }, loadingStatus);
                    const chipWaveElement = div$3({ style: `padding: 0.6em; margin: 0.4em; border: 1px solid ${ColorConfig.uiWidgetBackground}; border-radius: 4px;` }, div$3({
                        class: "add-sample-prompt-sample-name",
                        style: `margin-bottom: 0.5em; color: ${ColorConfig.secondaryText}; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;`,
                        title: sampleName,
                    }, sampleName), div$3({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$3({ style: `text-align: right; color: ${ColorConfig.primaryText};` }, "URL"), urlDisplay), div$3({ style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;" }, div$3({ style: `text-align: right; color: ${ColorConfig.primaryText};` }, "Status"), loadingStatusDisplay));
                    this._statusesContainer.appendChild(chipWaveElement);
                }
                if (allHaveStoppedChanging) {
                    this._renderedWhenAllHaveStoppedChanging = true;
                }
            };
            this._doc = _doc;
            this._interval = setInterval(() => this._render(), this._intervalDuration);
            this._render();
            this._cancelButton.addEventListener("click", this._close);
        }
    }

    const { div: div$2, input: input$1, button: button$2, a, code, textarea, details, summary, span: span$1, ul, li, select: select$2, option: option$2, h2: h2$1 } = HTML;
    class AddSamplesPrompt {
        constructor(_doc) {
            this._maxSamples = 64;
            this._entries = [];
            this._entryOptionsDisplayStates = {};
            this._cancelButton = button$2({ class: "cancelButton" });
            this._okayButton = button$2({ class: "okayButton", style: "width: 45%;" }, "Okay");
            this._addSampleButton = button$2({ style: "height: auto; min-height: var(--button-size);" }, "Add sample");
            this._entryContainer = div$2();
            this._addMultipleSamplesButton = button$2({ style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;" }, "Add multiple samples");
            this._addSamplesAreaBottom = div$2({ style: "margin-top: 0.5em;" }, this._addSampleButton, this._addMultipleSamplesButton);
            this._instructionsLink = a({ href: "#" }, "Here's more information and some instructions on how to use custom samples in Studio's Box.");
            this._description = div$2(
  { style: "margin-bottom: 0.5em; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: text;" },
  "You can use these built-in samples: ",
  span$2({ style: "color:yellow; margin-right: 0.3em;" }, "legacySamples"),
  ", ",
  span$2({ style: "color:pink; margin-right: 0.3em;" }, "nintariboxSamples"),
  ", ",
  span$2({ style: "color:aqua; margin-right: 0.3em;" }, "marioPaintboxSamples"),
  ", ",
  span$2({ style: "color: orange; margin-right: 0.3em;" }, "MoreWaves"),
  " or Studio Box built-in samples: ",
  span$2({ style: "color:lime; margin-right: 0.3em;" }, "studioSamples"),
  div$2({ style: "margin-bottom: 0.5em;" }, "Or a URL sample, for example from free file hosting like filegarden. "),
  div$2( { style: "margin-bottom: 0.5em;" },"The order of these samples isnt important ."),
  div$2( { style: "margin-bottom: 0.5em;" },  this._instructionsLink));
            this._closeInstructionsButton = button$2({ style: "height: auto; min-height: var(--button-size); width: 100%;" }, "Close instructions");
            this._instructionsArea = div$2({ style: "display: none; margin-top: 0; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: text; overflow-y: auto;" }, h2$1("Add Samples"), div$2({ style: "margin-top: 0.5em; margin-bottom: 0.5em;" }, "In Slarmoo's Box, custom samples are loaded from arbitrary URLs."), div$2({ style: `margin-top: 0.5em; margin-bottom: 0.5em; color: ${ColorConfig.secondaryText};` }, "(Technically, the web server behind the URL needs to support ", a({ href: "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS", target: "_blank", }, "CORS"), ", but you don't need to know about that: ", " the sample just won't load if that's not the case)"), div$2({ style: "margin-top: 0.5em; margin-bottom: 0.5em;" }, details(summary("Why arbitrary URLs?"), a({ href: "https://pandoras-box-archive.neptendo.repl.co/" }, "A certain BeepBox mod"), " did this with one central server, but it went down, taking down", " the samples with it, though thankfully it got archived.", " This is always an issue with servers: it may run out of space,", " stop working, and so on. With arbitrary URLs, you can always ", " change them to different ones if they stop working.")), div$2({ style: "margin-top: 0.5em; margin-bottom: 0.5em;" }, "As for where to upload your samples, here are some suggestions:", ul({ style: "text-align: left;" }, li(a({ href: "https://filegarden.com" }, "File Garden")), li(a({ href: "https://www.dropbox.com" }, "Dropbox"), " (domain needs to be ", code("https://dl.dropboxusercontent.com"), ")"))), div$2({ style: "margin-top: 0.5em; margin-bottom: 0.5em;" }, "Static website hosting services may also work (such as ", a({ href: "https://pages.github.com" }, "GitHub Pages"), ")", " but those require a bit more setup."), div$2({ style: "margin-top: 0.5em; margin-bottom: 1em;" }, "Finally, if have a soundfont you'd like to get samples from, consider using this ", a({ href: "./sample_extractor.html", target: "_blank" }, "sample extractor"), "."), "Or My Sf2 Tool in the plugins menu" ,div$2({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between; margin-top: 0.5em;" }, this._closeInstructionsButton));
            this._addSamplesArea = div$2({ style: "overflow-y: auto;" }, h2$1("Add Samples"), div$2({ style: "display: flex; flex-direction: column; align-items: center; margin-bottom: 0.5em;" }, this._description, div$2({ style: "width: 100%; max-height: 450px; overflow-y: scroll;" }, this._entryContainer), this._addSamplesAreaBottom), div$2({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton));
            this._bulkAddTextarea = textarea({
                style: "width: 100%; height: 100%; resize: none; box-sizing: border-box;",
            });
            this._bulkAddConfirmButton = button$2({ style: "height: auto; min-height: var(--button-size); width: 100%;" }, "Add");
            this._bulkAddArea = div$2({ style: "display: none; overflow-y: auto;" }, h2$1({ style: "margin-bottom: 0.5em;" }, "Add Multiple Samples"), div$2({ style: "display: flex; flex-direction: column; align-items: center;" }, div$2(`Add one URL per line. Remember that you can only have ${this._maxSamples} samples!`), div$2({ style: `color: ${ColorConfig.secondaryText}` }, "(This supports the syntax used to store samples in the song URLs as well)"), div$2({ style: "width: 100%; height: 250px; margin-top: 0.5em; margin-bottom: 0.5em;" }, this._bulkAddTextarea)), div$2({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._bulkAddConfirmButton));
            this.container = div$2({ class: "prompt noSelection", style: "width: 450px; max-height: calc(100% - 100px);" }, this._addSamplesArea, this._bulkAddArea, this._instructionsArea, this._cancelButton);
            this.cleanUp = () => {
                while (this._entryContainer.firstChild !== null) {
                    this._entryContainer.removeChild(this._entryContainer.firstChild);
                }
                this._addSampleButton.removeEventListener("click", this._whenAddSampleClicked);
                this._addMultipleSamplesButton.removeEventListener("click", this._whenAddMultipleSamplesClicked);
                this._bulkAddConfirmButton.removeEventListener("click", this._whenBulkAddConfirmClicked);
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this._instructionsLink.removeEventListener("click", this._whenInstructionsLinkClicked);
                this._closeInstructionsButton.removeEventListener("click", this._whenCloseInstructionsButtonClicked);
            };
            this._close = () => {
                this._doc.prompt = null;
                this._doc.undo();
                this._saveChanges();
            };
            this._saveChanges = () => {
                const urlData = this._generateURLData();
                EditorConfig.customSamples = urlData.split("|").filter(x => x !== ""); 
                Config.willReloadForCustomSamples = true;
                window.location.hash = this._doc.song.toBase64String();
                setTimeout(() => { reloadsite() }, 50);
            };
            this._whenAddSampleClicked = (event) => {
                const entryIndex = this._entries.length;
                this._entries.push({
                    url: "",
                    sampleRate: 44100,
                    rootKey: 60,
                    percussion: false,
                    chipWaveLoopStart: null,
                    chipWaveLoopEnd: null,
                    chipWaveStartOffset: null,
                    chipWaveLoopMode: null,
                    chipWavePlayBackwards: false,
                });
                this._entryOptionsDisplayStates[entryIndex] = false;
                this._reconfigureAddSampleButton();
                this._render(true);
            };
            this._whenAddMultipleSamplesClicked = (event) => {
                this._addSamplesArea.style.display = "none";
                this._bulkAddArea.style.display = "";
                this._bulkAddTextarea.value = "";
            };
            this._whenInstructionsLinkClicked = (event) => {
                event.preventDefault();
                this._addSamplesArea.style.display = "none";
                this._instructionsArea.style.display = "";
            };
            this._whenCloseInstructionsButtonClicked = (event) => {
                this._addSamplesArea.style.display = "";
                this._instructionsArea.style.display = "none";
            };
            this._whenBulkAddConfirmClicked = (event) => {
                this._addSamplesArea.style.display = "";
                this._bulkAddArea.style.display = "none";
                const parsed = this._parseURLs(this._bulkAddTextarea.value
                    .replace(/\n/g, "|")
                    .split("|")
                    .filter((x) => x !== ""), false);
                const seen = new Map();
                for (const entry of this._entries) {
                    seen.set(entry.url, true);
                }
                for (const entry of parsed.entries) {
                    if (this._entries.length >= this._maxSamples)
                        break;
                    if (seen.has(entry.url))
                        continue;
                    seen.set(entry.url, true);
                    const entryIndex = this._entries.length;
                    this._entries.push(entry);
                    this._entryOptionsDisplayStates[entryIndex] = false;
                }
                this._reconfigureAddSampleButton();
                this._render(false);
            };
            this._whenOptionsAreToggled = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                if (element.open) {
                    this._entryOptionsDisplayStates[entryIndex] = true;
                }
                else {
                    this._entryOptionsDisplayStates[entryIndex] = false;
                }
            };
            this._whenURLChanges = (event) => {
                var _a, _b;
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                this._entries[entryIndex].url = element.value;
                const sampleNameElement = (_b = (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.querySelector(".add-sample-prompt-sample-name");
                if (sampleNameElement != null) {
                    const sampleName = this._getSampleName(this._entries[entryIndex]);
                    sampleNameElement.innerText = sampleName;
                    sampleNameElement.title = sampleName;
                }
            };
            this._whenSampleRateChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const value = clamp(8000, 96000 + 1, parseFloatWithDefault(element.value, 44100));
                this._entries[entryIndex].sampleRate = value;
            };
            this._whenRootKeyChanges = (event) => {
                var _a, _b;
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const value = parseFloatWithDefault(element.value, 60);
                this._entries[entryIndex].rootKey = value;
                const rootKeyDisplay = (_b = (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.querySelector(".add-sample-prompt-root-key-display"); 
                if (rootKeyDisplay != null) {
                    const noteName = this._noteNameFromPitchNumber(this._entries[entryIndex].rootKey);
                    if (noteName !== "") {
                        rootKeyDisplay.innerText = `(${noteName})`;
                    }
                }
            };
            this._whenPercussionChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                this._entries[entryIndex].percussion = element.checked ? true : false;
            };
            this._whenChipWaveLoopStartChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const value = parseIntWithDefault(element.value, null);
                this._entries[entryIndex].chipWaveLoopStart = value;
            };
            this._whenChipWaveLoopEndChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const value = parseIntWithDefault(element.value, null);
                this._entries[entryIndex].chipWaveLoopEnd = value;
            };
            this._whenChipWaveStartOffsetChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const value = parseIntWithDefault(element.value, null);
                this._entries[entryIndex].chipWaveStartOffset = value;
            };
            this._whenChipWaveLoopModeChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const newValue = +element.value;
                if (newValue === -1) {
                    this._entries[entryIndex].chipWaveLoopMode = null;
                }
                else {
                    this._entries[entryIndex].chipWaveLoopMode = newValue;
                }
            };
            this._whenChipWavePlayBackwardsChanges = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const newValue = element.checked;
                this._entries[entryIndex].chipWavePlayBackwards = newValue;
            };
            this._whenCopyLinkPresetClicked = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                this._copyTextToClipboard(this._generateURLDataForEntry(this._entries[entryIndex]));
            };
            this._whenRemoveSampleClicked = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                this._entryOptionsDisplayStates[entryIndex] = false;
                this._entries.splice(entryIndex, 1);
                this._reconfigureAddSampleButton();
                this._render(false);
            };
            this._whenMoveSampleUpClicked = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const upEntryIndex = entryIndex - 1;
                if (this._entries.length >= 2 && upEntryIndex >= 0) {
                    const upEntry = this._entries[upEntryIndex];
                    const entry = this._entries[entryIndex];
                    const upEntryOptionsVisibility = this._entryOptionsDisplayStates[upEntryIndex];
                    const entryOptionsVisibility = this._entryOptionsDisplayStates[entryIndex];
                    this._entries[upEntryIndex] = entry;
                    this._entries[entryIndex] = upEntry;
                    this._entryOptionsDisplayStates[upEntryIndex] = entryOptionsVisibility;
                    this._entryOptionsDisplayStates[entryIndex] = upEntryOptionsVisibility;
                    this._render(false);
                }
            };
            this._whenMoveSampleDownClicked = (event) => {
                const element = event.target;
                const entryIndex = +(element.dataset.index);
                const downEntryIndex = entryIndex + 1;
                if (this._entries.length >= 2 && downEntryIndex < this._entries.length) {
                    const downEntry = this._entries[downEntryIndex];
                    const entry = this._entries[entryIndex];
                    const downEntryOptionsVisibility = this._entryOptionsDisplayStates[downEntryIndex];
                    const entryOptionsVisibility = this._entryOptionsDisplayStates[entryIndex];
                    this._entries[downEntryIndex] = entry;
                    this._entries[entryIndex] = downEntry;
                    this._entryOptionsDisplayStates[downEntryIndex] = entryOptionsVisibility;
                    this._entryOptionsDisplayStates[entryIndex] = downEntryOptionsVisibility;
                    this._render(false);
                }
            };
            this._reconfigureAddSampleButton = () => {
                if (this._entries.length >= this._maxSamples) {
                    this._addSampleButton.style.display = "none";
                }
                else {
                    this._addSampleButton.style.display = "";
                }
            };
            this._parseURLs = (urls, parseOldSyntax) => {
                function sliceForSampleRate(url) {
                    const newUrl = url.slice(0, url.indexOf(","));
                    const sampleRate = clamp(8000, 96000 + 1, parseFloatWithDefault(url.slice(url.indexOf(",") + 1), 44100));
                    return [newUrl, sampleRate];
                }
                function sliceForRootKey(url) {
                    const newUrl = url.slice(0, url.indexOf("!"));
                    const rootKey = parseFloatWithDefault(url.slice(url.indexOf("!") + 1), 60);
                    return [newUrl, rootKey];
                }
                let useLegacySamples = false;
                let useNintariboxSamples = false;
                let useMarioPaintboxSamples = false;
                let useStudioBoxSamples = false;
                const parsedEntries = [];
                for (const url of urls) {
                    if (url === "")
                        continue;
                    if (url.toLowerCase() === "legacysamples") {
                        if (!useLegacySamples) {
                            parsedEntries.push({
                                url: "legacySamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: false,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: false,
                            });
                        }
                        useLegacySamples = true;
                    }
                    else if (url.toLowerCase() === "nintariboxsamples") {
                        if (!useNintariboxSamples) {
                            parsedEntries.push({
                                url: "nintariboxSamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: false,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: false,
                            });
                        }
                        useNintariboxSamples = true;
                    }
                    else if (url.toLowerCase() === "mariopaintboxsamples") {
                        if (!useMarioPaintboxSamples) {
                            parsedEntries.push({
                                url: "marioPaintboxSamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: false,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: false,
                            });
                        }
                        useMarioPaintboxSamples = true; 
                    }else if (url.toLowerCase() === "studiosamples") {
                        if (!useStudioBoxSamples) {
                            parsedEntries.push({
                                url: "studiosamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: false,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: false,
                            });
                        }
                        useStudioBoxSamples = true;
                    }
                    else {
                        let urlSliced = url;
                        let sampleRate = 44100;
                        let rootKey = 60;
                        let percussion = false;
                        let chipWaveLoopStart = null;
                        let chipWaveLoopEnd = null;
                        let chipWaveStartOffset = null;
                        let chipWaveLoopMode = null;
                        let chipWavePlayBackwards = false;
                        let optionsStartIndex = url.indexOf("!");
                        let optionsEndIndex = -1;
                        let parsedSampleOptions = false;
                        if (optionsStartIndex === 0) {
                            optionsEndIndex = url.indexOf("!", optionsStartIndex + 1);
                            if (optionsEndIndex !== -1) {
                                const rawOptions = url.slice(optionsStartIndex + 1, optionsEndIndex).split(",");
                                for (const rawOption of rawOptions) {
                                    const optionCode = rawOption.charAt(0);
                                    const optionData = rawOption.slice(1, rawOption.length);
                                    if (optionCode === "s") {
                                        sampleRate = clamp(8000, 96000 + 1, parseFloatWithDefault(optionData, 44100));
                                    }
                                    else if (optionCode === "r") {
                                        rootKey = parseFloatWithDefault(optionData, 60);
                                    }
                                    else if (optionCode === "p") {
                                        percussion = true;
                                    }
                                    else if (optionCode === "a") {
                                        chipWaveLoopStart = parseIntWithDefault(optionData, null);
                                    }
                                    else if (optionCode === "b") {
                                        chipWaveLoopEnd = parseIntWithDefault(optionData, null);
                                    }
                                    else if (optionCode === "c") {
                                        chipWaveStartOffset = parseIntWithDefault(optionData, null);
                                    }
                                    else if (optionCode === "d") {
                                        chipWaveLoopMode = parseIntWithDefault(optionData, null);
                                        if (chipWaveLoopMode != null) {
                                            chipWaveLoopMode = clamp(0, 3 + 1, chipWaveLoopMode);
                                        }
                                    }
                                    else if (optionCode === "e") {
                                        chipWavePlayBackwards = true;
                                    }
                                }
                                urlSliced = url.slice(optionsEndIndex + 1, url.length);
                                parsedSampleOptions = true;
                            }
                        }
                        if (parseOldSyntax) {
                            if (!parsedSampleOptions) {
                                if (url.indexOf("@") != -1) {
                                    urlSliced = url.replaceAll("@", "");
                                    percussion = true;
                                }
                                if (url.indexOf(",") != -1 && url.indexOf("!") != -1) {
                                    if (url.indexOf(",") < url.indexOf("!")) {
                                        [urlSliced, rootKey] = sliceForRootKey(urlSliced);
                                        [urlSliced, sampleRate] = sliceForSampleRate(urlSliced);
                                    }
                                    else {
                                        [urlSliced, sampleRate] = sliceForSampleRate(urlSliced);
                                        [urlSliced, rootKey] = sliceForRootKey(urlSliced);
                                    }
                                }
                                else {
                                    if (url.indexOf(",") != -1) {
                                        [urlSliced, sampleRate] = sliceForSampleRate(urlSliced);
                                    }
                                    if (url.indexOf("!") != -1) {
                                        [urlSliced, rootKey] = sliceForRootKey(urlSliced);
                                    }
                                }
                            }
                        }
                        parsedEntries.push({
                            url: urlSliced,
                            sampleRate: sampleRate,
                            rootKey: rootKey,
                            percussion: percussion,
                            chipWaveLoopStart: chipWaveLoopStart,
                            chipWaveLoopEnd: chipWaveLoopEnd,
                            chipWaveStartOffset: chipWaveStartOffset,
                            chipWaveLoopMode: chipWaveLoopMode,
                            chipWavePlayBackwards: chipWavePlayBackwards,
                        });
                    }
                }
                return { entries: parsedEntries };
            };
            this._generateURLDataForEntry = (entry) => {
                const url = entry.url.trim();
                const sampleRate = entry.sampleRate;
                const rootKey = entry.rootKey;
                const percussion = entry.percussion;
                const chipWaveLoopStart = entry.chipWaveLoopStart;
                const chipWaveLoopEnd = entry.chipWaveLoopEnd;
                const chipWaveStartOffset = entry.chipWaveStartOffset;
                const chipWaveLoopMode = entry.chipWaveLoopMode;
                const chipWavePlayBackwards = entry.chipWavePlayBackwards;
                const urlInLowerCase = url.toLowerCase();
                const isBundledSamplePack = (urlInLowerCase === "legacysamples"|| urlInLowerCase === "nintariboxsamples"
                || urlInLowerCase === "mariopaintboxsamples" || urlInLowerCase === "studiosamples");
                const options = [];
                if (sampleRate !== 44100)
                    options.push("s" + sampleRate);
                if (rootKey !== 60)
                    options.push("r" + rootKey);
                if (percussion)
                    options.push("p");
                if (chipWaveLoopStart != null)
                    options.push("a" + chipWaveLoopStart);
                if (chipWaveLoopEnd != null)
                    options.push("b" + chipWaveLoopEnd);
                if (chipWaveStartOffset != null)
                    options.push("c" + chipWaveStartOffset);
                if (chipWaveLoopMode != null)
                    options.push("d" + chipWaveLoopMode);
                if (chipWavePlayBackwards)
                    options.push("e");
                if (isBundledSamplePack || options.length <= 0) {
                    return url;
                }
                else {
                    return "!" + options.join(",") + "!" + url;
                }
            };
            this._generateURLData = () => {
                let output = "";
                for (const entry of this._entries) {
                    const url = entry.url.trim();
                    if (url === "")
                        continue;
                    output += "|" + this._generateURLDataForEntry(entry);
                }
                return output;
            };
            this._getSampleName = (entry) => {
                try {
                    const parsedUrl = new URL(entry.url);
                    return decodeURIComponent(parsedUrl.pathname.replace(/^([^\/]*\/)+/, ""));
                }
                catch (error) {
                    return entry.url;
                }
            };
            this._noteNameFromPitchNumber = (n) => {
                function wrap(x, b) {
                    return (x % b + b) % b;
                }
                n = Math.floor(n) - 12;
                const pitchNameIndex = wrap(n + Config.keys[this._doc.song.key].basePitch, Config.pitchesPerOctave);
                let pitch = "";
                if (Config.keys[pitchNameIndex].isWhiteKey) {
                    pitch = Config.keys[pitchNameIndex].name;
                }
                else {
                    const shiftDir = Config.blackKeyNameParents[wrap(n, Config.pitchesPerOctave)];
                    pitch = Config.keys[wrap(pitchNameIndex + Config.pitchesPerOctave + shiftDir, Config.pitchesPerOctave)].name;
                    if (shiftDir == 1) {
                        pitch += "";
                    }
                    else if (shiftDir == -1) {
                        pitch += "";
                    }
                }
                pitch += Math.floor(n / Config.pitchesPerOctave);
                return pitch;
            };  
            this._render = (scrollToBottom) => {
                while (this._entryContainer.firstChild !== null) {
                    this._entryContainer.removeChild(this._entryContainer.firstChild);
                }
                for (let entryIndex = 0; entryIndex < this._entries.length; entryIndex++) {
                    const canMoveUp = this._entries.length >= 2 && entryIndex > 0;
                    const canMoveDown = this._entries.length >= 2 && entryIndex < this._entries.length - 1;
                    const entry = this._entries[entryIndex];
                    const optionsVisible = Boolean(this._entryOptionsDisplayStates[entryIndex]);
                    const urlInput = input$1({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", value: entry.url });
                    const sampleRateStepper = input$1({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: "" + entry.sampleRate, min: "8000", max: "96000", step: "1" });
                    const rootKeyStepper = input$1({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: "" + entry.rootKey, min: "0", max: Config.maxPitch + Config.pitchesPerOctave, step: "1" });
                    const rootKeyDisplay = span$1({ class: "add-sample-prompt-root-key-display", style: "margin-left: 0.4em; width: 3em; text-align: left; text-overflow: ellipsis; overflow: hidden; flex-shrink: 0;" }, `(${this._noteNameFromPitchNumber(entry.rootKey)})`);
                    const percussionBox = input$1({ style: "width: 1em; margin-left: 1em;", type: "checkbox" });
                    const chipWaveLoopStartStepper = input$1({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: "" + (entry.chipWaveLoopStart != null ? entry.chipWaveLoopStart : ""), min: "0", step: "1" });
                    const chipWaveLoopEndStepper = input$1({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: "" + (entry.chipWaveLoopEnd != null ? entry.chipWaveLoopEnd : ""), min: "0", step: "1" });
                    const chipWaveStartOffsetStepper = input$1({ style: "flex-grow: 1; margin-left: 1em; width: 100%;", type: "number", value: "" + (entry.chipWaveStartOffset != null ? entry.chipWaveStartOffset : ""), min: "0", step: "1" });
                    const chipWaveLoopModeSelect = select$2({ style: "width: 100%; flex-grow: 1; margin-left: 0.5em;" }, option$2({ value: -1 }, ""), option$2({ value: 0 }, "Loop"), option$2({ value: 1 }, "Ping-Pong"), option$2({ value: 2 }, "Play Once"), option$2({ value: 3 }, "Play Loop Once"));
                    if (entry.chipWaveLoopMode != null) {
                        chipWaveLoopModeSelect.value = "" + entry.chipWaveLoopMode;
                    }
                    const chipWavePlayBackwardsBox = input$1({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: auto; margin-right: auto;" });
                    chipWavePlayBackwardsBox.checked = entry.chipWavePlayBackwards;
                    const sampleName = this._getSampleName(entry);
                    percussionBox.checked = entry.percussion;
                    const copyLinkPresetButton = button$2({ style: "height: auto; min-height: var(--button-size);", title: "For use with \"Add multiple samples\"" }, "Copy link preset");
                    const removeButton = button$2({ style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;" }, "Remove");
                    const moveUpButton = button$2({ style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "16", height: "16", viewBox: "-13 -14 26 26", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.path({ d: "M -6 6 L 0 -6 L 6 6 z", fill: ColorConfig.primaryText })));
                    const moveDownButton = button$2({ style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;" }, SVG.svg({ width: "16", height: "16", viewBox: "-13 -14 26 26", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.path({ d: "M -6 -6 L 6 -6 L 0 6 z", fill: ColorConfig.primaryText })));
                    const optionsContainer = details({ open: optionsVisible, style: "margin-bottom: 2em; margin-top: 1em;" }, summary({ style: "margin-bottom: 1em;" }, "Options"), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `flex-shrink: 0; :text-align: right; color: ${ColorConfig.primaryText};` }, span$1({ title: "What rate to resample to" }, "Sample rate")), sampleRateStepper), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `text-align: right; color: ${ColorConfig.primaryText}; flex-shrink: 0;` }, span$1({ title: "Pitch where the sample is played as-is" }, "Root key")), rootKeyDisplay, rootKeyStepper), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between; margin-bottom: 0.5em;" }, div$2({ style: `text-align: right; color: ${ColorConfig.primaryText};` }, "Percussion (pitch doesn't change with key)"), percussionBox), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText};` }, span$1({ title: "Applies to the \"Loop Start\" loop control option of the preset created for this sample" }, "Loop Start")), chipWaveLoopStartStepper), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText};` }, span$1({ title: "Applies to the \"Loop End\" loop control option of the preset created for this sample" }, "Loop End")), chipWaveLoopEndStepper), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText};` }, span$1({ title: "Applies to the \"Offset\" loop control option of the preset created for this sample" }, "Sample Start Offset")), chipWaveStartOffsetStepper), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText};` }, span$1({ title: "Applies to the \"Loop Mode\" loop control option of the preset created for this sample" }, "Loop Mode")), chipWaveLoopModeSelect), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `flex-shrink: 0; text-align: right; color: ${ColorConfig.primaryText};` }, span$1({ title: "Applies to the \"Backwards\" loop control option of the preset created for this sample" }, "Backwards")), chipWavePlayBackwardsBox));
                    urlInput.dataset.index = "" + entryIndex;
                    sampleRateStepper.dataset.index = "" + entryIndex;
                    rootKeyStepper.dataset.index = "" + entryIndex;
                    percussionBox.dataset.index = "" + entryIndex;
                    chipWaveLoopStartStepper.dataset.index = "" + entryIndex;
                    chipWaveLoopEndStepper.dataset.index = "" + entryIndex;
                    chipWaveStartOffsetStepper.dataset.index = "" + entryIndex;
                    chipWaveLoopModeSelect.dataset.index = "" + entryIndex;
                    chipWavePlayBackwardsBox.dataset.index = "" + entryIndex;
                    copyLinkPresetButton.dataset.index = "" + entryIndex;
                    removeButton.dataset.index = "" + entryIndex;
                    moveUpButton.dataset.index = "" + entryIndex;
                    moveDownButton.dataset.index = "" + entryIndex;
                    optionsContainer.dataset.index = "" + entryIndex;
                    const bottomButtons = div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;" }, copyLinkPresetButton, removeButton);
                    if (canMoveUp) {
                        bottomButtons.appendChild(moveUpButton);
                    }
                    if (canMoveDown) {
                        bottomButtons.appendChild(moveDownButton);
                    }
                    const entryElement = div$2({ style: `padding: 0.6em; margin: 0.4em; border: 1px solid ${ColorConfig.uiWidgetBackground}; border-radius: 4px;` }, div$2({
                        class: "add-sample-prompt-sample-name",
                        style: `margin-bottom: 0.5em; color: ${ColorConfig.secondaryText}; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;`,
                        title: sampleName,
                    }, sampleName), div$2({ style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;" }, div$2({ style: `text-align: right; color: ${ColorConfig.primaryText};` }, "URL"), urlInput), optionsContainer, bottomButtons);
                    optionsContainer.addEventListener("toggle", this._whenOptionsAreToggled);
                    urlInput.addEventListener("change", this._whenURLChanges);
                    sampleRateStepper.addEventListener("change", this._whenSampleRateChanges);
                    rootKeyStepper.addEventListener("change", this._whenRootKeyChanges);
                    percussionBox.addEventListener("change", this._whenPercussionChanges);
                    chipWaveLoopStartStepper.addEventListener("change", this._whenChipWaveLoopStartChanges);
                    chipWaveLoopEndStepper.addEventListener("change", this._whenChipWaveLoopEndChanges);
                    chipWaveStartOffsetStepper.addEventListener("change", this._whenChipWaveStartOffsetChanges);
                    chipWaveLoopModeSelect.addEventListener("change", this._whenChipWaveLoopModeChanges);
                    chipWavePlayBackwardsBox.addEventListener("change", this._whenChipWavePlayBackwardsChanges);
                    copyLinkPresetButton.addEventListener("click", this._whenCopyLinkPresetClicked);
                    removeButton.addEventListener("click", this._whenRemoveSampleClicked);
                    if (canMoveUp) {
                        moveUpButton.addEventListener("click", this._whenMoveSampleUpClicked);
                    }
                    if (canMoveDown) {
                        moveDownButton.addEventListener("click", this._whenMoveSampleDownClicked);
                    }
                    this._entryContainer.appendChild(entryElement);
                    const thisIsTheLastElement = entryIndex === this._entries.length - 1;
                    if (scrollToBottom && thisIsTheLastElement) {
                        entryElement.scrollIntoView({ "block": "nearest", "inline": "nearest" });
                    }
                }
            };
            this._doc = _doc;
            if (EditorConfig.customSamples != null) {
                const parsed = this._parseURLs(EditorConfig.customSamples, false);
                this._entries = parsed.entries;
            }
            this._addSampleButton.addEventListener("click", this._whenAddSampleClicked);
            this._addMultipleSamplesButton.addEventListener("click", this._whenAddMultipleSamplesClicked);
            this._bulkAddConfirmButton.addEventListener("click", this._whenBulkAddConfirmClicked);
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this._instructionsLink.addEventListener("click", this._whenInstructionsLinkClicked);
            this._closeInstructionsButton.addEventListener("click", this._whenCloseInstructionsButtonClicked);
            this._reconfigureAddSampleButton();
            this._render(false);
        }
        _copyTextToClipboard(text) {
            let nav;
            nav = navigator;
            if (nav.clipboard && nav.clipboard.writeText) {
                nav.clipboard.writeText(text).catch(() => {
                    window.prompt("Copy to clipboard:", text);
                });
                return;
            }
            const textField = document.createElement("textarea");
            textField.textContent = text;
            document.body.appendChild(textField);
            textField.select();
            const succeeded = document.execCommand("copy");
            textField.remove();
            this.container.focus({ preventScroll: true });
            if (!succeeded)
                window.prompt("Copy this:", text);
        }
    }

    const { button: button$1, div: div$1, h2, select: select$1, option: option$1 } = HTML;
    class ShortenerConfigPrompt {
        constructor(_doc) {
            this._doc = _doc;
            this._shortenerStrategySelect = select$1({ style: "width: 100%;" }, option$1({ value: "tinyurl" }, "tinyurl.com"), option$1({ value: "isgd" }, "is.gd"));
            this._cancelButton = button$1({ class: "cancelButton" });
            this._okayButton = button$1({ class: "okayButton", style: "width:45%;" }, "Okay");
            this.container = div$1({ class: "prompt noSelection", style: "width: 250px;" }, h2("Configure Shortener"), div$1({ style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;" }, div$1({ class: "selectContainer", style: "width: 100%;" }, this._shortenerStrategySelect)), div$1({ style: "display: flex; flex-direction: row-reverse; justify-content: space-between;" }, this._okayButton), this._cancelButton);
            this._close = () => {
                this._doc.undo();
            };
            this.cleanUp = () => {
                this._okayButton.removeEventListener("click", this._saveChanges);
                this._cancelButton.removeEventListener("click", this._close);
                this.container.removeEventListener("keydown", this._whenKeyPressed);
            };
            this._whenKeyPressed = (event) => {
                if (event.target.tagName != "BUTTON" && event.keyCode == 13) {
                    this._saveChanges();
                }
            };
            this._saveChanges = () => {
                window.localStorage.setItem("shortenerStrategySelect", this._shortenerStrategySelect.value);
                this._doc.prompt = null;
                this._doc.undo();
            };
            const lastStrategy = window.localStorage.getItem("shortenerStrategySelect");
            if (lastStrategy != null) {
                this._shortenerStrategySelect.value = lastStrategy;
            }
            this._okayButton.addEventListener("click", this._saveChanges);
            this._cancelButton.addEventListener("click", this._close);
            this.container.addEventListener("keydown", this._whenKeyPressed);
        }
    }

    const { button, div, input, select, span, optgroup, option, canvas } = HTML;
    function buildOptions(menu, items) {
        for (let index = 0; index < items.length; index++) {
            menu.appendChild(option({ value: index }, items[index]));
        }
        return menu;
    }
    function buildHeaderedOptions(header, menu, items) {
        menu.appendChild(option({ selected: true, disabled: true, value: header }, header));
        for (const item of items) {
            menu.appendChild(option({ value: item }, item));
        }
        return menu;
    }
    function buildPresetOptions(isNoise, idSet) {
        const menu = select({ id: idSet, class: "presetSelect" });
        if (isNoise) {
            menu.appendChild(option({ value: 2 }, EditorConfig.valueToPreset(2).name));
            menu.appendChild(option({ value: 3 }, EditorConfig.valueToPreset(3).name));
            menu.appendChild(option({ value: 4 }, EditorConfig.valueToPreset(4).name));
        }
        else {
            menu.appendChild(option({ value: 0 }, EditorConfig.valueToPreset(0).name));
            menu.appendChild(option({ value: 9 }, EditorConfig.valueToPreset(9).name));
            menu.appendChild(option({ value: 6 }, EditorConfig.valueToPreset(6).name));
            menu.appendChild(option({ value: 8 }, EditorConfig.valueToPreset(8).name));
            menu.appendChild(option({ value: 1 }, EditorConfig.valueToPreset(1).name));
            menu.appendChild(option({ value: 11 }, EditorConfig.instrumentToPreset(11).name));
            menu.appendChild(option({ value: 12 }, EditorConfig.instrumentToPreset(12).name));
            menu.appendChild(option({ value: 5 }, EditorConfig.valueToPreset(5).name));
            menu.appendChild(option({ value: 7 }, EditorConfig.valueToPreset(7).name));
            menu.appendChild(option({ value: 3 }, EditorConfig.valueToPreset(3).name));
            menu.appendChild(option({ value: 2 }, EditorConfig.valueToPreset(2).name));
        }
        const randomGroup = optgroup({ label: "Randomize " });
        randomGroup.appendChild(option({ value: "randomPreset" }, "Random Preset"));
        randomGroup.appendChild(option({ value: "randomGenerated" }, "Random Generated"));
        menu.appendChild(randomGroup);
        let firstCategoryGroup = null;
        let customSampleCategoryGroup = null;
        for (let categoryIndex = 1; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {
            const category = EditorConfig.presetCategories[categoryIndex];
            
            const group = optgroup({ label: category.name + " " });
            let foundAny = false;
            for (let presetIndex = 0; presetIndex < category.presets.length; presetIndex++) {
                const preset = category.presets[presetIndex];
                if ((preset.isNoise == true) == isNoise) {
                    group.appendChild(option({ value: (categoryIndex << 6) + presetIndex }, preset.name)); 
                    foundAny = true;
                }
            }
            if (categoryIndex === 1 && foundAny) {
                firstCategoryGroup = group;
            }
            else if (category.name === "Custom Sample Presets" && foundAny) {
                customSampleCategoryGroup = group;
            }
            if (category.name == "String Presets" && foundAny) {
                let moveViolin2 = group.removeChild(group.children[11]);
                group.insertBefore(moveViolin2, group.children[1]);
            }
            if (category.name == "Flute Presets" && foundAny) {
                let moveFlute2 = group.removeChild(group.children[11]);
                group.insertBefore(moveFlute2, group.children[1]);
            }
            if (category.name == "Keyboard Presets" && foundAny) {
                let moveGrandPiano2 = group.removeChild(group.children[9]);
                let moveGrandPiano3 = group.removeChild(group.children[9]);
                group.insertBefore(moveGrandPiano3, group.children[1]);
                group.insertBefore(moveGrandPiano2, group.children[1]);
            }
            if (foundAny)
                menu.appendChild(group);
        }
        if (firstCategoryGroup != null && customSampleCategoryGroup != null) {
            const parent = customSampleCategoryGroup.parentNode;
            parent.removeChild(customSampleCategoryGroup);
            parent.insertBefore(customSampleCategoryGroup, firstCategoryGroup);
        }
        return menu;
    }
    function setSelectedValue(menu, value, isSelect2 = false) {
        const stringValue = value.toString();
        if (menu.value != stringValue) {
            menu.value = stringValue;
            if (isSelect2) {
                $(menu).val(value).trigger('change.select2');
            }
        }
    }
    class CustomChipCanvas {
        constructor(canvas, _doc, _getChange) {
            this.canvas = canvas;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._onMouseMove = (event) => {
                if (this.mouseDown) {
                    var x = (event.clientX || event.pageX) - this.canvas.getBoundingClientRect().left;
                    var y = Math.floor((event.clientY || event.pageY) - this.canvas.getBoundingClientRect().top);
                    if (y < 2)
                        y = 2;
                    if (y > 50)
                        y = 50;
                    var ctx = this.canvas.getContext("2d");
                    if (this.continuousEdit == true && Math.abs(this.lastX - x) < 40) {
                        var lowerBound = (x < this.lastX) ? x : this.lastX;
                        var upperBound = (x < this.lastX) ? this.lastX : x;
                        for (let i = lowerBound; i <= upperBound; i += 2) {
                            var progress = (Math.abs(x - this.lastX) > 2.0) ? ((x > this.lastX) ?
                                1.0 - ((i - lowerBound) / (upperBound - lowerBound))
                                : ((i - lowerBound) / (upperBound - lowerBound))) : 0.0;
                            var j = Math.round(y + (this.lastY - y) * progress);
                            ctx.fillStyle = ColorConfig.getComputed("--editor-background");
                            ctx.fillRect(Math.floor(i / 2) * 2, 0, 2, 53);
                            ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                            ctx.fillRect(Math.floor(i / 2) * 2, 25, 2, 2);
                            ctx.fillStyle = ColorConfig.getComputed("--track-editor-bg-pitch-dim");
                            ctx.fillRect(Math.floor(i / 2) * 2, 13, 2, 1);
                            ctx.fillRect(Math.floor(i / 2) * 2, 39, 2, 1);
                            ctx.fillStyle = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
                            ctx.fillRect(Math.floor(i / 2) * 2, j - 2, 2, 4);
                            this.newArray[Math.floor(i / 2)] = (j - 26);
                        }
                    }
                    else {
                        ctx.fillStyle = ColorConfig.getComputed("--editor-background");
                        ctx.fillRect(Math.floor(x / 2) * 2, 0, 2, 52);
                        ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
                        ctx.fillRect(Math.floor(x / 2) * 2, 25, 2, 2);
                        ctx.fillStyle = ColorConfig.getComputed("--track-editor-bg-pitch-dim");
                        ctx.fillRect(Math.floor(x / 2) * 2, 13, 2, 1);
                        ctx.fillRect(Math.floor(x / 2) * 2, 39, 2, 1);
                        ctx.fillStyle = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
                        ctx.fillRect(Math.floor(x / 2) * 2, y - 2, 2, 4);
                        this.newArray[Math.floor(x / 2)] = (y - 26);
                    }
                    this.continuousEdit = true;
                    this.lastX = x;
                    this.lastY = y;
                    let instrument = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()];
                    let sum = 0.0;
                    for (let i = 0; i < this.newArray.length; i++) {
                        sum += this.newArray[i];
                    }
                    const average = sum / this.newArray.length;
                    let cumulative = 0;
                    let wavePrev = 0;
                    for (let i = 0; i < this.newArray.length; i++) {
                        cumulative += wavePrev;
                        wavePrev = this.newArray[i] - average;
                        instrument.customChipWaveIntegral[i] = cumulative;
                    }
                    instrument.customChipWaveIntegral[64] = 0.0;
                }
            };
            this._onMouseDown = (event) => {
                this.mouseDown = true;
                this._onMouseMove(event);
            };
            this._onMouseUp = () => {
                this.mouseDown = false;
                this.continuousEdit = false;
                this._whenChange();
            };
            this._whenChange = () => {
                this._change = this._getChange(this.newArray);
                this._doc.record(this._change);
                this._change = null;
            };
            canvas.addEventListener("mousemove", this._onMouseMove);
            canvas.addEventListener("mousedown", this._onMouseDown);
            canvas.addEventListener("mouseup", this._onMouseUp);
            canvas.addEventListener("mouseleave", this._onMouseUp);
            this.mouseDown = false;
            this.continuousEdit = false;
            this.lastX = 0; 
            this.lastY = 0;
            this.newArray = new Float32Array(64);
            this.renderedArray = new Float32Array(64);
            this.renderedColor = "";
            this.redrawCanvas();
        }
        redrawCanvas() {
            const chipData = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].customChipWave;
            const renderColor = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
            let needsRedraw = false;
            if (renderColor != this.renderedColor) {
                needsRedraw = true;
            }
            else
                for (let i = 0; i < 64; i++) {
                    if (chipData[i] != this.renderedArray[i]) {
                        needsRedraw = true;
                        i = 64;
                    }
                }
            if (!needsRedraw) {
                return;
            }
            this.renderedArray.set(chipData);
            var ctx = this.canvas.getContext("2d");
            ctx.fillStyle = ColorConfig.getComputed("--editor-background");
            ctx.fillRect(0, 0, 128, 52);
            ctx.fillStyle = ColorConfig.getComputed("--ui-widget-background");
            ctx.fillRect(0, 25, 128, 2);
            ctx.fillStyle = ColorConfig.getComputed("--track-editor-bg-pitch-dim");
            ctx.fillRect(0, 13, 128, 1);
            ctx.fillRect(0, 39, 128, 1);
            ctx.fillStyle = renderColor;
            for (let x = 0; x < 64; x++) {
                var y = chipData[x] + 26;
                ctx.fillRect(x * 2, y - 2, 2, 4);
                this.newArray[x] = y - 26;
            }
        }
    }
    class CustomAlgorythmCanvas { 
        constructor(canvas, _doc, _getChange) {
            this.canvas = canvas;
            this._doc = _doc;
            this._getChange = _getChange;
            this._change = null;
            this._Box=this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].type==12?8:6
            this._onMouseMove = (event) => {
                var _a, _b, _c, _d;
                if (this.mouseDown) { 
                    var S =this._Box == 8? 0.5:0.5
                    const rect = this.canvas.getBoundingClientRect();const scaleX = this.canvas.width / rect.width;const scaleY = this.canvas.height / rect.height;const x = ((event.clientX - rect.left) * scaleX)*S;const y = ((event.clientY - rect.top) * scaleY) *S;
                    var ctx = this.canvas.getContext("2d");
                    ctx.fillStyle = ColorConfig.getComputedChannelColor(this._doc.song, this._doc.channel).primaryNote;
                    let cellSize = this.canvas.width / this._Box;
                   var xindex = Math.floor((x - 12) / 24);
                   var yindex = Math.floor(y / 24)
                    
                    yindex = yindex >= 0 && yindex <= this._Box-1 ? yindex : -1;
                    xindex = xindex >= 0 && xindex <= this._Box-1 ? xindex : -1;
                    ctx.fillRect(xindex * 24 + 12, yindex * 24, 2, 2);
                    if (this.selected == -1) {
                        if (((_b = (_a = this.drawArray) === null || _a === void 0 ? void 0 : _a[yindex]) === null || _b === void 0 ? void 0 : _b[xindex]) != undefined) {
                            this.selected = this.drawArray[yindex][xindex];
                            ctx.fillRect(xindex * 24 + 12, yindex * 24, 12, 12);
                            ctx.fillStyle = ColorConfig.getComputed("--editor-background");
                            ctx.fillText(this.drawArray[yindex][xindex] + "", xindex * 24 + 14, yindex * 24 + 10);
                            this.mouseDown = false;
                        }
                    }
                    else {
                        if (((_d = (_c = this.drawArray) === null || _c === void 0 ? void 0 : _c[yindex]) === null || _d === void 0 ? void 0 : _d[xindex]) != undefined) {const newmod2 = this.drawArray[yindex][xindex];if (this.mode !== "feedback" && this.selected === newmod2) {this.selected = -1;this.redrawCanvas(true);this.mouseDown = false;return;}
                            if (this.mode == "feedback") {
                                const newmod = this.drawArray[yindex][xindex];
                                let check = this.feedback[newmod - 1].indexOf(this.selected);
                                if (check != -1) {
                                    this.feedback[newmod - 1].splice(check, 1);
                                }
                                else {
                                    this.feedback[newmod - 1].push(this.selected);
                                }
                            }
                            else {
                                if (this.drawArray[yindex][xindex] == this.selected) {
                                    if (this.selected == this.carriers) {
                                        if (this.selected > 1) {
                                            this.carriers--;
                                        }
                                    }
                                    else if (this.selected - 1 == this.carriers) {
                                        this.carriers++;
                                    }
                                }
                                else {
                                    const newmod = this.drawArray[yindex][xindex];
                                    if (this.selected > newmod) {
                                        let check = this.newMods[newmod - 1].indexOf(this.selected);
                                        if (check != -1) {
                                            this.newMods[newmod - 1].splice(check, 1);
                                        }
                                        else {
                                            this.newMods[newmod - 1].push(this.selected);
                                        }
                                    }
                                    else {
                                        let check = this.newMods[this.selected - 1].indexOf(newmod);
                                        if (check != -1) {
                                            this.newMods[this.selected - 1].splice(check, 1);
                                        }
                                        else {
                                            this.newMods[this.selected - 1].push(newmod);
                                        }
                                    }
                                }
                            }
                            this.selected = -1;
                            this.redrawCanvas(true);
                            this.mouseDown = false;
                        }
                        else {
                            this.selected = -1;
                            this.redrawCanvas(true);
                            this.mouseDown = false;
                        }
                    }
                }
            };
            this._onMouseDown = (event) => {
                this.mouseDown = true;
                this._onMouseMove(event);
            };
            this._onMouseUp = () => {
                this.mouseDown = false;
                this._whenChange();
            };
            this._whenChange = () => {
            	for (let i = 0; i < this._Box; i++) {if (!this.newMods[i]) this.newMods[i] = [];}
                this._change = this._getChange(this.mode == "algorithm" ? this.newMods : this.feedback, this.carriers, this.mode);
                this._doc.record(this._change);
                this._change = null;
            };
            canvas.addEventListener("mousemove", this._onMouseMove);
            canvas.addEventListener("mousedown", this._onMouseDown);
            canvas.addEventListener("mouseup", this._onMouseUp);
            canvas.addEventListener("mouseleave", this._onMouseUp);
            this.mouseDown = false;
            this.drawArray = Array.from({ length: this._Box }, () => []);
            this.lookUpArray = Array.from({ length: this._Box }, () => []);
            this.carriers = 1;
            this.selected = -1;
            this.newMods = Array.from({ length: this._Box }, () => []);
            this.inverseModulation = Array.from({ length: this._Box }, () => []);
            this.feedback = Array.from({ length: this._Box }, () => []);
            this.inverseFeedback = Array.from({ length: this._Box }, () => []);
            this.mode = "algorithm";
            this.redrawCanvas();
        }
        reset() {
            this.redrawCanvas(false);
            this.selected = -1;
        }
normalizeAlgorithm(oldMods) {
    const max = this._Box;
    if (oldMods.carrierCount > max) {
        oldMods.carrierCount = max;
    }
    oldMods.modulatedBy = oldMods.modulatedBy
        .slice(0, max)
        .map(row => row.filter(op => op <= max)); 
    if (oldMods.customFeedbackType?.indices) {
        oldMods.customFeedbackType.indices =
            oldMods.customFeedbackType.indices
                .slice(0, max)
                .map(row => row.filter(op => op <= max));
    }
    return oldMods;
}

        fillDrawArray(noReset = false) {
        	var oldMods =
    this._doc.song.channels[this._doc.channel]
        .instruments[this._doc.getCurrentInstrument()]
        .customAlgorithm;
        oldMods = this.normalizeAlgorithm(oldMods);
            if (noReset) {
                this.drawArray = [];
                this.drawArray = Array.from({ length: this._Box }, () => []);
                this.inverseModulation = Array.from({ length: this._Box }, () => []);
                this.lookUpArray = Array.from({ length: this._Box }, () => []);
                for (let i = 0; i < this.newMods.length; i++) {
                    for (let o = 0; o < this.newMods[i].length; o++) {
                        this.inverseModulation[this.newMods[i][o] - 1].push(i + 1);
                    }
                }
                if (this.mode == "feedback") {
                    this.inverseFeedback = Array.from({ length: this._Box }, () => []);
                    for (let i = 0; i < this.feedback.length; i++) {
                        for (let o = 0; o < this.feedback[i].length; o++) {
                            this.inverseFeedback[this.feedback[i][o] - 1].push(i + 1);
                        }
                    }
                }
            }
            else {
                this.drawArray = [];
                this.drawArray = Array.from({ length: this._Box }, () => []);
                this.carriers = 1;
                this.newMods = Array.from({ length: this._Box }, () => []);
                this.inverseModulation = Array.from({ length: this._Box }, () => []);
                this.lookUpArray = Array.from({ length: this._Box }, () => []);
                if (this._Box == 8){
                 this.drawArray = [];
                this.drawArray = Array.from({ length: this._Box }, () => []);
                this.carriers = 1;
                this.newMods = Array.from({ length: this._Box }, () => []);
                this.inverseModulation = Array.from({ length: this._Box }, () => []);
                this.lookUpArray = Array.from({ length: this._Box }, () => []);
                }
                var oldMods = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].customAlgorithm;
                this.carriers = oldMods.carrierCount;
                for (let i = 0; i < oldMods.modulatedBy.length; i++) {
                    for (let o = 0; o < oldMods.modulatedBy[i].length; o++) {
                        this.inverseModulation[oldMods.modulatedBy[i][o] - 1].push(i + 1);
                        this.newMods[i][o] = oldMods.modulatedBy[i][o];
                    }
                }
                if (this.mode == "feedback") {
                    this.feedback = Array.from({ length: this._Box }, () => []);
                    this.inverseFeedback = Array.from({ length: this._Box }, () => [])
                    var oldfeed = this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].customFeedbackType.indices;
                    for (let i = 0; i < oldfeed.length; i++) {
                        for (let o = 0; o < oldfeed[i].length; o++) {
                            this.inverseFeedback[oldfeed[i][o] - 1].push(i + 1);
                            this.feedback[i][o] = oldfeed[i][o];
                        }
                    }
                }
            }
       const inv = this.inverseModulation || [];
    for (let i = 0; i < inv.length; i++) {
    if (i < this.carriers) {
        this.drawArray[this.drawArray.length - 1][i] = i + 1;
        this.lookUpArray[i] = [0, i];
        continue;
    }
    const mods = inv[i];
    let testPos = null;
    if (mods && mods.length) {
        const lastMod = mods[mods.length - 1] - 1;
        const ref = this.lookUpArray[lastMod];
        if (ref) {
            testPos = [
                this.drawArray.length - (ref[0] + 2),
                ref[1]
            ];
        }
    }
    if (!testPos) {
        testPos = [this._Box - 1, 0];
    }
    while (
        testPos[0] >= 0 &&
        testPos[0] < this.drawArray.length &&
        testPos[1] < this._Box &&
        this.drawArray[testPos[0]][testPos[1]] !== undefined
    ) {
        testPos[1]++;
    }
    if (
        testPos[0] >= 0 &&
        testPos[0] < this.drawArray.length &&
        testPos[1] < this._Box
    ) {
        this.drawArray[testPos[0]][testPos[1]] = i + 1;
        this.lookUpArray[i] = [
            this.drawArray.length - (testPos[0] + 1),
            testPos[1]
        ];
      }
    }
        }
        drawLines(ctx) {
            if (this.mode == "feedback") {
                for (let off = 0; off < this._Box; off++) {
                    ctx.strokeStyle = ColorConfig.getArbitaryChannelColor("pitch", off).primaryChannel;
                    const set = off * 2 + 0.5;
                    for (let i = 0; i < this.inverseFeedback[off].length; i++) {
                        let tar = this.inverseFeedback[off][i] - 1;
                        let srtpos = this.lookUpArray[off];
                        let tarpos = this.lookUpArray[tar];
                        ctx.beginPath();
                        ctx.moveTo(srtpos[1] * 24 + 12 + set, (this._Box - srtpos[0] - 1) * 24 + 12);
                        ctx.lineTo(srtpos[1] * 24 + 12 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                        if (tarpos[1] != srtpos[1]) {
                            let side = 0;
                            if (tarpos[0] >= srtpos[0]) {
                                side = 24;
                            }
                            ctx.lineTo(srtpos[1] * 24 + side + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                            if ((tarpos[1] == (srtpos[1] - 1)) && (tarpos[0] <= (srtpos[0] - 1))) ;
                            else {
                                if (tarpos[0] >= srtpos[0]) {
                                    ctx.lineTo((tarpos[1] + 1) * 24 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                                    ctx.lineTo((tarpos[1] + 1) * 24 + set, (this._Box- tarpos[0] - 1) * 24 + 12 + set);
                                }
                                else {
                                    ctx.lineTo(srtpos[1] * 24 + set, (6 - tarpos[0] - 1) * 24 + 12 + set);
                                    ctx.lineTo((tarpos[1] + 1) * 24 + set, (this._Box - tarpos[0] - 1) * 24 + 12 + set);
                                }
                            }
                            ctx.lineTo((tarpos[1] + 1) * 24 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                            ctx.lineTo((tarpos[1]) * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                            ctx.lineTo((tarpos[1]) * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24);
                        }
                        else {
                            if (srtpos[0] - tarpos[0] == 1) {
                                ctx.lineTo((tarpos[1]) * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24);
                            }
                            else {
                                if (tarpos[0] >= srtpos[0]) {
                                    ctx.lineTo(srtpos[1] * 24 + 24 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                                    ctx.lineTo(srtpos[1] * 24 + 24 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                                    ctx.lineTo(tarpos[1] * 24 + set + 12, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                                    ctx.lineTo(tarpos[1] * 24 + set + 12, (this._Box - tarpos[0] - 1) * 24);
                                }
                                else {
                                    ctx.lineTo(srtpos[1] * 24 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                                    ctx.lineTo(srtpos[1] * 24 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                                    ctx.lineTo(tarpos[1] * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                                    ctx.lineTo(tarpos[1] * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24);
                                }
                            }
                        }
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
                return;
            }
            for (let off = 0; off < this._Box; off++) {
                ctx.strokeStyle = ColorConfig.getArbitaryChannelColor("pitch", off).primaryChannel;
                const set = off * 2 - 1 + 0.5;
                for (let i = 0; i < this.inverseModulation[off].length; i++) {
                    let tar = this.inverseModulation[off][i] - 1;
                    let srtpos = this.lookUpArray[off];
                    let tarpos = this.lookUpArray[tar];
                    ctx.beginPath();
                    ctx.moveTo(srtpos[1] * 24 + 12 + set, (this._Box - srtpos[0] - 1) * 24 + 12);
                    ctx.lineTo(srtpos[1] * 24 + 12 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                    if ((tarpos[1]) != srtpos[1]) {
                        ctx.lineTo(srtpos[1] * 24 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                        if ((tarpos[1] == (srtpos[1] - 1)) && (tarpos[0] <= (srtpos[0] - 1))) ;
                        else {
                            ctx.lineTo(srtpos[1] * 24 + set, (this._Box - tarpos[0] - 1) * 24 + 12 + set);
                            ctx.lineTo((tarpos[1] + 1) * 24 + set, (this._Box - tarpos[0] - 1) * 24 + 12 + set);
                        }
                        ctx.lineTo((tarpos[1] + 1) * 24 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                        ctx.lineTo((tarpos[1]) * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                        ctx.lineTo((tarpos[1]) * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24);
                    }
                    else {
                        if (Math.abs(tarpos[0] - srtpos[0]) == 1) {
                            ctx.lineTo((tarpos[1]) * 24 + 12 + set, (this._Box- tarpos[0] - 1) * 24);
                        }
                        else {
                            ctx.lineTo(srtpos[1] * 24 + set, (this._Box - srtpos[0] - 1) * 24 + 12 + set);
                            ctx.lineTo(srtpos[1] * 24 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                            ctx.lineTo(srtpos[1] * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24 + set - 12);
                            ctx.lineTo(srtpos[1] * 24 + 12 + set, (this._Box - tarpos[0] - 1) * 24);
                        }
                    }
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
       redrawCanvas(noReset=false){
this._Box=this._doc.song.channels[this._doc.channel].instruments[this._doc.getCurrentInstrument()].type==12?8:6
if(this._Box==8){
	this.canvas.style.width="180px";
	this.canvas.style.height="180px";
}else{
	this.canvas.style.width = "180px";
this.canvas.style.height = "180px";
}
this.canvas.width=this._Box*24*2
this.canvas.height=this._Box*24*2
this.fillDrawArray(noReset)
const ctx=this.canvas.getContext("2d")
const S=2
ctx.setTransform(1,0,0,1,0,0)
ctx.scale(S,S)
ctx.fillStyle=ColorConfig.getComputed("--editor-background")
ctx.fillRect(0,0,this._Box*24,this._Box*24)
for(let x=0;x<this._Box;x++){
for(let y=0;y<this._Box;y++){
ctx.fillStyle=ColorConfig.getComputed("--track-editor-bg-pitch-dim")
ctx.fillRect(x*24+12,y*24,12,12)
ctx.fillStyle=ColorConfig.getComputed("--editor-background")
ctx.fillRect(x*24+13,y*24+1,10,10)
if(this.drawArray[y][x]!==undefined){
if(this.drawArray[y][x]<=this.carriers){
ctx.fillStyle=ColorConfig.getComputed("--primary-text")
ctx.fillRect(x*24+12,y*24,12,12)
ctx.fillStyle=ColorConfig.getComputed("--editor-background")
ctx.fillRect(x*24+13,y*24+1,10,10)
ctx.fillStyle=ColorConfig.getComputedChannelColor(this._doc.song,this._doc.channel).primaryNote
ctx.fillText(this.drawArray[y][x]+"",x*24+14,y*24+10)
}else{
ctx.fillStyle=ColorConfig.getComputedChannelColor(this._doc.song,this._doc.channel).primaryNote
ctx.fillRect(x*24+12,y*24,12,12)
ctx.fillStyle=ColorConfig.getComputed("--editor-background")
ctx.fillRect(x*24+13,y*24+1,10,10)
ctx.fillStyle=ColorConfig.getComputed("--primary-text")
ctx.fillText(this.drawArray[y][x]+"",x*24+14,y*24+10)
}}}}
this.drawLines(ctx)
}
}
    
class WhistleRecordContainer {
	constructor(parent = document.body, _doc = this._doc) {
		this.parent = parent;
		this.container = document.createElement("div");
		Object.assign(this.container.style, {
			position: "fixed",
			left: "50%",
			top: "50%",
			transform: "translate(-50%,-50%)",
			background: "var(--editor-background)",
			border: `2px solid ${ColorConfig.uiWidgetBackground}`,
			borderRadius: "8px",
			padding: "12px",
			zIndex: 100,
			color: ColorConfig.primaryText,
			width: "280px",
			maxHeight: "90vh",
			overflow: "hidden scroll ",
			fontFamily: "sans-serif",
			display: "none",
		});
		
		const title = document.createElement("h2");
		title.textContent = "Whistle Settings";
		title.style.margin = "0 0 10px 0";
		title.style.textAlign = "center";
		this.container.appendChild(title);

		this.inputStable = this._mkInput("Stable N", _doc.synth.STABLE_N);
		this.inputSilence = this._mkInput("Silence N", _doc.synth.SILENCE_N);
		this.inputMin = this._mkInput("Min Note MS", _doc.synth.MIN_NOTE_MS);
		this.inputChange = this._mkInput("Change Hold MS", _doc.synth.CHANGE_HOLD_MS);
		this.inputDb = this._mkInput("dB MIN", _doc.synth.Db);
		this.inputShift = this._mkInput("Pitch Shift", _doc.synth.SHIFT);
		this.inputTolerance = this._mkInput("Tolerance", _doc.synth.TOLERANCE);
		this.inputNoteHold = this._mkInput("Note Hold", _doc.synth.NOTE_HOLD_EXTRA);
		const btnRow = document.createElement("div");
		Object.assign(btnRow.style, { display: "flex", justifyContent: "flex-end", gap: "6px" });
		this.btnCancel = this._mkBtn("Cancel");
		this.btnDone = this._mkBtn("Done");
		btnRow.appendChild(this.btnCancel);
		btnRow.appendChild(this.btnDone);
		this.container.appendChild(btnRow);
const description = document.createElement("pre");
description.textContent = `\n\nStable N - How many frames of subsequent measurements must indicate the same note\n\nSilence N - How many frames of silence end the note\n\nMin Note Ms - minimal note length \n\nChange Hold Ms - just holds note even if you stop whistling`;
description.style.margin = "0 0 10px 0";
description.style.fontSize = "10px";
description.style.whiteSpace = "pre-wrap";

this.container.appendChild(description);
		this.parent.appendChild(this.container);
		
		this.btnCancel.onclick = () => this.hide();
		this.btnDone.onclick = () => {
			const params = {
				STABLE_N: Number(this.inputStable.value),
				SILENCE_N: Number(this.inputSilence.value),
				MIN_NOTE_MS: Number(this.inputMin.value),
				CHANGE_HOLD_MS: Number(this.inputChange.value),
				DB: Number(this.inputDb.value),
				Shift: Number(this.inputShift.value),
				TOLERANCE: Number(this.inputTolerance.value),
				NOTE_HOLD_EXTRA: Number(this.inputNoteHold.value),
			};
			if (this.ondone) this.ondone(params);
			this.hide();
		};
		
		this.ondone = null;
	}
	
	_mkInput(label, def) {
		const wrap = document.createElement("div");
		wrap.style.marginBottom = "6px";
		const lbl = document.createElement("label");
		lbl.textContent = label;
		lbl.style.display = "block";
		lbl.style.marginBottom = "2px";
		const inp = document.createElement("input");
		inp.type = "number";
		inp.value = def;
		Object.assign(inp.style, {
			width: "100%",
			padding: "4px",
			boxSizing: "border-box",
			background: "transparent",
			color: ColorConfig.primaryText,
			border: `1px solid ${ColorConfig.uiWidgetBackground}`
		});
		wrap.appendChild(lbl);
		wrap.appendChild(inp);
		this.container.appendChild(wrap);
		return inp;
	}
	
	_mkBtn(txt) {
		const b = document.createElement("button");
		b.textContent = txt;
		Object.assign(b.style, {
			padding: "6px 10px",
			cursor: "pointer",
			borderRadius: "4px",
			border: "1px solid #555",
			background: "#333",
			color: "#fff",
		});
		return b;
	}
	
	show() { this.container.style.display = "block"; }
	hide() { this.container.style.display = "none"; }
	destroy() { this.container.remove(); }
}
        

let lastScrollY = 0
let savedScrollY=0
window.addEventListener("scroll", () => {
	lastScrollY = window.scrollY
})
class CustomSelectModal{
 constructor(songDoc){
  let activeSelect=null
  const overlay=document.createElement('div')
  const modal=document.createElement('div')
  const overlayt=document.createElement('div')
  modal.appendChild(overlayt)
  overlay.appendChild(modal)
  document.body.appendChild(overlay)
  let theme='light'
  try{
   if(typeof NativeJava!=='undefined'&&NativeJava.getSheme)theme=NativeJava.getSheme()
   else{
    const mqDark=window.matchMedia('(prefers-color-scheme: dark)')
    const mqLight=window.matchMedia('(prefers-color-scheme: light)')
    if(mqDark.matches)theme='dark'
    else if(mqLight.matches)theme='light'
    else{
     const el=document.documentElement
     const bg=getComputedStyle(el).getPropertyValue('background-color')||''
     theme=(bg.indexOf('0, 0, 0')>-1||bg.indexOf('#292929')>-1)?'dark':'light'
    }
    const mq=mqDark.matches?mqDark:mqLight
    mq.addEventListener?.('change',e=>{document.documentElement.dataset.theme=e.matches?'dark':'light'})
    mq.addListener?.(e=>{document.documentElement.dataset.theme=e.matches?'dark':'light'})
   }
  }catch(e){}
  document.documentElement.dataset.theme=theme
  const isDark=theme==='dark'
  const bg=isDark?'#292929':'#FFFFFF'
  const fg=isDark?'#FFFFFF':'#000000'
  const border=isDark?'#292929':'#CCCCCC'
  const overlayBg=isDark?'rgba(0,0,0,0.6)':'rgba(0,0,0,0.5)'
  const circleBorder=isDark?'#FFFFFF':'#000000'
  const circleFill=isDark?'#FFFFFF':'#000000'
  overlay.style.cssText=`display:none;position:fixed;inset:0;z-index:1052;background:${overlayBg};justify-content:center;align-items:center;`
  modal.style.cssText=`display:flex;flex-direction:column;width:90%;height:90%;background:${bg};color:${fg};overflow:hidden;overflow-y:scroll;position:relative;`
  overlayt.style.cssText='display:flex;flex-direction:column;width:100%;height:100%;overflow:hidden;overflow-y:scroll;padding:2px;'
  function lockScroll(){
   savedScrollY=window.scrollY
   document.body.style.position='fixed'
   document.body.style.top=`-${savedScrollY}px`
   document.body.style.left='0'
   document.body.style.right='0'
   document.body.style.overflow='hidden'
   document.documentElement.style.overflow='hidden'
  }
  function unlockScroll(){
   document.body.style.position=''
   document.body.style.top=''
   document.body.style.left=''
   document.body.style.right=''
   document.body.style.overflow=''
   document.documentElement.style.overflow=''
   window.scrollTo(0,savedScrollY)
  }
  function closeOverlay(){
   overlay.style.display='none'
   window.CustomSelectModalOpen=false
   window.CustomSelectModalActiveSelect=null
   activeSelect=null
   unlockScroll()
  }
  function buildOverlayForSelect(sel,currentState){
   overlayt.innerHTML=''
   Array.from(sel.children).forEach(node=>{
    if(node.tagName==='OPTGROUP'&&!node.hidden){
     const group=document.createElement('div')
     group.style.cssText=`display:flex;flex-direction:column;width:100%;padding-bottom:8px;`
     const label=document.createElement('div')
     label.textContent=node.label
     label.style.cssText=`font-weight:500;padding:10px 16px;border-bottom:1px solid ${border};`
     group.appendChild(label)
     Array.from(node.children).forEach(opt=>{
      if(opt.hidden||opt.style.display==='none')return
      const item=document.createElement('div')
      item.style.cssText=`display:flex;align-items:center;gap:10px;padding:8px 16px;width:100%;cursor:default;position:relative;`
      const circle=document.createElement('div')
      circle.style.cssText=`width:16px;height:16px;border:2px solid ${circleBorder};border-radius:50%;position:absolute;left:calc(100% - 64px);`
      if(opt.value===sel.value)circle.style.background=circleFill
      const text=document.createElement('span')
      text.textContent=opt.textContent
      item.append(text,circle)
      item.addEventListener('mousedown',ev=>{
      ev.stopPropagation()
       sel.value=opt.value
       sel.selectedIndex=opt.index
       sel.focus()
       unlockScroll()
       overlay.style.display='none'
       sel.dispatchEvent(new Event('input',{bubbles:true}))
       sel.dispatchEvent(new Event('change',{bubbles:true}))
      },{once:true})
      group.appendChild(item)
     })
     overlayt.appendChild(group)
    }else if (node.tagName === 'OPTION' && !node.hidden && node.style.display !== 'none') {
    const item = document.createElement('div');
    item.style.cssText = `display:flex;align-items:center;gap:10px;padding:8px 16px;width:100%;position:relative;`;

    const text = document.createElement('span');
    text.textContent = node.textContent;
    item.appendChild(text);

    if (!node.disabled) {
        const circle = document.createElement('div');
        circle.style.cssText = `width:16px;height:16px;border:2px solid ${circleBorder};border-radius:50%;position:absolute;left:calc(100% - 64px);`;
        if (node.value === sel.value) circle.style.background = circleFill;
        item.appendChild(circle);

        item.addEventListener('mousedown', ev => {
            ev.stopPropagation();
            sel.value = node.value;
            sel.selectedIndex = node.index;
            node.selected = true;
            unlockScroll();
            overlay.style.display = 'none';
            sel.dispatchEvent(new Event('input', { bubbles: true }));
            sel.dispatchEvent(new Event('change', { bubbles: true }));
        }, { once: true });
    } else {
        item.style.opacity = '0.5';
        item.style.cursor = 'not-allowed';
    }

    overlayt.appendChild(item);
}

   })
  }
  function attachSelects(root=document.body){
   let currentState=history.state||{}
   setTimeout(function(){
   root.querySelectorAll('select').forEach(sel => {

    if (sel.disabled) {
        sel.style.opacity = '0.5';
        sel.style.cursor = 'not-allowed';

        if (sel.dataset.bound) {
            sel.removeEventListener('mousedown', sel.handler);
            delete sel.dataset.bound;
        }
        return;
    }

    if (!sel.handler) {
        sel.handler = e => {
            lockScroll();
            e.preventDefault();
            e.stopPropagation();
            activeSelect = sel;
            window.CustomSelectModalActiveSelect = sel;
            window.CustomSelectModalOpen = true;
            overlay.style.display = 'flex';
            overlayt.innerHTML = '';
            buildOverlayForSelect(sel, currentState);
        };
    }

    if (songDoc.prefs.useCustomSelectPrompt) {
        if (!sel.dataset.bound) {
            sel.addEventListener('mousedown', sel.handler);
            sel.dataset.bound = true;
        }
    } else {
        if (sel.dataset.bound) {
            sel.removeEventListener('mousedown', sel.handler);
            delete sel.dataset.bound;
        }
    }
});

   },200);
  }
  attachSelects()
  const observer=new MutationObserver(m=>m.forEach(r=>{
   r.addedNodes&&r.addedNodes.forEach(n=>{if(n.nodeType===1)attachSelects(n)})
  }))
  observer.observe(document.body,{childList:true,subtree:true})
  document.addEventListener('mousedown',e=>{
   if(overlay.style.display!=='none'){
    unlockScroll()
    if(overlay.style.display==='flex'&&!overlay.contains(e.target))closeOverlay()
   }
  })
  overlay.addEventListener('mousedown',e=>{
   if(overlay.style.display!=='none'){
    e.stopPropagation()
    unlockScroll()
    window.scrollTo(0,savedScrollY)
    closeOverlay()
   }
  })
  window.CustomSelectModalOpen=false
  window.CustomSelectModalActiveSelect=null
 }
}
    class SongEditor {
        constructor() {
            this.prompt = null;
            this.doc = new SongDocument();
          this.customSelectPrompt = new CustomSelectModal(this.doc)
            this._keyboardLayout = new KeyboardLayout(this.doc);
            this._patternEditorPrev = new PatternEditor(this.doc, false, -1);
            this._patternEditor = new PatternEditor(this.doc, true, 0);
            this._patternEditorNext = new PatternEditor(this.doc, false, 1);
            this._trackEditor = new TrackEditor(this.doc, this);
            this._muteEditor = new MuteEditor(this.doc, this);
            this._loopEditor = new LoopEditor(this.doc, this._trackEditor);
            this._piano = new Piano(this.doc);
            this._octaveScrollBar = new OctaveScrollBar(this.doc, this._piano);
            this._playButton = button({ class: "playButton", type: "button", title: "Play (Space)" }, span("Play"));
            this._pauseButton = button({ class: "pauseButton", style: "display: none;", type: "button", title: "Pause (Space)" }, "Pause");
            this._recordButton = button({ class: "recordButton", style: "display: none;", type: "button", title: "Record (Ctrl+Space)" }, span("Record"));
            this._stopButton = button({ class: "stopButton", style: "display: none;", type: "button", title: "Stop Recording (Space)" }, "Stop Recording");
            this._prevBarButton = button({ class: "prevBarButton", type: "button", title: "Previous Bar (left bracket)" });
            this._nextBarButton = button({ class: "nextBarButton", type: "button", title: "Next Bar (right bracket)" });
            this._volumeSlider = new Slider(input({ title: "main volume", style: "width: 5em; flex-grow: 1; margin: 0;", type: "range", min: "0", max: "75", value: "50", step: "1" }), this.doc, null, false); 
            this._outVolumeBarBg = SVG.rect({ "pointer-events": "none", width: "90%", height: "50%", x: "5%", y: "25%", fill: ColorConfig.uiWidgetBackground });
            this._outVolumeBar = SVG.rect({ "pointer-events": "none", height: "50%", width: "0%", x: "5%", y: "25%", fill: "url('#volumeGrad2')" });
            this._outVolumeCap = SVG.rect({ "pointer-events": "none", width: "2px", height: "50%", x: "5%", y: "25%", fill: ColorConfig.uiWidgetFocus });
            this._stop1 = SVG.stop({ "stop-color": "lime", offset: "60%" });
            this._stop2 = SVG.stop({ "stop-color": "orange", offset: "90%" });
            this._stop3 = SVG.stop({ "stop-color": "red", offset: "100%" });
            this._gradient = SVG.linearGradient({ id: "volumeGrad2", gradientUnits: "userSpaceOnUse" }, this._stop1, this._stop2, this._stop3);
            this._defs = SVG.defs({}, this._gradient);
            this._volumeBarContainer = SVG.svg({ style: `touch-action: none; overflow: visible; margin: auto; max-width: 20vw;`, width: "160px", height: "100%", preserveAspectRatio: "none", viewBox: "0 0 160 12" }, this._defs, this._outVolumeBarBg, this._outVolumeBar, this._outVolumeCap);
            this._volumeBarBox = div({ class: "playback-volume-bar", style: "height: 12px; align-self: center;" }, this._volumeBarContainer);
            this._fileMenu = select({ style: "width: 100%;" }, option({ selected: true, disabled: true, hidden: false }, "File"), option({ value: "new" }, "+ New Blank Song (`)"), option({ value: "import" }, " Import Song... (" + EditorConfig.ctrlSymbol + "O)"), option({ value: "export" }, " Export Song... (" + EditorConfig.ctrlSymbol + "S)"), option({ value: "copyUrl" }, " Copy Song URL"), option({ value: "shareUrl" }, " Share Song URL"), option({ value: "configureShortener" }, " Customize Url Shortener..."), option({ value: "shortenUrl" }, " Shorten Song URL"), option({ value: "viewPlayer" }, " View in Song Player (P)"), option({ value: "copyEmbed" }, " Copy HTML Embed Code"), option({ value: "songRecovery" }, " Recover Recent Song... (`)"));
            this._editMenu = select({ style: "width: 100%;" }, option({ selected: true, disabled: true, hidden: false }, "Edit Song"), option({ value: "undo" }, "Undo (Z)"), option({ value: "redo" }, "Redo (Y)"), option({ value: "copy" }, "Copy Pattern (C)"), option({ value: "pasteNotes" }, "Paste Pattern Notes (V)"),   option({ value: "pasteNumbers" }, "Paste Pattern Numbers (" + EditorConfig.ctrlSymbol + "V)"), option({ value: "insertBars" }, "Insert Bar ()"), option({ value: "deleteBars" }, "Delete Selected Bars ()"), option({ value: "insertChannel" }, "Insert Channel (" + EditorConfig.ctrlSymbol + ")"), option({ value: "deleteChannel" }, "Delete Selected Channels (" + EditorConfig.ctrlSymbol + ")"), option({ value: "selectChannel" }, "Select Channel (A)"), option({ value: "selectAll" }, "Select All (A)"), option({ value: "duplicatePatterns" }, "Duplicate Reused Patterns (D)"), option({ value: "transposeUp" }, "Move Notes Up (+ or +)"), option({ value: "transposeDown" }, "Move Notes Down (- or -)"), option$6({ value: "transposeOctaveUp" }, "Move Notes Up Octave +"), option$6({ value: "transposeOctaveDown" }, "Move Notes Down Octave -")  , option({ value: "moveNotesSideways" }, "Move All Notes Sideways... (W)"), option({ value: "generateEuclideanRhythm" }, "Generate Euclidean Rhythm... (" + EditorConfig.ctrlSymbol + "E)"), option({ value: "beatsPerBar" }, "Change Beats Per Bar... (B)"), option({ value: "barCount" }, "Change Song Length... (L)"), option({ value: "channelSettings" }, "Channel Settings... (Q)"), option({ value: "limiterSettings" }, "Limiter Settings... (L)"), option({ value: "addExternal" }, "Add Custom Samples... (Q)"));
            this._optionsMenu = select({ style: "width: 100%;" }, option({ selected: true, disabled: true, hidden: false }, "Settings"), optgroup({ label: "Technical" }, option({ value: "autoPlay" }, "Auto Play on Load"), option({ value: "autoFollow" }, "Auto Follow Playhead"), option({ value: "enableNotePreview" }, "Hear Added Notes"), option({ value: "notesOutsideScale" }, "Place Notes Out of Scale"), option({ value: "setDefaultScale" }, "Set Current Scale as Default"), option({ value: "alwaysFineNoteVol" }, "Always Fine Note Volume"), option({ value: "enableChannelMuting" }, "Enable Channel Muting"), option({ value: "instrumentCopyPaste" }, "Enable Copy/Paste Buttons"), option({ value: "instrumentImportExport" }, "Enable Import/Export Buttons"), option({ value: "displayBrowserUrl" }, "Enable Song Data in URL"), option({ value: "closePromptByClickoff" }, "Close Prompts on Click Off"),
            
            option({ value: "increaseAllPins" }, "Increase All Pins ."),  
            
            option({ value: "recordingSetup" }, "Note Recording..."), option({ value: "whistleRecord" }, "Record With Whistle ")),
                  optgroup({ label: "Appearance" }, option({ value: "showFifth" }, 'Highlight "Fifth" Note'), option({ value: "notesFlashWhenPlayed" }, "Notes Flash When Played"), option({ value: "instrumentButtonsAtTop" }, "Instrument Buttons at Top"), option({ value: "frostedGlassBackground" }, "Frosted Glass Prompt Backdrop"),option({ value: "pianoKeyboard" }, "Better Piano Roll ."),   option({ value: "useCustomSelectPrompt" }, "Custom Select Modal"), option({ value: "showChannels" }, "Show All Channels"), option({ value: "showScrollBar" }, "Show Octave Scroll Bar"), option$6({ value: "differentMod" }, "Better Mod Visuals"),
            option({ value: "showInstrumentScrollbars" }, "Show Intsrument Scrollbars"), option({ value: "showLetters" }, "Show Piano Keys"), option({ value: "displayVolumeBar" }, "Show Playback Volume"), option({ value: "showOscilloscope" }, "Show Oscilloscope"), option({ value: "showSampleLoadingStatus" }, "Show Sample Loading Status"), option({ value: "showDescription" }, "Show Description"), option({ value: "oldButtonSheme" }, "Old Buttons Positions ."), option({ value: "newloopeditor" }, "Not Centered Loop Editor ."),  
              option({ value: "openPlugins" }, "Open Plugins"), option({ value: "layout" }, "Set Layout..."), option({ value: "colorTheme" }, "Set Theme..."), option({ value: "customTheme" }, "Custom Theme..."),option({ value: "Fullscreen" }, "Open In Fullscreen"),/* option({ value: "setLanguage" }, "Set Language...")*/));
            this._scaleSelect = buildOptions(select(), Config.scales.map(scale => scale.name));
            this.uiof8op = {operatorWaveformSelects: [],operatorFrequencySelects: [],operatorAmplitudeSliders: [],};

            this._keySelect = buildOptions(select(), Config.keys.map(key => key.name).reverse());
            this._octaveStepper = input({ style: "width: 59.5%;", type: "number", min: Config.octaveMin, max: Config.octaveMax, value: "0" });
            this._tempoSlider = new Slider(input({ style: "margin: 0; vertical-align: middle;", type: "range", min: "1", max: 640 , value: "160", step: "1" }), this.doc, (oldValue, newValue) => new ChangeTempo(this.doc, oldValue, newValue), false);
            this._tempoStepper = input({ style: "width: 4em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", type: "number", step: "1" });
            this._songEqFilterEditor = new FilterEditor(this.doc, false, false, true);
            this._songEqFilterZoom = button({ style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("customSongEQFilterSettings") }, "+");
            this._chorusSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.chorusRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeChorus(this.doc, oldValue, newValue), false);
            this._chorusRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("chorus") }, "Chorus:"), this._chorusSlider.container);
            this._reverbSlider = new Slider(input({ style: "margin: 0; position: sticky,", type: "range", min: "0", max: Config.reverbRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeReverb(this.doc, oldValue, newValue), false);
            this._reverbRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("reverb") }, "Reverb:"), this._reverbSlider.container);
            this._ringModWaveSelect = buildOptions(select({}), Config.operatorWaves.map(wave => wave.name));
            this._ringModPulsewidthSlider = new Slider(input({ style: "margin-left: 10px; width: 85%;", type: "range", min: "0", max: Config.pwmOperatorWaves.length - 1, value: "0", step: "1", title: "Pulse Width" }), this.doc, (oldValue, newValue) => new ChangeRingModPulseWidth(this.doc, oldValue, newValue), true);
            this._ringModSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.ringModRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeRingMod(this.doc, oldValue, newValue), false);
            this._ringModRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("ringMod") }, "Ring Mod:"), this._ringModSlider.container);
            this._ringModHzSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.ringModHzRange - 1, value: (Config.ringModHzRange - (Config.ringModHzRange / 2)), step: "1" }), this.doc, (oldValue, newValue) => new ChangeRingModHz(this.doc, oldValue, newValue), true);
            this.ringModHzNum = div({ style: "font-size: 80%; ", id: "ringModHzNum" });
            this._ringModHzSliderRow = div({ class: "selectRow", style: "width:100%;" }, div({ style: "display:flex; flex-direction:column; align-items:center;" }, span({ class: "tip", style: "font-size: smaller;", onclick: () => this._openPrompt("RingModHz") }, "Hertz: "), div({ style: `color: ${ColorConfig.secondaryText}; ` }, this.ringModHzNum)), this._ringModHzSlider.container);
            this._ringModWaveText = span({ class: "tip", onclick: () => this._openPrompt("ringModChipWave") }, "Wave: ");
            this._ringModWaveSelectRow = div({ class: "selectRow", style: "width: 100%;" }, this._ringModWaveText, this._ringModPulsewidthSlider.container, div({ class: "selectContainer", style: "width:40%;" }, this._ringModWaveSelect));
            this._ringModContainerRow = div({ class: "", style: "display:flex; flex-direction:column;" }, this._ringModRow, this._ringModHzSliderRow, this._ringModWaveSelectRow);
            this._granularSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.granularRange, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeGranular(this.doc, oldValue, newValue), false);
            this._granularRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("granular") }, "Granular:"), this._granularSlider.container);
            this._grainSizeSlider = new Slider(input({ style: "margin: 0;", type: "range", min: Config.grainSizeMin / Config.grainSizeStep, max: Config.grainSizeMax / Config.grainSizeStep, value: Config.grainSizeMin / Config.grainSizeStep, step: "1" }), this.doc, (oldValue, newValue) => new ChangeGrainSize(this.doc, oldValue, newValue), false);
            this.grainSizeNum = div({ style: "font-size: 80%; ", id: "grainSizeNum" });
            this._grainSizeSliderRow = div({ class: "selectRow", style: "width:100%;" }, div({ style: "display:flex; flex-direction:column; align-items:center;" }, span({ class: "tip", style: "font-size: smaller;", onclick: () => this._openPrompt("grainSize") }, "Grain: "), div({ style: `color: ${ColorConfig.secondaryText}; ` }, this.grainSizeNum)), this._grainSizeSlider.container);
            this._grainAmountsSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.grainAmountsMax, value: 8, step: "1" }), this.doc, (oldValue, newValue) => new ChangeGrainAmounts(this.doc, oldValue, newValue), false);
            this._grainAmountsRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("grainAmount") }, "Grain Freq:"), this._grainAmountsSlider.container);
            this._grainRangeSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.grainRangeMax / Config.grainSizeStep, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeGrainRange(this.doc, oldValue, newValue), false);
            this.grainRangeNum = div({ style: "font-size: 80%; ", id: "grainRangeNum" });
            this._grainRangeSliderRow = div({ class: "selectRow", style: "width:100%;" }, div({ style: "display:flex; flex-direction:column; align-items:center;" }, span({ class: "tip", style: "font-size: smaller;", onclick: () => this._openPrompt("grainRange") }, "Range: "), div({ style: `color: ${ColorConfig.secondaryText}; ` }, this.grainRangeNum)), this._grainRangeSlider.container);
            this._granularContainerRow = div({ class: "", style: "display:flex; flex-direction:column;" }, this._granularRow, this._grainAmountsRow, this._grainSizeSliderRow, this._grainRangeSliderRow);
            this._echoSustainSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.echoSustainRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeEchoSustain(this.doc, oldValue, newValue), false);
            this._echoSustainRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("echoSustain") }, "Echo:"), this._echoSustainSlider.container);
            this._echoDelaySlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.echoDelayRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeEchoDelay(this.doc, oldValue, newValue), false);
            this._echoDelayRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("echoDelay") }, "Echo Delay:"), this._echoDelaySlider.container);
            this._rhythmSelect = buildOptions(select(), Config.rhythms.map(rhythm => rhythm.name));
            this._phaserMixSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.phaserMixRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangePhaserMix(this.doc, oldValue, newValue), false);  
            this._phaserMixRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("phaserMix") }, span("Phaser:")), this._phaserMixSlider.container);
            this._phaserFreqSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.phaserFreqRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangePhaserFreq(this.doc, oldValue, newValue), false);
            this._phaserFreqRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("phaserFreq") }, span(" Freq:")), this._phaserFreqSlider.container);
            this._phaserFeedbackSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.phaserFeedbackRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangePhaserFeedback(this.doc, oldValue, newValue), false);
            this._phaserFeedbackRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("phaserFeedback") }, span(" Feedback:")), this._phaserFeedbackSlider.container);
            this._phaserStagesSlider = new Slider(input({ style: "margin: 0;", type: "range", min: Config.phaserMinStages, max: Config.phaserMaxStages, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangePhaserStages(this.doc, oldValue, newValue), false);
            this._phaserStagesRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("phaserStages") }, span(" Stages:")), this._phaserStagesSlider.container);
            this._pitchedPresetSelect = buildPresetOptions(false, "pitchPresetSelect");
            this._drumPresetSelect = buildPresetOptions(true, "drumPresetSelect");
            this._algorithmSelect = buildOptions(select(), Config.algorithms.map(algorithm => algorithm.name));
            this._algorithmSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("algorithm") }, "Algorithm: "), div({ class: "selectContainer" }, this._algorithmSelect));
            this._instrumentButtons = [];
            this._instrumentAddButton = button({ type: "button", class: "add-instrument last-button" });
            this._instrumentRemoveButton = button({ type: "button", class: "remove-instrument" });
            this._instrumentsButtonBar = div({ class: "instrument-bar" }, this._instrumentRemoveButton, this._instrumentAddButton);
            this._instrumentsButtonRow = div({ class: "selectRow", style: "display: none;" }, span({ class: "tip", onclick: () => this._openPrompt("instrumentIndex") }, "Instrument:"), this._instrumentsButtonBar);
            this._instrumentVolumeSlider = new Slider(input({ style: "margin: 0; position: sticky;", type: "range", min: Math.floor(-Config.volumeRange / 2), max: Math.floor(Config.volumeRange / 2), value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeVolume(this.doc, oldValue, newValue), true);
            this._instrumentVolumeSliderInputBox = input({ style: "width: 4em; font-size: 80%", id: "volumeSliderInputBox", type: "number", step: "1", min: Math.floor(-Config.volumeRange / 2), max: Math.floor(Config.volumeRange / 2), value: "0" });
            this._instrumentVolumeSliderTip = div({ class: "selectRow", style: "height: 1em" }, span({ class: "tip", style: "font-size: smaller;", onclick: () => this._openPrompt("instrumentVolume") }, "Volume: "));
            this._instrumentVolumeSliderRow = div({ class: "selectRow" }, div({}, div({ style: `color: ${ColorConfig.secondaryText};` }, span({ class: "tip" }, this._instrumentVolumeSliderTip)), div({ style: `color: ${ColorConfig.secondaryText}; margin-top: -3px;` }, this._instrumentVolumeSliderInputBox)), this._instrumentVolumeSlider.container);
            this._panSlider = new Slider(input({ style: "margin: 0; position: sticky;", type: "range", min: "0", max: Config.panMax, value: Config.panCenter, step: "1" }), this.doc, (oldValue, newValue) => new ChangePan(this.doc, oldValue, newValue), true);
            this._panDropdown = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(1) }, "");
            this._panSliderInputBox = input({ style: "width: 4em; font-size: 80%; ", id: "panSliderInputBox", type: "number", step: "1", min: "0", max: "100", value: "0" });
            this._panSliderRow = div({ class: "selectRow" }, div({}, span({ class: "tip", tabindex: "0", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("pan") }, "Pan: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._panSliderInputBox)), this._panDropdown, this._panSlider.container);
            this._panDelaySlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["pan delay"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangePanDelay(this.doc, oldValue, newValue), false);
            this._panDelayRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("panDelay") }, " Delay:"), this._panDelaySlider.container);
            this._panDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._panDelayRow);
            this._chipWaveSelect = buildOptions(select(), Config.chipWaves.map(wave => wave.name)); 
            this._chipWaveError = p({ style:"font-size:5px;" , class: "tip" }, "")
            
            this._chipNoiseSelect = buildOptions(select(), Config.chipNoises.map(wave => wave.name));
            this._useChipWaveAdvancedLoopControlsBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: 0.4em; margin-right: 4em;" });
            this._chipWaveLoopModeSelect = buildOptions(select(), ["Loop", "Ping-Pong", "Play Once", "Play Loop Once"]);
            this._chipWaveLoopStartStepper = input({ type: "number", min: "0", step: "1", value: "0", style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;" });
            this._chipWaveLoopEndStepper = input({ type: "number", min: "0", step: "1", value: "0", style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;" });
            this._setChipWaveLoopEndToEndButton = button({ type: "button", style: "width: 1.5em; height: 1.5em; padding: 0; margin-left: 0.5em;" }, SVG.svg({ width: "16", height: "16", viewBox: "-13 -14 26 26", "pointer-events": "none", style: "width: 100%; height: 100%;" }, SVG.rect({ x: "4", y: "-6", width: "2", height: "12", fill: ColorConfig.primaryText }), SVG.path({ d: "M -6 -6 L -6 6 L 3 0 z", fill: ColorConfig.primaryText })));
            this._chipWaveStartOffsetStepper = input({ type: "number", min: "0", step: "1", value: "0", style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;" });
            this._chipWavePlayBackwardsBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-left: 0.4em; margin-right: 4em;" });
            this._chipWaveSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("chipWave") }, "Wave: "), div({ class: "selectContainer" }, this._chipWaveSelect));
            this._chipNoiseSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("chipNoise") }, "Noise: "), div({ class: "selectContainer" }, this._chipNoiseSelect));
            this._visualLoopControlsButton = button({ style: "margin-left: 0em; padding-left: 0.2em; height: 1.5em; max-width: 12px;", onclick: () => this._openPrompt("visualLoopControls") }, "+");
            this._useChipWaveAdvancedLoopControlsRow = div({ class: "selectRow" }, span({ class: "tip", style: "flex-shrink: 0;", onclick: () => this._openPrompt("loopControls") }, "Loop Controls: "), this._useChipWaveAdvancedLoopControlsBox);
            this._chipWaveLoopModeSelectRow = div({ class: "selectRow" }, span({ class: "tip", style: "font-size: x-small;", onclick: () => this._openPrompt("loopMode") }, "Loop Mode: "), div({ class: "selectContainer" }, this._chipWaveLoopModeSelect));
            this._chipWaveLoopStartRow = div({ class: "selectRow" }, span({ class: "tip", style: "font-size: x-small;", onclick: () => this._openPrompt("loopStart") }, "Loop Start: "), this._visualLoopControlsButton, span({ style: "display: flex;" }, this._chipWaveLoopStartStepper));
            this._chipWaveLoopEndRow = div({ class: "selectRow" }, span({ class: "tip", style: "font-size: x-small;", onclick: () => this._openPrompt("loopEnd") }, "Loop End: "), span({ style: "display: flex;" }, this._chipWaveLoopEndStepper, this._setChipWaveLoopEndToEndButton));
            this._chipWaveStartOffsetRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("offset") }, "Offset: "), span({ style: "display: flex;" }, this._chipWaveStartOffsetStepper));
            this._chipWavePlayBackwardsRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("backwards") }, "Backwards: "), this._chipWavePlayBackwardsBox);
            this._fadeInOutEditor = new FadeInOutEditor(this.doc);
            this._fadeInOutRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("fadeInOut") }, "Fade:"), this._fadeInOutEditor.container);
            this._transitionSelect = buildOptions(select(), Config.transitions.map(transition => transition.name));
            this._transitionDropdown = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(3) }, "");
            this._transitionRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("transition") }, "Transition:"), this._transitionDropdown, div({ class: "selectContainer", style: "width: 52.5%;" }, this._transitionSelect));
            this._clicklessTransitionBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;" });
            this._clicklessTransitionRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("clicklessTransition") }, " Clickless:"), this._clicklessTransitionBox);
            this._transitionDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._clicklessTransitionRow);
            this._effectsSelect = select(option({ selected: true, disabled: true, hidden: false }));
            this._eqFilterSimpleButton = button({ style: "font-size: x-small; width: 50%; height: 40%", class: "no-underline", onclick: () => this._switchEQFilterType(true) }, "simple");
            this._eqFilterAdvancedButton = button({ style: "font-size: x-small; width: 50%; height: 40%", class: "last-button no-underline", onclick: () => this._switchEQFilterType(false) }, "advanced");
            this._eqFilterTypeRow = div({ class: "selectRow", style: "padding-top: 4px; margin-bottom: 0px;" }, span({ style: "font-size: x-small;", class: "tip", onclick: () => this._openPrompt("filterType") }, "EQ Filt.Type:"), div({ class: "instrument-bar" }, this._eqFilterSimpleButton, this._eqFilterAdvancedButton));
            this._eqFilterEditor = new FilterEditor(this.doc);
            this._eqFilterZoom = button({ style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("customEQFilterSettings") }, "+");
            this._eqFilterRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("eqFilter") }, "EQ Filt:"), this._eqFilterZoom, this._eqFilterEditor.container);
            this._eqFilterSimpleCutSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimpleCutRange - 1, value: "6", step: "1" }), this.doc, (oldValue, newValue) => new ChangeEQFilterSimpleCut(this.doc, oldValue, newValue), false);
            this._eqFilterSimpleCutRow = div({ class: "selectRow", title: "Low-pass Filter Cutoff Frequency" }, span({ class: "tip", onclick: () => this._openPrompt("filterCutoff") }, "Filter Cut:"), this._eqFilterSimpleCutSlider.container);
            this._eqFilterSimplePeakSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimplePeakRange - 1, value: "6", step: "1" }), this.doc, (oldValue, newValue) => new ChangeEQFilterSimplePeak(this.doc, oldValue, newValue), false);
            this._eqFilterSimplePeakRow = div({ class: "selectRow", title: "Low-pass Filter Peak Resonance" }, span({ class: "tip", onclick: () => this._openPrompt("filterResonance") }, "Filter Peak:"), this._eqFilterSimplePeakSlider.container);
            this._noteFilterSimpleButton = button({ style: "font-size: x-small; width: 50%; height: 40%", class: "no-underline", onclick: () => this._switchNoteFilterType(true) }, "simple");
            this._noteFilterAdvancedButton = button({ style: "font-size: x-small; width: 50%; height: 40%", class: "last-button no-underline", onclick: () => this._switchNoteFilterType(false) }, "advanced");
            this._noteFilterTypeRow = div({ class: "selectRow", style: "padding-top: 4px; margin-bottom: 0px;" }, span({ style: "font-size: x-small;", class: "tip", onclick: () => this._openPrompt("filterType") }, "Note Filt.Type:"), div({ class: "instrument-bar" }, this._noteFilterSimpleButton, this._noteFilterAdvancedButton));
            this._noteFilterEditor = new FilterEditor(this.doc, true);
            this._noteFilterZoom = button({ style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("customNoteFilterSettings") }, "+");
            this._noteFilterRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("noteFilter") }, "Note Filt:"), this._noteFilterZoom, this._noteFilterEditor.container);
            this._noteFilterSimpleCutSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimpleCutRange - 1, value: "6", step: "1" }), this.doc, (oldValue, newValue) => new ChangeNoteFilterSimpleCut(this.doc, oldValue, newValue), false);
            this._noteFilterSimpleCutRow = div({ class: "selectRow", title: "Low-pass Filter Cutoff Frequency" }, span({ class: "tip", onclick: () => this._openPrompt("filterCutoff") }, "Filter Cut:"), this._noteFilterSimpleCutSlider.container);
            this._noteFilterSimplePeakSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.filterSimplePeakRange - 1, value: "6", step: "1" }), this.doc, (oldValue, newValue) => new ChangeNoteFilterSimplePeak(this.doc, oldValue, newValue), false);
            this._noteFilterSimplePeakRow = div({ class: "selectRow", title: "Low-pass Filter Peak Resonance" }, span({ class: "tip", onclick: () => this._openPrompt("filterResonance") }, "Filter Peak:"), this._noteFilterSimplePeakSlider.container);
            this._supersawDynamismSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.supersawDynamismMax, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeSupersawDynamism(this.doc, oldValue, newValue), false);
            this._supersawDynamismRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("supersawDynamism") }, "Dynamism:"), this._supersawDynamismSlider.container);
            this._supersawSpreadSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.supersawSpreadMax, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeSupersawSpread(this.doc, oldValue, newValue), false);
            this._supersawSpreadRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("supersawSpread") }, "Spread:"), this._supersawSpreadSlider.container);
            this._supersawShapeSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.supersawShapeMax, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeSupersawShape(this.doc, oldValue, newValue), false);
            this._supersawShapeRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("supersawShape"), style: "overflow: clip;" }, "Saw/Pulse:"), this._supersawShapeSlider.container);
            this._pulseWidthSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "1", max: Config.pulseWidthRange, value: "1", step: "1" }), this.doc, (oldValue, newValue) => new ChangePulseWidth(this.doc, oldValue, newValue), false);
            this._pulseWidthDropdown = button({ style: "margin-left:53px; position: absolute; margin-top: 15px; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(5) }, "");
            this._pwmSliderInputBox = input({ style: "width: 4em; font-size: 70%;", id: "pwmSliderInputBox", type: "number", step: "1", min: "1", max: Config.pulseWidthRange, value: "1" });
            this._pulseWidthRow = div({ class: "selectRow" }, div({}, span({ class: "tip", tabindex: "0", style: "height:1em; font-size: smaller; white-space: nowrap;", onclick: () => this._openPrompt("pulseWidth") }, "Pulse Width:"), div({ style: `color: ${ColorConfig.secondaryText}; margin-top: -3px;` }, this._pwmSliderInputBox)), this._pulseWidthDropdown, this._pulseWidthSlider.container);
            this._decimalOffsetSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: "99", value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeDecimalOffset(this.doc, oldValue, 99 - newValue), false);
            this._decimalOffsetRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("decimalOffset") }, " Offset:"), this._decimalOffsetSlider.container);
            this._pulseWidthDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._decimalOffsetRow);
            this._pitchShiftSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.pitchShiftRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangePitchShift(this.doc, oldValue, newValue), true); 
            this._octaveShiftSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.pitchShiftRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeOctaveShift(this.doc, oldValue, newValue), true);
            this._octaveShiftTonicMarkers = [div({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic } }), div({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic, left: "50%" } }), div({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic, left: "100%" } })];
            this._octaveShiftFifthMarkers = [div({ class: "pitchShiftMarker", style: { color: ColorConfig.fifthNote, left: (100 * 7 / 24) + "%" } }), div({ class: "pitchShiftMarker", style: { color: ColorConfig.fifthNote, left: (100 * 19 / 24) + "%" } })];
            this._pitchShiftTonicMarkers = [div({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic } }), div({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic, left: "50%" } }), div({ class: "pitchShiftMarker", style: { color: ColorConfig.tonic, left: "100%" } })];
            this._pitchShiftFifthMarkers = [div({ class: "pitchShiftMarker", style: { color: ColorConfig.fifthNote, left: (100 * 7 / 24) + "%" } }), div({ class: "pitchShiftMarker", style: { color: ColorConfig.fifthNote, left: (100 * 19 / 24) + "%" } })];
            this._pitchShiftMarkerContainer = div({ style: "display: flex; position: relative;" }, this._pitchShiftSlider.container, div({ class: "pitchShiftMarkerContainer" }, this._pitchShiftTonicMarkers, this._pitchShiftFifthMarkers));
            this._octaveShiftMarkerContainer = div({ style: "display: flex; position: relative;" }, this._octaveShiftSlider.container, div({ class: "pitchShiftMarkerContainer" }, this._octaveShiftTonicMarkers, this._octaveShiftFifthMarkers));
            this._octaveShiftBox = input$8({ style: "width: 4em; font-size: 80%; ", id: "pitchShiftBox", type: "number", step: "1", min: "0", max: "24", value: "0" });
            this._octaveShiftRow = div$d({ class: "selectRow" }, div$d({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._octaveShiftBox), span$4({ class: "tip",style:"font-size:6px", onclick: () => this._openPrompt("octaveShift") }, "Ocatve Shift:"), this._octaveShiftMarkerContainer);
             this._fnInput = textarea({ id: "function", style: `width: 19em;height: 40px;box-sizing: border-box;font-size: 30%;border: none;background: var(--ui-widget-background);color: var(--secondary-text);outline: none;resize: none;font-family: monospace;white-space: pre-wrap;overflow-x: auto;overflow-y: hidden scroll;`});
             this._fnInput.value= `sampleL=0`
              this._outInterface = div$1({id: "interface",style: `width: 100%;box-sizing: border-box;font-size: 80%;background: var(--ui-widget-background);color: var(--secondary-text);`});
              this._ioWrapper = div$d({  style: `display: flex;flex-direction: column;width: 23em;gap: 0.4em; align-items: center;`}, this._fnInput, this._outInterface);
             this._functionRow = div$d({ class: "selectRow" },div$d({ style: "color:" + ColorConfig.secondaryText + "; margin-top:-3px;" }),span$4({class: "tip",style: "font-size:8px",onclick: () => this._openPrompt("functionFN")}, "Function:"),this._ioWrapper);
            
            this._pitchShiftBox = input$8({ style: "width: 4em; font-size: 80%; ", id: "pitchShiftBox", type: "number", step: "1", min: "0", max: "24", value: "0" });
            this._pitchShiftRow = div$d({ class: "selectRow" }, div$d({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._pitchShiftBox), span$4({ class: "tip", style:"font-size:6px", onclick: () => this._openPrompt("pitchShift") }, "Pitch Shift:"), this._pitchShiftMarkerContainer);
            
            this._detuneSlider = new Slider(input({ style: "margin: 0;", type: "range", min: Config.detuneMin - Config.detuneCenter, max: Config.detuneMax - Config.detuneCenter, value: 0, step: "4" }), this.doc, (oldValue, newValue) => new ChangeDetune(this.doc, oldValue, newValue), true);
            this._detuneSliderInputBox = input({ style: "width: 4em; font-size: 80%; ", id: "detuneSliderInputBox", type: "number", step: "1", min: Config.detuneMin - Config.detuneCenter, max: Config.detuneMax - Config.detuneCenter, value: 0 });
            this._detuneSliderRow = div({ class: "selectRow" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("detune") }, "Detune: "), div({ style: `color: ${ColorConfig.secondaryText}; margin-top: -3px;` }, this._detuneSliderInputBox)), this._detuneSlider.container);
            this._distortionSlider = new Slider(input({ style: "margin: 0; position: sticky;", type: "range", min: "0", max: Config.distortionRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeDistortion(this.doc, oldValue, newValue), false);
            this._distortionRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("distortion") }, "Distortion:"), this._distortionSlider.container);
            this._aliasingBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;" });
            this._aliasingRow = div({ class: "selectRow" }, span({ class: "tip", style: "margin-left:10px;", onclick: () => this._openPrompt("aliases") }, "Aliasing:"), this._aliasingBox);
            this._bitcrusherQuantizationSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.bitcrusherQuantizationRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeBitcrusherQuantization(this.doc, oldValue, newValue), false);
            this._bitcrusherQuantizationRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("bitcrusherQuantization") }, "Bit Crush:"), this._bitcrusherQuantizationSlider.container);
            this._bitcrusherFreqSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.bitcrusherFreqRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeBitcrusherFreq(this.doc, oldValue, newValue), false);
            this._bitcrusherFreqRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("bitcrusherFreq") }, "Freq Crush:"), this._bitcrusherFreqSlider.container);
            this._stringSustainSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.stringSustainRange - 1, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeStringSustain(this.doc, oldValue, newValue), false);
            this._stringSustainLabel = span({ class: "tip", onclick: () => this._openPrompt("stringSustain") }, "Sustain:");
            this._stringSustainRow = div({ class: "selectRow" }, this._stringSustainLabel, this._stringSustainSlider.container);
            this._unisonDropdown = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(6) }, "");
            this._unisonSelect = buildOptions(select(), Config.unisons.map(unison => unison.name));
            this._unisonSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("unison") }, "Unison:"), this._unisonDropdown, div({ class: "selectContainer", style: "width: 61.5%;" }, this._unisonSelect));
            this._unisonVoicesInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonVoicesInputBox", type: "number", step: "1", min: Config.unisonVoicesMin, max: Config.unisonVoicesMax, value: 1 });
            this._unisonVoicesRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonVoices") }, " Voices: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonVoicesInputBox)));
            this._unisonSpreadInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonSpreadInputBox", type: "number", step: "0.001", min: Config.unisonSpreadMin, max: Config.unisonSpreadMax, value: 0.0 });
            this._unisonSpreadRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonSpread") }, " Spread: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonSpreadInputBox)));
            this._unisonOffsetInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonOffsetInputBox", type: "number", step: "0.001", min: Config.unisonOffsetMin, max: Config.unisonOffsetMax, value: 0.0 });
            this._unisonOffsetRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonOffset") }, " Offset: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonOffsetInputBox)));
            this._unisonExpressionInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonExpressionInputBox", type: "number", step: "0.001", min: Config.unisonExpressionMin, max: Config.unisonExpressionMax, value: 1.4 });
            this._unisonExpressionRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonExpression") }, " Volume: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonExpressionInputBox)));
            this._unisonSignInputBox = input({ style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;", id: "unisonSignInputBox", type: "number", step: "0.001", min: Config.unisonSignMin, max: Config.unisonSignMax, value: 1.0 });
            this._unisonSignRow = div({ class: "selectRow dropFader" }, div({}, span({ class: "tip", style: "height:1em; font-size: smaller;", onclick: () => this._openPrompt("unisonSign") }, " Sign: "), div({ style: "color: " + ColorConfig.secondaryText + "; margin-top: -3px;" }, this._unisonSignInputBox)));
            this._unisonDropdownGroup = div({ class: "editor-controls", style: "display: none; gap: 3px; margin-bottom: 0.5em;" }, this._unisonVoicesRow, this._unisonSpreadRow, this._unisonOffsetRow, this._unisonExpressionRow, this._unisonSignRow);
            this._chordSelect = buildOptions(select({ style: "flex-shrink: 100" }), Config.chords.map(chord => chord.name));
            this._chordDropdown = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(2) }, "");
            this._monophonicNoteInputBox = input({ style: "width: 2.35em; height: 1.5em; font-size: 80%; margin: 0.5em; vertical-align: middle;", id: "unisonSignInputBox", type: "number", step: "1", min: 1, max: Config.maxChordSize, value: 1.0 });
            this._chordSelectContainer = div({ class: "selectContainer", style: "width=100%" }, this._chordSelect);
            this._chordSelectRow = div({ class: "selectRow", style: "display: flex; flex-direction: row" }, span({ class: "tip", onclick: () => this._openPrompt("chords") }, "Chords:"), this._monophonicNoteInputBox, this._chordDropdown, this._chordSelectContainer);
            this._arpeggioSpeedDisplay = span({ style: `color: ${ColorConfig.secondaryText}; font-size: smaller; text-overflow: clip;` }, "x1");
            this._arpeggioSpeedSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["arp speed"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeArpeggioSpeed(this.doc, oldValue, newValue), false);
            this._arpeggioSpeedRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("arpeggioSpeed") }, " Spd:"), this._arpeggioSpeedDisplay, this._arpeggioSpeedSlider.container);
            
this._strumSpeedDisplay = span({ style: `color: ${ColorConfig.secondaryText}; font-size: smaller; text-overflow: clip;` }, "x1");
this._strumSpeedSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["arp speed"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeArpeggioSpeed(this.doc, oldValue, newValue), false);
this._strumSpeedRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("arpeggioSpeed") }, " Spd:"), this._strumSpeedDisplay, this._strumSpeedSlider.container);

            this._twoNoteArpBox = input({ type: "checkbox", style: "width: 1em; padding: 0; margin-right: 4em;" });
            this._twoNoteArpRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("twoNoteArpeggio") }, " Fast Two-Note:"), this._twoNoteArpBox);
            this._chordDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._arpeggioSpeedRow, this._twoNoteArpRow);
            this._chordStrumDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._strumSpeedRow);
            this._vibratoSelect = buildOptions(select(), Config.vibratos.map(vibrato => vibrato.name));
            this._vibratoDropdown = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(0) }, "");
            this._vibratoSelectRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("vibrato") }, "Vibrato:"), this._vibratoDropdown, div({ class: "selectContainer", style: "width: 61.5%;" }, this._vibratoSelect));
            this._vibratoDepthSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["vibrato depth"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeVibratoDepth(this.doc, oldValue, newValue), false);
            this._vibratoDepthRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("vibratoDepth") }, " Depth:"), this._vibratoDepthSlider.container);
            this._vibratoSpeedDisplay = span({ style: `color: ${ColorConfig.secondaryText}; font-size: smaller; text-overflow: clip;` }, "x1");
            this._vibratoSpeedSlider = new Slider(input({ style: "margin: 0; text-overflow: clip;", type: "range", min: "0", max: Config.modulators.dictionary["vibrato speed"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeVibratoSpeed(this.doc, oldValue, newValue), false);
            this._vibratoSpeedRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("vibratoSpeed") }, " Spd:"), this._vibratoSpeedDisplay, this._vibratoSpeedSlider.container);
            this._vibratoDelaySlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["vibrato delay"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeVibratoDelay(this.doc, oldValue, newValue), false);
            this._vibratoDelayRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("vibratoDelay") }, " Delay:"), this._vibratoDelaySlider.container);
            this._vibratoTypeSelect = buildOptions(select(), Config.vibratoTypes.map(vibrato => vibrato.name));
            this._vibratoTypeSelectRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("vibratoType") }, " Type:"), div({ class: "selectContainer", style: "width: 61.5%;" }, this._vibratoTypeSelect));
            this._vibratoDropdownGroup = div({ class: "editor-controls", style: `display: none;` }, this._vibratoDepthRow, this._vibratoSpeedRow, this._vibratoDelayRow, this._vibratoTypeSelectRow);
            this._phaseModGroup = div({ class: "editor-controls" });
            this._feedbackTypeSelect = buildOptions(select(), Config.feedbacks.map(feedback => feedback.name));
            this._feedbackRow1 = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("feedbackType") }, "Feedback:"), div({ class: "selectContainer" }, this._feedbackTypeSelect));
            this._spectrumEditor = new SpectrumEditor(this.doc, null);
            this._spectrumZoom = button({ style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("spectrumSettings") }, "+");
            this._spectrumRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("spectrum"), style: "font-size: smaller" }, "Spectrum:"), this._spectrumZoom, this._spectrumEditor.container);
            this._harmonicsEditor = new HarmonicsEditor(this.doc);
            this._harmonicsZoom = button({ style: "padding-left:0.2em; height:1.5em; max-width: 12px;", onclick: () => this._openPrompt("harmonicsSettings") }, "+");
            this._harmonicsRow = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("harmonics"), style: "font-size: smaller" }, "Harmonics:"), this._harmonicsZoom, this._harmonicsEditor.container);
            this.envelopeEditor = new EnvelopeEditor(this.doc, (id, submenu, subtype) => this._toggleDropdownMenu(id, submenu, subtype), (name) => this._openPrompt(name));
            this._envelopeSpeedDisplay = span({ style: `color: ${ColorConfig.secondaryText}; font-size: smaller; text-overflow: clip;` }, "x1");
            this._envelopeSpeedSlider = new Slider(input({ style: "margin: 0;", type: "range", min: "0", max: Config.modulators.dictionary["envelope speed"].maxRawVol, value: "0", step: "1" }), this.doc, (oldValue, newValue) => new ChangeEnvelopeSpeed(this.doc, oldValue, newValue), false);
            this._envelopeSpeedRow = div({ class: "selectRow dropFader" }, span({ class: "tip", style: "margin-left:4px;", onclick: () => this._openPrompt("envelopeSpeed") }, " Spd:"), this._envelopeSpeedDisplay, this._envelopeSpeedSlider.container);
            this._envelopeDropdownGroup = div({ class: "editor-controls", style: "display: none;" }, this._envelopeSpeedRow);
            this._envelopeDropdown = button({ style: "margin-left:0em; margin-right: 1em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(7) }, "");
            this._drumsetGroup = div({ class: "editor-controls" });
            this._drumsetZoom = button({ style: "margin-left:0em; padding-left:0.3em; margin-right:0.5em; height:1.5em; max-width: 16px;", onclick: () => this._openPrompt("drumsetSettings") }, "+");
            this._modulatorGroup = div({ class: "editor-controls" });
            this._feedback6OpTypeSelect = buildOptions(select(), Config.feedbacks6Op.map(feedback => feedback.name));
            this._feedback6OpRow1 = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("feedbackType") }, "Feedback:"), div({ class: "selectContainer" }, this._feedback6OpTypeSelect));
            this._algorithmCanvasSwitch = button({ style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;", onclick: (e) => this._toggleAlgorithmCanvas(e) }, "A");
            this._customAlgorithmCanvas = new CustomAlgorythmCanvas(canvas({ width: 144*2, height: 144*2, style: "width:144px; height:144px; border:2px solid " + ColorConfig.uiWidgetBackground, id: "customAlgorithmCanvas" }), this.doc, (newArray, carry, mode) => new ChangeCustomAlgorythmorFeedback(this.doc, newArray, carry, mode)); 
            this._algorithm6OpSelect = buildOptions(select(), Config.algorithms6Op.map(algorithm => algorithm.name));
            this._algorithm6OpSelectRow = div(div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("algorithm") }, "Algorithm: "), div({ class: "selectContainer" }, this._algorithm6OpSelect)), div({ style: "height:auto; display:flex; flex-direction: row; align-items:center; justify-content:center; margin-bottom:5px; margin-top:5px;" }, div({ style: "display:block; width:10px; margin-right: 0.1em" }, this._algorithmCanvasSwitch), div({ style: "width:144px; height:144px;" }, this._customAlgorithmCanvas.canvas)));
            this._instrumentCopyButton = button({ style: "max-width:86px; width: 86px;", class: "copyButton", title: "Copy Instrument (C)" }, [
                "Copy",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "-5 -21 26 26" }, [
                    SVG.path({ d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z", fill: "currentColor" }),
                ]),
            ]);
            this._instrumentPasteButton = button({ style: "max-width:86px;", class: "pasteButton", title: "Paste Instrument (V)" }, [
                "Paste",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 0 26 26" }, [
                    SVG.path({ d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z", stroke: "currentColor", fill: "none" }),
                    SVG.path({ d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z", fill: "currentColor", }),
                ]),
            ]);
            this._instrumentExportButton = button({ style: "max-width:86px; width: 86px;", class: "exportInstrumentButton" }, [
                "Export",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 -960 960 960" }, [
                    SVG.path({ d: "M200-120v-40h560v40H200Zm279.231-150.769L254.615-568.462h130.769V-840h188.462v271.538h130.77L479.231-270.769Zm0-65.385 142.923-191.538h-88.308V-800H425.385v272.308h-88.308l142.154 191.538ZM480-527.692Z", fill: "currentColor" }),
                ]),
            ]);
            this._instrumentImportButton = button({ style: "max-width:86px;", class: "importInstrumentButton" }, [
                "Import",
                SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;", width: "2em", height: "2em", viewBox: "0 -960 960 960" }, [
                    SVG.path({ d: "M200-120v-40h560v40H200Zm185.384-150.769v-271.539H254.615L480-840l224.616 297.692h-130.77v271.539H385.384Zm40.001-40h108.461v-272.308h88.308L480-774.615 337.077-583.077h88.308v272.308ZM480-583.077Z", fill: "currentColor" }),
                ]),
            ]);
            this._globalOscscope = new oscilloscopeCanvas(canvas({ width: 400, height: 64, style: `width:160px; height:45px; border: 2px solid ${ColorConfig.uiWidgetBackground};margin:0px; position: static;`, id: "oscilloscopeAll" }), 1); 
            this._globalOscscopeContainer = div({ style: "height: 38px; margin-left: auto; margin-right: auto;" }, this._globalOscscope.canvas);
            this._customWaveDrawCanvas = new CustomChipCanvas(canvas({ width: 128, height: 52, style: "border:2px solid " + ColorConfig.uiWidgetBackground, id: "customWaveDrawCanvas" }), this.doc, (newArray) => new ChangeCustomWave(this.doc, newArray));
            this._customWavePresetDrop = buildHeaderedOptions("Load Preset", select({ style: "width: 50%; height:1.5em; text-align: center; text-align-last: center;" }), Config.chipWaves.map(wave => wave.name));
            this._customWaveZoom = button({ style: "margin-left:0.5em; height:1.5em; max-width: 20px;", onclick: () => this._openPrompt("customChipSettings") }, "+");
            this._customWaveDraw = div({ style: "height:80px; margin-top:10px; margin-bottom:5px" }, [
                div({ style: "height:54px; display:flex; justify-content:center;" }, [this._customWaveDrawCanvas.canvas]),
                div({ style: "margin-top:5px; display:flex; justify-content:center;" }, [this._customWavePresetDrop, this._customWaveZoom]),
            ]);
            this._songTitleInputBox = new InputBox(input({ style: "font-weight:bold; border:none; width: 98%; background-color:${ColorConfig.editorBackground}; color:${ColorConfig.primaryText}; text-align:center", maxlength: "30", type: "text", value: EditorConfig.versionDisplayName }), this.doc, (oldValue, newValue) => new ChangeSongTitle(this.doc, oldValue, newValue));
            this._feedbackAmplitudeSlider = new Slider(input({ type: "range", min: "0", max: Config.operatorAmplitudeMax, value: "0", step: "1", title: "Feedback Amplitude" }), this.doc, (oldValue, newValue) => new ChangeFeedbackAmplitude(this.doc, oldValue, newValue), false);
            this._feedbackRow2 = div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("feedbackVolume") }, "Fdback Vol:"), this._feedbackAmplitudeSlider.container);
            this._addEnvelopeButton = button({ type: "button", class: "add-envelope" });
            this._customInstrumentSettingsGroup = div({ class: "editor-controls" }, this._panSliderRow, this._panDropdownGroup, this._chipWaveSelectRow, this._chipWaveError, this._chipNoiseSelectRow, this._useChipWaveAdvancedLoopControlsRow, this._chipWaveLoopModeSelectRow, this._chipWaveLoopStartRow, this._chipWaveLoopEndRow, this._chipWaveStartOffsetRow, this._chipWavePlayBackwardsRow, this._customWaveDraw, this._eqFilterTypeRow, this._eqFilterRow, this._eqFilterSimpleCutRow, this._eqFilterSimplePeakRow, this._fadeInOutRow, this._algorithmSelectRow, this._algorithm6OpSelectRow, this._phaseModGroup, this._feedbackRow1, this._feedback6OpRow1, this._feedbackRow2, this._spectrumRow, this._harmonicsRow, this._drumsetGroup, this._supersawDynamismRow, this._supersawSpreadRow, this._supersawShapeRow, this._pulseWidthRow, this._pulseWidthDropdownGroup, this._stringSustainRow, this._unisonSelectRow, this._unisonDropdownGroup, div({ style: `padding: 2px 0; margin-left: 2em; display: flex; align-items: center;` }, span({ style: `flex-grow: 1; text-align: center;` }, span({ class: "tip", onclick: () => this._openPrompt("effects") }, "Effects")), div({ class: "effects-menu" }, this._effectsSelect)), this._transitionRow, this._transitionDropdownGroup, this._chordSelectRow, this._chordStrumDropdownGroup,this._chordDropdownGroup, this._pitchShiftRow, this._octaveShiftRow , this._functionRow,  this._detuneSliderRow, this._vibratoSelectRow, this._vibratoDropdownGroup, this._noteFilterTypeRow, this._noteFilterRow, this._noteFilterSimpleCutRow, this._noteFilterSimplePeakRow, this._distortionRow, this._aliasingRow, this._bitcrusherQuantizationRow, this._bitcrusherFreqRow, this._chorusRow, this._echoSustainRow, this._echoDelayRow, this._reverbRow, this._ringModContainerRow,  this._phaserMixRow, this._phaserFreqRow, this._phaserFeedbackRow, this._phaserStagesRow,  this._granularContainerRow, div({ style: `padding: 2px 0; margin-left: 2em; display: flex; align-items: center;` }, span({ style: `flex-grow: 1; text-align: center;` }, span({ class: "tip", onclick: () => this._openPrompt("envelopes") }, "Envelopes")), this._envelopeDropdown, this._addEnvelopeButton), this._envelopeDropdownGroup, this.envelopeEditor.container);
            this._instrumentCopyGroup = div({ class: "editor-controls" }, div({ class: "selectRow" }, this._instrumentCopyButton, this._instrumentPasteButton));
            this._instrumentExportGroup = div({ class: "editor-controls" }, div({ class: "selectRow" }, this._instrumentExportButton, this._instrumentImportButton));
            
             
            this._instrumentName = input$8({ style: "width: 12em; font-size: 80%; display: flex; align-self: center; outline:none", id: "instrumentName", type: "text", value: "Instrument Settings" });
            
            this._instrumentSettingsTextRow = div({ id: "instrumentSettingsText", style: `margin-top:15px; padding: 3px 0; max-width: 12em; display: flex; align-self: center;  color: ${ColorConfig.secondaryText};` }, "Instrument Settings");
            this._instrumentTypeSelectRow = div({ class: "selectRow", id: "typeSelectRow" }, span({ class: "tip", onclick: () => this._openPrompt("instrumentType") }, "Type:"), div(div({ class: "pitchSelect" }, this._pitchedPresetSelect), div({ class: "drumSelect" }, this._drumPresetSelect)));
            this._instrumentSettingsGroup = div({ class: "editor-controls" },this._instrumentName, this._instrumentSettingsTextRow, this._instrumentsButtonRow, this._instrumentTypeSelectRow, this._instrumentVolumeSliderRow, this._customInstrumentSettingsGroup);
            
             
            this._usedPatternIndicator = SVG.path({ d: "M -6 -6 H 6 V 6 H -6 V -6 M -2 -3 L -2 -3 L -1 -4 H 1 V 4 H -1 V -1.2 L -1.2 -1 H -2 V -3 z", fill: ColorConfig.indicatorSecondary, "fill-rule": "evenodd" });
            this._usedInstrumentIndicator = SVG.path({ d: "M -6 -0.8 H -3.8 V -6 H 0.8 V 4.4 H 2.2 V -0.8 H 6 V 0.8 H 3.8 V 6 H -0.8 V -4.4 H -2.2 V 0.8 H -6 z", fill: ColorConfig.indicatorSecondary });
            this._jumpToModIndicator = SVG.svg({ style: "width: 92%; height: 1.3em; flex-shrink: 0; position: absolute;", viewBox: "0 0 200 200" }, [
                SVG.path({ d: "M90 155 l0 -45 -45 0 c-25 0 -45 -4 -45 -10 0 -5 20 -10 45 -10 l45 0 0 -45 c0 -25 5 -45 10 -45 6 0 10 20 10 45 l0 45 45 0 c25 0 45 5 45 10 0 6 -20 10 -45 10 l -45 0 0 45 c0 25 -4 45 -10 45 -5 0 -10 -20 -10 -45z" }),
                SVG.path({ d: "M42 158 c-15 -15 -16 -38 -2 -38 6 0 10 7 10 15 0 8 7 15 15 15 8 0 15 5 15 10 0 14 -23 13 -38 -2z" }),
                SVG.path({ d: "M120 160 c0 -5 7 -10 15 -10 8 0 15 -7 15 -15 0 -8 5 -15 10 -15 14 0 13 23 -2 38 -15 15 -38 16 -38 2z" }),
                SVG.path({ d: "M32 58 c3 -23 48 -40 48 -19 0 6 -7 11 -15 11 -8 0 -15 7 -15 15 0 8 -5 15 -11 15 -6 0 -9 -10 -7 -22z" }),
                SVG.path({ d: "M150 65 c0 -8 -7 -15 -15 -15 -8 0 -15 -4 -15 -10 0 -14 23 -13 38 2 15 15 16 38 2 38 -5 0 -10 -7 -10 -15z" })
            ]);
            this._promptContainer = div({ class: "promptContainer", style: "display: none; height: 100%; width: 100%; position: fixed; z-index: 100; overflow-x: hidden;" });
            this._promptContainerBG = div({ class: "promptContainerBG", style: "display: none; height: 100%; width: 100%; position: fixed; z-index: 99; overflow-x: hidden; pointer-events: none;" });
            this._zoomInButton = button({ class: "zoomInButton", type: "button", title: "Zoom In" });
            this._zoomOutButton = button({ class: "zoomOutButton", type: "button", title: "Zoom Out" });
            this._patternEditorRow = div({ style: "flex: 1; height: 100%; display: flex; overflow: hidden; justify-content: center;" }, this._patternEditorPrev.container, this._patternEditor.container, this._patternEditorNext.container);
            this._patternArea = div({ class: "pattern-area" }, this._piano.container, this._patternEditorRow, this._octaveScrollBar.container, this._zoomInButton, this._zoomOutButton);
            this._trackContainer = div({ class: "trackContainer" }, this._trackEditor.container, this._loopEditor.container);
            this._trackVisibleArea = div({ style: "position: absolute; width: 100%; height: 100%; pointer-events: none;" });
            this._trackAndMuteContainer = div({ class: "trackAndMuteContainer" }, this._muteEditor.container, this._trackContainer, this._trackVisibleArea);
            this._barScrollBar = new BarScrollBar(this.doc);
            this._trackArea = div({ class: "track-area" }, this._trackAndMuteContainer, this._barScrollBar.container);
            this._editMenu.options[0].textContent = "Edit Song";
            this._optionsMenu.options[0].textContent = "Settings"
            function setPreferencesIcon(svgString) {
               const encoded = encodeURIComponent(svgString);
               document.documentElement.style.setProperty(
               "--preferences-gear-symbol",
               `url("data:image/svg+xml,${encoded}")`
               );
            }
 
            this._menuArea = div({ class: "menu-area" }, div({ class: "selectContainer menu file" }, this._fileMenu), div({ class: "selectContainer menu preferences" }, this._optionsMenu) ,div({ class: "selectContainer menu edit" }, this._editMenu)); 
            if(this.doc.prefs.oldButtonSheme){
            	this._editMenu.options[0].textContent = "Edit";
             setPreferencesIcon('<svg xmlns="http:\/\/www.w3.org/2000\/svg" width="26" height="26" viewBox="-13 -13 26 26"><path d="M 5.78 -1.6 L 7.93 -0.94 L 7.93 0.94 L 5.78 1.6 L 4.85 3.53 L 5.68 5.61 L 4.21 6.78 L 2.36 5.52 L 0.27 5.99 L -0.85 7.94 L -2.68 7.52 L -2.84 5.28 L -4.52 3.95 L -6.73 4.28 L -7.55 2.59 L -5.9 1.07 L -5.9 -1.07 L -7.55 -2.59 L -6.73 -4.28 L -4.52 -3.95 L -2.84 -5.28 L -2.68 -7.52 L -0.85 -7.94 L 0.27 -5.99 L 2.36 -5.52 L 4.21 -6.78 L 5.68 -5.61 L 4.85 -3.53 M 2.92 0.67 L 2.92 -0.67 L 2.35 -1.87 L 1.3 -2.7 L 0 -3 L -1.3 -2.7 L -2.35 -1.87 L -2.92 -0.67 L -2.92 0.67 L -2.35 1.87 L -1.3 2.7 L -0 3 L 1.3 2.7 L 2.35 1.87 z" fill="gray"\/><\/svg>')	
            	this._optionsMenu.options[0].textContent = "Preferences"
            	this._menuArea = div({ class: "menu-area" }, div({ class: "selectContainer menu file" }, this._fileMenu),div({ class: "selectContainer menu edit" }, this._editMenu), div({ class: "selectContainer menu preferences" }, this._optionsMenu) ); 
            }
            this._sampleLoadingBar = div({ style: `width: 0%; height: 100%; background-color: ${ColorConfig.indicatorPrimary};` });
            this._sampleLoadingBarContainer = div({ style: `width: 80%; height: 4px; overflow: hidden; margin-left: auto; margin-right: auto; margin-top: 0.5em; cursor: pointer; background-color: ${ColorConfig.indicatorSecondary};` }, this._sampleLoadingBar);
            this._sampleLoadingStatusContainer = div({ style: "cursor: pointer;" }, div({ style: `margin-top: 0.5em; text-align: center; color: ${ColorConfig.secondaryText};` }, "Sample Loading Status"), div({ class: "selectRow", style: "height: 6px; margin-bottom: 0.5em;" }, this._sampleLoadingBarContainer));
            this._songSettingsArea = div({ class: "song-settings-area" }, div({ class: "editor-controls" }, div({ class: "editor-song-settings" }, div({ style: "margin: 3px 0; position: relative; text-align: center; color: ${ColorConfig.secondaryText};" }, div({ class: "tip", style: "flex-shrink: 0; position:absolute; left: 0; top: 0; width: 12px; height: 12px", onclick: () => this._openPrompt("usedPattern") }, SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 0; pointer-events: none;", width: "12px", height: "12px", "margin-right": "0.5em", viewBox: "-6 -6 12 12" }, this._usedPatternIndicator)), div({ class: "tip", style: "flex-shrink: 0; position: absolute; left: 14px; top: 0; width: 12px; height: 12px", onclick: () => this._openPrompt("usedInstrument") }, SVG.svg({ style: "flex-shrink: 0; position: absolute; left: 0; top: 0; pointer-events: none;", width: "12px", height: "12px", "margin-right": "1em", viewBox: "-6 -6 12 12" }, this._usedInstrumentIndicator)), "Song Settings", div({ style: "width: 100%; left: 0; top: -1px; position:absolute; overflow-x:clip;" }, this._jumpToModIndicator))), div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("scale") }, "Scale: "), div({ class: "selectContainer" }, this._scaleSelect)), div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("key") }, "Key: "), div({ class: "selectContainer" }, this._keySelect)), div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("key_octave") }, "Octave: "), this._octaveStepper), div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("tempo") }, "Tempo: "), span({ style: "display: flex;" }, this._tempoSlider.container, this._tempoStepper)), div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("rhythm") }, "Rhythm: "), div({ class: "selectContainer" }, this._rhythmSelect)), div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("songeq") }, span("Song EQ:")), this._songEqFilterZoom, this._songEqFilterEditor.container), this._sampleLoadingStatusContainer));
            this._instrumentSettingsArea = div({ class: "instrument-settings-area" }, this._instrumentSettingsGroup, this._modulatorGroup);
            this._settingsArea = div({ class: "settings-area noSelection" }, div({ class: "version-area" }, div({ style: `text-align: center; margin: 3px 0; color: ${ColorConfig.secondaryText};` }, this._songTitleInputBox.input)), div({ class: "play-pause-area" }, this._volumeBarBox, div({ class: "playback-bar-controls" }, this._playButton, this._pauseButton, this._recordButton, this._stopButton, this._prevBarButton, this._nextBarButton), div({ class: "playback-volume-controls" }, span({ class: "volume-speaker" }), this._volumeSlider.container), this._globalOscscopeContainer), this._menuArea, this._songSettingsArea, this._instrumentSettingsArea);
            this.mainLayer = div({ class: "beepboxEditor", tabIndex: "0" }, this._patternArea, this._trackArea, this._settingsArea);
            document.body.appendChild(this._promptContainer)
            this._wasPlaying = false;
            this._currentPromptName = null;
            this._highlightedInstrumentIndex = -1;
            this._renderedInstrumentCount = 0;
            this._renderedIsPlaying = false;
            this._renderedIsRecording = false;
            this._renderedShowRecordButton = false;
            this._renderedCtrlHeld = false;
            this._ctrlHeld = false;
            this._shiftHeld = false;
            this._deactivatedInstruments = false;
            this._operatorRows = [];
            this._operatorAmplitudeSliders = [];
            this._operatorFrequencySelects = [];
            this._operatorDropdowns = [];
            this._operatorWaveformSelects = [];
            this._operatorWaveformHints = [];
            this._operatorWaveformPulsewidthSliders = [];
            this.waveformPulsewidthSlider= [];
            this._operatorDropdownRows = [];
            this._operatorDropdownGroups = [];
            this._drumsetSpectrumEditors = [];
            this._drumsetEnvelopeSelects = [];
            this._showModSliders = [];
            this._newShowModSliders = [];
            this._modSliderValues = [];
            this._hasActiveModSliders = false;
            this._openPanDropdown = false;
            this._openVibratoDropdown = false;
            this._openEnvelopeDropdown = false;
            this._openChordDropdown = false;
            this._openTransitionDropdown = false;
            this._openOperatorDropdowns = [];
            this._openPulseWidthDropdown = false;
            this._openUnisonDropdown = false;
            this.outVolumeHistoricTimer = 0;
            this.outVolumeHistoricCap = 0;
            this.lastOutVolumeCap = 0;
            this.patternUsed = false;
            this._modRecTimeout = -1;
            this._whenSampleLoadingStatusClicked = () => {
                this._openPrompt("sampleLoadingStatus");
            };
            this.refocusStage = () => {
                this.mainLayer.focus({ preventScroll: true });
            };
            this._onFocusIn = (event) => {
                if (this.doc.synth.recording && event.target != this.mainLayer && event.target != this._stopButton && event.target != this._volumeSlider.input) {
                    this.refocusStage();
                }
            };
            this._refocusStageNotEditing = () => {
                if (!this._patternEditor.editingModLabel)
                    this.mainLayer.focus({ preventScroll: true });
            };
            this.whenUpdated = () => { 
                const prefs = this.doc.prefs;
                this._muteEditor.container.style.display = prefs.enableChannelMuting ? "" : "none";
                const trackBounds = this._trackVisibleArea.getBoundingClientRect();
                this.doc.trackVisibleBars = Math.floor((trackBounds.right - trackBounds.left - (prefs.enableChannelMuting ? 32 : 0)) / this.doc.getBarWidth());
                this.doc.trackVisibleChannels = Math.floor((trackBounds.bottom - trackBounds.top - 30) / ChannelRow.patternHeight);
                for (let i = this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount; i < this.doc.song.channels.length; i++) {
                    const channel = this.doc.song.channels[i];
                    for (let j = 0; j < channel.instruments.length; j++) {
                        this.doc.synth.determineInvalidModulators(channel.instruments[j]);
                    }
                }
                this._barScrollBar.render();
                this._trackEditor.render();
                this._muteEditor.render();
                this._trackAndMuteContainer.scrollLeft = this.doc.barScrollPos * this.doc.getBarWidth();
                this._trackAndMuteContainer.scrollTop = this.doc.channelScrollPos * ChannelRow.patternHeight;
                if (document.activeElement != this._patternEditor.modDragValueLabel && this._patternEditor.editingModLabel) {
                    this._patternEditor.stopEditingModLabel(false);
                }
                this._piano.container.style.display = prefs.showLetters ? "" : "none";
                this._octaveScrollBar.container.style.display = prefs.showScrollBar ? "" : "none";
                this._barScrollBar.container.style.display = this.doc.song.barCount > this.doc.trackVisibleBars ? "" : "none";
                this._volumeBarBox.style.display = this.doc.prefs.displayVolumeBar ? "" : "none";
                this._globalOscscopeContainer.style.display = this.doc.prefs.showOscilloscope ? "" : "none";
                this.doc.synth.oscEnabled = this.doc.prefs.showOscilloscope;
                this._sampleLoadingStatusContainer.style.display = this.doc.prefs.showSampleLoadingStatus ? "" : "none";
                this._instrumentCopyGroup.style.display = this.doc.prefs.instrumentCopyPaste ? "" : "none";
                this._instrumentExportGroup.style.display = this.doc.prefs.instrumentImportExport ? "" : "none";
                this._instrumentSettingsArea.style.scrollbarWidth = this.doc.prefs.showInstrumentScrollbars ? "" : "none";
 
                if (document.getElementById('text-content'))
                    document.getElementById('text-content').style.display = this.doc.prefs.showDescription ? "" : "none";
                if (this.doc.getFullScreen()) {
                    const semitoneHeight = this._patternEditorRow.clientHeight / this.doc.getVisiblePitchCount();
                    const targetBeatWidth = semitoneHeight * 5;
                    const minBeatWidth = this._patternEditorRow.clientWidth / (this.doc.song.beatsPerBar * 3);
                    const maxBeatWidth = this._patternEditorRow.clientWidth / (this.doc.song.beatsPerBar + 2);
                    const beatWidth = Math.max(minBeatWidth, Math.min(maxBeatWidth, targetBeatWidth));
                    const patternEditorWidth = beatWidth * this.doc.song.beatsPerBar;
                    const beepboxEditorContainer = document.getElementById("beepboxEditorContainer");
 
                    
                    if (this.doc.prefs.showDescription == false) {
                        beepboxEditorContainer.style.paddingBottom = "0";
                        beepboxEditorContainer.style.borderStyle = "none";
                    }
                    else {
                        beepboxEditorContainer.style.paddingBottom = "";
                        beepboxEditorContainer.style.borderStyle = "";
                    }
                    this._patternEditorPrev.container.style.width = patternEditorWidth + "px";
                    this._patternEditor.container.style.width = patternEditorWidth + "px";
                    this._patternEditorNext.container.style.width = patternEditorWidth + "px";
                    this._patternEditorPrev.container.style.flexShrink = "0";
                    this._patternEditor.container.style.flexShrink = "0";
                    this._patternEditorNext.container.style.flexShrink = "0";
                    this._patternEditorPrev.container.style.display = "";
                    this._patternEditorNext.container.style.display = "";
                    this._patternEditorPrev.render();
                    this._patternEditorNext.render();
                    this._zoomInButton.style.display = (this.doc.channel < this.doc.song.pitchChannelCount) ? "" : "none";
                    this._zoomOutButton.style.display = (this.doc.channel < this.doc.song.pitchChannelCount) ? "" : "none";
                    this._zoomInButton.style.right = prefs.showScrollBar ? "24px" : "4px";
                    this._zoomOutButton.style.right = prefs.showScrollBar ? "24px" : "4px";
                }
                else {
                    this._patternEditor.container.style.width = "";
                    this._patternEditor.container.style.flexShrink = "";
                    this._patternEditorPrev.container.style.display = "none";
                    this._patternEditorNext.container.style.display = "none";
                    this._zoomInButton.style.display = "none";
                    this._zoomOutButton.style.display = "none";
                }
                this._patternEditor.render();
                const textOnIcon = ColorConfig.getComputed("--text-enabled-icon");
                const textOffIcon = ColorConfig.getComputed("--text-disabled-icon");
                const textSpacingIcon = ColorConfig.getComputed("--text-spacing-icon");
                const optionCommands = [
                    "Technical",
                    (prefs.autoPlay ? textOnIcon : textOffIcon) + "Auto Play on Load",
                    (prefs.autoFollow ? textOnIcon : textOffIcon) + "Auto Follow Playhead",
                    (prefs.enableNotePreview ? textOnIcon : textOffIcon) + "Hear Added Notes",
                    (prefs.notesOutsideScale ? textOnIcon : textOffIcon) + "Place Notes Out of Scale",
                    (prefs.defaultScale == this.doc.song.scale ? textOnIcon : textOffIcon) + "Set Current Scale as Default",
                    (prefs.alwaysFineNoteVol ? textOnIcon : textOffIcon) + "Always Fine Note Volume",
                    (prefs.enableChannelMuting ? textOnIcon : textOffIcon) + "Enable Channel Muting",
                    (prefs.instrumentCopyPaste ? textOnIcon : textOffIcon) + "Enable Copy/Paste Buttons",
                    (prefs.instrumentImportExport ? textOnIcon : textOffIcon) + "Enable Import/Export Buttons",
                    (prefs.displayBrowserUrl ? textOnIcon : textOffIcon) + "Enable Song Data in URL",
                    (prefs.closePromptByClickoff ? textOnIcon : textOffIcon) + "Close Prompts on Click Off",
                    
                  ( prefs.increaseAllPins ? textOnIcon : textOffIcon) + "Increase All Pins",
                  
                    textSpacingIcon + "Note Recording...",
                    textSpacingIcon +  "Whistle Recording",
                    textSpacingIcon + "Appearance",
                    (prefs.showFifth ? textOnIcon : textOffIcon) + 'Highlight "Fifth" Note',
                    (prefs.notesFlashWhenPlayed ? textOnIcon : textOffIcon) + "Notes Flash When Played",
                    (prefs.instrumentButtonsAtTop ? textOnIcon : textOffIcon) + "Instrument Buttons at Top",
                    (prefs.frostedGlassBackground ? textOnIcon : textOffIcon) + "Frosted Glass Prompt Backdrop",
                    ( prefs.pianoKeyboard ? textOnIcon : textOffIcon) + "Better Piano Roll",
                    (prefs.useCustomSelectPrompt ? textOnIcon : textOffIcon) + "Use Custom Select Prompt",
                    (prefs.showChannels ? textOnIcon : textOffIcon) + "Show All Channels",
                    (prefs.showScrollBar ? textOnIcon : textOffIcon) + "Show Octave Scroll Bar",
                    (prefs.differentMod ? textOnIcon : textOffIcon) + "Different Mod",
                    (prefs.showInstrumentScrollbars ? textOnIcon : textOffIcon) + "Show Instrument Scrollbars",
                    (prefs.showLetters ? textOnIcon : textOffIcon) + "Show Piano Keys",
                    (prefs.displayVolumeBar ? textOnIcon : textOffIcon) + "Show Playback Volume",
                    (prefs.showOscilloscope ? textOnIcon : textOffIcon) + "Show Oscilloscope",
                    (prefs.showSampleLoadingStatus ? textOnIcon : textOffIcon) + "Show Sample Loading Status",
                    (prefs.showDescription ? textOnIcon : textOffIcon) + "Show Description",
                    ( prefs.oldButtonSheme ? textOnIcon : textOffIcon) + "Old Menu Sheme ()",
                    ( prefs.newloopeditor ? textOnIcon : textOffIcon) + "Not Centered Loop Editor",
                    textSpacingIcon + "Open Plugins",
                    textSpacingIcon + "Set Layout...",
                    textSpacingIcon + "Set Theme...",
                    textSpacingIcon + "Custom Theme...",
                    textSpacingIcon + "Open In Fullscreen",
                    textSpacingIcon + "Set Language...",
                ];
                const technicalOptionGroup = this._optionsMenu.children[1];
                for (let i = 0; i < technicalOptionGroup.children.length; i++) {
                    const option = technicalOptionGroup.children[i];
                    if (option.textContent != optionCommands[i + 1])
                        option.textContent = optionCommands[i + 1];
                }
                const appearanceOptionGroup = this._optionsMenu.children[2];
                for (let i = 0; i < appearanceOptionGroup.children.length; i++) {
                    const option = appearanceOptionGroup.children[i];
                    if (option.textContent != optionCommands[i + technicalOptionGroup.children.length + 2])
                        option.textContent = optionCommands[i + technicalOptionGroup.children.length + 2];
                }
                const channel = this.doc.song.channels[this.doc.channel];
                const instrumentIndex = this.doc.getCurrentInstrument();
                const instrument = channel.instruments[instrumentIndex];
                const wasActive = this.mainLayer.contains(document.activeElement);
                const activeElement = document.activeElement;
                const colors = ColorConfig.getChannelColor(this.doc.song, this.doc.channel);
                for (let i = this._effectsSelect.childElementCount - 1; i < Config.effectOrder.length; i++) {
                    this._effectsSelect.appendChild(option({ value: i }));
                }
                this._effectsSelect.selectedIndex = -1;
                for (let i = 0; i < Config.effectOrder.length; i++) {
                    let effectFlag = Config.effectOrder[i];
                    const selected = ((instrument.effects & (1 << effectFlag)) != 0);
                    const label = (selected ? textOnIcon : textOffIcon) + Config.effectNames[effectFlag];
                    const option = this._effectsSelect.children[i + 1];
                    if (option.textContent != label)
                        option.textContent = label;
                }
                setSelectedValue(this._scaleSelect, this.doc.song.scale);
                this._scaleSelect.title = Config.scales[this.doc.song.scale].realName;
                setSelectedValue(this._keySelect, Config.keys.length - 1 - this.doc.song.key);
                this._octaveStepper.value = Math.round(this.doc.song.octave).toString();
                this._tempoSlider.updateValue(Math.max(0, Math.round(this.doc.song.tempo)));
                this._tempoStepper.value = Math.round(this.doc.song.tempo).toString();
                this._songTitleInputBox.updateValue(this.doc.song.title);
                if (this.doc.synth.isFilterModActive(false, 0, 0, true)) {
                    this._songEqFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                }
                else {
                    this._songEqFilterEditor.render();
                }
                this._eqFilterTypeRow.style.setProperty("--text-color-lit", colors.primaryNote);
                this._eqFilterTypeRow.style.setProperty("--text-color-dim", colors.secondaryNote);
                this._eqFilterTypeRow.style.setProperty("--background-color-lit", colors.primaryChannel);
                this._eqFilterTypeRow.style.setProperty("--background-color-dim", colors.secondaryChannel);
                if (instrument.eqFilterType) {
                    this._eqFilterSimpleButton.classList.remove("deactivated");
                    this._eqFilterAdvancedButton.classList.add("deactivated");
                    this._eqFilterRow.style.display = "none";
                    this._eqFilterSimpleCutRow.style.display = "";
                    this._eqFilterSimplePeakRow.style.display = "";
                }
                else {
                    this._eqFilterSimpleButton.classList.add("deactivated");
                    this._eqFilterAdvancedButton.classList.remove("deactivated");
                    this._eqFilterRow.style.display = "";
                    this._eqFilterSimpleCutRow.style.display = "none";
                    this._eqFilterSimplePeakRow.style.display = "none";
                }
                setSelectedValue(this._rhythmSelect, this.doc.song.rhythm);
                if (!this.doc.song.getChannelIsMod(this.doc.channel)) {
                    this._customInstrumentSettingsGroup.style.display = "";
                    this._panSliderRow.style.display = "";
                    this._panDropdownGroup.style.display = (this._openPanDropdown ? "" : "none");
                    this._detuneSliderRow.style.display = "";
                    this._instrumentVolumeSliderRow.style.display = "";
                    this._instrumentTypeSelectRow.style.setProperty("display", "");
                    if (prefs.instrumentButtonsAtTop) {
                        this._instrumentSettingsGroup.insertBefore(this._instrumentExportGroup, this._instrumentSettingsGroup.firstChild);
                        this._instrumentSettingsGroup.insertBefore(this._instrumentCopyGroup, this._instrumentSettingsGroup.firstChild);
                    }
                    else {
                        this._instrumentSettingsGroup.appendChild(this._instrumentCopyGroup);
                        this._instrumentSettingsGroup.appendChild(this._instrumentExportGroup);
                    }
                    this._instrumentSettingsGroup.insertBefore(this._instrumentsButtonRow, this._instrumentSettingsGroup.firstChild);
                    this._instrumentSettingsGroup.insertBefore(this._instrumentSettingsTextRow, this._instrumentSettingsGroup.firstChild);
                    if (this.doc.song.channels[this.doc.channel].name == "") {
                        this._instrumentSettingsTextRow.textContent = "Instrument Settings";
                    }
                    else {
                        this._instrumentSettingsTextRow.textContent = this.doc.song.channels[this.doc.channel].name;
                    }
                    this._modulatorGroup.style.display = "none";
                    this._usageCheck(this.doc.channel, instrumentIndex);
                    if (this.doc.song.getChannelIsNoise(this.doc.channel)) {
                        this._pitchedPresetSelect.style.display = "none";
                        this._drumPresetSelect.style.display = "";
                        $("#pitchPresetSelect").parent().hide();
                        $("#drumPresetSelect").parent().show();
                        setSelectedValue(this._drumPresetSelect, instrument.preset, true);
                    }
                    else {
                        this._pitchedPresetSelect.style.display = "";
                        this._drumPresetSelect.style.display = "none";
                        $("#pitchPresetSelect").parent().show();
                        $("#drumPresetSelect").parent().hide();
                        setSelectedValue(this._pitchedPresetSelect, instrument.preset, true);
                    }
                    if (instrument.type == 2) {
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        this._chipNoiseSelectRow.style.display = "";
                        setSelectedValue(this._chipNoiseSelect, instrument.chipNoise, true);
                    }
                    else {
                        this._chipNoiseSelectRow.style.display = "none";
                    }
                    if (instrument.type == 3) {
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        this._spectrumRow.style.display = "";
                        this._spectrumEditor.render();
                    }
                    else {
                        this._spectrumRow.style.display = "none";
                    }
                    if (instrument.type == 5 || instrument.type == 7) {
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        this._harmonicsRow.style.display = "flex";
                        this._harmonicsEditor.render();
                    }
                    else {
                        this._harmonicsRow.style.display = "none";
                    }
                    if (instrument.type == 7) {
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        this._stringSustainRow.style.display = "";
                        this._stringSustainSlider.updateValue(instrument.stringSustain);
                        this._stringSustainLabel.textContent = Config.enableAcousticSustain ? "Sustain (" + Config.sustainTypeNames[instrument.stringSustainType].substring(0, 1).toUpperCase() + "):" : "Sustain:";
                    }
                    else {
                        this._stringSustainRow.style.display = "none";
                    }
                    if (instrument.type == 4) {
                        this._drumsetGroup.style.display = "";
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        this._fadeInOutRow.style.display = "none";
                        for (let i = 0; i < Config.drumCount; i++) {
                            setSelectedValue(this._drumsetEnvelopeSelects[i], instrument.drumsetEnvelopes[i]);
                            this._drumsetSpectrumEditors[i].render();
                        }
                    }
                    else {
                        this._drumsetGroup.style.display = "none";
                        this._fadeInOutRow.style.display = "";
                        this._fadeInOutEditor.render();
                    }
                    if (instrument.type == 0) {
                        this._chipWaveSelectRow.style.display = "";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "";
                        if (instrument.isUsingAdvancedLoopControls) {
                            this._chipWaveLoopModeSelectRow.style.display = "";
                            this._chipWaveLoopStartRow.style.display = "";
                            this._chipWaveLoopEndRow.style.display = "";
                            this._chipWaveStartOffsetRow.style.display = "";
                            this._chipWavePlayBackwardsRow.style.display = "";
                        }
                        else {
                            this._chipWaveLoopModeSelectRow.style.display = "none";
                            this._chipWaveLoopStartRow.style.display = "none";
                            this._chipWaveLoopEndRow.style.display = "none";
                            this._chipWaveStartOffsetRow.style.display = "none";
                            this._chipWavePlayBackwardsRow.style.display = "none";
                        }
                        let instrlast = instrument.chipWave;
                       setSelectedValue(this._chipWaveSelect, instrument.chipWave);
                       
                       var objectObject = buildOptions(select$6(), Config.chipWaves.map(wave => wave.name))
                       this._chipWaveSelect.innerHTML = objectObject.innerHTML
                       setSelectedValue(this._chipWaveSelect, instrlast);
                        if(instrument.wavenotfound){this._chipWaveError.innerText="Error loading: '"+instrument.wavenotfound+"'"}else{this._chipWaveError.innerText=""}
                        this._useChipWaveAdvancedLoopControlsBox.checked = instrument.isUsingAdvancedLoopControls ? true : false;
                        setSelectedValue(this._chipWaveLoopModeSelect, instrument.chipWaveLoopMode);
                        this._chipWaveLoopStartStepper.value = instrument.chipWaveLoopStart + "";
                        this._chipWaveLoopEndStepper.value = instrument.chipWaveLoopEnd + "";
                        this._chipWaveStartOffsetStepper.value = instrument.chipWaveStartOffset + "";
                        this._chipWavePlayBackwardsBox.checked = instrument.chipWavePlayBackwards ? true : false;
                    }else{ instrument.wavenotfound=null;if(instrument.wavenotfound){this._chipWaveError.innerText="Error loading: '"+instrument.wavenotfound+"'"}else{this._chipWaveError.innerText=""} }
                    if (instrument.type == 9) {
                        this._customWaveDraw.style.display = "";
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                    }
                    else {
                        this._customWaveDraw.style.display = "none";
                    }
                    if (instrument.type == 8) {
                        this._supersawDynamismRow.style.display = "";
                        this._supersawSpreadRow.style.display = "";
                        this._supersawShapeRow.style.display = "";
                        this._supersawDynamismSlider.updateValue(instrument.supersawDynamism);
                        this._supersawSpreadSlider.updateValue(instrument.supersawSpread);
                        this._supersawShapeSlider.updateValue(instrument.supersawShape);
                    }
                    else {
                        this._supersawDynamismRow.style.display = "none";
                        this._supersawSpreadRow.style.display = "none";
                        this._supersawShapeRow.style.display = "none";
                    }
                    if (instrument.type == 6 || instrument.type == 8) {
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        this._pulseWidthRow.style.display = "";
                        this._pulseWidthSlider.input.title = prettyNumber(instrument.pulseWidth) + "%";
                        this._pulseWidthSlider.updateValue(instrument.pulseWidth);
                        this._decimalOffsetSlider.input.title = instrument.decimalOffset / 100 <= 0 ? "none" : "-" + prettyNumber(instrument.decimalOffset / 100) + "%";
                        this._decimalOffsetSlider.updateValue(99 - instrument.decimalOffset);
                        this._pulseWidthDropdownGroup.style.display = (this._openPulseWidthDropdown ? "" : "none");
                    }
                    else {
                        this._pulseWidthRow.style.display = "none";
                        this._pulseWidthDropdownGroup.style.display = "none";
                    }
                    if (instrument.type == 1|| instrument.type == 11|| instrument.type == 12) {
                        this._phaseModGroup.style.display = "";
                        this._feedbackRow2.style.display = "";
                        this._chipWaveSelectRow.style.display = "none";
                        this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                        this._chipWaveLoopModeSelectRow.style.display = "none";
                        this._chipWaveLoopStartRow.style.display = "none";
                        this._chipWaveLoopEndRow.style.display = "none";
                        this._chipWaveStartOffsetRow.style.display = "none";
                        this._chipWavePlayBackwardsRow.style.display = "none";
                        // basically this shit rebuilds waveform Select in Fm6Op and Fm8Op 
                        const FeedSelectEl =this._feedback6OpTypeSelect;
                        FeedSelectEl.innerHTML = ""; 
                        if (instrument.type == 12) {
                       	Config.feedbacks8Op.forEach((alg, i) => {
                        		const opt = document.createElement("option");
	                        	opt.value = i;
                        		opt.textContent = alg.name;
                        		FeedSelectEl.appendChild(opt);
                       	});
                       } else {
                      	Config.feedbacks6Op.forEach((alg, i) => {
                     		const opt = document.createElement("option");
		                     opt.value = i;
                     		opt.textContent = alg.name;
                     		FeedSelectEl.appendChild(opt);
	                      });
                       }
                       const selectEl = this._algorithm6OpSelect;
                       selectEl.innerHTML = ""; 
                       if(instrument.type==12){
		                       Config.algorithms8Op.forEach((alg, i) => {
                         	const opt = document.createElement("option");
                         	opt.value = i;
                         	opt.textContent = alg.name;
                         	selectEl.appendChild(opt);
                       });
                       	}else{
                       	Config.algorithms6Op.forEach((alg, i) => {
                       	const opt = document.createElement("option");
                       	opt.value = i;
                       	opt.textContent = alg.name;
                       	selectEl.appendChild(opt);
                       });
                       	}
                       for (let i = 0; i < this._operatorWaveformSelects.length; i++) {
                       const select = this._operatorWaveformSelects[i];
                           if (!select) continue;
                           select.innerHTML = "";
                           if (instrument.type == 12) {
                           const classicGroup = document.createElement("optgroup");
                           classicGroup.label = "Normal";
                           Config.operatorWaves.forEach((wave, w) => {
                           const opt = document.createElement("option");
                           opt.value = w;
                           opt.textContent = wave.name;classicGroup.appendChild(opt);
                          });
                          select.appendChild(classicGroup);
                         const chipGroup = document.createElement("optgroup");
                          chipGroup.label = "Custom";
                          Config.chipWaves.forEach((wave, w) => {
                          if (!wave.samples) return;
                          const opt = document.createElement("option");
                          opt.value = w + Config.operatorWaves.length;
                               opt.textContent = wave.name;
                          chipGroup.appendChild(opt);});
                          select.appendChild(chipGroup);
                          } else {Config.operatorWaves.forEach((wave, w) => {const opt = document.createElement("option");opt.value = w;
                          opt.textContent = wave.name;select.appendChild(opt);});
                          }}
                       for (let i = 0; i < this._operatorAmplitudeSliders.length; i++) {
                           const slider = this._operatorAmplitudeSliders[i];
                           slider.input.step = instrument.type == 12 ? "0.25" : "1";
                       }
                        setSelectedValue(this._algorithmSelect, instrument.algorithm);
                       setSelectedValue(this._feedbackTypeSelect, instrument.feedbackType);
                       this._feedbackAmplitudeSlider.updateValue(instrument.feedbackAmplitude);
                        for (let i = 0; i < Config.operatorCount + (instrument.type == 11 ? 2 : instrument.type == 12 ? 4 : 0); i++) {
                            const isCarrier = instrument.type == 1 ? (i < Config.algorithms[instrument.algorithm].carrierCount) : (i < instrument.customAlgorithm.carrierCount);
                            this._operatorRows[i].style.color = isCarrier ? ColorConfig.primaryText : "";
                            setSelectedValue(this._operatorFrequencySelects[i], instrument.operators[i].frequency);
                            this._operatorAmplitudeSliders[i].updateValue(instrument.operators[i].amplitude);
                            const maxWave = Config.operatorWaves.length;
                            if (instrument.type == 11) {
                              for (let i = 0; i < instrument.operators.length; i++) {
                               if (instrument.operators[i].waveform >= maxWave) {
                                 instrument.operators[i].waveform = 0;
                               }
                             }
                            }
                            setSelectedValue(this._operatorWaveformSelects[i], instrument.operators[i].waveform); 
                            this._operatorWaveformPulsewidthSliders[i].updateValue(instrument.operators[i].pulseWidth);
                            if(instrument.operators[i].waveform==7){
                            	this._operatorWaveformPulsewidthSliders[i].input.title = "" + Config.expOperatorWaves[instrument.operators[i].pulseWidth].name;
                            }else if(instrument.operators[i].waveform==2){ 
                            	console.log("lol "+	instrument.operators[i].pulseWidth )
                            	if(	instrument.operators[i].pulseWidth>10){
                            		instrument.operators[i].pulseWidth=0
                            	}
                            	this._operatorWaveformPulsewidthSliders[i].input.title = "" + Config.pwmOperatorWaves[instrument.operators[i].pulseWidth].name; 
                            }
                            this._operatorDropdownGroups[i].style.color = isCarrier ? ColorConfig.primaryText : "";
                            const operatorName = (isCarrier ? "Voice " : "Modulator ") + (i + 1); 
                            this._operatorFrequencySelects[i].title = operatorName + " Frequency";
                            this._operatorAmplitudeSliders[i].input.title = operatorName + (isCarrier ? " Volume" : " Amplitude");
                            this._operatorDropdownGroups[i].style.display = (this._openOperatorDropdowns[i] ? "" : "none");
                            const wave = instrument.operators[i].waveform;
                          if (wave == 7) {this.waveformPulsewidthSlider[i].input.max = Config.expOperatorWaves.length - 1;
                          console.log(Config.expOperatorWaves[instrument.operators[i].pulseWidth].name)
                          this.waveformPulsewidthSlider[i].input.title = Config.expOperatorWaves[instrument.operators[i].pulseWidth].name;
                          } else if (wave == 2){
                          	this.waveformPulsewidthSlider[i].input.max = Config.pwmOperatorWaves.length - 1;this.waveformPulsewidthSlider[i].input.title = Config.pwmOperatorWaves[instrument.operators[i].pulseWidth].name;}
                            if (instrument.operators[i].waveform == 2 || instrument.operators[i].waveform == 7) {
                                this._operatorWaveformPulsewidthSliders[i].container.style.display = "";
                                this._operatorWaveformHints[i].style.display = "none";
                            }
                            else {
                                this._operatorWaveformPulsewidthSliders[i].container.style.display = "none";
                                this._operatorWaveformHints[i].style.display = "";
                            }
                        }
                        if (instrument.type == 11) {
                            setSelectedValue(this._algorithm6OpSelect, instrument.algorithm6Op);
                            setSelectedValue(this._feedback6OpTypeSelect, instrument.feedbackType6Op);
                            this._customAlgorithmCanvas.redrawCanvas();
                            this._algorithm6OpSelectRow.style.display = "";
                            this._feedback6OpRow1.style.display = "";
                            this._operatorRows[4].style.display = "";
                            this._operatorRows[5].style.display = "";
                            this._algorithm6OpSelectRow.style.marginBottom = "40px";
                            this._algorithm6OpSelectRow.style.marginRight = "2.5em";
                            this._operatorDropdownGroups[4].style.display = (this._openOperatorDropdowns[4] ? "" : "none");
                            this._operatorDropdownGroups[5].style.display = (this._openOperatorDropdowns[5] ? "" : "none");
                            this._operatorRows[6].style.display = "none";
                            this._operatorRows[7].style.display = "none";
                            this._algorithmSelectRow.style.display = "none";
                            this._feedbackRow1.style.display = "none";
                        }else if (instrument.type == 12) {
                            setSelectedValue(this._algorithm6OpSelect, instrument.algorithm6Op);
                            setSelectedValue(this._feedback6OpTypeSelect, instrument.feedbackType6Op);
                            this._customAlgorithmCanvas.redrawCanvas();
                            this._algorithm6OpSelectRow.style.display = "";
                            this._algorithm6OpSelectRow.style.marginBottom = "40px";
                            this._algorithm6OpSelectRow.style.marginRight = "2.5em";
                            this._feedback6OpRow1.style.display = "";
                            this._operatorRows[4].style.display = "";
                            this._operatorRows[5].style.display = "";
                            this._operatorRows[6].style.display = "";
                            this._operatorRows[7].style.display = "";
                            this._operatorDropdownGroups[4].style.display = (this._openOperatorDropdowns[4] ? "" : "none");
                            this._operatorDropdownGroups[5].style.display = (this._openOperatorDropdowns[5] ? "" : "none");
                            this._operatorDropdownGroups[6].style.display = (this._openOperatorDropdowns[6] ? "" : "none");
                            this._operatorDropdownGroups[7].style.display = (this._openOperatorDropdowns[7] ? "" : "none");
                            this._algorithmSelectRow.style.display = "none";
                            this._feedbackRow1.style.display = "none";
                        }
                        else {
                            this._algorithm6OpSelectRow.style.display = "none";
                            this._feedback6OpRow1.style.display = "none";
                            this._operatorRows[4].style.display = "none";
                            this._operatorRows[5].style.display = "none";
                            this._operatorRows[6].style.display = "none";
                            this._operatorRows[7].style.display = "none";
                            this._operatorDropdownGroups[4].style.display = "none";
                            this._operatorDropdownGroups[5].style.display = "none";
                            this._operatorDropdownGroups[6].style.display = "none";
                            this._algorithm6OpSelectRow.style.marginBottom = "5px";
                            this._operatorDropdownGroups[7].style.display = "none";
                            this._feedbackRow1.style.display = "";
                            this._algorithmSelectRow.style.display = "";
                        }
                    }
                    else {
                        this._algorithm6OpSelectRow.style.display = "none";
                        this._feedback6OpRow1.style.display = "none";
                        this._algorithmSelectRow.style.display = "none";
                        this._phaseModGroup.style.display = "none";
                        this._feedbackRow1.style.display = "none";
                        this._feedbackRow2.style.display = "none";
                    }
                    this._pulseWidthSlider.input.title = prettyNumber(instrument.pulseWidth) + "%";
                    if (effectsIncludeTransition(instrument.effects)) {
                        this._transitionRow.style.display = "";
                        if (this._openTransitionDropdown)
                            this._transitionDropdownGroup.style.display = "";
                        setSelectedValue(this._transitionSelect, instrument.transition);
                    }
                    else {
                        this._transitionDropdownGroup.style.display = "none";
                        this._transitionRow.style.display = "none";
                    }
                    if (effectsIncludeChord(instrument.effects)) {
                        this._chordSelectRow.style.display = "flex";
                        this._chordDropdown.style.display = instrument.chord == Config.chords.dictionary["arpeggio"].index  ? "" : "none";
                       
                        if (instrument.chord == Config.chords.dictionary["monophonic"].index) {
                            this._monophonicNoteInputBox.value = instrument.monoChordTone + 1 + "";
                            this._monophonicNoteInputBox.style.display = "";
                            this._chordSelectContainer.style.width = "52.5%";
                        }
                        else {
                            this._monophonicNoteInputBox.style.display = "none";
                            this._chordSelectContainer.style.width = "61.5%";
                        }
                    }
                    else {
                        this._chordSelectRow.style.display = "none";
                        this._chordDropdown.style.display = "none";
                        this._chordDropdownGroup.style.display = "none";
                    }
                    if (effectsIncludePitchShift(instrument.effects)) {
                        this._pitchShiftRow.style.display = "";
                        this._pitchShiftSlider.updateValue(instrument.pitchShift);
                        this._pitchShiftSlider.input.title = (instrument.pitchShift - Config.pitchShiftCenter) + " semitone(s)";
                        for (const marker of this._pitchShiftFifthMarkers) {
                            marker.style.display = prefs.showFifth ? "" : "none";
                        }
                    }
                    else {
                        this._pitchShiftRow.style.display = "none";
                    }
                    if (effectsIncludeOctaveShift(instrument.effects)) {
                        this._octaveShiftRow.style.display = "";
                        this._octaveShiftSlider.updateValue(instrument.octaveShift);
                        this._octaveShiftSlider.input.title = (instrument.octaveShift - Config.pitchShiftCenter) + " octave(s)";
                        for (const marker of this._octaveShiftFifthMarkers) {
                            marker.style.display = prefs.showFifth ? "" : "none";
                        }
                    }
                    else {
                        this._octaveShiftRow.style.display = "none";
                    }
                    
                    if (effectsIncludeFunction(instrument.effects)) {
                        this._functionRow.style.display = "";
                        if(instrument.customfunction[1]){
                        editor._fnInput.value = instrument.customfunction[1]
                        }
                    }
                    else {
                        this._functionRow.style.display = "none";
                    }
                    
                    if (effectsIncludeDetune(instrument.effects)) {
                        this._detuneSliderRow.style.display = "";
                        this._detuneSlider.updateValue(instrument.detune - Config.detuneCenter);
                        this._detuneSlider.input.title = (Synth.detuneToCents(instrument.detune)) + " cent(s)";
                    }
                    else {
                        this._detuneSliderRow.style.display = "none";
                    }
                    if (effectsIncludeVibrato(instrument.effects)) {
                        this._vibratoSelectRow.style.display = "";
                        if (this._openVibratoDropdown)
                            this._vibratoDropdownGroup.style.display = "";
                        setSelectedValue(this._vibratoSelect, instrument.vibrato);
                    }
                    else {
                        this._vibratoDropdownGroup.style.display = "none";
                        this._vibratoSelectRow.style.display = "none";
                    }
                    if (effectsIncludeNoteFilter(instrument.effects)) {
                        this._noteFilterTypeRow.style.setProperty("--text-color-lit", colors.primaryNote);
                        this._noteFilterTypeRow.style.setProperty("--text-color-dim", colors.secondaryNote);
                        this._noteFilterTypeRow.style.setProperty("--background-color-lit", colors.primaryChannel);
                        this._noteFilterTypeRow.style.setProperty("--background-color-dim", colors.secondaryChannel);
                        this._noteFilterTypeRow.style.display = "";
                        if (this.doc.synth.isFilterModActive(true, this.doc.channel, this.doc.getCurrentInstrument())) {
                            this._noteFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                        }
                        else {
                            this._noteFilterEditor.render();
                        }
                        if (instrument.noteFilterType) {
                            this._noteFilterSimpleButton.classList.remove("deactivated");
                            this._noteFilterAdvancedButton.classList.add("deactivated");
                            this._noteFilterRow.style.display = "none";
                            this._noteFilterSimpleCutRow.style.display = "";
                            this._noteFilterSimplePeakRow.style.display = "";
                        }
                        else {
                            this._noteFilterSimpleButton.classList.add("deactivated");
                            this._noteFilterAdvancedButton.classList.remove("deactivated");
                            this._noteFilterRow.style.display = "";
                            this._noteFilterSimpleCutRow.style.display = "none";
                            this._noteFilterSimplePeakRow.style.display = "none";
                        }
                    }
                    else {
                        this._noteFilterRow.style.display = "none";
                        this._noteFilterSimpleCutRow.style.display = "none";
                        this._noteFilterSimplePeakRow.style.display = "none";
                        this._noteFilterTypeRow.style.display = "none";
                    }
                    if (effectsIncludeDistortion(instrument.effects)) {
                        this._distortionRow.style.display = "";
                        if (instrument.type == 0 || instrument.type == 9 || instrument.type == 6 || instrument.type == 8)
                            this._aliasingRow.style.display = "";
                        else
                            this._aliasingRow.style.display = "none";
                        this._distortionSlider.updateValue(instrument.distortion);
                    }
                    else {
                        this._distortionRow.style.display = "none";
                        this._aliasingRow.style.display = "none";
                    }
                    if (effectsIncludeBitcrusher(instrument.effects)) {
                        this._bitcrusherQuantizationRow.style.display = "";
                        this._bitcrusherFreqRow.style.display = "";
                        this._bitcrusherQuantizationSlider.updateValue(instrument.bitcrusherQuantization);
                        this._bitcrusherFreqSlider.updateValue(instrument.bitcrusherFreq);
                    }
                    else {
                        this._bitcrusherQuantizationRow.style.display = "none";
                        this._bitcrusherFreqRow.style.display = "none";
                    }
                    if (effectsIncludePanning(instrument.effects)) {
                        this._panSliderRow.style.display = "";
                        if (this._openPanDropdown)
                            this._panDropdownGroup.style.display = "";
                        this._panSlider.updateValue(instrument.pan);
                    }
                    else {
                        this._panSliderRow.style.display = "none";
                        this._panDropdownGroup.style.display = "none";
                    }
                    if (effectsIncludeChorus(instrument.effects)) {
                        this._chorusRow.style.display = "";
                        this._chorusSlider.updateValue(instrument.chorus);
                    }
                    else {
                        this._chorusRow.style.display = "none";
                    }
                    if (effectsIncludeEcho(instrument.effects)) {
                        this._echoSustainRow.style.display = "";
                        this._echoSustainSlider.updateValue(instrument.echoSustain);
                        this._echoDelayRow.style.display = "";
                        this._echoDelaySlider.updateValue(instrument.echoDelay);
                        this._echoDelaySlider.input.title = (Math.round((instrument.echoDelay + 1) * Config.echoDelayStepTicks / (Config.ticksPerPart * Config.partsPerBeat) * 1000) / 1000) + " beat(s)";
                    }
                    else {
                        this._echoSustainRow.style.display = "none";
                        this._echoDelayRow.style.display = "none";
                    }
                    if (effectsIncludeReverb(instrument.effects)) {
                        this._reverbRow.style.display = "";
                        this._reverbSlider.updateValue(instrument.reverb);
                    }
                    else {
                        this._reverbRow.style.display = "none";
                    }
                    if (effectsIncludePhaser(instrument.effects)) {
                        this._phaserMixRow.style.display = "";
                        this._phaserMixSlider.updateValue(instrument.phaserMix);
                        this._phaserFreqRow.style.display = "";
                        this._phaserFreqSlider.updateValue(instrument.phaserFreq);
                        this._phaserFeedbackRow.style.display = "";
                        this._phaserFeedbackSlider.updateValue(instrument.phaserFeedback);
                        this._phaserStagesRow.style.display = "";
                        this._phaserStagesSlider.updateValue(instrument.phaserStages);
                    }
                    else {
                        this._phaserMixRow.style.display = "none";
                        this._phaserFreqRow.style.display = "none";
                        this._phaserFeedbackRow.style.display = "none";
                        this._phaserStagesRow.style.display = "none";
                    }
                    if (effectsIncludeRingModulation(instrument.effects)) {
                        this._ringModContainerRow.style.display = "";
                        this._ringModSlider.updateValue(instrument.ringModulation);
                        this._ringModHzSlider.updateValue(instrument.ringModulationHz);
                        const select = this._ringModWaveSelect;
                        select.innerHTML = "";
                        const classicGroup = document.createElement("optgroup");
                        classicGroup.label = "Normal";
                        Config.operatorWaves.forEach((wave, w) => {
                        const opt = document.createElement("option");
                        opt.value = w;
                        opt.textContent = wave.name;classicGroup.appendChild(opt);
                        });
                        select.appendChild(classicGroup);
                        const chipGroup = document.createElement("optgroup");
                        chipGroup.label = "Custom";
                        Config.chipWaves.forEach((wave, w) => {
                        if (!wave.samples) return;
                        const opt = document.createElement("option");
                        opt.value = w + Config.operatorWaves.length;
                        opt.textContent = wave.name;
                        chipGroup.appendChild(opt);});
                        select.appendChild(chipGroup);
                        setSelectedValue(this._ringModWaveSelect, instrument.ringModWaveformIndex);
                        this._ringModPulsewidthSlider.updateValue(instrument.ringModPulseWidth);
                    }
                    else {
                        this._ringModContainerRow.style.display = "none";
                    }
                    if (effectsIncludeGranular(instrument.effects)) {
                        this._granularContainerRow.style.display = "";
                        this._granularSlider.updateValue(instrument.granular);
                        this._grainSizeSlider.updateValue(instrument.grainSize);
                        this._grainAmountsSlider.updateValue(instrument.grainAmounts);
                        this._grainRangeSlider.updateValue(instrument.grainRange);
                    }
                    else {
                        this._granularContainerRow.style.display = "none";
                    }
                     
                    if (instrument.type == 0 || instrument.type == 9 || instrument.type == 5 || instrument.type == 7 || instrument.type == 3 || instrument.type == 6 || instrument.type == 2 || instrument.type == 4 ) {
                        this._unisonSelectRow.style.display = "";
                        setSelectedValue(this._unisonSelect, instrument.unison);
                        this._unisonVoicesInputBox.value = instrument.unisonVoices + "";
                        this._unisonSpreadInputBox.value = instrument.unisonSpread + "";
                        this._unisonOffsetInputBox.value = instrument.unisonOffset + "";
                        this._unisonExpressionInputBox.value = instrument.unisonExpression + "";
                        this._unisonSignInputBox.value = instrument.unisonSign + "";
                        this._unisonDropdownGroup.style.display = (this._openUnisonDropdown ? "" : "none");
                    }
                    else {
                        this._unisonSelectRow.style.display = "none";
                        this._unisonDropdownGroup.style.display = "none";
                    }
                    if (this._openEnvelopeDropdown)
                        this._envelopeDropdownGroup.style.display = "";
                    else
                        this._envelopeDropdownGroup.style.display = "none";
                    this.envelopeEditor.render();
                    this.envelopeEditor.rerenderExtraSettings();
                    for (let chordIndex = 0; chordIndex < Config.chords.length; chordIndex++) {
                        let hidden = (!Config.instrumentTypeHasSpecialInterval[instrument.type] && Config.chords[chordIndex].customInterval);
                        const option = this._chordSelect.children[chordIndex];
                        if (hidden) {
                            if (!option.hasAttribute("hidden")) {
                                option.setAttribute("hidden", "");
                            }
                        }
                        else {
                            option.removeAttribute("hidden");
                        }
                    }
                    this._instrumentSettingsGroup.style.color = ColorConfig.getChannelColor(this.doc.song, this.doc.channel).primaryNote;
                    setSelectedValue(this._transitionSelect, instrument.transition);
                    setSelectedValue(this._vibratoSelect, instrument.vibrato);
                    setSelectedValue(this._vibratoTypeSelect, instrument.vibratoType);
                    setSelectedValue(this._chordSelect, instrument.chord);
                    if (instrument.pitchShift) {
                     	this._pitchShiftBox.value = instrument.pitchShift
                    }
                    if (instrument.octaveShift) {
                     	this._octaveShiftBox.value = instrument.octaveShift
                    }
                    if(instrument.customfunction){
                       	if(instrument.customfunction[1]){this._fnInput.value = instrument.customfunction[1]}
                        if(instrument.customfunction[0]){}
                    }
                    this._instrumentName.value=this.doc.song.channels[this.doc.channel].name 
                    this._panSliderInputBox.value = instrument.pan + "";
                    this._pwmSliderInputBox.value = instrument.pulseWidth + "";
                    this._detuneSliderInputBox.value = (instrument.detune - Config.detuneCenter) + "";
                    this.ringModHzNum.innerHTML = " (" + calculateRingModHertz(instrument.ringModulationHz / (Config.ringModHzRange - 1)) + ")";
                    this.grainSizeNum.innerHTML = " (" + instrument.grainSize * Config.grainSizeStep + ")";
                    this.grainRangeNum.innerHTML = " (" + instrument.grainRange * Config.grainSizeStep + ")";
                    this._instrumentVolumeSlider.updateValue(instrument.volume);
                    this._instrumentVolumeSliderInputBox.value = "" + (instrument.volume);
                    this._vibratoDepthSlider.updateValue(Math.round(instrument.vibratoDepth * 25));
                    this._vibratoDelaySlider.updateValue(Math.round(instrument.vibratoDelay));
                    this._vibratoSpeedSlider.updateValue(instrument.vibratoSpeed);
                    setSelectedValue(this._vibratoTypeSelect, instrument.vibratoType);
                    this._arpeggioSpeedSlider.updateValue(instrument.arpeggioSpeed);
                    this._panDelaySlider.updateValue(instrument.panDelay);
                    this._vibratoDelaySlider.input.title = "" + Math.round(instrument.vibratoDelay);
                    this._vibratoDepthSlider.input.title = "" + instrument.vibratoDepth;
                    this._vibratoSpeedSlider.input.title = "x" + instrument.vibratoSpeed / 10;
                    this._vibratoSpeedDisplay.textContent = "x" + instrument.vibratoSpeed / 10;
                    this._panDelaySlider.input.title = "" + instrument.panDelay;
                    this._arpeggioSpeedSlider.input.title = "x" + prettyNumber(Config.arpSpeedScale[instrument.arpeggioSpeed]);
                    this._arpeggioSpeedDisplay.textContent = "x" + prettyNumber(Config.arpSpeedScale[instrument.arpeggioSpeed]);
                    this._eqFilterSimpleCutSlider.updateValue(instrument.eqFilterSimpleCut);
                    this._eqFilterSimplePeakSlider.updateValue(instrument.eqFilterSimplePeak);
                    this._noteFilterSimpleCutSlider.updateValue(instrument.noteFilterSimpleCut);
                    this._noteFilterSimplePeakSlider.updateValue(instrument.noteFilterSimplePeak);
                    this._envelopeSpeedSlider.updateValue(instrument.envelopeSpeed);
                    this._envelopeSpeedSlider.input.title = "x" + prettyNumber(Config.arpSpeedScale[instrument.envelopeSpeed]);
                    this._envelopeSpeedDisplay.textContent = "x" + prettyNumber(Config.arpSpeedScale[instrument.envelopeSpeed]);
                    if (instrument.type == 9) {
                        this._customWaveDrawCanvas.redrawCanvas();
                        if (this.prompt instanceof CustomChipPrompt) {
                            this.prompt.customChipCanvas.render();
                        }
                    }
                    this._renderInstrumentBar(channel, instrumentIndex, colors);
                }
                else {
                    this._usageCheck(this.doc.channel, instrumentIndex);
                    this._pitchedPresetSelect.style.display = "none";
                    this._drumPresetSelect.style.display = "none";
                    $("#pitchPresetSelect").parent().hide();
                    $("#drumPresetSelect").parent().hide();
                    if (prefs.instrumentButtonsAtTop) {
                        this._modulatorGroup.insertBefore(this._instrumentExportGroup, this._modulatorGroup.firstChild);
                        this._modulatorGroup.insertBefore(this._instrumentCopyGroup, this._modulatorGroup.firstChild);
                    }
                    else {
                        this._modulatorGroup.appendChild(this._instrumentCopyGroup);
                        this._modulatorGroup.appendChild(this._instrumentExportGroup);
                    }
                    this._modulatorGroup.insertBefore(this._instrumentsButtonRow, this._modulatorGroup.firstChild);
                    this._modulatorGroup.insertBefore(this._instrumentSettingsTextRow, this._modulatorGroup.firstChild);
                    if (this.doc.song.channels[this.doc.channel].name == "") {
                        this._instrumentSettingsTextRow.textContent = "Modulator Settings";
                    }
                    else {
                        this._instrumentSettingsTextRow.textContent = this.doc.song.channels[this.doc.channel].name;
                    }
                    this._chipNoiseSelectRow.style.display = "none";
                    this._chipWaveSelectRow.style.display = "none";
                    this._useChipWaveAdvancedLoopControlsRow.style.display = "none";
                    this._chipWaveLoopModeSelectRow.style.display = "none";
                    this._chipWaveLoopStartRow.style.display = "none";
                    this._chipWaveLoopEndRow.style.display = "none";
                    this._chipWaveStartOffsetRow.style.display = "none";
                    this._chipWavePlayBackwardsRow.style.display = "none";
                    this._spectrumRow.style.display = "none";
                    this._harmonicsRow.style.display = "none";
                    this._transitionRow.style.display = "none";
                    this._chordSelectRow.style.display = "none";
                    this._chordDropdownGroup.style.display = "none";
                    this._drumsetGroup.style.display = "none";
                    this._customWaveDraw.style.display = "none";
                    this._supersawDynamismRow.style.display = "none";
                    this._supersawSpreadRow.style.display = "none";
                    this._supersawShapeRow.style.display = "none";
                    this._algorithmSelectRow.style.display = "none";
                    this._phaseModGroup.style.display = "none";
                    this._feedbackRow1.style.display = "none";
                    this._feedbackRow2.style.display = "none";
                    this._pulseWidthRow.style.display = "none";
                    this._vibratoSelectRow.style.display = "none";
                    this._vibratoDropdownGroup.style.display = "none";
                    this._envelopeDropdownGroup.style.display = "none";
                    this._detuneSliderRow.style.display = "none";
                    this._panSliderRow.style.display = "none";
                    this._panDropdownGroup.style.display = "none";
                    this._pulseWidthDropdownGroup.style.display = "none";
                    this._unisonDropdownGroup.style.display = "none";
                    this._modulatorGroup.style.display = "";
                    this._modulatorGroup.style.color = ColorConfig.getChannelColor(this.doc.song, this.doc.channel).primaryNote;
                    for (let mod = 0; mod < Config.modCount; mod++) {
                        let instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                        let modChannel = Math.max(0, instrument.modChannels[mod]);
                        let modInstrument = instrument.modInstruments[mod];
                        if (modInstrument >= this.doc.song.channels[modChannel].instruments.length + 2 || (modInstrument > 0 && this.doc.song.channels[modChannel].instruments.length <= 1)) {
                            modInstrument = 0;
                            instrument.modInstruments[mod] = 0;
                        }
                        if (modChannel >= this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                            instrument.modInstruments[mod] = 0;
                            instrument.modulators[mod] = 0;
                        }
                        if (this.doc.recalcChannelNames || (this._modChannelBoxes[mod].children.length != 2 + this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount)) {
                            while (this._modChannelBoxes[mod].firstChild)
                                this._modChannelBoxes[mod].remove(0);
                            const channelList = [];
                            channelList.push("none");
                            channelList.push("song");
                            for (let i = 0; i < this.doc.song.pitchChannelCount; i++) {
                                if (this.doc.song.channels[i].name == "") {
                                    channelList.push("pitch " + (i + 1));
                                }
                                else {
                                    channelList.push(this.doc.song.channels[i].name);
                                }
                            }
                            for (let i = 0; i < this.doc.song.noiseChannelCount; i++) {
                                if (this.doc.song.channels[i + this.doc.song.pitchChannelCount].name == "") {
                                    channelList.push("noise " + (i + 1));
                                }
                                else {
                                    channelList.push(this.doc.song.channels[i + this.doc.song.pitchChannelCount].name);
                                }
                            }
                            buildOptions(this._modChannelBoxes[mod], channelList);
                        }
                        this._modChannelBoxes[mod].selectedIndex = instrument.modChannels[mod] + 2;
                        let channel = this.doc.song.channels[modChannel];
                        if (this._modInstrumentBoxes[mod].children.length != channel.instruments.length + 2) {
                            while (this._modInstrumentBoxes[mod].firstChild)
                                this._modInstrumentBoxes[mod].remove(0);
                            const instrumentList = [];
                            for (let i = 0; i < channel.instruments.length; i++) {
                                instrumentList.push("" + i + 1);
                            }
                            instrumentList.push("all");
                            instrumentList.push("active");
                            buildOptions(this._modInstrumentBoxes[mod], instrumentList);
                        }
                        if (channel.bars[this.doc.bar] > 0) {
                            let usedInstruments = channel.patterns[channel.bars[this.doc.bar] - 1].instruments;
                            for (let i = 0; i < channel.instruments.length; i++) {
                                if (usedInstruments.includes(i)) {
                                    this._modInstrumentBoxes[mod].options[i].label = "" + (i + 1);
                                }
                                else {
                                    this._modInstrumentBoxes[mod].options[i].label = "" + (i + 1);
                                }
                            }
                        }
                        else {
                            for (let i = 0; i < channel.instruments.length; i++) {
                                this._modInstrumentBoxes[mod].options[i].label = "" + (i + 1);
                            }
                        }
                        this._modInstrumentBoxes[mod].selectedIndex = instrument.modInstruments[mod];
                        if (instrument.modChannels[mod] != -2) {
                            while (this._modSetBoxes[mod].firstChild)
                                this._modSetBoxes[mod].remove(0);
                            const settingList = [];
                            const unusedSettingList = [];
                            settingList.push("none");
                            if (instrument.modChannels[mod] == -1) {
                                settingList.push("song volume");
                                settingList.push("tempo");
                                settingList.push("song reverb");
                                settingList.push("next bar");
                                settingList.push("song detune");
                                settingList.push("song eq");
                                settingList.push("song mastergain");
                                settingList.push("song limitratio");
                            }
                            else {
                                settingList.push("note volume");
                                
                                settingList.push("mix volume");
                                let tgtInstrumentTypes = [];
                                let anyInstrumentAdvancedEQ = false, anyInstrumentSimpleEQ = false, anyInstrumentAdvancedNote = false, anyInstrumentSimpleNote = false, anyInstrumentArps = false, anyInstrumentPitchShifts = false,anyInstrumentOctaveShifts = false, anyInstrumentDetunes = false, anyInstrumentVibratos = false, anyInstrumentNoteFilters = false, anyInstrumentDistorts = false, anyInstrumentBitcrushes = false, anyInstrumentPans = false, anyInstrumentChorus = false, anyInstrumentEchoes = false, anyInstrumentReverbs = false, anyInstrumentRingMods = false, anyInstrumentGranulars = false,
                                anyInstrumentPhasers = false, 
                                anyInstrumentCustomUnison = false, anyInstrumentHasEnvelopes = false;
                                let allInstrumentPitchShifts = true,allInstrumentOctaveShifts = true, allInstrumentNoteFilters = true, allInstrumentDetunes = true, allInstrumentVibratos = true, allInstrumentDistorts = true, allInstrumentBitcrushes = true, allInstrumentPans = true, allInstrumentChorus = true, allInstrumentEchoes = true, allInstrumentReverbs = true, allInstrumentRingMods = true, allInstrumentGranulars = true;
                                let instrumentCandidates = [];
                                if (modInstrument >= channel.instruments.length) {
                                    for (let i = 0; i < channel.instruments.length; i++) {
                                        instrumentCandidates.push(i);
                                    }
                                }
                                else {
                                    instrumentCandidates.push(modInstrument);
                                }
                                for (let i = 0; i < instrumentCandidates.length; i++) {
                                    let instrumentIndex = instrumentCandidates[i];
                                 let thisinstrument = channel.instruments[instrumentCandidates[i]];
                                 if (thisinstrument.unison === Config.unisons.length) {
                                    	anyInstrumentCustomUnison = true;
                                 }
                                    
                                    if (!tgtInstrumentTypes.includes(channel.instruments[instrumentIndex].type))
                                        tgtInstrumentTypes.push(channel.instruments[instrumentIndex].type);
                                    if (channel.instruments[instrumentIndex].eqFilterType)
                                        anyInstrumentSimpleEQ = true;
                                    else
                                        anyInstrumentAdvancedEQ = true;
                                    if (effectsIncludeChord(channel.instruments[instrumentIndex].effects) && channel.instruments[instrumentIndex].getChord().arpeggiates) {
                                        anyInstrumentArps = true;
                                    }
                                    if (effectsIncludePitchShift(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentPitchShifts = true;
                                    }
                                    else {
                                        allInstrumentPitchShifts = false;
                                    }
                                    if (effectsIncludeOctaveShift(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentOctaveShifts = true;
                                    }
                                    else {
                                        allInstrumentOctaveShifts = false;
                                    }
                                    if (effectsIncludeDetune(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentDetunes = true;
                                    }
                                    else {
                                        allInstrumentDetunes = false;
                                    }
                                    if (effectsIncludeVibrato(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentVibratos = true;
                                    }
                                    else {
                                        allInstrumentVibratos = false;
                                    }
                                    if (effectsIncludeNoteFilter(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentNoteFilters = true;
                                        if (channel.instruments[instrumentIndex].noteFilterType)
                                            anyInstrumentSimpleNote = true;
                                        else
                                            anyInstrumentAdvancedNote = true;
                                    }
                                    else {
                                        allInstrumentNoteFilters = false;
                                    }
                                    if (effectsIncludeDistortion(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentDistorts = true;
                                    }
                                    else {
                                        allInstrumentDistorts = false;
                                    }
                                    if (effectsIncludeBitcrusher(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentBitcrushes = true;
                                    }
                                    else {
                                        allInstrumentBitcrushes = false;
                                    }
                                    if (effectsIncludePanning(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentPans = true;
                                    }
                                    else {
                                        allInstrumentPans = false;
                                    }
                                    if (effectsIncludeChorus(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentChorus = true;
                                    }
                                    else {
                                        allInstrumentChorus = false;
                                    }
                                    if (effectsIncludeEcho(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentEchoes = true;
                                    }
                                    else {
                                        allInstrumentEchoes = false;
                                    }
                                    if (effectsIncludeReverb(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentReverbs = true;
                                    }
                                    else {
                                        allInstrumentReverbs = false;
                                    }
                                    if (effectsIncludePhaser(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentPhasers = true;
                                    }
                                    else {
                                        anyInstrumentPhasers = false;
                                    }
                                    if (effectsIncludeRingModulation(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentRingMods = true;
                                    }
                                    else {
                                        allInstrumentRingMods = false;
                                    }
                                    if (effectsIncludeGranular(channel.instruments[instrumentIndex].effects)) {
                                        anyInstrumentGranulars = true;
                                    }
                                    else {
                                        allInstrumentGranulars = false;
                                    }
                                    if (channel.instruments[instrumentIndex].envelopes.length > 0) {
                                        anyInstrumentHasEnvelopes = true;
                                    }
                                }
                                if (anyInstrumentAdvancedEQ) {
                                    settingList.push("eq filter");
                                }
                                if (anyInstrumentSimpleEQ) {
                                    settingList.push("eq filt cut");
                                    settingList.push("eq filt peak");
                                }
                                if (tgtInstrumentTypes.includes(1)) {
                                    settingList.push("fm slider 1");
                                    settingList.push("fm slider 2");
                                    settingList.push("fm slider 3");
                                    settingList.push("fm slider 4");
                                    settingList.push("fm feedback");
                                }
                                if (tgtInstrumentTypes.includes(11)) {
                                    settingList.push("fm slider 1");
                                    settingList.push("fm slider 2");
                                    settingList.push("fm slider 3");
                                    settingList.push("fm slider 4");
                                    settingList.push("fm slider 5");
                                    settingList.push("fm slider 6");
                                    settingList.push("fm feedback");
                                }
                                if (tgtInstrumentTypes.includes(12)) {
                                    settingList.push("fm slider 1");
                                    settingList.push("fm slider 2");
                                    settingList.push("fm slider 3");
                                    settingList.push("fm slider 4");
                                    settingList.push("fm slider 5");
                                    settingList.push("fm slider 6");
                                    settingList.push("fm slider 7");
                                    settingList.push("fm slider 8");
                                    settingList.push("fm feedback");
                                }
                                if (tgtInstrumentTypes.includes(6) || tgtInstrumentTypes.includes(8)) {
                                    settingList.push("pulse width");
                                    settingList.push("decimal offset");
                                }
                                if (tgtInstrumentTypes.includes(8)) {
                                    settingList.push("dynamism");
                                    settingList.push("spread");
                                    settingList.push("saw shape");
                                }
                                if (tgtInstrumentTypes.includes(7)) {
                                    settingList.push("sustain");
                                }
                                if (anyInstrumentArps) {
                                    settingList.push("arp speed");
                                    settingList.push("reset arp");
                                }
                                if (anyInstrumentPitchShifts) {
                                    settingList.push("pitch shift");
                                }
                                
                                if (!allInstrumentPitchShifts) {
                                    unusedSettingList.push("+ pitch shift");
                                }
                                if (anyInstrumentDetunes) {
                                    settingList.push("detune");
                                }
                                if (!allInstrumentDetunes) {
                                    unusedSettingList.push("+ detune");
                                }
                                if (anyInstrumentVibratos) {
                                    settingList.push("vibrato depth");
                                    settingList.push("vibrato speed");
                                    settingList.push("vibrato delay");
                                }
                                if (!allInstrumentVibratos) {
                                    unusedSettingList.push("+ vibrato depth");
                                    unusedSettingList.push("+ vibrato speed");
                                    unusedSettingList.push("+ vibrato delay");
                                }
                                if (anyInstrumentNoteFilters) {
                                    if (anyInstrumentAdvancedNote) {
                                        settingList.push("note filter");
                                    }
                                    if (anyInstrumentSimpleNote) {
                                        settingList.push("note filt cut");
                                        settingList.push("note filt peak");
                                    }
                                }
                                if (!allInstrumentNoteFilters) {
                                    unusedSettingList.push("+ note filter");
                                }
                                if (anyInstrumentDistorts) {
                                    settingList.push("distortion");
                                }
                                if (!allInstrumentDistorts) {
                                    unusedSettingList.push("+ distortion");
                                }
                                if (anyInstrumentBitcrushes) {
                                    settingList.push("bit crush");
                                    settingList.push("freq crush");
                                }
                                if (!allInstrumentBitcrushes) {
                                    unusedSettingList.push("+ bit crush");
                                    unusedSettingList.push("+ freq crush");
                                }
                                if (anyInstrumentPans) {
                                    settingList.push("pan");
                                    settingList.push("pan delay");
                                }
                                if (!allInstrumentPans) {
                                    unusedSettingList.push("+ pan");
                                    unusedSettingList.push("+ pan delay");
                                }
                                if (anyInstrumentChorus) {
                                    settingList.push("chorus");
                                }
                                if (!allInstrumentChorus) {
                                    unusedSettingList.push("+ chorus");
                                }
                                if (anyInstrumentEchoes) {
                                    settingList.push("echo");
                                    settingList.push("echo delay");
                                }
                                if (!allInstrumentEchoes) {
                                    unusedSettingList.push("+ echo");
                                    unusedSettingList.push("+ echo delay");
                                }
                                if (anyInstrumentReverbs) {
                                    settingList.push("reverb");
                                }
                                if (!allInstrumentReverbs) {
                                    unusedSettingList.push("+ reverb");
                                }
                                if (anyInstrumentRingMods) {
                                    settingList.push("ring modulation");
                                    settingList.push("ring mod hertz");
                                }
                                if (!allInstrumentRingMods) {
                                    unusedSettingList.push("+ ring modulation");
                                    unusedSettingList.push("+ ring mod hertz");
                                }
                                if (anyInstrumentPhasers) {
                                    settingList.push("phaser"); 
                                    settingList.push("phaser frequency");
                                    settingList.push("phaser feedback");
                                    settingList.push("phaser stages");
                                }
                                if (anyInstrumentGranulars) {
                                    settingList.push("granular");
                                    settingList.push("grain freq");
                                    settingList.push("grain size");
                                    settingList.push("grain range");
                                }
                                if (!allInstrumentGranulars) {
                                    unusedSettingList.push("+ granular");
                                    unusedSettingList.push("+ grain freq");
                                    unusedSettingList.push("+ grain size");
                                    unusedSettingList.push("+ grain range");
                                }
                                if (anyInstrumentHasEnvelopes) {
                                    settingList.push("envelope speed");
                                    settingList.push("individual envelope speed");
                                    settingList.push("individual envelope lower bound");
                                    settingList.push("individual envelope upper bound");
                                    settingList.push("reset envelope");
                                }
                                if (anyInstrumentCustomUnison) {
                               	settingList.push("unisonExpression");
                               	settingList.push("unisonSign")
                               	settingList.push("unisonOffset")
                               	settingList.push("unisonVoices")
                               	settingList.push("unisonSpread")
                                }
                                if (anyInstrumentOctaveShifts) {
                               	settingList.push("octave shift");
                                }
                                
                            }
                            buildOptions(this._modSetBoxes[mod], settingList);
                            if (unusedSettingList.length > 0) {
                                this._modSetBoxes[mod].appendChild(option({ selected: false, disabled: true, value: "Add Effect" }, "Add Effect"));
                                buildOptions(this._modSetBoxes[mod], unusedSettingList);
                            }
                            let setIndex = settingList.indexOf(Config.modulators[instrument.modulators[mod]].name);
                            if (setIndex == -1) {
                                this._modSetBoxes[mod].insertBefore(option({ value: Config.modulators[instrument.modulators[mod]].name, style: "color: red;" }, Config.modulators[instrument.modulators[mod]].name), this._modSetBoxes[mod].children[0]);
                                this._modSetBoxes[mod].selectedIndex = 0;
                                this._whenSetModSetting(mod, true);
                            }
                            else {
                                this._modSetBoxes[mod].selectedIndex = setIndex;
                                this._modSetBoxes[mod].classList.remove("invalidSetting");
                                instrument.invalidModulators[mod] = false;
                            }
                        }
                        else if (this._modSetBoxes[mod].selectedIndex > 0) {
                            this._modSetBoxes[mod].selectedIndex = 0;
                            this._whenSetModSetting(mod);
                        }
                        if (instrument.modChannels[mod] < 0) {
                            (this._modInstrumentBoxes[mod].parentElement).style.display = "none";
                            $("#modInstrumentText" + mod).get(0).style.display = "none";
                            $("#modChannelText" + mod).get(0).innerText = "Channel:";
                            if (instrument.modChannels[mod] == -2) {
                                $("#modSettingText" + mod).get(0).style.display = "none";
                                (this._modSetBoxes[mod].parentElement).style.display = "none";
                            }
                            else {
                                $("#modSettingText" + mod).get(0).style.display = "";
                                (this._modSetBoxes[mod].parentElement).style.display = "";
                            }
                            this._modTargetIndicators[mod].style.setProperty("fill", ColorConfig.uiWidgetFocus);
                            this._modTargetIndicators[mod].classList.remove("modTarget");
                        }
                        else {
                            (this._modInstrumentBoxes[mod].parentElement).style.display = (channel.instruments.length > 1) ? "" : "none";
                            $("#modInstrumentText" + mod).get(0).style.display = (channel.instruments.length > 1) ? "" : "none";
                            $("#modChannelText" + mod).get(0).innerText = (channel.instruments.length > 1) ? "Ch:" : "Channel:";
                            $("#modSettingText" + mod).get(0).style.display = "";
                            (this._modSetBoxes[mod].parentElement).style.display = "";
                            this._modTargetIndicators[mod].style.setProperty("fill", ColorConfig.indicatorPrimary);
                            this._modTargetIndicators[mod].classList.add("modTarget");
                        }
                        let filterType = Config.modulators[instrument.modulators[mod]].name;
                        let useSongEq = filterType == "song eq";
                        if (useSongEq)
                            filterType = "eq filter";
                        if (filterType == "eq filter" || filterType == "note filter") {
                            $("#modFilterText" + mod).get(0).style.display = "";
                            $("#modEnvelopeText" + mod).get(0).style.display = "none";
                            $("#modSettingText" + mod).get(0).style.setProperty("margin-bottom", "2px");
                            let useInstrument = instrument.modInstruments[mod];
                            let modChannel = this.doc.song.channels[Math.max(0, instrument.modChannels[mod])];
                            let tmpCount = -1;
                            if (useInstrument >= modChannel.instruments.length) {
                                for (let i = 0; i < modChannel.instruments.length; i++) {
                                    if (filterType == "eq filter") {
                                        if (modChannel.instruments[i].eqFilter.controlPointCount > tmpCount) {
                                            tmpCount = modChannel.instruments[i].eqFilter.controlPointCount;
                                            useInstrument = i;
                                        }
                                    }
                                    else {
                                        if (modChannel.instruments[i].noteFilter.controlPointCount > tmpCount) {
                                            tmpCount = modChannel.instruments[i].noteFilter.controlPointCount;
                                            useInstrument = i;
                                        }
                                    }
                                }
                            }
                            let dotCount = (filterType == "eq filter")
                                ? channel.instruments[useInstrument].getLargestControlPointCount(false)
                                : channel.instruments[useInstrument].getLargestControlPointCount(true);
                            const isSimple = useSongEq ? false : (filterType == "eq filter" ? channel.instruments[useInstrument].eqFilterType : channel.instruments[useInstrument].noteFilterType);
                            if (isSimple)
                                dotCount = 0;
                            if (useSongEq) {
                                dotCount = this.doc.song.eqFilter.controlPointCount;
                                if (this._modFilterBoxes[mod].children.length != 1 + dotCount * 2) {
                                    while (this._modFilterBoxes[mod].firstChild)
                                        this._modFilterBoxes[mod].remove(0);
                                    const dotList = [];
                                    dotList.push("morph");
                                    for (let i = 0; i < dotCount; i++) {
                                        dotList.push("dot " + (i + 1) + " x");
                                        dotList.push("dot " + (i + 1) + " y");
                                    }
                                    buildOptions(this._modFilterBoxes[mod], dotList);
                                }
                            }
                            else if (isSimple || this._modFilterBoxes[mod].children.length != 1 + dotCount * 2) {
                                while (this._modFilterBoxes[mod].firstChild)
                                    this._modFilterBoxes[mod].remove(0);
                                const dotList = [];
                                if (!isSimple)
                                    dotList.push("morph");
                                for (let i = 0; i < dotCount; i++) {
                                    dotList.push("dot " + (i + 1) + " x");
                                    dotList.push("dot " + (i + 1) + " y");
                                }
                                buildOptions(this._modFilterBoxes[mod], dotList);
                            }
                            if (isSimple || instrument.modFilterTypes[mod] >= this._modFilterBoxes[mod].length) {
                                this._modFilterBoxes[mod].classList.add("invalidSetting");
                                instrument.invalidModulators[mod] = true;
                                let useName = ((instrument.modFilterTypes[mod] - 1) % 2 == 1) ?
                                    "dot " + (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) + 1) + " y"
                                    : "dot " + (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) + 1) + " x";
                                if (instrument.modFilterTypes[mod] == 0)
                                    useName = "morph";
                                this._modFilterBoxes[mod].insertBefore(option({ value: useName, style: "color: red;" }, useName), this._modFilterBoxes[mod].children[0]);
                                this._modFilterBoxes[mod].selectedIndex = 0;
                            }
                            else {
                                this._modFilterBoxes[mod].classList.remove("invalidSetting");
                                instrument.invalidModulators[mod] = false;
                                this._modFilterBoxes[mod].selectedIndex = instrument.modFilterTypes[mod];
                            }
                        }
                        else {
                            $("#modFilterText" + mod).get(0).style.display = "none";
                            $("#modSettingText" + mod).get(0).style.setProperty("margin-bottom", "0.9em");
                        }
                        let envelopes = Config.modulators[instrument.modulators[mod]].name;
                        if (envelopes == "individual envelope speed" || envelopes == "reset envelope" || envelopes == "individual envelope lower bound" || envelopes == "individual envelope upper bound") {
                            $("#modEnvelopeText" + mod).get(0).style.display = "";
                            $("#modFilterText" + mod).get(0).style.display = "none";
                            $("#modSettingText" + mod).get(0).style.setProperty("margin-bottom", "2px");
                            let modChannel = this.doc.song.channels[Math.max(0, instrument.modChannels[mod])];
                            let envCount = -1;
                            for (let i = 0; i < modChannel.instruments.length; i++) {
                                if (modChannel.instruments[i].envelopeCount > envCount) {
                                    envCount = modChannel.instruments[i].envelopeCount;
                                }
                            }
                            while (this._modEnvelopeBoxes[mod].firstChild)
                                this._modEnvelopeBoxes[mod].remove(0);
                            const envelopeList = [];
                            for (let i = 0; i < envCount; i++) {
                                envelopeList.push("envelope " + (i + 1));
                            }
                            buildOptions(this._modEnvelopeBoxes[mod], envelopeList);
                            if (instrument.modEnvelopeNumbers[mod] >= this._modEnvelopeBoxes[mod].length) {
                                this._modEnvelopeBoxes[mod].classList.add("invalidSetting");
                                instrument.invalidModulators[mod] = true;
                                let useName = "envelope " + (instrument.modEnvelopeNumbers[mod]);
                                this._modEnvelopeBoxes[mod].insertBefore(option({ value: useName, style: "color: red;" }, useName), this._modEnvelopeBoxes[mod].children[0]);
                                this._modEnvelopeBoxes[mod].selectedIndex = 0;
                            }
                            else {
                                this._modEnvelopeBoxes[mod].classList.remove("invalidSetting");
                                instrument.invalidModulators[mod] = false;
                                this._modEnvelopeBoxes[mod].selectedIndex = instrument.modEnvelopeNumbers[mod];
                            }
                        }
                        else {
                            $("#modEnvelopeText" + mod).get(0).style.display = "none";
                            if (!(filterType == "eq filter" || filterType == "note filter")) {
                                $("#modSettingText" + mod).get(0).style.setProperty("margin-bottom", "0.9em");
                            }
                        }
                    }
                    this.doc.recalcChannelNames = false;
                    for (let chordIndex = 0; chordIndex < Config.chords.length; chordIndex++) {
                        const option = this._chordSelect.children[chordIndex];
                        if (!option.hasAttribute("hidden")) {
                            option.setAttribute("hidden", "");
                        }
                    }
                    this._customInstrumentSettingsGroup.style.display = "none";
                    this._panSliderRow.style.display = "none";
                    this._panDropdownGroup.style.display = "none";
                    this._instrumentVolumeSliderRow.style.display = "none";
                    this._instrumentTypeSelectRow.style.setProperty("display", "none");
                    this._instrumentSettingsGroup.style.color = ColorConfig.getChannelColor(this.doc.song, this.doc.channel).primaryNote;
                    if (this.doc.channel >= this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                        this._piano.forceRender();
                    }
                    this._renderInstrumentBar(channel, instrumentIndex, colors);
                }
                this._instrumentSettingsGroup.style.color = colors.primaryNote;
                if (this.doc.synth.isFilterModActive(false, this.doc.channel, this.doc.getCurrentInstrument())) {
                    this._eqFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                }
                else {
                    this._eqFilterEditor.render();
                }
                if (this.doc.synth.isFilterModActive(false, 0, 0, true)) {
                    this._songEqFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                }
                else {
                    this._songEqFilterEditor.render();
                }
                this._instrumentVolumeSlider.updateValue(instrument.volume);
                this._detuneSlider.updateValue(instrument.detune - Config.detuneCenter);
                this._twoNoteArpBox.checked = instrument.fastTwoNoteArp ? true : false;
                this._clicklessTransitionBox.checked = instrument.clicklessTransition ? true : false;
                this._aliasingBox.checked = instrument.aliases ? true : false;
                this._addEnvelopeButton.disabled = (instrument.envelopeCount >= Config.maxEnvelopeCount);
                this._volumeSlider.updateValue(prefs.volume);
                if (wasActive && activeElement != null && activeElement.clientWidth == 0) {
                    this.refocusStage();
                }
                this._setPrompt(this.doc.prompt);
                if (prefs.autoFollow && !this.doc.synth.playing) {
                    this.doc.synth.goToBar(this.doc.bar);
                }
                if (this.doc.addedEffect) {
                    const envButtonRect = this._addEnvelopeButton.getBoundingClientRect();
                    const instSettingsRect = this._instrumentSettingsArea.getBoundingClientRect();
                    const settingsRect = this._settingsArea.getBoundingClientRect();
                    this._instrumentSettingsArea.scrollTop += Math.max(0, envButtonRect.top - (instSettingsRect.top + instSettingsRect.height));
                    this._settingsArea.scrollTop += Math.max(0, envButtonRect.top - (settingsRect.top + settingsRect.height));
                    this.doc.addedEffect = false;
                }
                if (this.doc.addedEnvelope) {
                    this._instrumentSettingsArea.scrollTop = this._instrumentSettingsArea.scrollHeight;
                    this._settingsArea.scrollTop = this._settingsArea.scrollHeight;
                    this.doc.addedEnvelope = false;
                }
                if (this._ringModWaveSelect.selectedIndex == Config.operatorWaves.dictionary['pulse width'].index) {
                    this._ringModPulsewidthSlider.container.style.display = "";
                    this._ringModWaveText.style.display = "none";
                }
                else {
                    this._ringModPulsewidthSlider.container.style.display = "none";
                    this._ringModWaveText.style.display = "";
                }
                this.handleModRecording();
            };
            this.updatePlayButton = () => {
                if (this._renderedIsPlaying != this.doc.synth.playing || this._renderedIsRecording != this.doc.synth.recording || this._renderedShowRecordButton != this.doc.prefs.showRecordButton || this._renderedCtrlHeld != this._ctrlHeld) {
                    this._renderedIsPlaying = this.doc.synth.playing;
                    this._renderedIsRecording = this.doc.synth.recording;
                    this._renderedShowRecordButton = this.doc.prefs.showRecordButton;
                    this._renderedCtrlHeld = this._ctrlHeld;
                    if (document.activeElement == this._playButton || document.activeElement == this._pauseButton || document.activeElement == this._recordButton || document.activeElement == this._stopButton) {
                        this.refocusStage();
                    }
                    this._playButton.style.display = "none";
                    this._pauseButton.style.display = "none";
                    this._recordButton.style.display = "none";
                    this._stopButton.style.display = "none";
                    this._prevBarButton.style.display = "";
                    this._nextBarButton.style.display = "";
                    this._playButton.classList.remove("shrunk");
                    this._recordButton.classList.remove("shrunk");
                    this._patternEditorRow.style.pointerEvents = "";
                    this._octaveScrollBar.container.style.pointerEvents = "";
                    this._octaveScrollBar.container.style.opacity = "";
                    this._trackContainer.style.pointerEvents = "";
                    this._loopEditor.container.style.opacity = "";
                    this._instrumentSettingsArea.style.pointerEvents = "";
                    this._instrumentSettingsArea.style.opacity = "";
                    this._menuArea.style.pointerEvents = "";
                    this._menuArea.style.opacity = "";
                    this._songSettingsArea.style.pointerEvents = "";
                    this._songSettingsArea.style.opacity = "";
                    if (this.doc.synth.recording) {
                        this._stopButton.style.display = "";
                        this._prevBarButton.style.display = "none";
                        this._nextBarButton.style.display = "none";
                        this._patternEditorRow.style.pointerEvents = "none";
                        this._octaveScrollBar.container.style.pointerEvents = "none";
                        this._octaveScrollBar.container.style.opacity = "0.5";
                        this._trackContainer.style.pointerEvents = "none";
                        this._loopEditor.container.style.opacity = "0.5";
                        this._instrumentSettingsArea.style.pointerEvents = "none";
                        this._instrumentSettingsArea.style.opacity = "0.5";
                        this._menuArea.style.pointerEvents = "none";
                        this._menuArea.style.opacity = "0.5";
                        this._songSettingsArea.style.pointerEvents = "none";
                        this._songSettingsArea.style.opacity = "0.5";
                    }
                    else if (this.doc.synth.playing) {
                        this._pauseButton.style.display = "";
                    }
                    else if (this.doc.prefs.showRecordButton) {
                        this._playButton.style.display = "";
                        this._recordButton.style.display = "";
                        this._playButton.classList.add("shrunk");
                        this._recordButton.classList.add("shrunk");
                    }
                    else if (this._ctrlHeld) {
                        this._recordButton.style.display = "";
                    }
                    else {
                        this._playButton.style.display = "";
                    }
                }
                window.requestAnimationFrame(this.updatePlayButton);
            };
            this._onTrackAreaScroll = (event) => {
                this.doc.barScrollPos = (this._trackAndMuteContainer.scrollLeft / this.doc.getBarWidth());
                this.doc.channelScrollPos = (this._trackAndMuteContainer.scrollTop / ChannelRow.patternHeight);
            };
            this._disableCtrlContextMenu = (event) => {
                if (event.ctrlKey) {
                    event.preventDefault();
                    return false;
                }
                return true;
            };
            this._tempoStepperCaptureNumberKeys = (event) => {
                switch (event.keyCode) {
                    case 8:
                    case 13:
                    case 38:
                    case 40:
                    case 37:
                    case 39:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                        event.stopPropagation();
                        break;
                }
            };
            this._whenKeyPressed = (event) => {
                this._ctrlHeld = event.ctrlKey;
                this._shiftHeld = event.shiftKey;
                if (this.prompt) {
                    if (this.prompt instanceof CustomChipPrompt || this.prompt instanceof LimiterPrompt || this.prompt instanceof CustomScalePrompt || this.prompt instanceof CustomFilterPrompt) {
                        this.prompt.whenKeyPressed(event);
                    }
                    if (event.keyCode == 27) {
                        this.doc.undo();
                    }
                    return;
                }
                if ((document.activeElement == this._songTitleInputBox.input || this._patternEditor.editingModLabel || document.activeElement == this._muteEditor._channelNameInput.input ) && document.activeElement !== this._fnInput) {
                    if (event.keyCode == 13 || event.keyCode == 27) {
                        this.mainLayer.focus();
                        this._patternEditor.stopEditingModLabel(event.keyCode == 27);
                    }
                    return;
                }
                if (document.activeElement == this._panSliderInputBox
                    || document.activeElement == this._pwmSliderInputBox
                    || document.activeElement == this._detuneSliderInputBox||
                    document.activeElement == this._pitchShiftBox || document.activeElement == this._octaveShiftBox || document.activeElement == this._fnInput ||  document.activeElement == this._instrumentName 
                    || document.activeElement == this._instrumentVolumeSliderInputBox
                    || document.activeElement == this._chipWaveLoopStartStepper
                    || document.activeElement == this._chipWaveLoopEndStepper
                    || document.activeElement == this._chipWaveStartOffsetStepper
                    || document.activeElement == this._octaveStepper
                    || document.activeElement == this._unisonVoicesInputBox
                    || document.activeElement == this._unisonSpreadInputBox
                    || document.activeElement == this._unisonOffsetInputBox
                    || document.activeElement == this._unisonExpressionInputBox
                    || document.activeElement == this._unisonSignInputBox
                    || document.activeElement == this._monophonicNoteInputBox
                    || this.envelopeEditor.pitchStartBoxes.find((element) => element == document.activeElement)
                    || this.envelopeEditor.pitchEndBoxes.find((element) => element == document.activeElement)
                    || this.envelopeEditor.perEnvelopeLowerBoundBoxes.find((element) => element == document.activeElement)
                    || this.envelopeEditor.perEnvelopeUpperBoundBoxes.find((element) => element == document.activeElement)
                    || this.envelopeEditor.randomStepsBoxes.find((element) => element == document.activeElement)
                    || this.envelopeEditor.randomStepsBoxes.find((element) => element == document.activeElement)
                    || this.envelopeEditor.LFOStepsBoxes.find((element) => element == document.activeElement)) {
                    if ((event.keyCode == 13 || event.keyCode == 27) && document.activeElement !== this._fnInput) {
                        this.mainLayer.focus();
                    }
                    return;
                }
                if (this.doc.synth.recording) {
                    if (!event.ctrlKey && !event.metaKey) {
                        this._keyboardLayout.handleKeyEvent(event, true);
                    }
                    if (event.keyCode == 32) {
                        this._toggleRecord();
                        event.preventDefault();
                        this.refocusStage();
                    }
                    else if (event.keyCode == 80 && (event.ctrlKey || event.metaKey)) {
                        this._toggleRecord();
                        event.preventDefault();
                        this.refocusStage();
                    }
                    return;
                }
                const needControlForShortcuts = (this.doc.prefs.pressControlForShortcuts != event.getModifierState("CapsLock"));
                const canPlayNotes = (!event.ctrlKey && !event.metaKey && needControlForShortcuts);
                if (canPlayNotes)
                    this._keyboardLayout.handleKeyEvent(event, true);
                switch (event.keyCode) {
                    case 27:
                        if (!event.ctrlKey && !event.metaKey) {
                            new ChangePatternSelection(this.doc, 0, 0);
                            this.doc.selection.resetBoxSelection();
                        }
                        break;
                    case 16:
                        this._patternEditor.shiftMode = true;
                        break;
                    case 17:
                        this._patternEditor.controlMode = true;
                        break;
                    case 32:
                        if (event.ctrlKey) {
                            this._toggleRecord();
                        }
                        else if (event.shiftKey) {
                            if (this._trackEditor.movePlayheadToMouse() || this._patternEditor.movePlayheadToMouse()) {
                                if (!this.doc.synth.playing)
                                    this.doc.performance.play();
                            }
                            if (Math.floor(this.doc.synth.playhead) < this.doc.synth.loopBarStart || Math.floor(this.doc.synth.playhead) > this.doc.synth.loopBarEnd) {
                                this.doc.synth.loopBarStart = -1;
                                this.doc.synth.loopBarEnd = -1;
                                this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            }
                        }
                        else {
                            this.togglePlay();
                        }
                        event.preventDefault();
                        this.refocusStage();
                        break;
                    case 80:
                        if (canPlayNotes)
                            break;
                        if (event.ctrlKey || event.metaKey) {
                            this._toggleRecord();
                            this.doc.synth.loopBarStart = -1;
                            this.doc.synth.loopBarEnd = -1;
                            this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            event.preventDefault();
                            this.refocusStage();
                        }
                        else if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey) && event.shiftKey) {
                        	cleanMemoryBeforeNavigation()
                            location.href = "" + (OFFLINE ? "player.html" : "") + "#song=" + this.doc.song.toBase64String();
                            event.preventDefault();
                        }
                        break;
                    case 192:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            this.doc.goBackToStart();
                            this.doc.song.restoreLimiterDefaults();
                            for (const channel of this.doc.song.channels) {
                                channel.muted = false;
                                channel.name = "";
                            }
                            this.doc.record(new ChangeSong(this.doc, ""), false, true);
                        }
                        else {
                            if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                                this._openPrompt("songRecovery");
                            }
                        }
                        event.preventDefault();
                        break;
                    case 90:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            this.doc.redo();
                        }
                        else {
                            this.doc.undo();
                        }
                        event.preventDefault();
                        break;
                    case 88:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.cutNotes();
                        event.preventDefault();
                        break;
                    case 89:
                        if (canPlayNotes)
                            break;
                        this.doc.redo();
                        event.preventDefault();
                        break;
                    case 66:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            if (event.shiftKey) {
                                this._openPrompt("beatsPerBar");
                            }
                            else {
                                const leftSel = Math.min(this.doc.selection.boxSelectionX0, this.doc.selection.boxSelectionX1);
                                const rightSel = Math.max(this.doc.selection.boxSelectionX0, this.doc.selection.boxSelectionX1);
                                if ((leftSel < this.doc.synth.loopBarStart || this.doc.synth.loopBarStart == -1)
                                    || (rightSel > this.doc.synth.loopBarEnd || this.doc.synth.loopBarEnd == -1)) {
                                    this.doc.synth.loopBarStart = leftSel;
                                    this.doc.synth.loopBarEnd = rightSel;
                                    if (!this.doc.synth.playing) {
                                        this.doc.synth.snapToBar();
                                        this.doc.performance.play();
                                    }
                                }
                                else {
                                    this.doc.synth.loopBarStart = -1;
                                    this.doc.synth.loopBarEnd = -1;
                                }
                                if (this.doc.bar != Math.floor(this.doc.synth.playhead) && this.doc.synth.loopBarStart != -1) {
                                    this.doc.synth.goToBar(this.doc.bar);
                                    this.doc.synth.snapToBar();
                                    this.doc.synth.initModFilters(this.doc.song);
                                    this.doc.synth.computeLatestModValues();
                                    if (this.doc.prefs.autoFollow) {
                                        this.doc.selection.setChannelBar(this.doc.channel, Math.floor(this.doc.synth.playhead));
                                    }
                                }
                                this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            }
                        }
                        event.preventDefault();
                        break;
                    case 67:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            this._copyInstrument();
                        }
                        else {
                            this.doc.selection.copy();
                            this.doc.selection.resetBoxSelection();
                            this.doc.selection.selectionUpdated();
                        }
                        event.preventDefault();
                        break;
                    case 13:
                        this.doc.synth.loopBarStart = -1;
                        this.doc.synth.loopBarEnd = -1;
                        this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                        if ((event.ctrlKey || event.metaKey) && !event.shiftKey) {
                            this.doc.selection.insertChannel();
                        }
                        else if (event.shiftKey) {
                            const width = this.doc.selection.boxSelectionWidth;
                            this.doc.selection.boxSelectionX0 -= width;
                            this.doc.selection.boxSelectionX1 -= width;
                            this.doc.selection.insertBars();
                        }
                        else {
                            this.doc.selection.insertBars();
                        }
                        event.preventDefault();
                        break;
                    case 8:
                        this.doc.synth.loopBarStart = -1;
                        this.doc.synth.loopBarEnd = -1;
                        this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                        if (event.ctrlKey || event.metaKey) {
                            this.doc.selection.deleteChannel();
                        }
                        else {
                            this.doc.selection.deleteBars();
                        }
                        this._barScrollBar.animatePlayhead();
                        event.preventDefault();
                        break;
                    case 65:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            this.doc.selection.selectChannel();
                        }
                        else {
                            this.doc.selection.selectAll();
                        }
                        event.preventDefault();
                        break;
                    case 68:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.selection.duplicatePatterns(event.shiftKey ? false : true);
                            event.preventDefault();
                        }
                        break;
                    case 69:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            const instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                            if (!instrument.eqFilterType && this.doc.channel < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount)
                                this._openPrompt("customEQFilterSettings");
                        }
                        else if (event.altKey) {
                            const instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                            const isAllOpen = this.envelopeEditor.openExtraSettingsDropdowns.every((x) => { return x == true; });
                            for (let i = 0; i < instrument.envelopeCount; i++) {
                                if (isAllOpen)
                                    this.envelopeEditor.openExtraSettingsDropdowns[i] = false;
                                else
                                    this.envelopeEditor.openExtraSettingsDropdowns[i] = true;
                            }
                            this.envelopeEditor.rerenderExtraSettings();
                            event.preventDefault();
                        }
                        else if (event.ctrlKey) {
                            this._openPrompt("generateEuclideanRhythm");
                            event.preventDefault();
                            break;
                        }
                        else if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this._openPrompt("customSongEQFilterSettings");
                        }
                        break;
                    case 70:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            this.doc.synth.loopBarStart = -1;
                            this.doc.synth.loopBarEnd = -1;
                            this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            this.doc.synth.goToBar(this.doc.song.loopStart);
                            this.doc.synth.snapToBar();
                            this.doc.synth.initModFilters(this.doc.song);
                            this.doc.synth.computeLatestModValues();
                            if (this.doc.prefs.autoFollow) {
                                this.doc.selection.setChannelBar(this.doc.channel, Math.floor(this.doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        else if (event.altKey) {
                            const instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                            const operatorCount = instrument.type == 1 ? 4 : 6;
                            let isAllOpen = true;
                            for (let i = 0; i < operatorCount; i++) {
                                if (!this._openOperatorDropdowns[i])
                                    isAllOpen = false;
                            }
                            for (let i = 0; i < operatorCount; i++) {
                                if (this._openOperatorDropdowns[i] == false && !isAllOpen || isAllOpen)
                                    this._toggleDropdownMenu(4, i);
                            }
                            event.preventDefault();
                        }
                        else if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.synth.loopBarStart = -1;
                            this.doc.synth.loopBarEnd = -1;
                            this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            this.doc.synth.snapToStart();
                            this.doc.synth.initModFilters(this.doc.song);
                            this.doc.synth.computeLatestModValues();
                            if (this.doc.prefs.autoFollow) {
                                this.doc.selection.setChannelBar(this.doc.channel, Math.floor(this.doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 72:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.synth.goToBar(this.doc.bar);
                            this.doc.synth.snapToBar();
                            this.doc.synth.initModFilters(this.doc.song);
                            this.doc.synth.computeLatestModValues();
                            if (Math.floor(this.doc.synth.playhead) < this.doc.synth.loopBarStart || Math.floor(this.doc.synth.playhead) > this.doc.synth.loopBarEnd) {
                                this.doc.synth.loopBarStart = -1;
                                this.doc.synth.loopBarEnd = -1;
                                this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            }
                            if (this.doc.prefs.autoFollow) {
                                this.doc.selection.setChannelBar(this.doc.channel, Math.floor(this.doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 74:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey && event.ctrlKey && event.altKey) {
                            this.doc.prefs.autoPlay = false;
                            this.doc.prefs.autoFollow = false;
                            this.doc.prefs.enableNotePreview = true;
                            this.doc.prefs.showFifth = true;
                            this.doc.prefs.notesOutsideScale = false;
                            this.doc.prefs.defaultScale = 0;
                            this.doc.prefs.showLetters = true;
                            this.doc.prefs.showChannels = true;
                            this.doc.prefs.showScrollBar = true;
                            this.doc.prefs.useCustomSelectPrompt = true;
                            this.doc.prefs.alwaysFineNoteVol = false;
                            this.doc.prefs.enableChannelMuting = true;
                            this.doc.prefs.displayBrowserUrl = true;
                            this.doc.prefs.displayVolumeBar = true;
                            this.doc.prefs.layout = "wide";
                            this.doc.prefs.visibleOctaves = 5;
                            this.doc.prefs.save();
                            event.preventDefault();
                            reloadsite()
                        }
                        break;
                    case 76:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey) {
                            this._openPrompt("limiterSettings");
                        }
                        else {
                            this._openPrompt("barCount");
                        }
                        break;
                    case 77:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            if (this.doc.prefs.enableChannelMuting) {
                                this.doc.selection.muteChannels(event.shiftKey);
                                event.preventDefault();
                            }
                        }
                        break;
                    case 78:
                        if (canPlayNotes)
                            break;
                        const group = new ChangeGroup();
                        if (event.shiftKey) {
                            const instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                            if (effectsIncludeNoteFilter(instrument.effects) && !instrument.noteFilterType && this.doc.channel < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount)
                                this._openPrompt("customNoteFilterSettings");
                            break;
                        }
                        else if (event.ctrlKey) {
                            let nextEmpty = 0;
                            while (nextEmpty < this.doc.song.patternsPerChannel && this.doc.song.channels[this.doc.channel].patterns[nextEmpty].notes.length > 0)
                                nextEmpty++;
                            nextEmpty++;
                            if (nextEmpty <= Config.barCountMax) {
                                if (nextEmpty > this.doc.song.patternsPerChannel) {
                                    group.append(new ChangePatternsPerChannel(this.doc, nextEmpty));
                                }
                                group.append(new ChangePatternNumbers(this.doc, nextEmpty, this.doc.bar, this.doc.channel, 1, 1));
                                if (this.doc.channel >= this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                                    this.doc.viewedInstrument[this.doc.channel] = this.doc.recentPatternInstruments[this.doc.channel][0];
                                }
                                group.append(new ChangeSetPatternInstruments(this.doc, this.doc.channel, this.doc.recentPatternInstruments[this.doc.channel], this.doc.song.channels[this.doc.channel].patterns[nextEmpty - 1]));
                            }
                        }
                        else {
                            let nextUnused = 1;
                            while (this.doc.song.channels[this.doc.channel].bars.indexOf(nextUnused) != -1
                                && nextUnused <= this.doc.song.patternsPerChannel)
                                nextUnused++;
                            if (nextUnused <= Config.barCountMax) {
                                if (nextUnused > this.doc.song.patternsPerChannel) {
                                    group.append(new ChangePatternsPerChannel(this.doc, nextUnused));
                                }
                                group.append(new ChangePatternNumbers(this.doc, nextUnused, this.doc.bar, this.doc.channel, 1, 1));
                                if (this.doc.channel >= this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                                    this.doc.viewedInstrument[this.doc.channel] = this.doc.recentPatternInstruments[this.doc.channel][0];
                                }
                                group.append(new ChangeSetPatternInstruments(this.doc, this.doc.channel, this.doc.recentPatternInstruments[this.doc.channel], this.doc.song.channels[this.doc.channel].patterns[nextUnused - 1]));
                            }
                        }
                        this.doc.record(group);
                        event.preventDefault();
                        break;
                    case 81:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            if (event.shiftKey) {
                                this._openPrompt("addExternal");
                                event.preventDefault();
                                break;
                            }
                            else {
                                this._openPrompt("channelSettings");
                                event.preventDefault();
                                break;
                            }
                        }
                        break;
                    case 83:
                        if (canPlayNotes)
                            break;
                        if (event.shiftKey && event.ctrlKey && event.altKey) {
                            this.doc.prefs.autoPlay = false;
                            this.doc.prefs.autoFollow = true;
                            this.doc.prefs.enableNotePreview = true;
                            this.doc.prefs.showFifth = true;
                            this.doc.prefs.notesOutsideScale = false;
                            this.doc.prefs.defaultScale = 0;
                            this.doc.prefs.showLetters = true;
                            this.doc.prefs.showChannels = true;
                            this.doc.prefs.showScrollBar = true;
                            this.doc.prefs.useCustomSelectPrompt = true;
                            this.doc.prefs.alwaysFineNoteVol = false;
                            this.doc.prefs.enableChannelMuting = true;
                            this.doc.prefs.displayBrowserUrl = true;
                            this.doc.prefs.displayVolumeBar = true;
                            this.doc.prefs.layout = "tall";
                            this.doc.prefs.visibleOctaves = 5;
                            this.doc.prefs.closePromptByClickoff = false;
                            this.doc.prefs.colorTheme = "Standard";
                            this.doc.prefs.language="en"
                            this.doc.prefs.frostedGlassBackground = false;
                            this.doc.prefs.pianoKeyboard=true
                            this.doc.prefs.instrumentButtonsAtTop = true;
                            this.doc.prefs.instrumentCopyPaste = true;
                            this.doc.prefs.instrumentImportExport = true;
                            this.doc.prefs.notesFlashWhenPlayed = true;
                            this.doc.prefs.showOscilloscope = true;
                            this.doc.prefs.save();
                            event.preventDefault();
                            reloadsite()
                        }
                        else if (event.ctrlKey || event.metaKey) {
                            this._openPrompt("export");
                            event.preventDefault();
                        }
                        else if (this.doc.prefs.enableChannelMuting) {
                            if (event.shiftKey) {
                                this.doc.selection.muteChannels(false);
                            }
                            else {
                                this.doc.selection.soloChannels(false);
                            }
                            event.preventDefault();
                        }
                        break;
                    case 79:
                        if (canPlayNotes)
                            break;
                        if (event.ctrlKey || event.metaKey) {
                            this._openPrompt("import");
                            event.preventDefault();
                        }
                        break;
                    case 86:
                        if (canPlayNotes)
                            break;
                        if ((event.ctrlKey || event.metaKey) && event.shiftKey && !needControlForShortcuts) {
                            this.doc.selection.pasteNumbers();
                        }
                        else if (event.shiftKey) {
                            this._pasteInstrument();
                        }
                        else {
                            this.doc.selection.pasteNotes();
                        }
                        event.preventDefault();
                        break;
                    case 87:
                        if (canPlayNotes)
                            break;
                        this._openPrompt("moveNotesSideways");
                        break;
                    case 73:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey) && event.shiftKey) {
                            const instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                            const instrumentObject = instrument.toJsonObject();
                            delete instrumentObject["preset"];
                            delete instrumentObject["volume"];
                            delete instrumentObject["pan"];
                            const panningEffectIndex = instrumentObject["effects"].indexOf(Config.effectNames[2]);
                            if (panningEffectIndex != -1)
                                instrumentObject["effects"].splice(panningEffectIndex, 1);
                            for (let i = 0; i < instrumentObject["envelopes"].length; i++) {
                                const envelope = instrumentObject["envelopes"][i];
                                if (envelope["target"] == "panning" || envelope["target"] == "none" || envelope["envelope"] == "none") {
                                    instrumentObject["envelopes"].splice(i, 1);
                                    i--;
                                }
                            }
                            this._copyTextToClipboard(JSON.stringify(instrumentObject));
                            event.preventDefault();
                        }
                        break;
                    case 82:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            if (event.shiftKey) {
                                this._randomGenerated(false);
                            }
                            else if (event.altKey) {
                                this._randomGenerated(true);
                            }
                            else {
                                this._randomPreset();
                            }
                            event.preventDefault();
                        }
                        break;
                    case 219:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.synth.goToPrevBar();
                            this.doc.synth.initModFilters(this.doc.song);
                            this.doc.synth.computeLatestModValues();
                            if (Math.floor(this.doc.synth.playhead) < this.doc.synth.loopBarStart || Math.floor(this.doc.synth.playhead) > this.doc.synth.loopBarEnd) {
                                this.doc.synth.loopBarStart = -1;
                                this.doc.synth.loopBarEnd = -1;
                                this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            }
                            if (this.doc.prefs.autoFollow) {
                                this.doc.selection.setChannelBar(this.doc.channel, Math.floor(this.doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 221:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.synth.goToNextBar();
                            this.doc.synth.initModFilters(this.doc.song);
                            this.doc.synth.computeLatestModValues();
                            if (Math.floor(this.doc.synth.playhead) < this.doc.synth.loopBarStart || Math.floor(this.doc.synth.playhead) > this.doc.synth.loopBarEnd) {
                                this.doc.synth.loopBarStart = -1;
                                this.doc.synth.loopBarEnd = -1;
                                this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                            }
                            if (this.doc.prefs.autoFollow) {
                                this.doc.selection.setChannelBar(this.doc.channel, Math.floor(this.doc.synth.playhead));
                            }
                            event.preventDefault();
                        }
                        break;
                    case 189:
                    case 173:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.selection.transpose(false, event.shiftKey);
                            event.preventDefault();
                        }
                        break;
                    case 187:
                    case 61:
                    case 171:
                        if (canPlayNotes)
                            break;
                        if (needControlForShortcuts == (event.ctrlKey || event.metaKey)) {
                            this.doc.selection.transpose(true, event.shiftKey);
                            event.preventDefault();
                        }
                        break;
                    case 38:
                        if (event.ctrlKey || event.metaKey) {
                            this.doc.selection.swapChannels(-1);
                        }
                        else if (event.shiftKey) {
                            this.doc.selection.boxSelectionY1 = Math.max(0, this.doc.selection.boxSelectionY1 - 1);
                            this.doc.selection.scrollToEndOfSelection();
                            this.doc.selection.selectionUpdated();
                        }
                        else {
                            this.doc.selection.setChannelBar((this.doc.channel - 1 + this.doc.song.getChannelCount()) % this.doc.song.getChannelCount(), this.doc.bar);
                            this.doc.selection.resetBoxSelection();
                            this.envelopeEditor.rerenderExtraSettings();
                        }
                        event.preventDefault();
                        break;
                    case 40:
                        if (event.ctrlKey || event.metaKey) {
                            this.doc.selection.swapChannels(1);
                        }
                        else if (event.shiftKey) {
                            this.doc.selection.boxSelectionY1 = Math.min(this.doc.song.getChannelCount() - 1, this.doc.selection.boxSelectionY1 + 1);
                            this.doc.selection.scrollToEndOfSelection();
                            this.doc.selection.selectionUpdated();
                        }
                        else {
                            this.doc.selection.setChannelBar((this.doc.channel + 1) % this.doc.song.getChannelCount(), this.doc.bar);
                            this.doc.selection.resetBoxSelection();
                            this.envelopeEditor.rerenderExtraSettings();
                        }
                        event.preventDefault();
                        break;
                    case 37:
                        if (event.shiftKey) {
                            this.doc.selection.boxSelectionX1 = Math.max(0, this.doc.selection.boxSelectionX1 - 1);
                            this.doc.selection.scrollToEndOfSelection();
                            this.doc.selection.selectionUpdated();
                        }
                        else {
                            this.doc.selection.setChannelBar(this.doc.channel, (this.doc.bar + this.doc.song.barCount - 1) % this.doc.song.barCount);
                            this.doc.selection.resetBoxSelection();
                        }
                        event.preventDefault();
                        break;
                    case 39:
                        if (event.shiftKey) {
                            this.doc.selection.boxSelectionX1 = Math.min(this.doc.song.barCount - 1, this.doc.selection.boxSelectionX1 + 1);
                            this.doc.selection.scrollToEndOfSelection();
                            this.doc.selection.selectionUpdated();
                        }
                        else {
                            this.doc.selection.setChannelBar(this.doc.channel, (this.doc.bar + 1) % this.doc.song.barCount);
                            this.doc.selection.resetBoxSelection();
                        }
                        event.preventDefault();
                        break;
                    case 46:
                        this.doc.selection.digits = "";
                        this.doc.selection.nextDigit("0", false, false);
                        break;
                    case 48:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("0", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 49:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("1", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 50:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("2", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 51:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("3", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 52:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("4", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 53:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("5", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 54:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("6", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 55:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("7", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 56:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("8", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    case 57:
                        if (canPlayNotes)
                            break;
                        this.doc.selection.nextDigit("9", needControlForShortcuts != (event.shiftKey || event.ctrlKey || event.metaKey), event.altKey);
                        this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], this.doc.getCurrentInstrument(), ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                        event.preventDefault();
                        break;
                    default:
                        this.doc.selection.digits = "";
                        this.doc.selection.instrumentDigits = "";
                        break;
                }
                if (canPlayNotes) {
                    this.doc.selection.digits = "";
                    this.doc.selection.instrumentDigits = "";
                }
            };
            this._whenKeyReleased = (event) => {
                this._muteEditor.onKeyUp(event);
                if (!event.ctrlKey) {
                    this._patternEditor.controlMode = false;
                }
                if (!event.shiftKey) {
                    this._patternEditor.shiftMode = false;
                }
                this._ctrlHeld = event.ctrlKey;
                this._shiftHeld = event.shiftKey;
                this._keyboardLayout.handleKeyEvent(event, false);
            };
            this._whenPrevBarPressed = () => {
                this.doc.synth.goToPrevBar();
                if (Math.floor(this.doc.synth.playhead) < this.doc.synth.loopBarStart || Math.floor(this.doc.synth.playhead) > this.doc.synth.loopBarEnd) {
                    this.doc.synth.loopBarStart = -1;
                    this.doc.synth.loopBarEnd = -1;
                    this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                }
                this._barScrollBar.animatePlayhead();
            };
            this._whenNextBarPressed = () => {
                this.doc.synth.goToNextBar();
                if (Math.floor(this.doc.synth.playhead) < this.doc.synth.loopBarStart || Math.floor(this.doc.synth.playhead) > this.doc.synth.loopBarEnd) {
                    this.doc.synth.loopBarStart = -1;
                    this.doc.synth.loopBarEnd = -1;
                    this._loopEditor.setLoopAt(this.doc.synth.loopBarStart, this.doc.synth.loopBarEnd);
                }
                this._barScrollBar.animatePlayhead();
            };
            this.togglePlay = () => {
                if (this.doc.synth.playing) {
                    this.doc.performance.pause();
                    this.outVolumeHistoricCap = 0;
                }
                else {
                    this.doc.synth.snapToBar();
                    this.doc.performance.play();
                }
            };
            this._toggleRecord = () => {
                if (this.doc.synth.playing) {
                    this.doc.performance.pause();
                }
                else {
                    this.doc.performance.record();
                }
            };
            this._animate = () => { 
                this._modSliderUpdate();
                
function step1(value, stepSize) {
	return (value).toFixed(2);
}
let instrument =false
if(this.doc.synth.playing){
let usesCustomUnison ;
	for (let instrumentIndex = 0; instrumentIndex < this.doc.song.channels[this.doc.channel].instruments.length; instrumentIndex++) {
	 instrument = this.doc.song.channels[this.doc.channel].instruments[instrumentIndex];
		usesCustomUnison = instrument.unison === Config.unisons.length
	} 
if (usesCustomUnison) {
	this.changedUnisonPreview=0;
	this._unisonVoicesInputBox.style.color = "red"
this._unisonSpreadInputBox.style.color = "red"
this._unisonOffsetInputBox.style.color = "red"
this._unisonExpressionInputBox.style.color = "red"
this._unisonSignInputBox.style.color = "red"

this._unisonVoicesInputBox.disabled=true;
this._unisonSpreadInputBox.disabled=true;
this._unisonOffsetInputBox.disabled=true;
this._unisonExpressionInputBox.disabled=true;
this._unisonSignInputBox.disabled=true;
if(instrument){
this._unisonVoicesInputBox.value = step1(instrument.unisonVoices,0.01) + "";
this._unisonSpreadInputBox.value = step1(instrument.unisonSpread,0.01) + "";
this._unisonOffsetInputBox.value = step1(instrument.unisonOffset,0.01) + "";
this._unisonExpressionInputBox.value = step1(instrument.unisonExpression,0.1) + "";
this._unisonSignInputBox.value = step1(instrument.unisonSign,0.1) + ""
}
}else{
this._unisonVoicesInputBox.disabled = false;
this._unisonSpreadInputBox.disabled = false;
this._unisonOffsetInputBox.disabled = false;
this._unisonExpressionInputBox.disabled = false;
this._unisonSignInputBox.disabled = false;

this._unisonVoicesInputBox.style.color = "white"
this._unisonSpreadInputBox.style.color = "white"
this._unisonOffsetInputBox.style.color = "white"
this._unisonExpressionInputBox.style.color = "white"
this._unisonSignInputBox.style.color = "white"

if(this.changedUnisonPreview==0){
	if(instrument){
this._unisonVoicesInputBox.value = instrument.last_unisonVoices + "";
this._unisonSpreadInputBox.value = instrument.last_unisonSpread + "";
this._unisonOffsetInputBox.value = instrument.last_unisonOffset + "";
this._unisonExpressionInputBox.value = instrument.last_unisonExpression + "";
this._unisonSignInputBox.value = instrument.last_unisonSign + ""; 
}}
this.changedUnisonPreview = 1
}
}else{
this._unisonVoicesInputBox.disabled = false;
this._unisonSpreadInputBox.disabled = false;
this._unisonOffsetInputBox.disabled = false;
this._unisonExpressionInputBox.disabled = false;
this._unisonSignInputBox.disabled = false;

this._unisonVoicesInputBox.style.color = "white"
this._unisonSpreadInputBox.style.color = "white"
this._unisonOffsetInputBox.style.color = "white"
this._unisonExpressionInputBox.style.color = "white"
this._unisonSignInputBox.style.color = "white"
}
                
                if (this.doc.prefs.displayVolumeBar) {
                    this._volumeUpdate();
                }
                this._barScrollBar.animatePlayhead();
                if (this.doc.synth.isFilterModActive(false, this.doc.channel, this.doc.getCurrentInstrument())) {
                    this._eqFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                }
                if (this.doc.synth.isFilterModActive(true, this.doc.channel, this.doc.getCurrentInstrument())) {
                    this._noteFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                }
                if (this.doc.synth.isFilterModActive(false, 0, 0, true)) {
                    this._songEqFilterEditor.render(true, this._ctrlHeld || this._shiftHeld);
                }
                window.requestAnimationFrame(this._animate);
            };
            this._volumeUpdate = () => {
                this.outVolumeHistoricTimer--;
                if (this.outVolumeHistoricTimer <= 0) {
                    this.outVolumeHistoricCap -= 0.03;
                }
                if (this.doc.song.outVolumeCap > this.outVolumeHistoricCap) {
                    this.outVolumeHistoricCap = this.doc.song.outVolumeCap;
                    this.outVolumeHistoricTimer = 50;
                }
                if (this.doc.song.outVolumeCap != this.lastOutVolumeCap) {
                    this.lastOutVolumeCap = this.doc.song.outVolumeCap;
                    this._animateVolume(this.doc.song.outVolumeCap, this.outVolumeHistoricCap);
                }
            };
            this._setVolumeSlider = () => {
                if ((this._ctrlHeld || this._shiftHeld) && this.doc.synth.playing) {
                    const prevVol = this.doc.prefs.volume;
                    this.doc.prefs.volume = Math.round(Number(this._volumeSlider.input.value) * 4 / 3);
                    const changedPatterns = this._patternEditor.setModSettingsForChange(null, this); 
                    const useVol = this.doc.prefs.volume;      
                    window.clearTimeout(this._modRecTimeout);
                    this._modRecTimeout = window.setTimeout(() => { this._recordVolumeSlider(useVol); }, 10);
                    this.doc.recordingModulators = true;
                    this.doc.prefs.volume = prevVol;
                    this._volumeSlider.updateValue(this.doc.prefs.volume);
                    if (changedPatterns)
                        this._trackEditor.render();
                }
                else {
                    this.doc.setVolume(Number(this._volumeSlider.input.value));
                    if (this.doc.recordingModulators) {
                        this.doc.recordingModulators = false;
                        this.doc.record(new ChangeHoldingModRecording(this.doc, null, null, null));
                    }
                }
            };
            this._copyInstrument = () => {
                const channel = this.doc.song.channels[this.doc.channel];
                const instrument = channel.instruments[this.doc.getCurrentInstrument()];
                const instrumentCopy = instrument.toJsonObject();
                instrumentCopy["isDrum"] = this.doc.song.getChannelIsNoise(this.doc.channel);
                instrumentCopy["isMod"] = this.doc.song.getChannelIsMod(this.doc.channel);
                window.localStorage.setItem("instrumentCopy", JSON.stringify(instrumentCopy));
                this.refocusStage();
            };
            this._pasteInstrument = () => {
                const channel = this.doc.song.channels[this.doc.channel];
                const instrument = channel.instruments[this.doc.getCurrentInstrument()];
                const instrumentCopy = JSON.parse(String(window.localStorage.getItem("instrumentCopy")));
                if (instrumentCopy != null && instrumentCopy["isDrum"] == this.doc.song.getChannelIsNoise(this.doc.channel) && instrumentCopy["isMod"] == this.doc.song.getChannelIsMod(this.doc.channel)) {
                    this.doc.record(new ChangePasteInstrument(this.doc, instrument, instrumentCopy));
                }
                this.refocusStage();
            };
            this._exportInstruments = () => {
                this._openPrompt("exportInstrument");
            };
            this._importInstruments = () => {
                this._openPrompt("importInstrument");
            };
            this._whenSetTempo = () => {
                this.doc.record(new ChangeTempo(this.doc, -1, parseInt(this._tempoStepper.value) | 0));
            };
            this._whenSetOctave = () => {
                this.doc.record(new ChangeKeyOctave(this.doc, this.doc.song.octave, parseInt(this._octaveStepper.value) | 0));
                this._piano.forceRender();
            };
            this._whenSetScale = () => {
                if (isNaN(this._scaleSelect.value)) {
                    switch (this._scaleSelect.value) {
                        case "forceScale":
                            this.doc.selection.forceScale();
                            break;
                        case "customize":
                            this._openPrompt("customScale");
                            break;
                    }
                    this.doc.notifier.changed();
                }
                else {
                    this.doc.record(new ChangeScale(this.doc, this._scaleSelect.selectedIndex));
                }
            };
            this._whenSetKey = () => {
                if (isNaN(this._keySelect.value)) {
                    switch (this._keySelect.value) {
                        case "detectKey":
                            this.doc.record(new ChangeDetectKey(this.doc));
                            break;
                    }
                    this.doc.notifier.changed();
                }
                else {
                    this.doc.record(new ChangeKey(this.doc, Config.keys.length - 1 - this._keySelect.selectedIndex));
                }
            };
            this._whenSetRhythm = () => {
                if (isNaN(this._rhythmSelect.value)) {
                    switch (this._rhythmSelect.value) {
                        case "forceRhythm":
                            this.doc.selection.forceRhythm();
                            break;
                    }
                    this.doc.notifier.changed();
                }
                else {
                    this.doc.record(new ChangeRhythm(this.doc, this._rhythmSelect.selectedIndex));
                }
            };
            this._refocus = () => {
                var selfRef = this;
                setTimeout(function () { selfRef.mainLayer.focus(); }, 20);
            };
            this._whenSetPitchedPreset = () => {
                this._setPreset($('#pitchPresetSelect').val() + "");
            };
            this._whenSetDrumPreset = () => {
                this._setPreset($('#drumPresetSelect').val() + "");
            };
            this._whenSetFeedbackType = () => {
                this.doc.record(new ChangeFeedbackType(this.doc, this._feedbackTypeSelect.selectedIndex));
            };
            this._whenSetAlgorithm = () => {
                this.doc.record(new ChangeAlgorithm(this.doc, this._algorithmSelect.selectedIndex));
            };
            this._whenSet6OpFeedbackType = () => {
                this.doc.record(new Change6OpFeedbackType(this.doc, this._feedback6OpTypeSelect.selectedIndex));
                this._customAlgorithmCanvas.reset();
            };
            this._whenSet6OpAlgorithm = () => {
                this.doc.record(new Change6OpAlgorithm(this.doc, this._algorithm6OpSelect.selectedIndex));
                this._customAlgorithmCanvas.reset();
            };
            this._whenSelectInstrument = (event) => {
                if (event.target == this._instrumentAddButton) {
                    this.doc.record(new ChangeAddChannelInstrument(this.doc));
                }
                else if (event.target == this._instrumentRemoveButton) {
                    this.doc.record(new ChangeRemoveChannelInstrument(this.doc));
                }
                else {
                    const index = this._instrumentButtons.indexOf(event.target);
                    if (index != -1) {
                        this.doc.selection.selectInstrument(index);
                    }
                    if (this.doc.channel >= this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                        this._piano.forceRender();
                    }
                    this._renderInstrumentBar(this.doc.song.channels[this.doc.channel], index, ColorConfig.getChannelColor(this.doc.song, this.doc.channel));
                }
                this.refocusStage();
            };
            this._whenSetModChannel = (mod) => {
                let instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                let previouslyUnset = (instrument.modulators[mod] == 0 || Config.modulators[instrument.modulators[mod]].forSong);
                this.doc.selection.setModChannel(mod, this._modChannelBoxes[mod].selectedIndex);
                const modChannel = Math.max(0, instrument.modChannels[mod]);
                if (this.doc.song.channels[modChannel].instruments.length > 1 && previouslyUnset && this._modChannelBoxes[mod].selectedIndex >= 2) {
                    if (this.doc.song.channels[modChannel].bars[this.doc.bar] > 0) {
                        this.doc.selection.setModInstrument(mod, this.doc.song.channels[modChannel].patterns[this.doc.song.channels[modChannel].bars[this.doc.bar] - 1].instruments[0]);
                    }
                }
                this._piano.forceRender();
            };
            this._whenSetModInstrument = (mod) => {
                this.doc.selection.setModInstrument(mod, this._modInstrumentBoxes[mod].selectedIndex);
                this._piano.forceRender();
            };
            this._whenSetModSetting = (mod, invalidIndex = false) => {
                let text = "none";
                if (this._modSetBoxes[mod].selectedIndex != -1) {
                    text = this._modSetBoxes[mod].children[this._modSetBoxes[mod].selectedIndex].textContent;
                    if (invalidIndex) {
                        this._modSetBoxes[mod].selectedOptions.item(0).style.setProperty("color", "red");
                        this._modSetBoxes[mod].classList.add("invalidSetting");
                        this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].invalidModulators[mod] = true;
                    }
                    else {
                        this._modSetBoxes[mod].classList.remove("invalidSetting");
                        this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].invalidModulators[mod] = false;
                    }
                }
                if (!invalidIndex)
                    this.doc.selection.setModSetting(mod, text);
                this._piano.forceRender();
            };
            this._whenClickModTarget = (mod) => {
                if (this._modChannelBoxes[mod].selectedIndex >= 2) {
                    this.doc.selection.setChannelBar(this._modChannelBoxes[mod].selectedIndex - 2, this.doc.bar);
                }
            };
            this._whenClickJumpToModTarget = () => {
                const channelIndex = this.doc.channel;
                const instrumentIndex = this.doc.getCurrentInstrument();
                if (channelIndex < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                    for (let modChannelIdx = this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount; modChannelIdx < this.doc.song.channels.length; modChannelIdx++) {
                        const modChannel = this.doc.song.channels[modChannelIdx];
                        const patternIdx = modChannel.bars[this.doc.bar];
                        if (patternIdx > 0) {
                            const modInstrumentIdx = modChannel.patterns[patternIdx - 1].instruments[0];
                            const modInstrument = modChannel.instruments[modInstrumentIdx];
                            for (let mod = 0; mod < Config.modCount; mod++) {
                                if (modInstrument.modChannels[mod] == channelIndex && (modInstrument.modInstruments[mod] == instrumentIndex || modInstrument.modInstruments[mod] >= this.doc.song.channels[channelIndex].instruments.length)) {
                                    this.doc.selection.setChannelBar(modChannelIdx, this.doc.bar);
                                    return;
                                }
                            }
                        }
                    }
                }
            };
            this._whenSetModFilter = (mod) => {
                this.doc.selection.setModFilter(mod, this._modFilterBoxes[mod].selectedIndex);
            };
            this._whenSetModEnvelope = (mod) => {
                this.doc.selection.setModEnvelope(mod, this._modEnvelopeBoxes[mod].selectedIndex);
            };
            this._whenSetChipWave = () => {
                this.doc.record(new ChangeChipWave(this.doc, this._chipWaveSelect.selectedIndex));
                
            };
            this._whenSetRingModChipWave = () => {
                this.doc.record(new ChangeRingModChipWave(this.doc, this._ringModWaveSelect.selectedIndex));
            };
            this._whenSetUseChipWaveAdvancedLoopControls = () => {
                this.doc.record(new ChangeChipWaveUseAdvancedLoopControls(this.doc, this._useChipWaveAdvancedLoopControlsBox.checked ? true : false));
            };
            this._whenSetChipWaveLoopMode = () => {
                this.doc.record(new ChangeChipWaveLoopMode(this.doc, this._chipWaveLoopModeSelect.selectedIndex));
            };
            this._whenSetChipWaveLoopStart = () => {
                this.doc.record(new ChangeChipWaveLoopStart(this.doc, parseInt(this._chipWaveLoopStartStepper.value) | 0));
            };
            this._whenSetChipWaveLoopEnd = () => {
                this.doc.record(new ChangeChipWaveLoopEnd(this.doc, parseInt(this._chipWaveLoopEndStepper.value) | 0));
            };
            this._whenSetChipWaveLoopEndToEnd = () => {
                const channel = this.doc.song.channels[this.doc.channel];
                const instrument = channel.instruments[this.doc.getCurrentInstrument()];
                const chipWave = Config.rawRawChipWaves[instrument.chipWave];
                const chipWaveLength = chipWave.samples.length;
                this.doc.record(new ChangeChipWaveLoopEnd(this.doc, chipWaveLength - 1));
            };
            this._whenSetChipWaveStartOffset = () => {
                this.doc.record(new ChangeChipWaveStartOffset(this.doc, parseInt(this._chipWaveStartOffsetStepper.value) | 0));
            };
            this._whenSetChipWavePlayBackwards = () => {
                this.doc.record(new ChangeChipWavePlayBackwards(this.doc, this._chipWavePlayBackwardsBox.checked));
            };
            this._whenSetNoiseWave = () => {
                this.doc.record(new ChangeNoiseWave(this.doc, this._chipNoiseSelect.selectedIndex));
            };
            this._whenSetTransition = () => {
                this.doc.record(new ChangeTransition(this.doc, this._transitionSelect.selectedIndex));
            };
            this._whenSetEffects = () => {
                const instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                const oldValue = instrument.effects;
                const toggleFlag = Config.effectOrder[this._effectsSelect.selectedIndex - 1];
                this.doc.record(new ChangeToggleEffects(this.doc, toggleFlag, null));
                this._effectsSelect.selectedIndex = 0;
                if (instrument.effects > oldValue) {
                    this.doc.addedEffect = true;
                }
                this.doc.notifier.changed();
            };
            this._whenSetVibrato = () => {
                this.doc.record(new ChangeVibrato(this.doc, this._vibratoSelect.selectedIndex));
            };
            this._whenSetVibratoType = () => {
                this.doc.record(new ChangeVibratoType(this.doc, this._vibratoTypeSelect.selectedIndex));
            };
            this._whenSetUnison = () => {
                this.doc.record(new ChangeUnison(this.doc, this._unisonSelect.selectedIndex));
            };
            this._whenSetChord = () => {
                this.doc.record(new ChangeChord(this.doc, this._chordSelect.selectedIndex));
            };
            this._whenSetMonophonicNote = () => {
                this.doc.record(new ChangeMonophonicTone(this.doc, parseInt(this._monophonicNoteInputBox.value) - 1));
            };
            this._addNewEnvelope = () => {
                this.doc.record(new ChangeAddEnvelope(this.doc));
                this.refocusStage();
                this.doc.addedEnvelope = true;
            };
            this._zoomIn = () => {
                this.doc.prefs.visibleOctaves = Math.max(1, this.doc.prefs.visibleOctaves - 1);
                this.doc.prefs.save();
                this.doc.notifier.changed();
                this.refocusStage();
            };
            this._zoomOut = () => {
                this.doc.prefs.visibleOctaves = Math.min(Config.pitchOctaves, this.doc.prefs.visibleOctaves + 1);
                this.doc.prefs.save();
                this.doc.notifier.changed();
                this.refocusStage();
            };
            this._fileMenuHandler = (event) => {
                switch (this._fileMenu.value) {
                    case "new":
                        this.doc.goBackToStart();
                        this.doc.song.restoreLimiterDefaults();
                        for (const channel of this.doc.song.channels) {
                            channel.muted = false;
                            channel.name = "";
                        }
                        this.doc.record(new ChangeSong(this.doc, ""), false, true);
                        break;
                    case "export":
                        this._openPrompt("export");
                        break;
                    case "import":
                        this._openPrompt("import");
                        break;
                    case "copyUrl":
                        this._copyTextToClipboard(new URL("#" + this.doc.song.toBase64String(), location.href).href);
                        break;
                    case "shareUrl":
                        navigator.share({ url: new URL("#" + this.doc.song.toBase64String(), location.href).href });
                        break;
                    case "shortenUrl":
                        let shortenerStrategy = "https://tinyurl.com/api-create.php?url=";
                        const localShortenerStrategy = window.localStorage.getItem("shortenerStrategySelect");
                        if (localShortenerStrategy == "isgd")
                            shortenerStrategy = "https://is.gd/create.php?format=simple&url=";
                        window.open(shortenerStrategy + encodeURIComponent(new URL("#" + this.doc.song.toBase64String(), location.href).href));
                        break;
                    case "configureShortener":
                        this._openPrompt("configureShortener");
                        break;
                    case "viewPlayer":
if (location.href.startsWith("file:///")) {
	cleanMemoryBeforeNavigation()
	let fileFull = "file:///android_asset/WebView/player.html#" + this.doc.song.toBase64String();
	window.open(fileFull, "_self")
} else {
	cleanMemoryBeforeNavigation()
	location.href = "./player.html" + "#" + this.doc.song.toBase64String();
}
                        break;
                    case "copyEmbed":
                        this._copyTextToClipboard(`<iframe width="384" height="60" style="border: none;" src="${new URL("player.html/#song=" + this.doc.song.toBase64String(), location.href).href}"></iframe>`);
                        break;
                    case "songRecovery":
                        this._openPrompt("songRecovery");
                        break;
                }
                this._fileMenu.selectedIndex = 0;
            };
            this._editMenuHandler = (event) => {
                switch (this._editMenu.value) {
                    case "undo":
                        this.doc.undo();
                        break;
                    case "redo":
                        this.doc.redo();
                        break;
                    case "copy":
                        this.doc.selection.copy();
                        break;
                    case "insertBars":
                        this.doc.selection.insertBars();
                        break;
                    case "deleteBars":
                        this.doc.selection.deleteBars();
                        break;
                    case "insertChannel":
                        this.doc.selection.insertChannel();
                        break;
                    case "deleteChannel":
                        this.doc.selection.deleteChannel();
                        break;
                    case "pasteNotes":
                        this.doc.selection.pasteNotes();
                        break;
                    case "pasteNumbers":
                        this.doc.selection.pasteNumbers();
                        break;
                    case "transposeUp":
                        this.doc.selection.transpose(true, false);
                        break;
                    case "transposeDown":
                        this.doc.selection.transpose(false, false);
                        break;
case "transposeOctaveUp":
this.doc.selection.transpose(true, true);
break;
case "transposeOctaveDown":
this.doc.selection.transpose(false, true);
break;
                    case "selectAll":
                        this.doc.selection.selectAll();
                        break;
                    case "selectChannel":
                        this.doc.selection.selectChannel();
                        break;
                    case "duplicatePatterns":
                        this.doc.selection.duplicatePatterns(false);
                        break;
                    case "barCount":
                        this._openPrompt("barCount");
                        break;
                    case "beatsPerBar":
                        this._openPrompt("beatsPerBar");
                        break;
                    case "moveNotesSideways":
                        this._openPrompt("moveNotesSideways");
                        break;
                    case "channelSettings":
                        this._openPrompt("channelSettings");
                        break;
                    case "limiterSettings":
                        this._openPrompt("limiterSettings");
                        break;
                    case "generateEuclideanRhythm":
                        this._openPrompt("generateEuclideanRhythm");
                        break;
                    case "addExternal":
                        this._openPrompt("addExternal");
                        break;
                }
                this._editMenu.selectedIndex = 0;
            };
            this._optionsMenuHandler = (event) => {
                switch (this._optionsMenu.value) {
                    case "autoPlay":
                        this.doc.prefs.autoPlay = !this.doc.prefs.autoPlay;
                        break;
                    case "autoFollow":
                        this.doc.prefs.autoFollow = !this.doc.prefs.autoFollow;
                        break;
                    case "enableNotePreview":
                        this.doc.prefs.enableNotePreview = !this.doc.prefs.enableNotePreview;
                        break;
                    case "showLetters":
                        this.doc.prefs.showLetters = !this.doc.prefs.showLetters;
                        break;
                    case "showFifth":
                        this.doc.prefs.showFifth = !this.doc.prefs.showFifth;
                        break;
                    case "notesOutsideScale":
                        this.doc.prefs.notesOutsideScale = !this.doc.prefs.notesOutsideScale;
                        break;
                    case "setDefaultScale":
                        this.doc.prefs.defaultScale = this.doc.song.scale;
                        break;
                    case "showChannels":
                        this.doc.prefs.showChannels = !this.doc.prefs.showChannels;
                        break;
                    case "showScrollBar":
                        this.doc.prefs.showScrollBar = !this.doc.prefs.showScrollBar;
                        break;
                        case "useCustomSelectPrompt":
                      this.doc.prefs.useCustomSelectPrompt = !this.doc.prefs.useCustomSelectPrompt;
                      this.customSelectPrompt = new CustomSelectModal(this.doc)
                        break;
                    case "alwaysFineNoteVol":
                        this.doc.prefs.alwaysFineNoteVol = !this.doc.prefs.alwaysFineNoteVol;
                        break;
                    case "enableChannelMuting":
                        this.doc.prefs.enableChannelMuting = !this.doc.prefs.enableChannelMuting;
                        for (const channel of this.doc.song.channels)
                            channel.muted = false;
                        break;
                    case "displayBrowserUrl":
                        this.doc.toggleDisplayBrowserUrl();
                        break;
                    case "displayVolumeBar":
                        this.doc.prefs.displayVolumeBar = !this.doc.prefs.displayVolumeBar;
                        break;
                    case "notesFlashWhenPlayed":
                        this.doc.prefs.notesFlashWhenPlayed = !this.doc.prefs.notesFlashWhenPlayed;
                        break;
                    case "layout":
                        this._openPrompt("layout");
                        break;
                    case "colorTheme":
                        this._openPrompt("theme");
                        break;
                   case "setLanguage":
                        this._openPrompt("language");
                        break;
                    case "customTheme":
                        this._openPrompt("customTheme");
                        break;
                    case "Fullscreen":
                        document.documentElement.requestFullscreen()
                        break;
                    case "recordingSetup":
                        this._openPrompt("recordingSetup");
                        break;
                    case "showOscilloscope":
                        this.doc.prefs.showOscilloscope = !this.doc.prefs.showOscilloscope;
                        break;
                    case "showDescription":
                        this.doc.prefs.showDescription = !this.doc.prefs.showDescription;
                        break;
case "oldButtonSheme":
this.doc.prefs.oldButtonSheme = !this.doc.prefs.oldButtonSheme;
reloadsite();
break;
case "newloopeditor":
this.doc.prefs.newloopeditor = !this.doc.prefs.newloopeditor;
break;
case "openPlugins":
 this._openPrompt("plugins");
break;
case "whistleRecord":
this.doc.prefs.whistleRecord = false; 
this.doc.selection.whistleRecord();
break;
case "increaseAllPins":
this.doc.prefs.increaseAllPins = !this.doc.prefs.increaseAllPins;
break;
case "differentMod":
this.doc.prefs.differentMod = !this.doc.prefs.differentMod;
break; 
                    case "showInstrumentScrollbars":
                        this.doc.prefs.showInstrumentScrollbars = !this.doc.prefs.showInstrumentScrollbars;
                        break;
                    case "showSampleLoadingStatus":
                        this.doc.prefs.showSampleLoadingStatus = !this.doc.prefs.showSampleLoadingStatus;
                        break;
                    case "closePromptByClickoff":
                        this.doc.prefs.closePromptByClickoff = !this.doc.prefs.closePromptByClickoff;
                        break;
                    case "instrumentCopyPaste":
                        this.doc.prefs.instrumentCopyPaste = !this.doc.prefs.instrumentCopyPaste;
                        break;
                    case "instrumentImportExport":
                        this.doc.prefs.instrumentImportExport = !this.doc.prefs.instrumentImportExport;
                        break;
                    case "instrumentButtonsAtTop":
                        this.doc.prefs.instrumentButtonsAtTop = !this.doc.prefs.instrumentButtonsAtTop;
                        break;
                    case "frostedGlassBackground":
                        this.doc.prefs.frostedGlassBackground = !this.doc.prefs.frostedGlassBackground;
                        break;
                    case "pianoKeyboard":
                        this.doc.prefs.pianoKeyboard = !this.doc.prefs.pianoKeyboard;
                        rebuiltKeyboard()
                        break;
                }
                this._optionsMenu.selectedIndex = 0;
                this.doc.notifier.changed();
                this.doc.prefs.save();
            };
            this._customWavePresetHandler = (event) => {
                let customWaveArray = new Float32Array(64);
                let index = this._customWavePresetDrop.selectedIndex - 1;
                let maxValue = Number.MIN_VALUE;
                let minValue = Number.MAX_VALUE;
                let arrayPoint = 0;
                let arrayStep = (Config.chipWaves[index].samples.length - 1) / 64.0;
                for (let i = 0; i < 64; i++) {
                    customWaveArray[i] = (Config.chipWaves[index].samples[Math.floor(arrayPoint)] - Config.chipWaves[index].samples[(Math.floor(arrayPoint) + 1)]) / arrayStep;
                    if (customWaveArray[i] < minValue)
                        minValue = customWaveArray[i];
                    if (customWaveArray[i] > maxValue)
                        maxValue = customWaveArray[i];
                    arrayPoint += arrayStep;
                }
                for (let i = 0; i < 64; i++) {
                    customWaveArray[i] -= minValue;
                    customWaveArray[i] /= (maxValue - minValue);
                    customWaveArray[i] *= 48.0;
                    customWaveArray[i] -= 24.0;
                    customWaveArray[i] = Math.ceil(customWaveArray[i]);
                    this._customWaveDrawCanvas.newArray[i] = customWaveArray[i];
                }
                this.doc.record(new ChangeCustomWave(this.doc, customWaveArray));
                if (+this._instrumentVolumeSlider.input.value != -Config.volumeRange / 2) {
                    this.doc.record(new ChangeVolume(this.doc, +this._instrumentVolumeSlider.input.value, Math.min(Math.max(-Config.volumeRange / 2 + Math.round(Math.sqrt(Config.chipWaves[index].expression) * Config.volumeRange / 2 + parseInt(this._instrumentVolumeSlider.input.value)), -Config.volumeRange / 2) >> 1, Config.volumeRange / 2)));
                }
                this._customWavePresetDrop.selectedIndex = 0;
                this.doc.notifier.changed();
                this.doc.prefs.save();
            };
            this.doc.notifier.watch(this.whenUpdated);
            this.doc.modRecordingHandler = () => { this.handleModRecording(); };
            new MidiInputHandler(this.doc);
            window.addEventListener("resize", this.whenUpdated);
            window.requestAnimationFrame(this.updatePlayButton);
            window.requestAnimationFrame(this._animate);
            if (!("share" in navigator)) {
                this._fileMenu.removeChild(this._fileMenu.querySelector("[value='shareUrl']"));
            }
            this._scaleSelect.appendChild(optgroup({ label: "Edit" }, option({ value: "forceScale" }, "Snap Notes To Scale"), option({ value: "customize" }, "Edit Custom Scale")));
            this._keySelect.appendChild(optgroup({ label: "Edit" }, option({ value: "detectKey" }, "Detect Key")));
            this._rhythmSelect.appendChild(optgroup({ label: "Edit" }, option({ value: "forceRhythm" }, "Snap Notes To Rhythm")));
            this._vibratoSelect.appendChild(option({ hidden: true, value: 5 }, "custom"));
            this._unisonSelect.appendChild(option({ hidden: true, value: Config.unisons.length }, "custom"));
            this._showModSliders = new Array(Config.modulators.length);
            this._modSliderValues = new Array(Config.modulators.length);
            
            for (let i = 0; i < Config.modulators.length; i++) {
                this._newShowModSliders[i] = [];
                this._showModSliders[i] = [];
                this._modSliderValues[i] = [];
            }
            this._phaseModGroup.appendChild(div({ class: "selectRow", style: `color: ${ColorConfig.secondaryText}; height: 1em; margin-top: 0.5em;` }, div({ style: "margin-right: .1em; visibility: hidden;" }, 1 + "."), div({ style: "width: 3em; margin-right: .3em;", class: "tip", onclick: () => this._openPrompt("operatorFrequency") }, "Freq:"), div({ class: "tip", onclick: () => this._openPrompt("operatorVolume") }, "Volume:")));
            for (let i = 0; i < Config.operatorCount + 4; i++) {
                const operatorIndex = i;
                const operatorNumber = div({ style: "margin-right: 0px; color: " + ColorConfig.secondaryText + ";" }, i + 1 + "");
                const frequencySelect = buildOptions(select({ style: "width: 100%;", title: "Frequency" }), Config.operatorFrequencies.map(freq => freq.name));
                const amplitudeSlider = new Slider(input({ type: "range", min: "0", max: Config.operatorAmplitudeMax, value: "0", step: "1", title: "Volume" }), this.doc, (oldValue, newValue) => new ChangeOperatorAmplitude(this.doc, operatorIndex, oldValue, newValue), false);
                let waveformSelect = buildOptions(select({ style: "width: 100%;", title: "Waveform" }), Config.operatorWaves.map(wave => wave.name));  
                const waveformDropdown = button({ style: "margin-left:0em; margin-right: 2px; height:1.5em; width: 8px; max-width: 10px; padding: 0px; font-size: 8px;", onclick: () => this._toggleDropdownMenu(4, i) }, "");
                const waveformDropdownHint = span({ class: "tip", style: "margin-left: 10px;", onclick: () => this._openPrompt("operatorWaveform") }, "Wave:");
                this.waveformPulsewidthSlider[i] = new Slider(input({ style: "margin-left: 10px; width: 85%;", type: "range", min: "0", max: Config.pwmOperatorWaves.length - 1, value: "0", step: "1", title: "Pulse Width" }), this.doc, (oldValue, newValue) => new ChangeOperatorPulseWidth(this.doc, operatorIndex, oldValue, newValue), true); 
                const waveformDropdownRow = div({ class: "selectRow" }, waveformDropdownHint, this.waveformPulsewidthSlider[i].container, div({ class: "selectContainer", style: "width: 6em; margin-left: .3em;" }, waveformSelect));
                const waveformDropdownGroup = div({ class: "operatorRow" }, waveformDropdownRow);
                const row = div({ class: "selectRow" }, operatorNumber, waveformDropdown, div({ class: "selectContainer", style: "width: 3em; margin-right: .3em;" }, frequencySelect), amplitudeSlider.container); 
                this._phaseModGroup.appendChild(row);
                this._operatorRows[i] = row; 
                this._operatorAmplitudeSliders[i] = amplitudeSlider;
                this._operatorFrequencySelects[i] = frequencySelect;
                this._operatorDropdowns[i] = waveformDropdown;
                this._operatorWaveformHints[i] = waveformDropdownHint;
                this._operatorWaveformSelects[i] = waveformSelect;
                this._operatorWaveformPulsewidthSliders[i] = this.waveformPulsewidthSlider[i];
                this._operatorDropdownRows[i] = waveformDropdownRow;
                this._phaseModGroup.appendChild(waveformDropdownGroup);
                this._operatorDropdownGroups[i] = waveformDropdownGroup;
                this._openOperatorDropdowns[i] = false;
                waveformSelect.addEventListener("change", () => {
                    this.doc.record(new ChangeOperatorWaveform(this.doc, operatorIndex, waveformSelect.selectedIndex));
                });
                frequencySelect.addEventListener("change", () => {
                    this.doc.record(new ChangeOperatorFrequency(this.doc, operatorIndex, frequencySelect.selectedIndex));
                });
            }
            this._drumsetGroup.appendChild(div({ class: "selectRow" }, span({ class: "tip", onclick: () => this._openPrompt("drumsetEnvelope") }, "Envelope:"), span({ class: "tip", onclick: () => this._openPrompt("drumsetSpectrum") }, "Spectrum:"), this._drumsetZoom));
            for (let i = Config.drumCount - 1; i >= 0; i--) {
                const drumIndex = i;
                const spectrumEditor = new SpectrumEditor(this.doc, drumIndex);
                spectrumEditor.container.addEventListener("mousedown", this.refocusStage);
                this._drumsetSpectrumEditors[i] = spectrumEditor;
                const envelopeSelect = buildOptions(select({ style: "width: 100%;", title: "Filter Envelope" }), Config.envelopes.map(envelope => envelope.name));
                this._drumsetEnvelopeSelects[i] = envelopeSelect;
                envelopeSelect.addEventListener("change", () => {
                    this.doc.record(new ChangeDrumsetEnvelope(this.doc, drumIndex, envelopeSelect.selectedIndex));
                });
                const row = div({ class: "selectRow" }, div({ class: "selectContainer", style: "width: 5em; margin-right: .3em;" }, envelopeSelect), this._drumsetSpectrumEditors[i].container);
                this._drumsetGroup.appendChild(row);
            }
            this._modNameRows = [];
            this._modChannelBoxes = [];
            this._modInstrumentBoxes = [];
            this._modSetRows = [];
            this._modSetBoxes = [];
            this._modFilterRows = [];
            this._modFilterBoxes = [];
            this._modEnvelopeRows = [];
            this._modEnvelopeBoxes = [];
            this._modTargetIndicators = [];
            for (let mod = 0; mod < Config.modCount; mod++) {
                let modChannelBox = select({ style: "width: 100%; color: currentColor; text-overflow:ellipsis;" });
                let modInstrumentBox = select({ style: "width: 100%; color: currentColor;" });
                let modNameRow = div({ class: "operatorRow", style: "height: 1em; margin-bottom: 0.65em;" }, div({ class: "tip", style: "width: 10%; max-width: 5.4em;", id: "modChannelText" + mod, onclick: () => this._openPrompt("modChannel") }, "Ch:"), div({ class: "selectContainer", style: 'width: 35%;' }, modChannelBox), div({ class: "tip", style: "width: 1.2em; margin-left: 0.8em;", id: "modInstrumentText" + mod, onclick: () => this._openPrompt("modInstrument") }, "Ins:"), div({ class: "selectContainer", style: "width: 10%;" }, modInstrumentBox));
                let modSetBox = select();
                let modFilterBox = select();
                let modEnvelopeBox = select();
                let modSetRow = div({ class: "selectRow", id: "modSettingText" + mod, style: "margin-bottom: 0.9em; color: currentColor;" }, span({ class: "tip", onclick: () => this._openPrompt("modSet") }, "Setting: "), span({ class: "tip", style: "font-size:x-small;", onclick: () => this._openPrompt("modSetInfo" + mod) }, "?"), div({ class: "selectContainer" }, modSetBox));
                let modFilterRow = div({ class: "selectRow", id: "modFilterText" + mod, style: "margin-bottom: 0.9em; color: currentColor;" }, span({ class: "tip", onclick: () => this._openPrompt("modFilter" + mod) }, "Target: "), div({ class: "selectContainer" }, modFilterBox));
                let modEnvelopeRow = div({ class: "selectRow", id: "modEnvelopeText" + mod, style: "margin-bottom: 0.9em; color: currentColor;" }, span({ class: "tip", onclick: () => this._openPrompt("modEnvelope") }, "Envelope: "), div({ class: "selectContainer" }, modEnvelopeBox));
                let modTarget = SVG.svg({ style: "transform: translate(0px, 1px);", width: "1.5em", height: "1em", viewBox: "0 0 200 200" }, [
                    SVG.path({ d: "M90 155 l0 -45 -45 0 c-25 0 -45 -4 -45 -10 0 -5 20 -10 45 -10 l45 0 0 -45 c0 -25 5 -45 10 -45 6 0 10 20 10 45 l0 45 45 0 c25 0 45 5 45 10 0 6 -20 10 -45 10 l -45 0 0 45 c0 25 -4 45 -10 45 -5 0 -10 -20 -10 -45z" }),
                    SVG.path({ d: "M42 158 c-15 -15 -16 -38 -2 -38 6 0 10 7 10 15 0 8 7 15 15 15 8 0 15 5 15 10 0 14 -23 13 -38 -2z" }),
                    SVG.path({ d: "M120 160 c0 -5 7 -10 15 -10 8 0 15 -7 15 -15 0 -8 5 -15 10 -15 14 0 13 23 -2 38 -15 15 -38 16 -38 2z" }),
                    SVG.path({ d: "M32 58 c3 -23 48 -40 48 -19 0 6 -7 11 -15 11 -8 0 -15 7 -15 15 0 8 -5 15 -11 15 -6 0 -9 -10 -7 -22z" }),
                    SVG.path({ d: "M150 65 c0 -8 -7 -15 -15 -15 -8 0 -15 -4 -15 -10 0 -14 23 -13 38 2 15 15 16 38 2 38 -5 0 -10 -7 -10 -15z" })
                ]);
                this._modNameRows.push(modNameRow);
                this._modChannelBoxes.push(modChannelBox);
                this._modInstrumentBoxes.push(modInstrumentBox);
                this._modSetRows.push(modSetRow);
                this._modSetBoxes.push(modSetBox);
                this._modFilterRows.push(modFilterRow);
                this._modFilterBoxes.push(modFilterBox);
                this._modEnvelopeRows.push(modEnvelopeRow);
                this._modEnvelopeBoxes.push(modEnvelopeBox);
                this._modTargetIndicators.push(modTarget);
                this._modulatorGroup.appendChild(div({ style: "margin: 3px 0; font-weight: bold; margin-bottom: 0.7em; text-align: center; color: " + ColorConfig.secondaryText + "; background: " + ColorConfig.uiWidgetBackground + ";" }, ["Modulator " + (mod + 1), modTarget]));
                this._modulatorGroup.appendChild(modNameRow);
                this._modulatorGroup.appendChild(modSetRow);
                this._modulatorGroup.appendChild(modFilterRow);
                this._modulatorGroup.appendChild(modEnvelopeRow);
            }
            this._pitchShiftSlider.container.style.setProperty("transform", "translate(0px, 3px)");
            this._octaveShiftSlider.container.style.setProperty("transform", "translate(0px, 3px)");
            this._pitchShiftSlider.container.style.setProperty("width", "100%");
            this._octaveShiftSlider.container.style.setProperty("width", "100%");
            this._fileMenu.addEventListener("change", this._fileMenuHandler);
            this._editMenu.addEventListener("change", this._editMenuHandler);
            this._optionsMenu.addEventListener("change", this._optionsMenuHandler);
            this._customWavePresetDrop.addEventListener("change", this._customWavePresetHandler);
            this._tempoStepper.addEventListener("change", this._whenSetTempo);
            this._scaleSelect.addEventListener("change", this._whenSetScale);
            this._keySelect.addEventListener("change", this._whenSetKey);
            this._octaveStepper.addEventListener("change", this._whenSetOctave);
            this._rhythmSelect.addEventListener("change", this._whenSetRhythm);
            this._algorithmSelect.addEventListener("change", this._whenSetAlgorithm);
            this._instrumentsButtonBar.addEventListener("click", this._whenSelectInstrument);
            this._feedbackTypeSelect.addEventListener("change", this._whenSetFeedbackType);
            this._algorithm6OpSelect.addEventListener("change", this._whenSet6OpAlgorithm);
            this._feedback6OpTypeSelect.addEventListener("change", this._whenSet6OpFeedbackType);
            this._chipWaveSelect.addEventListener("change", this._whenSetChipWave);
            this._ringModWaveSelect.addEventListener("change", this._whenSetRingModChipWave);
            this._useChipWaveAdvancedLoopControlsBox.addEventListener("input", this._whenSetUseChipWaveAdvancedLoopControls);
            this._chipWaveLoopModeSelect.addEventListener("change", this._whenSetChipWaveLoopMode);
            this._chipWaveLoopStartStepper.addEventListener("change", this._whenSetChipWaveLoopStart);
            this._chipWaveLoopEndStepper.addEventListener("change", this._whenSetChipWaveLoopEnd);
            this._setChipWaveLoopEndToEndButton.addEventListener("click", this._whenSetChipWaveLoopEndToEnd);
            this._chipWaveStartOffsetStepper.addEventListener("change", this._whenSetChipWaveStartOffset);
            this._chipWavePlayBackwardsBox.addEventListener("input", this._whenSetChipWavePlayBackwards);
            this._sampleLoadingStatusContainer.addEventListener("click", this._whenSampleLoadingStatusClicked);
            this._chipNoiseSelect.addEventListener("change", this._whenSetNoiseWave);
            this._transitionSelect.addEventListener("change", this._whenSetTransition);
            this._effectsSelect.addEventListener("change", this._whenSetEffects);
            this._unisonSelect.addEventListener("change", this._whenSetUnison);
            this._chordSelect.addEventListener("change", this._whenSetChord);
            this._monophonicNoteInputBox.addEventListener("input", this._whenSetMonophonicNote);
            this._vibratoSelect.addEventListener("change", this._whenSetVibrato);
            this._vibratoTypeSelect.addEventListener("change", this._whenSetVibratoType);
            this._playButton.addEventListener("click", this.togglePlay);
            this._pauseButton.addEventListener("click", this.togglePlay);
            this._recordButton.addEventListener("click", this._toggleRecord);
            this._stopButton.addEventListener("click", this._toggleRecord);
            this._recordButton.addEventListener("contextmenu", (event) => {
                if (event.ctrlKey) {
                    event.preventDefault();
                    this._toggleRecord();
                }
            });
            this._stopButton.addEventListener("contextmenu", (event) => {
                if (event.ctrlKey) {
                    event.preventDefault();
                    this._toggleRecord();
                }
            });
            this._prevBarButton.addEventListener("click", this._whenPrevBarPressed);
            this._nextBarButton.addEventListener("click", this._whenNextBarPressed);
            this._volumeSlider.input.addEventListener("input", this._setVolumeSlider);
            this._zoomInButton.addEventListener("click", this._zoomIn);
            this._zoomOutButton.addEventListener("click", this._zoomOut);
            this._patternArea.addEventListener("mousedown", this._refocusStageNotEditing);
            this._trackArea.addEventListener("mousedown", this.refocusStage);
            this._volumeSlider.container.style.setProperty("flex-grow", "1");
            this._volumeSlider.container.style.setProperty("display", "flex");
            this._volumeBarContainer.style.setProperty("flex-grow", "1");
            this._volumeBarContainer.style.setProperty("display", "flex");
            this._volumeSlider.container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
            this._volumeSlider.container.style.setProperty("--mod-border-radius", "50%");
            this._instrumentVolumeSlider.container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
            this._instrumentVolumeSlider.container.style.setProperty("--mod-border-radius", "50%");
            this._feedbackAmplitudeSlider.container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
            this._feedbackAmplitudeSlider.container.style.setProperty("--mod-border-radius", "50%");
            for (let i = 0; i < Config.operatorCount + 4; i++) {
                this._operatorAmplitudeSliders[i].container.style.setProperty("--mod-color", ColorConfig.multiplicativeModSlider);
                this._operatorAmplitudeSliders[i].container.style.setProperty("--mod-border-radius", "50%");
            }
            let thisRef = this;
            for (let mod = 0; mod < Config.modCount; mod++) {
                this._modChannelBoxes[mod].addEventListener("change", function () { thisRef._whenSetModChannel(mod); });
                this._modInstrumentBoxes[mod].addEventListener("change", function () { thisRef._whenSetModInstrument(mod); });
                this._modSetBoxes[mod].addEventListener("change", function () { thisRef._whenSetModSetting(mod); });
                this._modFilterBoxes[mod].addEventListener("change", function () { thisRef._whenSetModFilter(mod); });
                this._modEnvelopeBoxes[mod].addEventListener("change", function () { thisRef._whenSetModEnvelope(mod); });
                this._modTargetIndicators[mod].addEventListener("click", function () { thisRef._whenClickModTarget(mod); });
            }
            this._jumpToModIndicator.addEventListener("click", function () { thisRef._whenClickJumpToModTarget(); });
            this._patternArea.addEventListener("mousedown", this.refocusStage);
            this._fadeInOutEditor.container.addEventListener("mousedown", this.refocusStage);
            this._spectrumEditor.container.addEventListener("mousedown", this.refocusStage);
            this._eqFilterEditor.container.addEventListener("mousedown", this.refocusStage);
            this._noteFilterEditor.container.addEventListener("mousedown", this.refocusStage);
            this._songEqFilterEditor.container.addEventListener("mousedown", this.refocusStage);
            this._harmonicsEditor.container.addEventListener("mousedown", this.refocusStage);
            this._tempoStepper.addEventListener("keydown", this._tempoStepperCaptureNumberKeys, false);
            this._addEnvelopeButton.addEventListener("click", this._addNewEnvelope);
            this._patternArea.addEventListener("contextmenu", this._disableCtrlContextMenu);
            this._trackArea.addEventListener("contextmenu", this._disableCtrlContextMenu);
            this.mainLayer.addEventListener("keydown", this._whenKeyPressed);
            this.mainLayer.addEventListener("keyup", this._whenKeyReleased);
            this.mainLayer.addEventListener("focusin", this._onFocusIn);
            this._instrumentCopyButton.addEventListener("click", this._copyInstrument.bind(this));
            this._instrumentPasteButton.addEventListener("click", this._pasteInstrument.bind(this));
            this._instrumentExportButton.addEventListener("click", this._exportInstruments.bind(this));
            this._instrumentImportButton.addEventListener("click", this._importInstruments.bind(this));
            sampleLoadEvents.addEventListener("sampleloaded", this._updateSampleLoadingBar.bind(this));
            this._instrumentVolumeSliderInputBox.addEventListener("input", () => { this.doc.record(new ChangeVolume(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].volume, Math.min(25.0, Math.max(-25.0, Math.round(+this._instrumentVolumeSliderInputBox.value))))); });
            this._panSliderInputBox.addEventListener("input", () => { this.doc.record(new ChangePan(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].pan, Math.min(100.0, Math.max(0.0, Math.round(+this._panSliderInputBox.value))))); });
            this._pwmSliderInputBox.addEventListener("input", () => { this.doc.record(new ChangePulseWidth(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].pulseWidth, Math.min(Config.pulseWidthRange, Math.max(1.0, Math.round(+this._pwmSliderInputBox.value))))); });
            
this._pitchShiftBox.addEventListener("input", () => {
	const parsed = Number(this._pitchShiftBox.value);
	if (!isNaN(parsed)) {
		const clamped = Math.abs(Math.min(24.0, Math.max(0.0, Math.round(parsed))))
		this._pitchShiftBox.value = clamped
		this.doc.record(new ChangeShift(
			this.doc,
			this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].pitchShift,
			clamped
		));
	}
});
let fnhandler=()=>{
	const parsed = (this._fnInput.value);
if ((parsed)) {
	this.doc.record(new ChangeFunction(
		this.doc,
		1,
		parsed,
		this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].customfunction[1],
	));
}
}
this._fnInput.addEventListener("input", () => {
	fnhandler()
}); 
this._octaveShiftBox.addEventListener("input", () => {
	const parsed = Number(this._octaveShiftBox.value);
	if (!isNaN(parsed)) {
		const clamped = Math.abs(Math.min(24.0, Math.max(0.0, Math.round(parsed))))
		this._octaveShiftBox.value = clamped
		this.doc.record(new ChangeOctaveShf(
			this.doc,
			this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].octaveShift,
			clamped
		));
	}
});
this._instrumentName.addEventListener("input", () => {
	const parsed = (this._instrumentName.value);
	this.doc.song.channels[this.doc.channel].name = parsed
});
            
            this._detuneSliderInputBox.addEventListener("input", () => { this.doc.record(new ChangeDetune(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].detune, Math.min(Config.detuneMax - Config.detuneCenter, Math.max(Config.detuneMin - Config.detuneCenter, Math.round(+this._detuneSliderInputBox.value))))); });
            this._unisonVoicesInputBox.addEventListener("input", () => { this.doc.record(new ChangeUnisonVoices(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].unisonVoices, Math.min(Config.unisonVoicesMax, Math.max(Config.unisonVoicesMin, Math.round(+this._unisonVoicesInputBox.value))))); });
            this._unisonSpreadInputBox.addEventListener("input", () => { this.doc.record(new ChangeUnisonSpread(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].unisonSpread, Math.min(Config.unisonSpreadMax, Math.max(Config.unisonSpreadMin, +this._unisonSpreadInputBox.value)))); });
            this._unisonOffsetInputBox.addEventListener("input", () => { this.doc.record(new ChangeUnisonOffset(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].unisonOffset, Math.min(Config.unisonOffsetMax, Math.max(Config.unisonOffsetMin, +this._unisonOffsetInputBox.value)))); });
            this._unisonExpressionInputBox.addEventListener("input", () => { this.doc.record(new ChangeUnisonExpression(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].unisonExpression, Math.min(Config.unisonExpressionMax, Math.max(Config.unisonExpressionMin, +this._unisonExpressionInputBox.value)))); });
            this._unisonSignInputBox.addEventListener("input", () => { this.doc.record(new ChangeUnisonSign(this.doc, this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()].unisonSign, Math.min(Config.unisonSignMax, Math.max(Config.unisonSignMin, +this._unisonSignInputBox.value)))); });
            this._customWaveDraw.addEventListener("input", () => { this.doc.record(new ChangeCustomWave(this.doc, this._customWaveDrawCanvas.newArray)); });
            this._twoNoteArpBox.addEventListener("input", () => { this.doc.record(new ChangeFastTwoNoteArp(this.doc, this._twoNoteArpBox.checked)); });
            this._clicklessTransitionBox.addEventListener("input", () => { this.doc.record(new ChangeClicklessTransition(this.doc, this._clicklessTransitionBox.checked)); });
            this._aliasingBox.addEventListener("input", () => { this.doc.record(new ChangeAliasing(this.doc, this._aliasingBox.checked)); });
            this._promptContainer.addEventListener("click", (event) => {
                if (this.doc.prefs.closePromptByClickoff === true) {
                    if (this.prompt != null && this.prompt.gotMouseUp === true)
                        return;
                    if (event.target == this._promptContainer) {
                        this.doc.undo();
                    }
                }
            });
            this._trackAndMuteContainer.addEventListener("scroll", this._onTrackAreaScroll, { capture: false, passive: true });
            if (isMobile) {
                const autoPlayOption = this._optionsMenu.querySelector("[value=autoPlay]");
                autoPlayOption.disabled = true;
                autoPlayOption.setAttribute("hidden", "");
            }
            if (window.screen.availWidth < 0) {
                const layoutOption = this._optionsMenu.querySelector("[value=layout]");
                layoutOption.disabled = true;
                layoutOption.setAttribute("hidden", "");
            }
        }
        _updateSampleLoadingBar(_e) {
            const e = _e;
            const percent = (e.totalSamples === 0
                ? 0
                : Math.floor((e.samplesLoaded / e.totalSamples) * 100));
            this._sampleLoadingBar.style.width = `${percent}%`;
        }
        _toggleAlgorithmCanvas(e) {
            if (this._customAlgorithmCanvas.mode != "feedback") {
                this._customAlgorithmCanvas.mode = "feedback";
                e.target.textContent = "F";
                this._algorithmCanvasSwitch.value = "feedback";
            }
            else {
                this._customAlgorithmCanvas.mode = "algorithm";
                e.target.textContent = "A";
            }
            this._customAlgorithmCanvas.redrawCanvas();
        }
        _toggleDropdownMenu(dropdown, submenu = 0, subtype = null) {
            let target = this._vibratoDropdown;
            let group = this._vibratoDropdownGroup;
            switch (dropdown) {
                case 7:
                    target = this._envelopeDropdown;
                    this._openEnvelopeDropdown = this._openEnvelopeDropdown ? false : true;
                    group = this._envelopeDropdownGroup;
                    break;
                case 0:
                    target = this._vibratoDropdown;
                    this._openVibratoDropdown = this._openVibratoDropdown ? false : true;
                    group = this._vibratoDropdownGroup;
                    break;
                case 1:
                    target = this._panDropdown;
                    this._openPanDropdown = this._openPanDropdown ? false : true;
                    group = this._panDropdownGroup;
                    break;
                case 2:
                    target = this._chordDropdown;
                    this._openChordDropdown = this._openChordDropdown ? false : true;
                    group = this._chordDropdownGroup;
                    break;
                case 3:
                    target = this._transitionDropdown;
                    this._openTransitionDropdown = this._openTransitionDropdown ? false : true;
                    group = this._transitionDropdownGroup;
                    break;
                case 4:
                    target = this._operatorDropdowns[submenu];
                    this._openOperatorDropdowns[submenu] = this._openOperatorDropdowns[submenu] ? false : true;
                    group = this._operatorDropdownGroups[submenu];
                    break;
                case 5:
                    target = this._pulseWidthDropdown;
                    this._openPulseWidthDropdown = this._openPulseWidthDropdown ? false : true;
                    group = this._pulseWidthDropdownGroup;
                    break;
                case 6:
                    target = this._unisonDropdown;
                    this._openUnisonDropdown = this._openUnisonDropdown ? false : true;
                    group = this._unisonDropdownGroup;
                    break;
                case 8:
                    target = this.envelopeEditor.extraSettingsDropdowns[submenu];
                    this.envelopeEditor.openExtraSettingsDropdowns[submenu] = this.envelopeEditor.openExtraSettingsDropdowns[submenu] ? false : true;
                    group = this.envelopeEditor.extraSettingsDropdownGroups[submenu];
                    break;
            }
            if (target.textContent == "") {
                let instrument = this.doc.song.channels[this.doc.channel].instruments[this.doc.getCurrentInstrument()];
                target.textContent = "";
                if (dropdown == 8) {
                    group.style.display = "flex";
                    this.envelopeEditor.rerenderExtraSettings();
                }
                else if (group != this._chordDropdownGroup) {
                    group.style.display = "";
                }
                else if (instrument.chord == Config.chords.dictionary["arpeggio"].index) {
                    group.style.display = "";
                    if (instrument.chord == Config.chords.dictionary["arpeggio"].index) {
                        this._chordDropdownGroup.style.display = "";
                    }
                    else {
                        this._chordDropdownGroup.style.display = "none";
                    }
                }
                for (let i = 0; i < group.children.length; i++) {
                    setTimeout(() => {
                        group.children[i].style.animationDelay = '0.17s';
                        group.children[i].style.opacity = '1';
                    });
                }
            }
            else {
                for (let i = 0; i < group.children.length; i++) {
                    group.children[i].style.animationDelay = '0s';
                    group.children[i].style.opacity = '0';
                }
                target.textContent = "";
                group.style.display = "none";
            }
        }
        _modSliderUpdate() {
            if (!this.doc.synth.playing) {
                this._hasActiveModSliders = false;
                this._songEqFilterEditor.render();
                for (let setting = 0; setting < Config.modulators.length; setting++) {
                    for (let index = 0; index <= Config.modulators[setting].maxIndex; index++) {
                        if (this._showModSliders[setting][index] == true) {
                            this._showModSliders[setting][index] = false;
                            this._newShowModSliders[setting][index] = false;
                            let slider = this.getSliderForModSetting(setting, index);
                            if (slider != null) {
                                slider.container.classList.remove("modSlider");
                            }
                        }
                    }
                }
            }
            else {
                let instrument = this.doc.getCurrentInstrument();
                const anyModActive = this.doc.synth.isAnyModActive(this.doc.channel, instrument);
                if (anyModActive) {
                    let instrument = this.doc.getCurrentInstrument();
                    function updateModSlider(editor, slider, setting, channel, instrument, index) {
                        if (editor.doc.synth.isModActive(setting, channel, instrument)) {
                            if (Config.modulators[setting].maxIndex > 0) {
                                const envelope = editor.doc.synth.song.channels[channel].instruments[instrument].envelopes[index];
                                switch (setting) {
                                    case Config.modulators.dictionary["individual envelope speed"].index: {
                                        if (envelope.tempEnvelopeSpeed == null) {
                                            return false;
                                        }
                                        break;
                                    }
                                    case Config.modulators.dictionary["individual envelope lower bound"].index: {
                                        if (envelope.tempEnvelopeLowerBound == null) {
                                            return false;
                                        }
                                        break;
                                    }
                                    case Config.modulators.dictionary["individual envelope upper bound"].index: {
                                        if (envelope.tempEnvelopeUpperBound == null) {
                                            return false;
                                        }
                                        break;
                                    }
                                }
                            }
                            let currentVal = (editor.doc.synth.getModValue(setting, channel, instrument, false) - Config.modulators[setting].convertRealFactor) / Config.modulators[setting].maxRawVol;
                            if (Config.modulators[setting].invertSliderIndicator == true) {
                                currentVal = 1 - currentVal;
                            }
                            if (currentVal != editor._modSliderValues[setting][index]) {
                                editor._modSliderValues[setting][index] = currentVal;
                                slider.container.style.setProperty("--mod-position", (currentVal * 96.0 + 2.0) + "%");
                            }
                            return true;
                        }
                        return false;
                    }
                    for (let setting = 0; setting < Config.modulators.length; setting++) {
                        for (let index = 0; index <= Config.modulators[setting].maxIndex; index++) {
                            this._newShowModSliders[setting][index] = Boolean(this._showModSliders[setting][index]);
                            let slider = this.getSliderForModSetting(setting, index);
                            if (slider != null) {
                                this._newShowModSliders[setting][index] = updateModSlider(this, slider, setting, this.doc.channel, instrument, index);
                            }
                        }
                    }
                }
                else if (this._hasActiveModSliders) {
                    for (let setting = 0; setting < Config.modulators.length; setting++) {
                        for (let index = 0; index <= Config.modulators[setting].maxIndex; index++) {
                            this._newShowModSliders[setting][index] = false;
                        }
                    }
                }
                if (anyModActive || this._hasActiveModSliders) {
                    let anySliderActive = false;
                    for (let setting = 0; setting < Config.modulators.length; setting++) {
                        for (let index = 0; index <= Config.modulators[setting].maxIndex; index++) {
                            if (this._newShowModSliders[setting][index] != this._showModSliders[setting][index]) {
                                this._showModSliders[setting][index] = this._newShowModSliders[setting][index];
                                let slider = this.getSliderForModSetting(setting, index);
                                if (slider != null) {
                                    if (this._showModSliders[setting][index] == true) {
                                        slider.container.classList.add("modSlider");
                                    }
                                    else {
                                        slider.container.classList.remove("modSlider");
                                    }
                                }
                            }
                            if (this._newShowModSliders[setting][index] == true)
                                anySliderActive = true;
                        }
                    }
                    this._hasActiveModSliders = anySliderActive;
                }
            }
        }
        getSliderForModSetting(setting, index) {
            index = index == undefined ? 0 : index;
            switch (setting) {
                case Config.modulators.dictionary["pan"].index:
                    return this._panSlider;
                case Config.modulators.dictionary["detune"].index:
                    return this._detuneSlider;
                case Config.modulators.dictionary["fm slider 1"].index:
                    return this._operatorAmplitudeSliders[0];
                case Config.modulators.dictionary["fm slider 2"].index:
                    return this._operatorAmplitudeSliders[1];
                case Config.modulators.dictionary["fm slider 3"].index:
                    return this._operatorAmplitudeSliders[2];
                case Config.modulators.dictionary["fm slider 4"].index:
                    return this._operatorAmplitudeSliders[3];
                case Config.modulators.dictionary["fm feedback"].index:
                    return this._feedbackAmplitudeSlider;
                case Config.modulators.dictionary["pulse width"].index:
                    return this._pulseWidthSlider;
                case Config.modulators.dictionary["decimal offset"].index:
                    return this._decimalOffsetSlider;
                case Config.modulators.dictionary["reverb"].index:
                    return this._reverbSlider;
                case Config.modulators.dictionary["distortion"].index:
                    return this._distortionSlider;
                case Config.modulators.dictionary["note volume"].index:
                    if (!this._showModSliders[Config.modulators.dictionary["mix volume"].index][index])
                        return this._instrumentVolumeSlider;
                return this._instrumentVolumeSlide;
																 
                case Config.modulators.dictionary["mix volume"].index:
                    return null;
                case Config.modulators.dictionary["vibrato depth"].index:
                    return this._vibratoDepthSlider;
                case Config.modulators.dictionary["vibrato speed"].index:
                    return this._vibratoSpeedSlider;
                case Config.modulators.dictionary["vibrato delay"].index:
                    return this._vibratoDelaySlider;
                case Config.modulators.dictionary["arp speed"].index:
                    return this._arpeggioSpeedSlider;
                case Config.modulators.dictionary["pan delay"].index:
                    return this._panDelaySlider;
                case Config.modulators.dictionary["tempo"].index:
                    return this._tempoSlider;
                case Config.modulators.dictionary["song volume"].index:
                    return this._volumeSlider;
                case Config.modulators.dictionary["eq filt cut"].index:
                    return this._eqFilterSimpleCutSlider;
                case Config.modulators.dictionary["eq filt peak"].index:
                    return this._eqFilterSimplePeakSlider;
                case Config.modulators.dictionary["note filt cut"].index:
                    return this._noteFilterSimpleCutSlider;
                case Config.modulators.dictionary["note filt peak"].index:
                    return this._noteFilterSimplePeakSlider;
                case Config.modulators.dictionary["bit crush"].index:
                    return this._bitcrusherQuantizationSlider;
                case Config.modulators.dictionary["freq crush"].index:
                    return this._bitcrusherFreqSlider;
                case Config.modulators.dictionary["pitch shift"].index:
                    return this._pitchShiftSlider;
                case Config.modulators.dictionary["octave shift"].index:
                    return this._octaveShiftSlider;
                case Config.modulators.dictionary["chorus"].index:
                    return this._chorusSlider;
                case Config.modulators.dictionary["echo"].index:
                    return this._echoSustainSlider;
                case Config.modulators.dictionary["echo delay"].index:
                    return this._echoDelaySlider;
                case Config.modulators.dictionary["sustain"].index:
                    return this._stringSustainSlider;
                case Config.modulators.dictionary["fm slider 5"].index:
                    return this._operatorAmplitudeSliders[4];
                case Config.modulators.dictionary["fm slider 6"].index:
                    return this._operatorAmplitudeSliders[5];
                case Config.modulators.dictionary["fm slider 7"].index:
                    return this._operatorAmplitudeSliders[6];
                case Config.modulators.dictionary["fm slider 8"].index:
                    return this._operatorAmplitudeSliders[7];
                case Config.modulators.dictionary["envelope speed"].index:
                    return this._envelopeSpeedSlider;
                case Config.modulators.dictionary["dynamism"].index:
                    return this._supersawDynamismSlider;
                case Config.modulators.dictionary["spread"].index:
                    return this._supersawSpreadSlider;
                case Config.modulators.dictionary["saw shape"].index:
                    return this._supersawShapeSlider;
                case Config.modulators.dictionary["individual envelope speed"].index:
                    return this.envelopeEditor.perEnvelopeSpeedSliders[index];
                case Config.modulators.dictionary["individual envelope lower bound"].index:
                    return this.envelopeEditor.perEnvelopeLowerBoundSliders[index];
                case Config.modulators.dictionary["individual envelope upper bound"].index:
                    return this.envelopeEditor.perEnvelopeUpperBoundSliders[index];
                case Config.modulators.dictionary["ring modulation"].index:
                    return this._ringModSlider;
                case Config.modulators.dictionary["ring mod hertz"].index:
                    return this._ringModHzSlider;
                case Config.modulators.dictionary["phaser"].index:
                    return this._phaserMixSlider;
                case Config.modulators.dictionary["phaser frequency"].index:
                    return this._phaserFreqSlider;
                case Config.modulators.dictionary["phaser feedback"].index:
                    return this._phaserFeedbackSlider;
                case Config.modulators.dictionary["phaser stages"].index:
                    return this._phaserStagesSlider;
                case Config.modulators.dictionary["granular"].index:
                    return this._granularSlider;
                case Config.modulators.dictionary["grain freq"].index:
                    return this._grainAmountsSlider;
                case Config.modulators.dictionary["grain size"].index:
                    return this._grainSizeSlider;
                case Config.modulators.dictionary["grain range"].index:
                    return this._grainRangeSlider;
                default:
                    return null;
            }
        }
        _openPrompt(promptName) {
            this.doc.openPrompt(promptName);
            this._setPrompt(promptName);
        }
        _setPrompt(promptName) {
            if (this._currentPromptName == promptName)
                return;
            this._currentPromptName = promptName;
            if (this.prompt) {
                if (this._wasPlaying && !(this.prompt instanceof TipPrompt || this.prompt instanceof LimiterPrompt || this.prompt instanceof CustomScalePrompt || this.prompt instanceof CustomChipPrompt || this.prompt instanceof CustomFilterPrompt|| this.prompt instanceof VisualLoopControlsPromptOLD || this.prompt instanceof VisualLoopControlsPrompt|| this.prompt instanceof SustainPrompt || this.prompt instanceof HarmonicsEditorPrompt || this.prompt instanceof SpectrumEditorPrompt)) {
                    this.doc.performance.play();
                }
                this._wasPlaying = false;
                this._promptContainerBG.style.display = "none";
                this._promptContainer.style.display = "none";
                this._promptContainer.removeChild(this.prompt.container);
                this.prompt.cleanUp();
                this.prompt = null;
                this.refocusStage();
            }
            if (promptName) {
                switch (promptName) {
                    case "export":
                        this.prompt = new ExportPrompt(this.doc);
                        break;
                    case "import":
                        this.prompt = new ImportPrompt(this.doc);
                        break;
                    case "songRecovery":
                        this.prompt = new SongRecoveryPrompt(this.doc);
                        break;
                    case "barCount":
                        this.prompt = new SongDurationPrompt(this.doc);
                        break;
                    case "beatsPerBar":
                        this.prompt = new BeatsPerBarPrompt(this.doc);
                        break;
                    case "moveNotesSideways":
                        this.prompt = new MoveNotesSidewaysPrompt(this.doc);
                        break;
                    case "channelSettings":
                        this.prompt = new ChannelSettingsPrompt(this.doc);
                        break;
                    case "limiterSettings":
                        this.prompt = new LimiterPrompt(this.doc, this);
                        break;
                    case "customScale":
                        this.prompt = new CustomScalePrompt(this.doc);
                        break;
                    case "customChipSettings":
                        this.prompt = new CustomChipPrompt(this.doc, this);
                        break;
                    case "customEQFilterSettings":
                        this.prompt = new CustomFilterPrompt(this.doc, this, false);
                        break;
                    case "customNoteFilterSettings":
                        this.prompt = new CustomFilterPrompt(this.doc, this, true);
                        break;
                    case "customSongEQFilterSettings":
                        this.prompt = new CustomFilterPrompt(this.doc, this, false, true);
                        break;
                    case "theme":
                        this.prompt = new ThemePrompt(this.doc);
                        break;
                    case "layout":
                        this.prompt = new LayoutPrompt(this.doc);
                        break;
                    case "recordingSetup":
                        this.prompt = new RecordingSetupPrompt(this.doc);
                        break;
                    case "exportInstrument":
                        this.prompt = new InstrumentExportPrompt(this.doc);
                        break;
                    case "importInstrument":
                        this.prompt = new InstrumentImportPrompt(this.doc);
                        break;
                    case "stringSustain":
                        this.prompt = new SustainPrompt(this.doc);
                        break;
                    case "addExternal":
                        this.prompt = new AddSamplesPrompt(this.doc);
                        break;
                    case "generateEuclideanRhythm":
                        this.prompt = new EuclideanRhythmPrompt(this.doc);
                        break;
                    case "customTheme":
                        this.prompt = new CustomThemePrompt(this.doc, this._patternEditor, this._trackArea, document.getElementById("beepboxEditorContainer"));
                        break;
                    case "language":
                        this.prompt = new SelectLanguage(this.doc);
                        break;
                    case "plugins":
                        this.prompt = new SelectPlugin(this.doc);
                        break;
case "plugin:samplesOffline":
case "plugin:sampleEditor":
case "plugin:fadeoutPlugin":
case "plugin:reversePlugin":
case "plugin:advEditor":
case "plugin:whistleToNotes":
case "plugin:melMaker":
case "plugin:customThemes":
case "plugin:other": {
    const data = editor.doc._pendingPlugin;
    if (!data) {
        console.error("No pending plugin!");
        break;
    }
    const { title, html, plugin } = data;
    const win = new PluginContainer(title, html, () => {
        if (plugin && plugin.destroy) plugin.destroy();
        editor.doc._pendingPlugin = null;
        editor._setPrompt(null);
    }, this.doc);
    this.prompt = win;
    if (plugin && plugin.script) {
        plugin.script(win.content);
    }
    break;
}
                   case "visualLoopControls":
                   	if(!this.doc.prefs.newloopeditor){
                        this.prompt = new VisualLoopControlsPromptOLD(this.doc, this);
                   	}else{
                   		   this.prompt = new VisualLoopControlsPrompt(this.doc, this);
                   	}
                        break;
                    case "sampleLoadingStatus":
                        this.prompt = new SampleLoadingStatusPrompt(this.doc);
                        break;
                    case "configureShortener":
                        this.prompt = new ShortenerConfigPrompt(this.doc);
                        break;
                    case "harmonicsSettings":
                        this.prompt = new HarmonicsEditorPrompt(this.doc, this);
                        break;
                    case "spectrumSettings":
                        this.prompt = new SpectrumEditorPrompt(this.doc, this, false);
                        break;
                    case "drumsetSettings":
                        this.prompt = new SpectrumEditorPrompt(this.doc, this, true);
                        break;
                    default:
                        this.prompt = new TipPrompt(this.doc, promptName);
                        break;
                }
                if (this.prompt) {
                    if (!(this.prompt instanceof TipPrompt || this.prompt instanceof LimiterPrompt || this.prompt instanceof CustomChipPrompt || this.prompt instanceof CustomFilterPrompt|| this.prompt instanceof VisualLoopControlsPromptOLD|| this.prompt instanceof VisualLoopControlsPrompt || this.prompt instanceof SustainPrompt || this.prompt instanceof HarmonicsEditorPrompt || this.prompt instanceof SpectrumEditorPrompt)) {
                        this._wasPlaying = this.doc.synth.playing;
                        this.doc.performance.pause();
                    }
                    this._promptContainer.style.display = "";
                    if (this.doc.prefs.frostedGlassBackground == true) {
this._promptContainerBG.style.display = "block"
this._promptContainerBG.style.backgroundColor = "rgba(0,0,0,0.01)"
this._promptContainerBG.style.backdropFilter = "brightness(0.9) blur(14px)"
this._promptContainerBG.style.webkitBackdropFilter = "brightness(0.9) blur(14px)"
this._promptContainerBG.style.opacity = "1"
this._promptContainerBG.style.filter = "none"
                    }
                    else {
                        this._promptContainerBG.style.display = "";
                        this._promptContainerBG.style.backgroundColor = "var(--editor-background)";
                        this._promptContainerBG.style.backdropFilter = "";
                        this._promptContainerBG.style.opacity = "0.5";
                    }
                    this._promptContainer.appendChild(this.prompt.container);
                    document.body.appendChild(this._promptContainerBG);
                }
            }
        }
        changeBarScrollPos(offset) {
            this._barScrollBar.changePos(offset);
        }
        handleModRecording() {
            window.clearTimeout(this._modRecTimeout);
            const lastChange = this.doc.checkLastChange();
            if ((this._ctrlHeld || this._shiftHeld) && lastChange != null && this.doc.synth.playing) {
                const changedPatterns = this._patternEditor.setModSettingsForChange(lastChange, this);
                if (this.doc.continuingModRecordingChange != null) {
                    this._modRecTimeout = window.setTimeout(() => { this.handleModRecording(); }, 10);
                    this.doc.recordingModulators = true;
                    if (changedPatterns)
                        this._trackEditor.render();
                }
            }
            else if (this.doc.recordingModulators) {
                this.doc.recordingModulators = false;
                this.doc.record(new ChangeHoldingModRecording(this.doc, null, null, null));
            }
        }
        _renderInstrumentBar(channel, instrumentIndex, colors) {
            if (this.doc.song.layeredInstruments || this.doc.song.patternInstruments) {
                this._instrumentsButtonRow.style.display = "";
                this._instrumentsButtonBar.style.setProperty("--text-color-lit", colors.primaryNote);
                this._instrumentsButtonBar.style.setProperty("--text-color-dim", colors.secondaryNote);
                this._instrumentsButtonBar.style.setProperty("--background-color-lit", colors.primaryChannel);
                this._instrumentsButtonBar.style.setProperty("--background-color-dim", colors.secondaryChannel);
                const maxInstrumentsPerChannel = this.doc.song.getMaxInstrumentsPerChannel();
                while (this._instrumentButtons.length < channel.instruments.length) {
                    const instrumentButton = button(String(this._instrumentButtons.length + 1));
                    this._instrumentButtons.push(instrumentButton);
                    this._instrumentsButtonBar.insertBefore(instrumentButton, this._instrumentRemoveButton);
                }
                for (let i = this._renderedInstrumentCount; i < channel.instruments.length; i++) {
                    this._instrumentButtons[i].style.display = "";
                }
                for (let i = channel.instruments.length; i < this._renderedInstrumentCount; i++) {
                    this._instrumentButtons[i].style.display = "none";
                }
                this._renderedInstrumentCount = channel.instruments.length;
                while (this._instrumentButtons.length > maxInstrumentsPerChannel) {
                    this._instrumentsButtonBar.removeChild(this._instrumentButtons.pop());
                }
                this._instrumentRemoveButton.style.display = (channel.instruments.length > Config.instrumentCountMin) ? "" : "none";
                this._instrumentAddButton.style.display = (channel.instruments.length < maxInstrumentsPerChannel) ? "" : "none";
                if (channel.instruments.length < maxInstrumentsPerChannel) {
                    this._instrumentRemoveButton.classList.remove("last-button");
                }
                else {
                    this._instrumentRemoveButton.classList.add("last-button");
                }
                if (channel.instruments.length > 1) {
                    if (this._highlightedInstrumentIndex != instrumentIndex) {
                        const oldButton = this._instrumentButtons[this._highlightedInstrumentIndex];
                        if (oldButton != null)
                            oldButton.classList.remove("selected-instrument");
                        const newButton = this._instrumentButtons[instrumentIndex];
                        newButton.classList.add("selected-instrument");
                        this._highlightedInstrumentIndex = instrumentIndex;
                    }
                }
                else {
                    const oldButton = this._instrumentButtons[this._highlightedInstrumentIndex];
                    if (oldButton != null)
                        oldButton.classList.remove("selected-instrument");
                    this._highlightedInstrumentIndex = -1;
                }
                if (this.doc.song.layeredInstruments && this.doc.song.patternInstruments && (this.doc.channel < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount)) {
                    for (let i = 0; i < channel.instruments.length; i++) {
                        if (this.doc.recentPatternInstruments[this.doc.channel].indexOf(i) != -1) {
                            this._instrumentButtons[i].classList.remove("deactivated");
                        }
                        else {
                            this._instrumentButtons[i].classList.add("deactivated");
                        }
                    }
                    this._deactivatedInstruments = true;
                }
                else if (this._deactivatedInstruments || (this.doc.channel >= this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount)) {
                    for (let i = 0; i < channel.instruments.length; i++) {
                        this._instrumentButtons[i].classList.remove("deactivated");
                    }
                    this._deactivatedInstruments = false;
                }
                if ((this.doc.song.layeredInstruments && this.doc.song.patternInstruments) && channel.instruments.length > 1 && (this.doc.channel < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount)) {
                    for (let i = 0; i < channel.instruments.length; i++) {
                        this._instrumentButtons[i].classList.remove("no-underline");
                    }
                }
                else {
                    for (let i = 0; i < channel.instruments.length; i++) {
                        this._instrumentButtons[i].classList.add("no-underline");
                    }
                }
            }
            else {
                this._instrumentsButtonRow.style.display = "none";
            }
        }
        _usageCheck(channelIndex, instrumentIndex) {
            var instrumentUsed = false;
            var patternUsed = false;
            var modUsed = false;
            const channel = this.doc.song.channels[channelIndex];
            if (channelIndex < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                for (let modChannelIdx = this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount; modChannelIdx < this.doc.song.channels.length; modChannelIdx++) {
                    const modChannel = this.doc.song.channels[modChannelIdx];
                    const patternIdx = modChannel.bars[this.doc.bar];
                    if (patternIdx > 0) {
                        const modInstrumentIdx = modChannel.patterns[patternIdx - 1].instruments[0];
                        const modInstrument = modChannel.instruments[modInstrumentIdx];
                        for (let mod = 0; mod < Config.modCount; mod++) {
                            if (modInstrument.modChannels[mod] == channelIndex && (modInstrument.modInstruments[mod] == instrumentIndex || modInstrument.modInstruments[mod] >= channel.instruments.length)) {
                                modUsed = true;
                            }
                        }
                    }
                }
            }
            let lowestSelX = Math.min(this.doc.selection.boxSelectionX0, this.doc.selection.boxSelectionX1);
            let highestSelX = Math.max(this.doc.selection.boxSelectionX0, this.doc.selection.boxSelectionX1);
            let lowestSelY = Math.min(this.doc.selection.boxSelectionY0, this.doc.selection.boxSelectionY1);
            let highestSelY = Math.max(this.doc.selection.boxSelectionY0, this.doc.selection.boxSelectionY1);
            if (channel.bars[this.doc.bar] != 0) {
                for (let i = 0; i < this.doc.song.barCount; i++) {
                    if (channel.bars[i] == channel.bars[this.doc.bar] && i != this.doc.bar &&
                        (i < lowestSelX || i > highestSelX || this.doc.channel < lowestSelY || this.doc.channel > highestSelY)) {
                        patternUsed = true;
                        i = this.doc.song.barCount;
                    }
                }
            }
            for (let i = 0; i < this.doc.song.barCount; i++) {
                if (channel.bars[i] != 0 && channel.bars[i] != channel.bars[this.doc.bar] &&
                    channel.patterns[channel.bars[i] - 1].instruments.includes(instrumentIndex) && i != this.doc.bar &&
                    (i < lowestSelX || i > highestSelX || this.doc.channel < lowestSelY || this.doc.channel > highestSelY)) {
                    instrumentUsed = true;
                    i = this.doc.song.barCount;
                }
            }
            if (patternUsed) {
                this._usedPatternIndicator.style.setProperty("fill", ColorConfig.indicatorPrimary);
                this.patternUsed = true;
            }
            else {
                this._usedPatternIndicator.style.setProperty("fill", ColorConfig.indicatorSecondary);
                this.patternUsed = false;
            }
            if (instrumentUsed) {
                this._usedInstrumentIndicator.style.setProperty("fill", ColorConfig.indicatorPrimary);
            }
            else {
                this._usedInstrumentIndicator.style.setProperty("fill", ColorConfig.indicatorSecondary);
            }
            if (modUsed) {
                this._jumpToModIndicator.style.setProperty("display", "");
                this._jumpToModIndicator.style.setProperty("fill", ColorConfig.indicatorPrimary);
                this._jumpToModIndicator.classList.add("modTarget");
            }
            else if (channelIndex < this.doc.song.pitchChannelCount + this.doc.song.noiseChannelCount) {
                this._jumpToModIndicator.style.setProperty("display", "");
                this._jumpToModIndicator.style.setProperty("fill", ColorConfig.indicatorSecondary);
                this._jumpToModIndicator.classList.remove("modTarget");
            }
            else {
                this._jumpToModIndicator.style.setProperty("display", "none");
            }
        }
        _copyTextToClipboard(text) {
            let nav;
            nav = navigator;
            if (nav.clipboard && nav.clipboard.writeText) {
                nav.clipboard.writeText(text).catch(() => {
                    window.prompt("Copy to clipboard:", text);
                });
                return;
            }
            const textField = document.createElement("textarea");
            textField.textContent = text;
            document.body.appendChild(textField);
            textField.select();
            const succeeded = document.execCommand("copy");
            textField.remove();
            this.refocusStage();
            if (!succeeded)
                window.prompt("Copy this:", text);
        }
        _animateVolume(outVolumeCap, historicOutCap) {
            this._outVolumeBar.setAttribute("width", "" + Math.min(144, outVolumeCap * 144));
            this._outVolumeCap.setAttribute("x", "" + (8 + Math.min(144, historicOutCap * 144)));
        }
        _recordVolumeSlider(useVol) {
            if ((this._ctrlHeld || this._shiftHeld) && this.doc.synth.playing) {
                const prevVol = this.doc.prefs.volume;
                this.doc.prefs.volume = useVol;
                this._patternEditor.setModSettingsForChange(null, this);
                window.clearTimeout(this._modRecTimeout);
                this._modRecTimeout = window.setTimeout(() => { this._recordVolumeSlider(useVol); }, 10);
                this.doc.recordingModulators = true;
                this.doc.prefs.volume = prevVol;
                this._volumeSlider.updateValue(this.doc.prefs.volume);
            }
            else {
                this.doc.setVolume(Number(this._volumeSlider.input.value));
                if (this.doc.recordingModulators) {
                    this.doc.recordingModulators = false;
                    this.doc.record(new ChangeHoldingModRecording(this.doc, null, null, null));
                }
            }
        }
        _switchEQFilterType(toSimple) {
            const channel = this.doc.song.channels[this.doc.channel];
            const instrument = channel.instruments[this.doc.getCurrentInstrument()];
            if (instrument.eqFilterType != toSimple) {
                this.doc.record(new ChangeEQFilterType(this.doc, instrument, toSimple));
            }
        }
        _switchNoteFilterType(toSimple) {
            const channel = this.doc.song.channels[this.doc.channel];
            const instrument = channel.instruments[this.doc.getCurrentInstrument()];
            if (instrument.noteFilterType != toSimple) {
                this.doc.record(new ChangeNoteFilterType(this.doc, instrument, toSimple));
            }
        }
        _randomPreset() {
            const isNoise = this.doc.song.getChannelIsNoise(this.doc.channel);
            this.doc.record(new ChangePreset(this.doc, pickRandomPresetValue(isNoise)));
        }
        _randomGenerated(usesCurrentInstrumentType) {
            this.doc.record(new ChangeRandomGeneratedInstrument(this.doc, usesCurrentInstrumentType));
        }
        _setPreset(preset) {
            if (isNaN(preset)) {
                switch (preset) {
                    case "copyInstrument":
                        this._copyInstrument();
                        break;
                    case "pasteInstrument":
                        this._pasteInstrument();
                        break;
                    case "randomPreset":
                        this._randomPreset();
                        break;
                    case "randomGenerated":
                        this._randomGenerated(false);
                        break;
                }
                this.doc.notifier.changed();
            }
            else {
                this.doc.record(new ChangePreset(this.doc, parseInt(preset)));
            }
        }
    }

    editor = new SongEditor();
 
const activePitchTimeouts = new Map(); 

function playPitch(pitch, duration = 200) {
    if (!editor || !editor.doc || !editor.doc.synth) return;
    const perf = editor.doc.performance;
    if (activePitchTimeouts.has(pitch)) {
        const arr = activePitchTimeouts.get(pitch);
        for (const tId of arr) {
            clearTimeout(tId);
            const shortTimeout = setTimeout(() => {
                perf.removePerformedPitch(pitch);
                const timeouts = activePitchTimeouts.get(pitch) || [];
                const index = timeouts.indexOf(shortTimeout);
                if (index !== -1) timeouts.splice(index, 1);
                if (timeouts.length === 0) activePitchTimeouts.delete(pitch);
            }, 3); 
            arr[arr.indexOf(tId)] = shortTimeout;
        }
    }

    perf.addPerformedPitch(pitch);

    const timeoutId = setTimeout(() => {
        perf.removePerformedPitch(pitch);
        const arr = activePitchTimeouts.get(pitch) || [];
        const index = arr.indexOf(timeoutId);
        if (index !== -1) arr.splice(index, 1);
        if (arr.length === 0) activePitchTimeouts.delete(pitch);
    }, duration);

    if (!activePitchTimeouts.has(pitch)) activePitchTimeouts.set(pitch, []);
    activePitchTimeouts.get(pitch).push(timeoutId);
}



 
 


reloadsite = function (){
 cleanMemoryBeforeNavigation()
 setTimeout(function (){
 location.reload()
 },50); 
}
pressPianoKey = function(pitchIndex, duration = 200) {
    playPitch(pitchIndex, duration);
}

pressPianoKey = function(pitchIndex, duration = 200) {
    playPitch(pitchIndex, duration);
}

 

    const beepboxEditorContainer = document.getElementById("beepboxEditorContainer");
    beepboxEditorContainer.appendChild(editor.mainLayer);
    editor.whenUpdated();
    editor.mainLayer.className += " load";
    editor.mainLayer.getElementsByClassName("pattern-area")[0].className += " load"; 
    editor.mainLayer.getElementsByClassName("settings-area")[0].className += " load";
    editor.mainLayer.getElementsByClassName("editor-song-settings")[0].className += " load";
    editor.mainLayer.getElementsByClassName("instrument-settings-area")[0].className += " load";
    editor.mainLayer.getElementsByClassName("trackAndMuteContainer")[0].className += " load";
    editor.mainLayer.getElementsByClassName("barScrollBar")[0].className += " load";
    $('#pitchPresetSelect').select2({ dropdownAutoWidth: true });
    $('#drumPresetSelect').select2({ dropdownAutoWidth: true });
    $("body").on('click', '.select2-container--open .select2-results__group', function () {
        $(this).siblings().toggle();
    });
    $("#pitchPresetSelect").on('select2:open', function () {
        $('.select2-dropdown--below').css('opacity', 0);
        $('.select2-dropdown').css('opacity', 1);
        $('#pitchPresetSelect');
        setTimeout(() => {
            let groups = $('.select2-container--open .select2-results__group');
            let options = $('.select2-container--open .select2-results__option');
            $.each(groups, (index, v) => {
                $(v).siblings().hide();
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(editor.doc.song, editor.doc.channel).primaryNote + ";");
            });
            $.each(options, (index, v) => {
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(editor.doc.song, editor.doc.channel).primaryNote + ";");
            });
            $('.select2-dropdown--below').css('opacity', 1);
        }, 0);
    });
    $("#drumPresetSelect").on('select2:open', function () {
        $('.select2-dropdown--below').css('opacity', 0);
        $('.select2-dropdown').css('opacity', 1);
        $('#drumPresetSelect');
        setTimeout(() => {
            let groups = $('.select2-container--open .select2-results__group');
            let options = $('.select2-container--open .select2-results__option');
            $.each(groups, (index, v) => {
                $(v).siblings().hide();
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(editor.doc.song, editor.doc.channel).primaryNote + ";");
            });
            $.each(options, (index, v) => {
                $(v)[0].setAttribute("style", "color: " + ColorConfig.getChannelColor(editor.doc.song, editor.doc.channel).primaryNote + ";");
            });
            $('.select2-dropdown--below').css('opacity', 1);
        }, 0);
    });
    $('#pitchPresetSelect').on("change", editor._whenSetPitchedPreset);
    $('#pitchPresetSelect').on("select2:close", editor._refocus);
    $('#drumPresetSelect').on("change", editor._whenSetDrumPreset);
    $('#drumPresetSelect').on("select2:close", editor._refocus);
    editor.mainLayer.focus();
    if (!isMobile && editor.doc.prefs.autoPlay) {
        function autoplay() {
            if (!document.hidden) {
                editor.doc.synth.play();
                editor.updatePlayButton();
                window.removeEventListener("visibilitychange", autoplay);
            }
        }
        if (document.hidden) {
            window.addEventListener("visibilitychange", autoplay);
        }
        else {
            window.setTimeout(autoplay);
        }
    }
    if ("scrollRestoration" in history)
        history.scrollRestoration = "manual";
    editor.updatePlayButton();
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/service_worker.js", { updateViaCache: "all", scope: "/" }).catch(() => { });
    }

    exports.ChangePreset = ChangePreset;
    exports.Channel = Channel;
    exports.ColorConfig = ColorConfig;
    exports.Config = Config;
    exports.EditorConfig = EditorConfig;
    exports.ExportPrompt = ExportPrompt;
    exports.Instrument = Instrument;
    exports.Note = Note;
    exports.Pattern = Pattern;
    exports.Song = Song;
    exports.SongDocument = SongDocument;
    exports.SongEditor = SongEditor;
    exports.Synth = Synth;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}));
}catch (error){
    alert(error)
}
}   